{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Device, filters, FocusContext, FocusRule, focusUtils, scout } from '../index';\nimport $ from 'jquery';\n/**\n * The focus manager ensures proper focus handling based on focus contexts.\n *\n * A focus context is bound to a $container. Once a context is activated, that container defines the tab cycle,\n * meaning that only child elements of that container can be entered by tab. Also, the context ensures proper\n * focus gaining, meaning that only focusable elements can gain focus. A focusable element is defined as an element,\n * which is natively focusable and which is not covert by a glass pane. Furthermore, if a context is unintalled,\n * the previously active focus context is activated and its focus position restored.\n */\n\nvar FocusManager = /*#__PURE__*/function () {\n  function FocusManager(options) {\n    _classCallCheck(this, FocusManager);\n\n    var defaults = {\n      // Auto focusing of elements is bad with on screen keyboards -> deactivate to prevent unwanted popping up of the keyboard\n      active: !Device.get().supportsOnlyTouch(),\n      // Preventing blur is bad on touch devices because every touch on a non input field is supposed to close the keyboard which does not happen if preventDefault is used on mouse down\n      restrictedFocusGain: !Device.get().supportsOnlyTouch()\n    };\n    $.extend(this, defaults, options);\n\n    if (!this.session) {\n      throw new Error('Session expected');\n    }\n\n    this._focusContexts = [];\n    this._glassPaneTargets = [];\n    this._glassPaneDisplayParents = [];\n    this._glassPaneRenderers = []; // Make $entryPoint focusable and install focus context.\n\n    var $mainEntryPoint = this.session.$entryPoint;\n    var portletPartId = $mainEntryPoint.data('partid') || '0';\n    $mainEntryPoint.attr('tabindex', portletPartId); // Restricted focus gain means that not every click outside of the active element necessarily focuses another element but the active element stays focused\n    // See _acceptFocusChangeOnMouseDown for details\n\n    if (this.restrictedFocusGain) {\n      this.installTopLevelMouseHandlers($mainEntryPoint);\n    }\n\n    this.installFocusContext($mainEntryPoint, FocusRule.AUTO);\n  }\n\n  _createClass(FocusManager, [{\n    key: \"installTopLevelMouseHandlers\",\n    value: function installTopLevelMouseHandlers($container) {\n      // Install 'mousedown' on top-level $container to accept or prevent focus gain\n      $container.on('mousedown', function (event) {\n        if (!this._acceptFocusChangeOnMouseDown($(event.target))) {\n          event.preventDefault();\n        } else {\n          // Because in IE DOM elements are focusable without tabindex we have to handle it here -> select next parent with tabindex.\n          this._handleIEEvent(event);\n        }\n\n        return true;\n      }.bind(this));\n    }\n    /**\n     * Note: this method is a collection of bugfixes for focus problems which only occur on\n     * Internet Explorer. Focus handling in IE is different from focus-handling in Chrome and Firefox.\n     * Basically this method emulates the focus behavior of the other two browsers, by setting the\n     * focus programmatically to the correct element. And yes, the method is ugly since it deals with\n     * a lot of specific cases. However: distributing the IE specific bugfix code over several classes\n     * wouldn't be much better.\n     */\n\n  }, {\n    key: \"_handleIEEvent\",\n    value: function _handleIEEvent(event) {\n      if (!Device.get().isInternetExplorer()) {\n        return;\n      }\n\n      var $elementToFocus,\n          $element = $(event.target); // table fix - required because IE focuses the table-cell element (unlike Chrome and Firefox)\n      // that means in IE, the table-cell is focused. But all our styles apply to a focused table\n      // that's why we must set the focus programmatically to the closest table in the DOM.\n\n      if ($element.is('.table-cell') || $element.closest('.table-cell').length > 0) {\n        this.requestFocus($element.closest('.table'));\n        event.preventDefault();\n        return;\n      } // tree fix - same issue as in table\n\n\n      if ($element.is('.tree-node') || $element.closest('.tree-node').length > 0) {\n        this.requestFocus($element.closest('.tree'));\n        event.preventDefault();\n        return;\n      }\n\n      var userSelect = $element.css('user-select');\n      var selectableElements = 'div:not(.desktop),[tabindex]:not([tabindex=-1]),radio,a[href],area[href],input:not([disabled]),' + 'select:not([disabled]),textarea:not([disabled]),button:not([disabled]),iframe'; // other fixes (NBU)\n\n      if ($element.not(selectableElements).length === 0) {\n        return;\n      }\n\n      if ($element.closest('[contenteditable=\"true\"]').length === 0 && userSelect && userSelect === 'none') {\n        $elementToFocus = $element.closest(selectableElements);\n\n        if ($elementToFocus) {\n          this.requestFocus($elementToFocus.get(0));\n        }\n\n        event.preventDefault();\n      }\n    }\n    /**\n     * Activates or deactivates focus management.\n     *\n     * If deactivated, the focus manager still validates the current focus, but never gains focus nor enforces a valid focus position.\n     * Once activated, the current focus position is revalidated.\n     */\n\n  }, {\n    key: \"activate\",\n    value: function activate(_activate) {\n      if (this.active !== _activate) {\n        this.active = _activate;\n\n        if ($.log.isDebugEnabled()) {\n          $.log.isDebugEnabled() && $.log.debug('Focus manager active: ' + this.active);\n        }\n\n        if (this.active) {\n          this.validateFocus();\n        }\n      }\n    }\n    /**\n     * Installs a new focus context for the given $container, and sets the $container's initial focus, either by\n     * the given rule, or tries to gain focus for the given element.\n     * @returns {FocusContext} the installed context.\n     */\n\n  }, {\n    key: \"installFocusContext\",\n    value: function installFocusContext($container, focusRuleOrElement) {\n      var elementToFocus = this.evaluateFocusRule($container, focusRuleOrElement); // Create and register the focus context.\n\n      var focusContext = new FocusContext($container, this);\n\n      if (FocusRule.PREPARE !== focusRuleOrElement) {\n        focusContext.ready();\n      }\n\n      this._pushIfAbsendElseMoveTop(focusContext);\n\n      if (elementToFocus) {\n        focusContext.validateAndSetFocus(elementToFocus);\n      }\n\n      return focusContext;\n    }\n    /**\n     * Evaluates the {@link FocusRule} or just returns the given element if focusRuleOrElement is not a focus rule.\n     */\n\n  }, {\n    key: \"evaluateFocusRule\",\n    value: function evaluateFocusRule($container, focusRuleOrElement) {\n      var elementToFocus;\n\n      if (!focusRuleOrElement || scout.isOneOf(focusRuleOrElement, FocusRule.AUTO, FocusRule.PREPARE)) {\n        elementToFocus = this.findFirstFocusableElement($container);\n      } else if (focusRuleOrElement === FocusRule.NONE) {\n        elementToFocus = null;\n      } else {\n        elementToFocus = focusRuleOrElement;\n      }\n\n      return elementToFocus;\n    }\n    /**\n     * Uninstalls the focus context for the given $container, and activates the last active context.\n     * This method has no effect, if there is no focus context installed for the given $container.\n     */\n\n  }, {\n    key: \"uninstallFocusContext\",\n    value: function uninstallFocusContext($container) {\n      var focusContext = this.getFocusContext($container);\n\n      if (!focusContext) {\n        return;\n      } // Filter to exclude the current focus context's container and any of its child elements to gain focus.\n\n\n      var filter = filters.outsideFilter(focusContext.$container); // Remove and dispose the current focus context.\n\n      arrays.remove(this._focusContexts, focusContext);\n      focusContext.dispose(); // Activate last active focus context.\n\n      var activeFocusContext = this._findActiveContext();\n\n      if (activeFocusContext) {\n        activeFocusContext.validateAndSetFocus(activeFocusContext.lastValidFocusedElement, filter);\n      }\n    }\n    /**\n     * Returns whether there is a focus context installed for the given $container.\n     */\n\n  }, {\n    key: \"isFocusContextInstalled\",\n    value: function isFocusContextInstalled($container) {\n      return !!this.getFocusContext($container);\n    }\n    /**\n     * Activates the focus context of the given $container or the given focus context and validates the focus so that the previously focused element will be focused again.\n     * @param {(FocusContext|$)} focusContextOr$Container\n     */\n\n  }, {\n    key: \"activateFocusContext\",\n    value: function activateFocusContext(focusContextOr$Container) {\n      var focusContext = focusContextOr$Container;\n\n      if (!(focusContextOr$Container instanceof FocusContext)) {\n        focusContext = this.getFocusContext(focusContextOr$Container);\n      }\n\n      if (!focusContext || this.isElementCovertByGlassPane(focusContext.$container)) {\n        return;\n      }\n\n      this._pushIfAbsendElseMoveTop(focusContext);\n\n      this.validateFocus();\n    }\n    /**\n     * Checks if the given element is accessible, meaning not covert by a glasspane.\n     *\n     * @param element a HTMLElement or a jQuery collection\n     * @param [filter] if specified, the filter is used to filter the array of glass pane targets\n     */\n\n  }, {\n    key: \"isElementCovertByGlassPane\",\n    value: function isElementCovertByGlassPane(element, filter) {\n      var targets = this._glassPaneTargets;\n\n      if (filter) {\n        targets = this._glassPaneTargets.filter(filter);\n      }\n\n      if (!targets.length) {\n        return false; // no glasspanes active.\n      }\n\n      if (this._glassPaneDisplayParents.indexOf(scout.widget(element)) >= 0) {\n        return true;\n      } // Checks whether the element is a child of a glasspane target.\n      // If so, the some-iterator returns immediately with true.\n\n\n      return targets.some(function ($glassPaneTarget) {\n        return $(element).closest($glassPaneTarget).length !== 0;\n      });\n    }\n    /**\n     * Registers the given glasspane target, so that the focus cannot be gained on the given target nor on its child elements.\n     */\n\n  }, {\n    key: \"registerGlassPaneTarget\",\n    value: function registerGlassPaneTarget($glassPaneTarget) {\n      this._glassPaneTargets.push($glassPaneTarget);\n\n      this.validateFocus();\n    }\n  }, {\n    key: \"registerGlassPaneDisplayParent\",\n    value: function registerGlassPaneDisplayParent(displayParent) {\n      this._glassPaneDisplayParents.push(displayParent);\n    }\n  }, {\n    key: \"registerGlassPaneRenderer\",\n    value: function registerGlassPaneRenderer(glassPaneRenderer) {\n      this._glassPaneRenderers.push(glassPaneRenderer);\n    }\n    /**\n     * Unregisters the given glasspane target, so that the focus can be gained again for the target or one of its child controls.\n     */\n\n  }, {\n    key: \"unregisterGlassPaneTarget\",\n    value: function unregisterGlassPaneTarget($glassPaneTarget) {\n      arrays.$remove(this._glassPaneTargets, $glassPaneTarget);\n      this.validateFocus();\n    }\n  }, {\n    key: \"unregisterGlassPaneDisplayParent\",\n    value: function unregisterGlassPaneDisplayParent(displayParent) {\n      arrays.remove(this._glassPaneDisplayParents, displayParent);\n    }\n  }, {\n    key: \"unregisterGlassPaneRenderer\",\n    value: function unregisterGlassPaneRenderer(glassPaneRenderer) {\n      arrays.remove(this._glassPaneRenderers, glassPaneRenderer);\n    }\n  }, {\n    key: \"rerenderGlassPanes\",\n    value: function rerenderGlassPanes() {\n      // create a copy of the current glassPaneRenderers\n      var currGlassPaneRenderers = this._glassPaneRenderers.slice(); // remove and rerender every glassPaneRenderer to keep them (and their members) valid.\n\n\n      currGlassPaneRenderers.forEach(function (glassPaneRenderer) {\n        glassPaneRenderer.removeGlassPanes();\n        glassPaneRenderer.renderGlassPanes();\n      });\n    }\n    /**\n     * Enforces proper focus on the currently active focus context.\n     *\n     * @param filter\n     *        Filter to exclude elements to gain focus.\n     */\n\n  }, {\n    key: \"validateFocus\",\n    value: function validateFocus(filter) {\n      var activeContext = this._findActiveContext();\n\n      if (activeContext) {\n        activeContext.validateFocus(filter);\n      }\n    }\n  }, {\n    key: \"requestFocusIfReady\",\n    value: function requestFocusIfReady(element, filter) {\n      return this.requestFocus(element, filter, true);\n    }\n    /**\n     * Requests the focus for the given element, but only if being a valid focus location.\n     *\n     * @return {boolean} true if focus was gained, false otherwise.\n     */\n\n  }, {\n    key: \"requestFocus\",\n    value: function requestFocus(element, filter, onlyIfReady) {\n      element = element instanceof $ ? element[0] : element;\n\n      if (!element) {\n        return false;\n      }\n\n      var context = this._findFocusContextFor(element);\n\n      if (context) {\n        if (onlyIfReady && !context.prepared) {\n          return false;\n        }\n\n        context.validateAndSetFocus(element, filter);\n      }\n\n      return focusUtils.isActiveElement(element);\n    }\n    /**\n     * Finds the first focusable element of the given $container, or null if not found.\n     */\n\n  }, {\n    key: \"findFirstFocusableElement\",\n    value: function findFirstFocusableElement($container, filter) {\n      var firstElement,\n          firstDefaultButton,\n          firstButton,\n          i,\n          candidate,\n          $candidate,\n          $menuParents,\n          $tabParents,\n          $boxButtons,\n          $entryPoint = $container.entryPoint(),\n          $candidates = $container.find(':focusable').addBack(':focusable')\n      /* in some use cases, the container should be focusable as well, e.g. context menu without focusable children */\n      .not($entryPoint)\n      /* $entryPoint should never be a focusable candidate. However, if no focusable candidate is found, 'FocusContext.validateAndSetFocus' focuses the $entryPoint as a fallback. */\n      .filter(filter || filters.returnTrue);\n\n      for (i = 0; i < $candidates.length; i++) {\n        candidate = $candidates[i];\n        $candidate = $(candidate); // Check whether the candidate is accessible and not covert by a glass pane.\n\n        if (this.isElementCovertByGlassPane(candidate)) {\n          continue;\n        } // Check if the element (or one of its parents) does not want to be the first focusable element\n\n\n        if ($candidate.is('.prevent-initial-focus') || $candidate.closest('.prevent-initial-focus').length > 0) {\n          continue;\n        }\n\n        if (!firstElement && !($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {\n          firstElement = candidate;\n        }\n\n        if (!firstDefaultButton && $candidate.is('.default-menu')) {\n          firstDefaultButton = candidate;\n        }\n\n        $menuParents = $candidate.parents('.menubar');\n        $tabParents = $candidate.parents('.tab-box-header');\n        $boxButtons = $candidate.parents('.box-buttons');\n\n        if (($menuParents.length > 0 || $tabParents.length > 0 || $boxButtons.length > 0) && !firstButton && ($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {\n          firstButton = candidate;\n        } else if (!$menuParents.length && !$tabParents.length && !$boxButtons.length && typeof candidate.focus === 'function') {\n          // inline buttons and menues are selectable before choosing button or menu from bar\n          return candidate;\n        }\n      }\n\n      if (firstDefaultButton) {\n        return firstDefaultButton;\n      } else if (firstButton) {\n        if (firstButton !== firstElement && firstElement) {\n          var $tabParentsButton = $(firstButton).parents('.tab-box-header'),\n              $firstItem = $(firstElement),\n              $tabParentsFirstElement = $(firstElement).parents('.tab-box-header');\n\n          if ($tabParentsFirstElement.length > 0 && $tabParentsButton.length > 0 && $firstItem.is('.tab-item')) {\n            return firstElement;\n          }\n        }\n\n        return firstButton;\n      }\n\n      return firstElement;\n    }\n    /**\n     * Returns the currently active focus context, or null if not applicable.\n     */\n\n  }, {\n    key: \"_findActiveContext\",\n    value: function _findActiveContext() {\n      return arrays.last(this._focusContexts);\n    }\n    /**\n     * Returns the focus context which is associated with the given $container, or null if not applicable.\n     */\n\n  }, {\n    key: \"getFocusContext\",\n    value: function getFocusContext($container) {\n      return arrays.find(this._focusContexts, function (focusContext) {\n        return focusContext.$container === $container;\n      });\n    }\n  }, {\n    key: \"_findFocusContextFor\",\n    value: function _findFocusContextFor($element) {\n      $element = $.ensure($element);\n      var context = null;\n      var distance = Number.MAX_VALUE;\n\n      this._focusContexts.forEach(function (focusContext) {\n        if (!focusContext.$container.isOrHas($element)) {\n          return;\n        } // Return the context which is closest to the element\n\n\n        var length = $element.parentsUntil(focusContext.$container).length;\n\n        if (length < distance) {\n          context = focusContext;\n        }\n      });\n\n      return context;\n    }\n    /**\n     * Returns whether to accept a 'mousedown event'.\n     */\n\n  }, {\n    key: \"_acceptFocusChangeOnMouseDown\",\n    value: function _acceptFocusChangeOnMouseDown($element) {\n      // 1. Prevent focus gain when glasspane is clicked.\n      //    Even if the glasspane is not focusable, this check is required because the glasspane might be contained in a focusable container\n      //    like table. Use case: outline modality with table-page as 'outlineContent'.\n      if ($element.hasClass('glasspane')) {\n        return false;\n      } // 2. Prevent focus gain if covert by glasspane.\n\n\n      if (this.isElementCovertByGlassPane($element)) {\n        return false;\n      } // 3. Prevent focus gain on elements excluded to gain focus by mouse, e.g. buttons.\n\n\n      if (!focusUtils.isFocusableByMouse($element)) {\n        return false;\n      } // 4. Allow focus gain on focusable elements.\n\n\n      if ($element.is(':focusable')) {\n        return true;\n      } // 5. Allow focus gain on elements with selectable content, e.g. the value of a label field.\n\n\n      if (focusUtils.isSelectableText($element)) {\n        return true;\n      } // 6. Allow focus gain on elements with a focusable parent, e.g. when clicking on a row in a table.\n\n\n      if (focusUtils.containsParentFocusableByMouse($element, $element.entryPoint())) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Registers the given focus context, or moves it on top if already registered.\n     */\n\n  }, {\n    key: \"_pushIfAbsendElseMoveTop\",\n    value: function _pushIfAbsendElseMoveTop(focusContext) {\n      arrays.remove(this._focusContexts, focusContext);\n\n      this._focusContexts.push(focusContext);\n    }\n  }]);\n\n  return FocusManager;\n}();\n\nexport { FocusManager as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/focus/FocusManager.js"],"names":["arrays","Device","filters","FocusContext","FocusRule","focusUtils","scout","$","FocusManager","options","defaults","active","get","supportsOnlyTouch","restrictedFocusGain","extend","session","Error","_focusContexts","_glassPaneTargets","_glassPaneDisplayParents","_glassPaneRenderers","$mainEntryPoint","$entryPoint","portletPartId","data","attr","installTopLevelMouseHandlers","installFocusContext","AUTO","$container","on","event","_acceptFocusChangeOnMouseDown","target","preventDefault","_handleIEEvent","bind","isInternetExplorer","$elementToFocus","$element","is","closest","length","requestFocus","userSelect","css","selectableElements","not","activate","log","isDebugEnabled","debug","validateFocus","focusRuleOrElement","elementToFocus","evaluateFocusRule","focusContext","PREPARE","ready","_pushIfAbsendElseMoveTop","validateAndSetFocus","isOneOf","findFirstFocusableElement","NONE","getFocusContext","filter","outsideFilter","remove","dispose","activeFocusContext","_findActiveContext","lastValidFocusedElement","focusContextOr$Container","isElementCovertByGlassPane","element","targets","indexOf","widget","some","$glassPaneTarget","push","displayParent","glassPaneRenderer","$remove","currGlassPaneRenderers","slice","forEach","removeGlassPanes","renderGlassPanes","activeContext","onlyIfReady","context","_findFocusContextFor","prepared","isActiveElement","firstElement","firstDefaultButton","firstButton","i","candidate","$candidate","$menuParents","$tabParents","$boxButtons","entryPoint","$candidates","find","addBack","returnTrue","hasClass","parents","focus","$tabParentsButton","$firstItem","$tabParentsFirstElement","last","ensure","distance","Number","MAX_VALUE","isOrHas","parentsUntil","isFocusableByMouse","isSelectableText","containsParentFocusableByMouse"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Device, filters, FocusContext, FocusRule, focusUtils, scout} from '../index';\nimport $ from 'jquery';\n\n/**\n * The focus manager ensures proper focus handling based on focus contexts.\n *\n * A focus context is bound to a $container. Once a context is activated, that container defines the tab cycle,\n * meaning that only child elements of that container can be entered by tab. Also, the context ensures proper\n * focus gaining, meaning that only focusable elements can gain focus. A focusable element is defined as an element,\n * which is natively focusable and which is not covert by a glass pane. Furthermore, if a context is unintalled,\n * the previously active focus context is activated and its focus position restored.\n */\nexport default class FocusManager {\n\n  constructor(options) {\n    var defaults = {\n      // Auto focusing of elements is bad with on screen keyboards -> deactivate to prevent unwanted popping up of the keyboard\n      active: !Device.get().supportsOnlyTouch(),\n      // Preventing blur is bad on touch devices because every touch on a non input field is supposed to close the keyboard which does not happen if preventDefault is used on mouse down\n      restrictedFocusGain: !Device.get().supportsOnlyTouch()\n    };\n    $.extend(this, defaults, options);\n\n    if (!this.session) {\n      throw new Error('Session expected');\n    }\n\n    this._focusContexts = [];\n    this._glassPaneTargets = [];\n    this._glassPaneDisplayParents = [];\n    this._glassPaneRenderers = [];\n\n    // Make $entryPoint focusable and install focus context.\n    var $mainEntryPoint = this.session.$entryPoint;\n    var portletPartId = $mainEntryPoint.data('partid') || '0';\n    $mainEntryPoint.attr('tabindex', portletPartId);\n\n    // Restricted focus gain means that not every click outside of the active element necessarily focuses another element but the active element stays focused\n    // See _acceptFocusChangeOnMouseDown for details\n    if (this.restrictedFocusGain) {\n      this.installTopLevelMouseHandlers($mainEntryPoint);\n    }\n    this.installFocusContext($mainEntryPoint, FocusRule.AUTO);\n  }\n\n  installTopLevelMouseHandlers($container) {\n    // Install 'mousedown' on top-level $container to accept or prevent focus gain\n    $container.on('mousedown', function(event) {\n      if (!this._acceptFocusChangeOnMouseDown($(event.target))) {\n        event.preventDefault();\n      } else {\n        // Because in IE DOM elements are focusable without tabindex we have to handle it here -> select next parent with tabindex.\n        this._handleIEEvent(event);\n      }\n      return true;\n    }.bind(this));\n  }\n\n  /**\n   * Note: this method is a collection of bugfixes for focus problems which only occur on\n   * Internet Explorer. Focus handling in IE is different from focus-handling in Chrome and Firefox.\n   * Basically this method emulates the focus behavior of the other two browsers, by setting the\n   * focus programmatically to the correct element. And yes, the method is ugly since it deals with\n   * a lot of specific cases. However: distributing the IE specific bugfix code over several classes\n   * wouldn't be much better.\n   */\n  _handleIEEvent(event) {\n    if (!Device.get().isInternetExplorer()) {\n      return;\n    }\n\n    var\n      $elementToFocus,\n      $element = $(event.target);\n\n    // table fix - required because IE focuses the table-cell element (unlike Chrome and Firefox)\n    // that means in IE, the table-cell is focused. But all our styles apply to a focused table\n    // that's why we must set the focus programmatically to the closest table in the DOM.\n    if ($element.is('.table-cell') || $element.closest('.table-cell').length > 0) {\n      this.requestFocus($element.closest('.table'));\n      event.preventDefault();\n      return;\n    }\n\n    // tree fix - same issue as in table\n    if ($element.is('.tree-node') || $element.closest('.tree-node').length > 0) {\n      this.requestFocus($element.closest('.tree'));\n      event.preventDefault();\n      return;\n    }\n\n    var userSelect = $element.css('user-select');\n    var selectableElements =\n      'div:not(.desktop),[tabindex]:not([tabindex=-1]),radio,a[href],area[href],input:not([disabled]),' +\n      'select:not([disabled]),textarea:not([disabled]),button:not([disabled]),iframe';\n\n    // other fixes (NBU)\n    if ($element.not(selectableElements).length === 0) {\n      return;\n    }\n\n    if ($element.closest('[contenteditable=\"true\"]').length === 0 &&\n      (userSelect && userSelect === 'none')) {\n      $elementToFocus = $element.closest(selectableElements);\n      if ($elementToFocus) {\n        this.requestFocus($elementToFocus.get(0));\n      }\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Activates or deactivates focus management.\n   *\n   * If deactivated, the focus manager still validates the current focus, but never gains focus nor enforces a valid focus position.\n   * Once activated, the current focus position is revalidated.\n   */\n  activate(activate) {\n    if (this.active !== activate) {\n      this.active = activate;\n      if ($.log.isDebugEnabled()) {\n        $.log.isDebugEnabled() && $.log.debug('Focus manager active: ' + this.active);\n      }\n      if (this.active) {\n        this.validateFocus();\n      }\n    }\n  }\n\n  /**\n   * Installs a new focus context for the given $container, and sets the $container's initial focus, either by\n   * the given rule, or tries to gain focus for the given element.\n   * @returns {FocusContext} the installed context.\n   */\n  installFocusContext($container, focusRuleOrElement) {\n    var elementToFocus = this.evaluateFocusRule($container, focusRuleOrElement);\n\n    // Create and register the focus context.\n    var focusContext = new FocusContext($container, this);\n    if (FocusRule.PREPARE !== focusRuleOrElement) {\n      focusContext.ready();\n    }\n    this._pushIfAbsendElseMoveTop(focusContext);\n\n    if (elementToFocus) {\n      focusContext.validateAndSetFocus(elementToFocus);\n    }\n    return focusContext;\n  }\n\n  /**\n   * Evaluates the {@link FocusRule} or just returns the given element if focusRuleOrElement is not a focus rule.\n   */\n  evaluateFocusRule($container, focusRuleOrElement) {\n    var elementToFocus;\n    if (!focusRuleOrElement || scout.isOneOf(focusRuleOrElement, FocusRule.AUTO, FocusRule.PREPARE)) {\n      elementToFocus = this.findFirstFocusableElement($container);\n    } else if (focusRuleOrElement === FocusRule.NONE) {\n      elementToFocus = null;\n    } else {\n      elementToFocus = focusRuleOrElement;\n    }\n    return elementToFocus;\n  }\n\n  /**\n   * Uninstalls the focus context for the given $container, and activates the last active context.\n   * This method has no effect, if there is no focus context installed for the given $container.\n   */\n  uninstallFocusContext($container) {\n    var focusContext = this.getFocusContext($container);\n    if (!focusContext) {\n      return;\n    }\n\n    // Filter to exclude the current focus context's container and any of its child elements to gain focus.\n    var filter = filters.outsideFilter(focusContext.$container);\n\n    // Remove and dispose the current focus context.\n    arrays.remove(this._focusContexts, focusContext);\n    focusContext.dispose();\n\n    // Activate last active focus context.\n    var activeFocusContext = this._findActiveContext();\n    if (activeFocusContext) {\n      activeFocusContext.validateAndSetFocus(activeFocusContext.lastValidFocusedElement, filter);\n    }\n  }\n\n  /**\n   * Returns whether there is a focus context installed for the given $container.\n   */\n  isFocusContextInstalled($container) {\n    return !!this.getFocusContext($container);\n  }\n\n  /**\n   * Activates the focus context of the given $container or the given focus context and validates the focus so that the previously focused element will be focused again.\n   * @param {(FocusContext|$)} focusContextOr$Container\n   */\n  activateFocusContext(focusContextOr$Container) {\n    var focusContext = focusContextOr$Container;\n    if (!(focusContextOr$Container instanceof FocusContext)) {\n      focusContext = this.getFocusContext(focusContextOr$Container);\n    }\n    if (!focusContext || this.isElementCovertByGlassPane(focusContext.$container)) {\n      return;\n    }\n    this._pushIfAbsendElseMoveTop(focusContext);\n    this.validateFocus();\n  }\n\n  /**\n   * Checks if the given element is accessible, meaning not covert by a glasspane.\n   *\n   * @param element a HTMLElement or a jQuery collection\n   * @param [filter] if specified, the filter is used to filter the array of glass pane targets\n   */\n  isElementCovertByGlassPane(element, filter) {\n    var targets = this._glassPaneTargets;\n    if (filter) {\n      targets = this._glassPaneTargets.filter(filter);\n    }\n    if (!targets.length) {\n      return false; // no glasspanes active.\n    }\n\n    if (this._glassPaneDisplayParents.indexOf(scout.widget(element)) >= 0) {\n      return true;\n    }\n    // Checks whether the element is a child of a glasspane target.\n    // If so, the some-iterator returns immediately with true.\n    return targets.some(function($glassPaneTarget) {\n      return $(element).closest($glassPaneTarget).length !== 0;\n    });\n  }\n\n  /**\n   * Registers the given glasspane target, so that the focus cannot be gained on the given target nor on its child elements.\n   */\n  registerGlassPaneTarget($glassPaneTarget) {\n    this._glassPaneTargets.push($glassPaneTarget);\n    this.validateFocus();\n  }\n\n  registerGlassPaneDisplayParent(displayParent) {\n    this._glassPaneDisplayParents.push(displayParent);\n  }\n\n  registerGlassPaneRenderer(glassPaneRenderer) {\n    this._glassPaneRenderers.push(glassPaneRenderer);\n  }\n\n  /**\n   * Unregisters the given glasspane target, so that the focus can be gained again for the target or one of its child controls.\n   */\n  unregisterGlassPaneTarget($glassPaneTarget) {\n    arrays.$remove(this._glassPaneTargets, $glassPaneTarget);\n    this.validateFocus();\n  }\n\n  unregisterGlassPaneDisplayParent(displayParent) {\n    arrays.remove(this._glassPaneDisplayParents, displayParent);\n  }\n\n  unregisterGlassPaneRenderer(glassPaneRenderer) {\n    arrays.remove(this._glassPaneRenderers, glassPaneRenderer);\n  }\n\n  rerenderGlassPanes() {\n    // create a copy of the current glassPaneRenderers\n    var currGlassPaneRenderers = this._glassPaneRenderers.slice();\n    // remove and rerender every glassPaneRenderer to keep them (and their members) valid.\n    currGlassPaneRenderers.forEach(function(glassPaneRenderer) {\n      glassPaneRenderer.removeGlassPanes();\n      glassPaneRenderer.renderGlassPanes();\n    });\n  }\n\n  /**\n   * Enforces proper focus on the currently active focus context.\n   *\n   * @param filter\n   *        Filter to exclude elements to gain focus.\n   */\n  validateFocus(filter) {\n    var activeContext = this._findActiveContext();\n    if (activeContext) {\n      activeContext.validateFocus(filter);\n    }\n  }\n\n  requestFocusIfReady(element, filter) {\n    return this.requestFocus(element, filter, true);\n  }\n\n  /**\n   * Requests the focus for the given element, but only if being a valid focus location.\n   *\n   * @return {boolean} true if focus was gained, false otherwise.\n   */\n  requestFocus(element, filter, onlyIfReady) {\n    element = element instanceof $ ? element[0] : element;\n    if (!element) {\n      return false;\n    }\n\n    var context = this._findFocusContextFor(element);\n    if (context) {\n      if (onlyIfReady && !context.prepared) {\n        return false;\n      }\n      context.validateAndSetFocus(element, filter);\n    }\n\n    return focusUtils.isActiveElement(element);\n  }\n\n  /**\n   * Finds the first focusable element of the given $container, or null if not found.\n   */\n  findFirstFocusableElement($container, filter) {\n    var firstElement, firstDefaultButton, firstButton, i, candidate, $candidate, $menuParents, $tabParents, $boxButtons,\n      $entryPoint = $container.entryPoint(),\n      $candidates = $container\n        .find(':focusable')\n        .addBack(':focusable') /* in some use cases, the container should be focusable as well, e.g. context menu without focusable children */\n        .not($entryPoint) /* $entryPoint should never be a focusable candidate. However, if no focusable candidate is found, 'FocusContext.validateAndSetFocus' focuses the $entryPoint as a fallback. */\n        .filter(filter || filters.returnTrue);\n\n    for (i = 0; i < $candidates.length; i++) {\n      candidate = $candidates[i];\n      $candidate = $(candidate);\n\n      // Check whether the candidate is accessible and not covert by a glass pane.\n      if (this.isElementCovertByGlassPane(candidate)) {\n        continue;\n      }\n      // Check if the element (or one of its parents) does not want to be the first focusable element\n      if ($candidate.is('.prevent-initial-focus') || $candidate.closest('.prevent-initial-focus').length > 0) {\n        continue;\n      }\n\n      if (!firstElement && !($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {\n        firstElement = candidate;\n      }\n\n      if (!firstDefaultButton && $candidate.is('.default-menu')) {\n        firstDefaultButton = candidate;\n      }\n\n      $menuParents = $candidate.parents('.menubar');\n      $tabParents = $candidate.parents('.tab-box-header');\n      $boxButtons = $candidate.parents('.box-buttons');\n      if (($menuParents.length > 0 || $tabParents.length > 0 || $boxButtons.length > 0) && !firstButton && ($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {\n        firstButton = candidate;\n      } else if (!$menuParents.length && !$tabParents.length && !$boxButtons.length && typeof candidate.focus === 'function') { // inline buttons and menues are selectable before choosing button or menu from bar\n        return candidate;\n      }\n    }\n    if (firstDefaultButton) {\n      return firstDefaultButton;\n    } else if (firstButton) {\n      if (firstButton !== firstElement && firstElement) {\n        var $tabParentsButton = $(firstButton).parents('.tab-box-header'),\n          $firstItem = $(firstElement),\n          $tabParentsFirstElement = $(firstElement).parents('.tab-box-header');\n        if ($tabParentsFirstElement.length > 0 && $tabParentsButton.length > 0 && $firstItem.is('.tab-item')) {\n          return firstElement;\n        }\n      }\n      return firstButton;\n    }\n    return firstElement;\n  }\n\n  /**\n   * Returns the currently active focus context, or null if not applicable.\n   */\n  _findActiveContext() {\n    return arrays.last(this._focusContexts);\n  }\n\n  /**\n   * Returns the focus context which is associated with the given $container, or null if not applicable.\n   */\n  getFocusContext($container) {\n    return arrays.find(this._focusContexts, function(focusContext) {\n      return focusContext.$container === $container;\n    });\n  }\n\n  _findFocusContextFor($element) {\n    $element = $.ensure($element);\n    var context = null;\n    var distance = Number.MAX_VALUE;\n    this._focusContexts.forEach(function(focusContext) {\n      if (!focusContext.$container.isOrHas($element)) {\n        return;\n      }\n      // Return the context which is closest to the element\n      var length = $element.parentsUntil(focusContext.$container).length;\n      if (length < distance) {\n        context = focusContext;\n      }\n    });\n    return context;\n  }\n\n  /**\n   * Returns whether to accept a 'mousedown event'.\n   */\n  _acceptFocusChangeOnMouseDown($element) {\n    // 1. Prevent focus gain when glasspane is clicked.\n    //    Even if the glasspane is not focusable, this check is required because the glasspane might be contained in a focusable container\n    //    like table. Use case: outline modality with table-page as 'outlineContent'.\n    if ($element.hasClass('glasspane')) {\n      return false;\n    }\n\n    // 2. Prevent focus gain if covert by glasspane.\n    if (this.isElementCovertByGlassPane($element)) {\n      return false;\n    }\n\n    // 3. Prevent focus gain on elements excluded to gain focus by mouse, e.g. buttons.\n    if (!focusUtils.isFocusableByMouse($element)) {\n      return false;\n    }\n\n    // 4. Allow focus gain on focusable elements.\n    if ($element.is(':focusable')) {\n      return true;\n    }\n\n    // 5. Allow focus gain on elements with selectable content, e.g. the value of a label field.\n    if (focusUtils.isSelectableText($element)) {\n      return true;\n    }\n\n    // 6. Allow focus gain on elements with a focusable parent, e.g. when clicking on a row in a table.\n    if (focusUtils.containsParentFocusableByMouse($element, $element.entryPoint())) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Registers the given focus context, or moves it on top if already registered.\n   */\n  _pushIfAbsendElseMoveTop(focusContext) {\n    arrays.remove(this._focusContexts, focusContext);\n    this._focusContexts.push(focusContext);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}