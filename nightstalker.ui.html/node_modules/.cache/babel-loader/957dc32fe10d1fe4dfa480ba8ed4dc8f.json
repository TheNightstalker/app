{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport $ from 'jquery';\nimport { scout } from '../index';\n/**\n * Enhances the table with selection behaviour.<p>\n *\n * If mouseMoveSelectionEnabled is set to true, the user can select the rows by moving the mouse with pressed left mouse button.\n *\n */\n\nvar TableSelectionHandler = /*#__PURE__*/function () {\n  function TableSelectionHandler(table) {\n    _classCallCheck(this, TableSelectionHandler);\n\n    this.table = table;\n    this.mouseMoveSelectionEnabled = true;\n    this._mouseDown = false;\n    this.lastActionRow = null;\n    this._allRows = null;\n    this.mouseOverHandler = null;\n    this.select = true;\n    this.counterDebug = 0;\n    this.fromIndex = -1;\n    this.toIndex = -1; // Index of the row that got a 'mouseover' event previously (needed to determine if the user is going up or down)\n\n    this._prevSelectedRowIndex = -1; // The index of the selected row with the greatest distance to fromIndex (needed to efficiently clear the selection)\n\n    this._maxSelectedRowIndex = -1;\n  }\n\n  _createClass(TableSelectionHandler, [{\n    key: \"clearLastSelectedRowMarker\",\n    value: function clearLastSelectedRowMarker() {\n      this.lastActionRow = null;\n    } // TODO [7.0] bsh: Table Selection | Try to merge this with TableKeystrokeContext\n\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      var $row = $(event.currentTarget),\n          row = $row.data('row'),\n          oldSelectedState = $row.isSelected();\n      this._mouseDown = true;\n      this._allRows = this.table.visibleRows;\n      this.select = true;\n\n      if (this.table.multiSelect && event.shiftKey) {\n        // when a selected row in the middle of a selection-block has\n        // been clicked while shift is pressed -> do nothing\n        if (this.table.selectedRows.indexOf(row) > -1) {\n          return;\n        }\n\n        if (this.table.selectedRows.length === 0) {\n          // Shift-click was pressed without selection -> behave like normal click\n          this.lastActionRow = row;\n        }\n\n        if (!this.lastActionRow) {\n          // The last action row may have been cleared, e.g. when rows have been replaced. In that case, simply assume\n          // the first or the last of the currently selected rows as being the last action row to make shift-click\n          // behave as expected (depending on which row is nearer from the clicked row).\n          var thisRowIndex = this._allRows.indexOf(row);\n\n          var firstSelectedRow = this.table.selectedRows[0];\n          var lastSelectedRow = this.table.selectedRows[this.table.selectedRows.length - 1];\n\n          if (thisRowIndex <= (this._allRows.indexOf(firstSelectedRow) + this._allRows.indexOf(lastSelectedRow)) / 2) {\n            this.lastActionRow = firstSelectedRow;\n          } else {\n            this.lastActionRow = lastSelectedRow;\n          }\n\n          this._maxSelectedRowIndex = this._allRows.indexOf(lastSelectedRow);\n          this._prevSelectedRowIndex = this._allRows.indexOf(this.lastActionRow);\n        }\n\n        this.fromIndex = this._allRows.indexOf(this.lastActionRow);\n      } else if (event.ctrlKey) {\n        this.select = !oldSelectedState;\n      } else {\n        // Click on the already selected row must not clear the selection it to avoid another selection event sent to the server\n        // Right click on already selected rows must not clear the selection\n        if (!oldSelectedState || this.table.selectedRows.length > 1 && event.which !== 3) {\n          this.table._removeSelection();\n\n          this.table.selectedRows = [];\n        }\n      }\n\n      if (this.fromIndex < 0) {\n        this.fromIndex = this._allRows.indexOf(row);\n      }\n\n      if (event.which !== 3 || !oldSelectedState) {\n        this.toIndex = this._allRows.indexOf(row);\n        this.handleSelection(event);\n        this.table.notifyRowSelectionFinished();\n      }\n\n      if (this.mouseMoveSelectionEnabled && event.which !== 3) {\n        this.table.$data.off('mouseover', this.mouseOverHandler);\n        this.mouseOverHandler = this.onMouseOver.bind(this);\n        this.table.$data.on('mouseover', '.table-row', this.mouseOverHandler); // This additionally window listener is necessary to track the clicks outside of a table row.\n        // If the mouse is released on a table row, onMouseUp gets called by the table's mouseUp listener.\n      }\n\n      $row.window().one('mouseup.selectionHandler', this.onMouseUp.bind(this));\n      this.lastActionRow = row;\n    }\n  }, {\n    key: \"onMouseOver\",\n    value: function onMouseOver(event) {\n      var $row = $(event.currentTarget),\n          row = $row.data('row');\n      this.toIndex = this._allRows.indexOf(row);\n      this.handleSelection(event);\n      this.lastActionRow = row;\n    }\n  }, {\n    key: \"handleSelection\",\n    value: function handleSelection(event) {\n      var rowsToUnselect;\n\n      if (this.table.multiSelect) {\n        // Multi-selection -> expand/shrink selection\n        var thisIndex = this.toIndex;\n        var goingUp = thisIndex < this._prevSelectedRowIndex;\n        var goingDown = thisIndex > this._prevSelectedRowIndex;\n        var beforeFromSelection = this._prevSelectedRowIndex < this.fromIndex;\n        var afterFromSelection = this._prevSelectedRowIndex > this.fromIndex; // In 'ctrlKey' mode, the unselection is done via 'select=false'\n        // Also prevent unselect in shiftKey mode, because otherwise we'd could\n        // possibly have unwanted gaps within the selection block (see #172929).\n\n        if (!event.ctrlKey) {\n          // If we are going _towards_ the startIndex, unselect all rows between the current row and the\n          // selected row with the greatest distance (this._maxSelectedRowIndex).\n          if (goingUp && afterFromSelection) {\n            rowsToUnselect = this._allRows.slice(thisIndex + 1, this._maxSelectedRowIndex + 1);\n          } else if (goingDown && beforeFromSelection) {\n            rowsToUnselect = this._allRows.slice(this._maxSelectedRowIndex, thisIndex);\n          } // when shift is pressed: only unselect when first or last row (but not in the middle of the selection, see #172929)\n\n\n          if (rowsToUnselect && event.shiftKey) {\n            var selectionIndizes = this.getMinMaxSelectionIndizes();\n            rowsToUnselect = rowsToUnselect.reduce(function (aggr, row) {\n              var rowIndex = this._allRows.indexOf(row);\n\n              if (scout.isOneOf(rowIndex, selectionIndizes[0], selectionIndizes[1])) {\n                aggr.push(row);\n              }\n\n              return aggr;\n            }.bind(this), []);\n          }\n\n          if (rowsToUnselect) {\n            rowsToUnselect.forEach(function (row) {\n              this.table.removeRowFromSelection(row, true);\n            }, this);\n          }\n        } // Adjust the indexes\n\n\n        this._maxSelectedRowIndex = goingUp ? Math.min(this._maxSelectedRowIndex, thisIndex) : goingDown ? Math.max(this._maxSelectedRowIndex, thisIndex) : thisIndex;\n        this._prevSelectedRowIndex = thisIndex;\n      } else {\n        // Single selection -> unselect previously selected row\n        if (this.select) {\n          this.table._removeSelection();\n\n          this.table.selectedRows = [];\n        } // Adjust the indexes\n\n\n        this.fromIndex = this.toIndex;\n      } // Set the new selection\n\n\n      this._selectRange(this.fromIndex, this.toIndex, this.select);\n    }\n  }, {\n    key: \"_selectRange\",\n    value: function _selectRange(fromIndex, toIndex, select) {\n      var startIndex = Math.min(fromIndex, toIndex),\n          endIndex = Math.max(fromIndex, toIndex) + 1,\n          actionRows = this._allRows.slice(startIndex, endIndex); // set/remove selection\n\n\n      if (select) {\n        actionRows.forEach(function (row) {\n          this.table.addRowToSelection(row, true);\n        }, this);\n      } else {\n        actionRows.forEach(function (row) {\n          this.table.removeRowFromSelection(row, true);\n        }, this);\n      }\n    }\n  }, {\n    key: \"getMinMaxSelectionIndizes\",\n    value: function getMinMaxSelectionIndizes() {\n      var selectedRows = this.table.selectedRows,\n          allRows = this.table.visibleRows;\n\n      if (!selectedRows || selectedRows.length === 0) {\n        return [-1, -1];\n      }\n\n      var min = -1,\n          max = -1;\n      selectedRows.forEach(function (row) {\n        var index = allRows.indexOf(row);\n\n        if (min === -1 || index < min) {\n          min = index;\n        }\n\n        if (max === -1 || index > max) {\n          max = index;\n        }\n      });\n      return [min, max];\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(event) {\n      if (!this._mouseDown) {\n        // May happen when selecting elements with chrome dev tools\n        return;\n      }\n\n      if (!this.table.rendered) {\n        // May happen when the table is removed between the mouse down and the mouse up event\n        // (e.g. when the user clicks 3 times very fast --> table is removed after double click).\n        return;\n      }\n\n      this._mouseDown = false;\n      this.table.$data.off('mouseover', this.mouseOverHandler);\n      this._allRows = null;\n      this.fromIndex = -1;\n      this.toIndex = -1;\n      this.select = true; // Update selectedRows and allRows, this might have changed in the meantime (e.g. when row\n      // was replaced by update event due to cell editing)\n\n      this.table.notifyRowSelectionFinished();\n    }\n  }]);\n\n  return TableSelectionHandler;\n}();\n\nexport { TableSelectionHandler as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/table/TableSelectionHandler.js"],"names":["$","scout","TableSelectionHandler","table","mouseMoveSelectionEnabled","_mouseDown","lastActionRow","_allRows","mouseOverHandler","select","counterDebug","fromIndex","toIndex","_prevSelectedRowIndex","_maxSelectedRowIndex","event","$row","currentTarget","row","data","oldSelectedState","isSelected","visibleRows","multiSelect","shiftKey","selectedRows","indexOf","length","thisRowIndex","firstSelectedRow","lastSelectedRow","ctrlKey","which","_removeSelection","handleSelection","notifyRowSelectionFinished","$data","off","onMouseOver","bind","on","window","one","onMouseUp","rowsToUnselect","thisIndex","goingUp","goingDown","beforeFromSelection","afterFromSelection","slice","selectionIndizes","getMinMaxSelectionIndizes","reduce","aggr","rowIndex","isOneOf","push","forEach","removeRowFromSelection","Math","min","max","_selectRange","startIndex","endIndex","actionRows","addRowToSelection","allRows","index","rendered"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport $ from 'jquery';\nimport {scout} from '../index';\n\n/**\n * Enhances the table with selection behaviour.<p>\n *\n * If mouseMoveSelectionEnabled is set to true, the user can select the rows by moving the mouse with pressed left mouse button.\n *\n */\nexport default class TableSelectionHandler {\n\n  constructor(table) {\n    this.table = table;\n    this.mouseMoveSelectionEnabled = true;\n    this._mouseDown = false;\n    this.lastActionRow = null;\n    this._allRows = null;\n    this.mouseOverHandler = null;\n    this.select = true;\n    this.counterDebug = 0;\n\n    this.fromIndex = -1;\n    this.toIndex = -1;\n    // Index of the row that got a 'mouseover' event previously (needed to determine if the user is going up or down)\n    this._prevSelectedRowIndex = -1;\n    // The index of the selected row with the greatest distance to fromIndex (needed to efficiently clear the selection)\n    this._maxSelectedRowIndex = -1;\n  }\n\n  clearLastSelectedRowMarker() {\n    this.lastActionRow = null;\n  }\n\n  // TODO [7.0] bsh: Table Selection | Try to merge this with TableKeystrokeContext\n  onMouseDown(event) {\n    var $row = $(event.currentTarget),\n      row = $row.data('row'),\n      oldSelectedState = $row.isSelected();\n    this._mouseDown = true;\n\n    this._allRows = this.table.visibleRows;\n    this.select = true;\n    if (this.table.multiSelect && event.shiftKey) {\n      // when a selected row in the middle of a selection-block has\n      // been clicked while shift is pressed -> do nothing\n      if (this.table.selectedRows.indexOf(row) > -1) {\n        return;\n      }\n      if (this.table.selectedRows.length === 0) {\n        // Shift-click was pressed without selection -> behave like normal click\n        this.lastActionRow = row;\n      }\n      if (!this.lastActionRow) {\n        // The last action row may have been cleared, e.g. when rows have been replaced. In that case, simply assume\n        // the first or the last of the currently selected rows as being the last action row to make shift-click\n        // behave as expected (depending on which row is nearer from the clicked row).\n        var thisRowIndex = this._allRows.indexOf(row);\n        var firstSelectedRow = this.table.selectedRows[0];\n        var lastSelectedRow = this.table.selectedRows[this.table.selectedRows.length - 1];\n        if (thisRowIndex <= (this._allRows.indexOf(firstSelectedRow) + this._allRows.indexOf(lastSelectedRow)) / 2) {\n          this.lastActionRow = firstSelectedRow;\n        } else {\n          this.lastActionRow = lastSelectedRow;\n        }\n        this._maxSelectedRowIndex = this._allRows.indexOf(lastSelectedRow);\n        this._prevSelectedRowIndex = this._allRows.indexOf(this.lastActionRow);\n      }\n      this.fromIndex = this._allRows.indexOf(this.lastActionRow);\n    } else if (event.ctrlKey) {\n      this.select = !oldSelectedState;\n    } else {\n      // Click on the already selected row must not clear the selection it to avoid another selection event sent to the server\n      // Right click on already selected rows must not clear the selection\n      if (!oldSelectedState || (this.table.selectedRows.length > 1 && event.which !== 3)) {\n        this.table._removeSelection();\n        this.table.selectedRows = [];\n      }\n    }\n    if (this.fromIndex < 0) {\n      this.fromIndex = this._allRows.indexOf(row);\n    }\n\n    if (event.which !== 3 || !oldSelectedState) {\n      this.toIndex = this._allRows.indexOf(row);\n      this.handleSelection(event);\n      this.table.notifyRowSelectionFinished();\n    }\n\n    if (this.mouseMoveSelectionEnabled && event.which !== 3) {\n      this.table.$data.off('mouseover', this.mouseOverHandler);\n      this.mouseOverHandler = this.onMouseOver.bind(this);\n      this.table.$data.on('mouseover', '.table-row', this.mouseOverHandler);\n      // This additionally window listener is necessary to track the clicks outside of a table row.\n      // If the mouse is released on a table row, onMouseUp gets called by the table's mouseUp listener.\n    }\n\n    $row.window().one('mouseup.selectionHandler', this.onMouseUp.bind(this));\n    this.lastActionRow = row;\n  }\n\n  onMouseOver(event) {\n    var $row = $(event.currentTarget),\n      row = $row.data('row');\n    this.toIndex = this._allRows.indexOf(row);\n    this.handleSelection(event);\n    this.lastActionRow = row;\n  }\n\n  handleSelection(event) {\n    var rowsToUnselect;\n    if (this.table.multiSelect) {\n      // Multi-selection -> expand/shrink selection\n      var thisIndex = this.toIndex;\n      var goingUp = (thisIndex < this._prevSelectedRowIndex);\n      var goingDown = (thisIndex > this._prevSelectedRowIndex);\n      var beforeFromSelection = (this._prevSelectedRowIndex < this.fromIndex);\n      var afterFromSelection = (this._prevSelectedRowIndex > this.fromIndex);\n\n      // In 'ctrlKey' mode, the unselection is done via 'select=false'\n      // Also prevent unselect in shiftKey mode, because otherwise we'd could\n      // possibly have unwanted gaps within the selection block (see #172929).\n      if (!event.ctrlKey) {\n\n        // If we are going _towards_ the startIndex, unselect all rows between the current row and the\n        // selected row with the greatest distance (this._maxSelectedRowIndex).\n        if (goingUp && afterFromSelection) {\n          rowsToUnselect = this._allRows.slice(thisIndex + 1, this._maxSelectedRowIndex + 1);\n        } else if (goingDown && beforeFromSelection) {\n          rowsToUnselect = this._allRows.slice(this._maxSelectedRowIndex, thisIndex);\n        }\n\n        // when shift is pressed: only unselect when first or last row (but not in the middle of the selection, see #172929)\n        if (rowsToUnselect && event.shiftKey) {\n          var selectionIndizes = this.getMinMaxSelectionIndizes();\n          rowsToUnselect = rowsToUnselect.reduce(function(aggr, row) {\n            var rowIndex = this._allRows.indexOf(row);\n            if (scout.isOneOf(rowIndex, selectionIndizes[0], selectionIndizes[1])) {\n              aggr.push(row);\n            }\n            return aggr;\n          }.bind(this), []);\n        }\n\n        if (rowsToUnselect) {\n          rowsToUnselect.forEach(function(row) {\n            this.table.removeRowFromSelection(row, true);\n          }, this);\n        }\n      }\n      // Adjust the indexes\n      this._maxSelectedRowIndex = (goingUp ? Math.min(this._maxSelectedRowIndex, thisIndex) : (goingDown ? Math.max(this._maxSelectedRowIndex, thisIndex) : thisIndex));\n      this._prevSelectedRowIndex = thisIndex;\n    } else {\n      // Single selection -> unselect previously selected row\n      if (this.select) {\n        this.table._removeSelection();\n        this.table.selectedRows = [];\n      }\n\n      // Adjust the indexes\n      this.fromIndex = this.toIndex;\n    }\n\n    // Set the new selection\n    this._selectRange(this.fromIndex, this.toIndex, this.select);\n  }\n\n  _selectRange(fromIndex, toIndex, select) {\n    var startIndex = Math.min(fromIndex, toIndex),\n      endIndex = Math.max(fromIndex, toIndex) + 1,\n      actionRows = this._allRows.slice(startIndex, endIndex);\n    // set/remove selection\n    if (select) {\n      actionRows.forEach(function(row) {\n        this.table.addRowToSelection(row, true);\n      }, this);\n    } else {\n      actionRows.forEach(function(row) {\n        this.table.removeRowFromSelection(row, true);\n      }, this);\n    }\n  }\n\n  getMinMaxSelectionIndizes() {\n    var\n      selectedRows = this.table.selectedRows,\n      allRows = this.table.visibleRows;\n\n    if (!selectedRows || selectedRows.length === 0) {\n      return [-1, -1];\n    }\n\n    var min = -1,\n      max = -1;\n    selectedRows.forEach(function(row) {\n      var index = allRows.indexOf(row);\n      if (min === -1 || index < min) {\n        min = index;\n      }\n      if (max === -1 || index > max) {\n        max = index;\n      }\n    });\n    return [min, max];\n  }\n\n  onMouseUp(event) {\n    if (!this._mouseDown) {\n      // May happen when selecting elements with chrome dev tools\n      return;\n    }\n    if (!this.table.rendered) {\n      // May happen when the table is removed between the mouse down and the mouse up event\n      // (e.g. when the user clicks 3 times very fast --> table is removed after double click).\n      return;\n    }\n\n    this._mouseDown = false;\n    this.table.$data.off('mouseover', this.mouseOverHandler);\n    this._allRows = null;\n    this.fromIndex = -1;\n    this.toIndex = -1;\n    this.select = true;\n    // Update selectedRows and allRows, this might have changed in the meantime (e.g. when row\n    // was replaced by update event due to cell editing)\n    this.table.notifyRowSelectionFinished();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}