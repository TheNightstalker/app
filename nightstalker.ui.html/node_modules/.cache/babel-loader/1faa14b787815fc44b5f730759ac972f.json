{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { objects, scout, SmartField, strings } from '../../../index';\nimport $ from 'jquery';\n\nvar ProposalField = /*#__PURE__*/function (_SmartField) {\n  _inherits(ProposalField, _SmartField);\n\n  var _super = _createSuper(ProposalField);\n\n  function ProposalField() {\n    var _this;\n\n    _classCallCheck(this, ProposalField);\n\n    _this = _super.call(this);\n    _this.maxLength = 4000;\n    _this.trimText = true;\n    /**\n     * If this flag is set to true the proposal field performs a lookup by text when\n     * accept proposal is called. The behavior is similar to what the smart-field does\n     * in that case, but without the need to have a valid single match as the result\n     * from the lookup.\n     */\n\n    _this.lookupOnAcceptByText = false;\n    return _this;\n  }\n\n  _createClass(ProposalField, [{\n    key: \"_getValueFromLookupRow\",\n    value: function _getValueFromLookupRow(lookupRow) {\n      return lookupRow.text;\n    }\n  }, {\n    key: \"_getLastSearchText\",\n    value: function _getLastSearchText() {\n      return this.value;\n    }\n  }, {\n    key: \"cssClassName\",\n    value: function cssClassName() {\n      return 'proposal-field';\n    }\n  }, {\n    key: \"_handleEnterKey\",\n    value: function _handleEnterKey(event) {\n      // The state of 'this.popup' is different on various browsers. On some browsers (IE11) we don't\n      // do CSS animations. This means IE11 sets the popup to null immediately whereas other browsers\n      // use a timeout. Anyway: in case the popup is open at the time the user presses enter, we must\n      // stop propagation (e.g. to avoid calls of other registered enter key-shortcuts, like the default\n      // button on a form). See Widget.js for details about removing with or without CSS animations.\n      var hasPopup = !!this.popup;\n      this.acceptInput();\n\n      if (this.popup) {\n        this.closePopup();\n      }\n\n      if (hasPopup) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"_lookupByTextOrAllDone\",\n    value: function _lookupByTextOrAllDone(result) {\n      if (_get(_getPrototypeOf(ProposalField.prototype), \"_handleException\", this).call(this, result)) {\n        return;\n      }\n\n      if (result.lookupRows.length === 0) {\n        this.setLoading(false);\n\n        this._handleEmptyResult();\n\n        return;\n      }\n\n      _get(_getPrototypeOf(ProposalField.prototype), \"_lookupByTextOrAllDone\", this).call(this, result);\n    }\n  }, {\n    key: \"_formatValue\",\n    value: function _formatValue(value) {\n      return scout.nvl(value, '');\n    }\n  }, {\n    key: \"_validateValue\",\n    value: function _validateValue(value) {\n      if (objects.isNullOrUndefined(value)) {\n        return value;\n      }\n\n      var validValue = strings.asString(value);\n\n      if (this.trimText) {\n        validValue = validValue.trim();\n      }\n\n      if (validValue.length > this.maxLength) {\n        validValue = validValue.substring(0, this.maxLength);\n      }\n\n      if (validValue === '') {\n        validValue = null;\n      }\n\n      return validValue;\n    }\n  }, {\n    key: \"_ensureValue\",\n    value: function _ensureValue(value) {\n      return strings.asString(value);\n    }\n    /**\n     * When 'clear' has been clicked (searchText is empty), we want to call customTextAccepted,\n     * so the new value is sent to the server #221199.\n     */\n\n  }, {\n    key: \"_acceptByText\",\n    value: function _acceptByText(sync, searchText) {\n      $.log.isDebugEnabled() && $.log.debug('(ProposalField#_acceptByText) searchText=', searchText);\n      var async = !sync; // In case sync=true we cannot wait for the results of the lookup-call,\n      // that's why we simply accept the text that's already in the field\n\n      if (async && this.lookupOnAcceptByText && strings.hasText(searchText)) {\n        _get(_getPrototypeOf(ProposalField.prototype), \"_acceptByTextAsync\", this).call(this, searchText);\n      } else {\n        this._customTextAccepted(searchText);\n      }\n    }\n    /**\n     * Only used in case lookupOnAcceptByText is true. It's basically the same code\n     * as in the smart-field but without the error handling.\n     */\n\n  }, {\n    key: \"_acceptByTextDone\",\n    value: function _acceptByTextDone(result) {\n      this._userWasTyping = false;\n\n      this._extendResult(result); // when there's exactly one result, we accept that lookup row\n\n\n      if (result.uniqueMatch) {\n        var lookupRow = result.uniqueMatch;\n\n        if (this._isLookupRowActive(lookupRow)) {\n          this.setLookupRow(lookupRow);\n\n          this._inputAccepted();\n\n          return;\n        }\n      }\n\n      this._customTextAccepted(result.text);\n    }\n  }, {\n    key: \"_checkResetLookupRow\",\n    value: function _checkResetLookupRow(value) {\n      return this.lookupRow && this.lookupRow.text !== value;\n    }\n  }, {\n    key: \"_checkSearchTextChanged\",\n    value: function _checkSearchTextChanged(searchText) {\n      return this._checkDisplayTextChanged(searchText);\n    }\n  }, {\n    key: \"_customTextAccepted\",\n    value: function _customTextAccepted(searchText) {\n      this._setLookupRow(null); // only reset property lookup\n\n\n      this._setValue(searchText);\n\n      this._inputAccepted(true, false);\n    }\n  }, {\n    key: \"getValueForSelection\",\n    value: function getValueForSelection() {\n      return this._showSelection() ? this.lookupRow.key : null;\n    }\n    /**\n     * This function is overridden by ProposalField because it has a different behavior than the smart-field.\n     */\n\n  }, {\n    key: \"_acceptLookupRowAndValueFromField\",\n    value: function _acceptLookupRowAndValueFromField(otherField) {\n      if (this.lookupRow !== otherField.lookupRow) {\n        this.setLookupRow(otherField.lookupRow);\n      }\n    }\n    /**\n     * In ProposalField value and display-text is the same. When a custom text has been entered,\n     * the value is set and the lookup-row is null.\n     */\n\n  }, {\n    key: \"_copyValuesFromField\",\n    value: function _copyValuesFromField(otherField) {\n      if (this.lookupRow !== otherField.lookupRow) {\n        this.setLookupRow(otherField.lookupRow);\n      }\n\n      if (this.value !== otherField.value) {\n        this.setValue(otherField.value);\n      }\n    }\n  }, {\n    key: \"_acceptInput\",\n    value: function _acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow) {\n      // Do nothing when search text is equals to the text of the current lookup row\n      if (!selectedLookupRow && this.lookupRow && this.lookupRow.text === searchText) {\n        $.log.isDebugEnabled() && $.log.debug('(ProposalField#_acceptInput) unchanged: text is equals. Close popup');\n\n        this._inputAccepted(false);\n\n        return;\n      } // 2.) proposal chooser is open -> use the selected row as value\n\n\n      if (selectedLookupRow) {\n        $.log.isDebugEnabled() && $.log.debug('(ProposalField#_acceptInput) lookup-row selected. Set lookup-row, close popup lookupRow=', selectedLookupRow.toString());\n        this.clearErrorStatus();\n        this.setLookupRow(selectedLookupRow);\n\n        this._inputAccepted();\n\n        return;\n      } // 3.) proposal chooser is not open -> try to accept the current display text\n      // this causes a lookup which may fail and open a new proposal chooser (property\n      // change for 'result').\n\n\n      if (searchTextChanged) {\n        this._acceptByText(sync, searchText);\n      } else if (!this._hasUiError()) {\n        this._inputAccepted(false);\n      } else {\n        // even though there's nothing todo, someone could wait for our promise to be resolved\n        this._acceptInputDeferred.resolve();\n      }\n\n      return this._acceptInputDeferred.promise();\n    }\n  }, {\n    key: \"setTrimText\",\n    value: function setTrimText(trimText) {\n      this.setProperty('trimText', trimText);\n    }\n  }, {\n    key: \"setMaxLength\",\n    value: function setMaxLength(maxLength) {\n      this.setProperty('maxLength', maxLength);\n    }\n    /**\n     * @override ValueField.js\n     */\n\n  }, {\n    key: \"_updateEmpty\",\n    value: function _updateEmpty() {\n      this.empty = strings.empty(this.value);\n    }\n  }]);\n\n  return ProposalField;\n}(SmartField);\n\nexport { ProposalField as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/form/fields/smartfield/ProposalField.js"],"names":["objects","scout","SmartField","strings","$","ProposalField","maxLength","trimText","lookupOnAcceptByText","lookupRow","text","value","event","hasPopup","popup","acceptInput","closePopup","stopPropagation","result","lookupRows","length","setLoading","_handleEmptyResult","nvl","isNullOrUndefined","validValue","asString","trim","substring","sync","searchText","log","isDebugEnabled","debug","async","hasText","_customTextAccepted","_userWasTyping","_extendResult","uniqueMatch","_isLookupRowActive","setLookupRow","_inputAccepted","_checkDisplayTextChanged","_setLookupRow","_setValue","_showSelection","key","otherField","setValue","searchTextEmpty","searchTextChanged","selectedLookupRow","toString","clearErrorStatus","_acceptByText","_hasUiError","_acceptInputDeferred","resolve","promise","setProperty","empty"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,OAAR,EAAiBC,KAAjB,EAAwBC,UAAxB,EAAoCC,OAApC,QAAkD,gBAAlD;AACA,OAAOC,CAAP,MAAc,QAAd;;IAEqBC,a;;;;;AAEnB,2BAAc;AAAA;;AAAA;;AACZ;AAEA,UAAKC,SAAL,GAAiB,IAAjB;AACA,UAAKC,QAAL,GAAgB,IAAhB;AAEA;AACJ;AACA;AACA;AACA;AACA;;AACI,UAAKC,oBAAL,GAA4B,KAA5B;AAZY;AAab;;;;2CAEsBC,S,EAAW;AAChC,aAAOA,SAAS,CAACC,IAAjB;AACD;;;yCAEoB;AACnB,aAAO,KAAKC,KAAZ;AACD;;;mCAEc;AACb,aAAO,gBAAP;AACD;;;oCAEeC,K,EAAO;AACrB;AACA;AACA;AACA;AACA;AACA,UAAIC,QAAQ,GAAG,CAAC,CAAC,KAAKC,KAAtB;AACA,WAAKC,WAAL;;AACA,UAAI,KAAKD,KAAT,EAAgB;AACd,aAAKE,UAAL;AACD;;AACD,UAAIH,QAAJ,EAAc;AACZD,QAAAA,KAAK,CAACK,eAAN;AACD;AACF;;;2CAEsBC,M,EAAQ;AAC7B,8FAA2BA,MAA3B,GAAoC;AAClC;AACD;;AACD,UAAIA,MAAM,CAACC,UAAP,CAAkBC,MAAlB,KAA6B,CAAjC,EAAoC;AAClC,aAAKC,UAAL,CAAgB,KAAhB;;AACA,aAAKC,kBAAL;;AACA;AACD;;AACD,gGAA6BJ,MAA7B;AACD;;;iCAEYP,K,EAAO;AAClB,aAAOV,KAAK,CAACsB,GAAN,CAAUZ,KAAV,EAAiB,EAAjB,CAAP;AACD;;;mCAEcA,K,EAAO;AACpB,UAAIX,OAAO,CAACwB,iBAAR,CAA0Bb,KAA1B,CAAJ,EAAsC;AACpC,eAAOA,KAAP;AACD;;AACD,UAAIc,UAAU,GAAGtB,OAAO,CAACuB,QAAR,CAAiBf,KAAjB,CAAjB;;AACA,UAAI,KAAKJ,QAAT,EAAmB;AACjBkB,QAAAA,UAAU,GAAGA,UAAU,CAACE,IAAX,EAAb;AACD;;AACD,UAAIF,UAAU,CAACL,MAAX,GAAoB,KAAKd,SAA7B,EAAwC;AACtCmB,QAAAA,UAAU,GAAGA,UAAU,CAACG,SAAX,CAAqB,CAArB,EAAwB,KAAKtB,SAA7B,CAAb;AACD;;AACD,UAAImB,UAAU,KAAK,EAAnB,EAAuB;AACrBA,QAAAA,UAAU,GAAG,IAAb;AACD;;AACD,aAAOA,UAAP;AACD;;;iCAEYd,K,EAAO;AAClB,aAAOR,OAAO,CAACuB,QAAR,CAAiBf,KAAjB,CAAP;AACD;AAED;AACF;AACA;AACA;;;;kCACgBkB,I,EAAMC,U,EAAY;AAC9B1B,MAAAA,CAAC,CAAC2B,GAAF,CAAMC,cAAN,MAA0B5B,CAAC,CAAC2B,GAAF,CAAME,KAAN,CAAY,2CAAZ,EAAyDH,UAAzD,CAA1B;AACA,UAAII,KAAK,GAAG,CAACL,IAAb,CAF8B,CAI9B;AACA;;AACA,UAAIK,KAAK,IAAI,KAAK1B,oBAAd,IAAsCL,OAAO,CAACgC,OAAR,CAAgBL,UAAhB,CAA1C,EAAuE;AACrE,8FAAyBA,UAAzB;AACD,OAFD,MAEO;AACL,aAAKM,mBAAL,CAAyBN,UAAzB;AACD;AACF;AAED;AACF;AACA;AACA;;;;sCACoBZ,M,EAAQ;AACxB,WAAKmB,cAAL,GAAsB,KAAtB;;AACA,WAAKC,aAAL,CAAmBpB,MAAnB,EAFwB,CAIxB;;;AACA,UAAIA,MAAM,CAACqB,WAAX,EAAwB;AACtB,YAAI9B,SAAS,GAAGS,MAAM,CAACqB,WAAvB;;AACA,YAAI,KAAKC,kBAAL,CAAwB/B,SAAxB,CAAJ,EAAwC;AACtC,eAAKgC,YAAL,CAAkBhC,SAAlB;;AACA,eAAKiC,cAAL;;AACA;AACD;AACF;;AAED,WAAKN,mBAAL,CAAyBlB,MAAM,CAACR,IAAhC;AACD;;;yCAEoBC,K,EAAO;AAC1B,aAAO,KAAKF,SAAL,IAAkB,KAAKA,SAAL,CAAeC,IAAf,KAAwBC,KAAjD;AACD;;;4CAEuBmB,U,EAAY;AAClC,aAAO,KAAKa,wBAAL,CAA8Bb,UAA9B,CAAP;AACD;;;wCAEmBA,U,EAAY;AAC9B,WAAKc,aAAL,CAAmB,IAAnB,EAD8B,CACJ;;;AAC1B,WAAKC,SAAL,CAAef,UAAf;;AACA,WAAKY,cAAL,CAAoB,IAApB,EAA0B,KAA1B;AACD;;;2CAEsB;AACrB,aAAO,KAAKI,cAAL,KAAwB,KAAKrC,SAAL,CAAesC,GAAvC,GAA6C,IAApD;AACD;AAED;AACF;AACA;;;;sDACoCC,U,EAAY;AAC5C,UAAI,KAAKvC,SAAL,KAAmBuC,UAAU,CAACvC,SAAlC,EAA6C;AAC3C,aAAKgC,YAAL,CAAkBO,UAAU,CAACvC,SAA7B;AACD;AACF;AAED;AACF;AACA;AACA;;;;yCACuBuC,U,EAAY;AAC/B,UAAI,KAAKvC,SAAL,KAAmBuC,UAAU,CAACvC,SAAlC,EAA6C;AAC3C,aAAKgC,YAAL,CAAkBO,UAAU,CAACvC,SAA7B;AACD;;AACD,UAAI,KAAKE,KAAL,KAAeqC,UAAU,CAACrC,KAA9B,EAAqC;AACnC,aAAKsC,QAAL,CAAcD,UAAU,CAACrC,KAAzB;AACD;AACF;;;iCAEYkB,I,EAAMC,U,EAAYoB,e,EAAiBC,iB,EAAmBC,iB,EAAmB;AACpF;AACA,UAAI,CAACA,iBAAD,IAAsB,KAAK3C,SAA3B,IAAwC,KAAKA,SAAL,CAAeC,IAAf,KAAwBoB,UAApE,EAAgF;AAC9E1B,QAAAA,CAAC,CAAC2B,GAAF,CAAMC,cAAN,MAA0B5B,CAAC,CAAC2B,GAAF,CAAME,KAAN,CAAY,qEAAZ,CAA1B;;AACA,aAAKS,cAAL,CAAoB,KAApB;;AACA;AACD,OANmF,CAQpF;;;AACA,UAAIU,iBAAJ,EAAuB;AACrBhD,QAAAA,CAAC,CAAC2B,GAAF,CAAMC,cAAN,MAA0B5B,CAAC,CAAC2B,GAAF,CAAME,KAAN,CAAY,0FAAZ,EAAwGmB,iBAAiB,CAACC,QAAlB,EAAxG,CAA1B;AACA,aAAKC,gBAAL;AACA,aAAKb,YAAL,CAAkBW,iBAAlB;;AACA,aAAKV,cAAL;;AACA;AACD,OAfmF,CAiBpF;AACA;AACA;;;AACA,UAAIS,iBAAJ,EAAuB;AACrB,aAAKI,aAAL,CAAmB1B,IAAnB,EAAyBC,UAAzB;AACD,OAFD,MAEO,IAAI,CAAC,KAAK0B,WAAL,EAAL,EAAyB;AAC9B,aAAKd,cAAL,CAAoB,KAApB;AACD,OAFM,MAEA;AACL;AACA,aAAKe,oBAAL,CAA0BC,OAA1B;AACD;;AAED,aAAO,KAAKD,oBAAL,CAA0BE,OAA1B,EAAP;AACD;;;gCAEWpD,Q,EAAU;AACpB,WAAKqD,WAAL,CAAiB,UAAjB,EAA6BrD,QAA7B;AACD;;;iCAEYD,S,EAAW;AACtB,WAAKsD,WAAL,CAAiB,WAAjB,EAA8BtD,SAA9B;AACD;AAED;AACF;AACA;;;;mCACiB;AACb,WAAKuD,KAAL,GAAa1D,OAAO,CAAC0D,KAAR,CAAc,KAAKlD,KAAnB,CAAb;AACD;;;;EA7MwCT,U;;SAAtBG,a","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {objects, scout, SmartField, strings} from '../../../index';\nimport $ from 'jquery';\n\nexport default class ProposalField extends SmartField {\n\n  constructor() {\n    super();\n\n    this.maxLength = 4000;\n    this.trimText = true;\n\n    /**\n     * If this flag is set to true the proposal field performs a lookup by text when\n     * accept proposal is called. The behavior is similar to what the smart-field does\n     * in that case, but without the need to have a valid single match as the result\n     * from the lookup.\n     */\n    this.lookupOnAcceptByText = false;\n  }\n\n  _getValueFromLookupRow(lookupRow) {\n    return lookupRow.text;\n  }\n\n  _getLastSearchText() {\n    return this.value;\n  }\n\n  cssClassName() {\n    return 'proposal-field';\n  }\n\n  _handleEnterKey(event) {\n    // The state of 'this.popup' is different on various browsers. On some browsers (IE11) we don't\n    // do CSS animations. This means IE11 sets the popup to null immediately whereas other browsers\n    // use a timeout. Anyway: in case the popup is open at the time the user presses enter, we must\n    // stop propagation (e.g. to avoid calls of other registered enter key-shortcuts, like the default\n    // button on a form). See Widget.js for details about removing with or without CSS animations.\n    var hasPopup = !!this.popup;\n    this.acceptInput();\n    if (this.popup) {\n      this.closePopup();\n    }\n    if (hasPopup) {\n      event.stopPropagation();\n    }\n  }\n\n  _lookupByTextOrAllDone(result) {\n    if (super._handleException(result)) {\n      return;\n    }\n    if (result.lookupRows.length === 0) {\n      this.setLoading(false);\n      this._handleEmptyResult();\n      return;\n    }\n    super._lookupByTextOrAllDone(result);\n  }\n\n  _formatValue(value) {\n    return scout.nvl(value, '');\n  }\n\n  _validateValue(value) {\n    if (objects.isNullOrUndefined(value)) {\n      return value;\n    }\n    var validValue = strings.asString(value);\n    if (this.trimText) {\n      validValue = validValue.trim();\n    }\n    if (validValue.length > this.maxLength) {\n      validValue = validValue.substring(0, this.maxLength);\n    }\n    if (validValue === '') {\n      validValue = null;\n    }\n    return validValue;\n  }\n\n  _ensureValue(value) {\n    return strings.asString(value);\n  }\n\n  /**\n   * When 'clear' has been clicked (searchText is empty), we want to call customTextAccepted,\n   * so the new value is sent to the server #221199.\n   */\n  _acceptByText(sync, searchText) {\n    $.log.isDebugEnabled() && $.log.debug('(ProposalField#_acceptByText) searchText=', searchText);\n    var async = !sync;\n\n    // In case sync=true we cannot wait for the results of the lookup-call,\n    // that's why we simply accept the text that's already in the field\n    if (async && this.lookupOnAcceptByText && strings.hasText(searchText)) {\n      super._acceptByTextAsync(searchText);\n    } else {\n      this._customTextAccepted(searchText);\n    }\n  }\n\n  /**\n   * Only used in case lookupOnAcceptByText is true. It's basically the same code\n   * as in the smart-field but without the error handling.\n   */\n  _acceptByTextDone(result) {\n    this._userWasTyping = false;\n    this._extendResult(result);\n\n    // when there's exactly one result, we accept that lookup row\n    if (result.uniqueMatch) {\n      var lookupRow = result.uniqueMatch;\n      if (this._isLookupRowActive(lookupRow)) {\n        this.setLookupRow(lookupRow);\n        this._inputAccepted();\n        return;\n      }\n    }\n\n    this._customTextAccepted(result.text);\n  }\n\n  _checkResetLookupRow(value) {\n    return this.lookupRow && this.lookupRow.text !== value;\n  }\n\n  _checkSearchTextChanged(searchText) {\n    return this._checkDisplayTextChanged(searchText);\n  }\n\n  _customTextAccepted(searchText) {\n    this._setLookupRow(null); // only reset property lookup\n    this._setValue(searchText);\n    this._inputAccepted(true, false);\n  }\n\n  getValueForSelection() {\n    return this._showSelection() ? this.lookupRow.key : null;\n  }\n\n  /**\n   * This function is overridden by ProposalField because it has a different behavior than the smart-field.\n   */\n  _acceptLookupRowAndValueFromField(otherField) {\n    if (this.lookupRow !== otherField.lookupRow) {\n      this.setLookupRow(otherField.lookupRow);\n    }\n  }\n\n  /**\n   * In ProposalField value and display-text is the same. When a custom text has been entered,\n   * the value is set and the lookup-row is null.\n   */\n  _copyValuesFromField(otherField) {\n    if (this.lookupRow !== otherField.lookupRow) {\n      this.setLookupRow(otherField.lookupRow);\n    }\n    if (this.value !== otherField.value) {\n      this.setValue(otherField.value);\n    }\n  }\n\n  _acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow) {\n    // Do nothing when search text is equals to the text of the current lookup row\n    if (!selectedLookupRow && this.lookupRow && this.lookupRow.text === searchText) {\n      $.log.isDebugEnabled() && $.log.debug('(ProposalField#_acceptInput) unchanged: text is equals. Close popup');\n      this._inputAccepted(false);\n      return;\n    }\n\n    // 2.) proposal chooser is open -> use the selected row as value\n    if (selectedLookupRow) {\n      $.log.isDebugEnabled() && $.log.debug('(ProposalField#_acceptInput) lookup-row selected. Set lookup-row, close popup lookupRow=', selectedLookupRow.toString());\n      this.clearErrorStatus();\n      this.setLookupRow(selectedLookupRow);\n      this._inputAccepted();\n      return;\n    }\n\n    // 3.) proposal chooser is not open -> try to accept the current display text\n    // this causes a lookup which may fail and open a new proposal chooser (property\n    // change for 'result').\n    if (searchTextChanged) {\n      this._acceptByText(sync, searchText);\n    } else if (!this._hasUiError()) {\n      this._inputAccepted(false);\n    } else {\n      // even though there's nothing todo, someone could wait for our promise to be resolved\n      this._acceptInputDeferred.resolve();\n    }\n\n    return this._acceptInputDeferred.promise();\n  }\n\n  setTrimText(trimText) {\n    this.setProperty('trimText', trimText);\n  }\n\n  setMaxLength(maxLength) {\n    this.setProperty('maxLength', maxLength);\n  }\n\n  /**\n   * @override ValueField.js\n   */\n  _updateEmpty() {\n    this.empty = strings.empty(this.value);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}