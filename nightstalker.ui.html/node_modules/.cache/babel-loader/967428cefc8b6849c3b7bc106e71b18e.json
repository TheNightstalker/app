{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, DeferredGlassPaneTarget, Device, Form, scout } from '../index';\nimport $ from 'jquery';\n/**\n * Renders glassPanes over the 'glassPaneTargets' of a widget.\n */\n\nvar GlassPaneRenderer = /*#__PURE__*/function () {\n  function GlassPaneRenderer(widget, enabled) {\n    _classCallCheck(this, GlassPaneRenderer);\n\n    this._widget = widget;\n    this.session = widget.session;\n    this._enabled = scout.nvl(enabled, true);\n    this._$glassPanes = [];\n    this._deferredGlassPanes = [];\n    this._resolvedDisplayParent = null;\n    this._registeredDisplayParent = null;\n    this._displayParentRenderHandler = this._onDisplayParentRender.bind(this);\n    this._glassPaneRemoveHandler = this._onGlassPaneRemove.bind(this);\n    this._glassPaneRendererRegistered = false;\n  }\n\n  _createClass(GlassPaneRenderer, [{\n    key: \"renderGlassPanes\",\n    value: function renderGlassPanes() {\n      this.findGlassPaneTargets().forEach(function (glassPaneTarget) {\n        if (glassPaneTarget instanceof DeferredGlassPaneTarget) {\n          glassPaneTarget.rendererReady(this);\n\n          this._deferredGlassPanes.push(glassPaneTarget);\n        } else {\n          this.renderGlassPane(glassPaneTarget);\n        }\n      }, this);\n\n      if (!this._glassPaneRendererRegistered) {\n        this.session.focusManager.registerGlassPaneRenderer(this);\n        this._glassPaneRendererRegistered = true;\n      }\n    }\n    /**\n     * @param {($|HTMLElement)} $glassPaneTarget\n     */\n\n  }, {\n    key: \"renderGlassPane\",\n    value: function renderGlassPane($glassPaneTarget) {\n      $glassPaneTarget = $.ensure($glassPaneTarget);\n\n      if (this._widget.$container && this._widget.$container[0] === $glassPaneTarget[0]) {\n        // Don't render a glass pane on the widget itself (necessary if glass pane is added after the widget is rendered)\n        return;\n      } // If glassPaneTarget already has a glasspane added by this renderer, don't add another one\n      // May happen if a part of the display parent is removed and rendered again while covered by a glass pane\n      // E.g. display parent is set to outline and navigation is made invisible but bench is still there.\n      // When navigation is made visible again, renderGlassPanes is called but only the glass panes of the navigation need to be added and not the ones of the bench (because they are already there)\n\n\n      var alreadyRendered = this._$glassPanes.some(function ($pane) {\n        return $pane.parent()[0] === $glassPaneTarget[0];\n      });\n\n      if (alreadyRendered) {\n        return;\n      } // Render glasspanes onto glasspane targets.\n\n\n      var $glassPane = $glassPaneTarget.appendDiv('glasspane').on('mousedown', this._onMouseDown.bind(this));\n\n      this._adjustGlassPaneSize($glassPane, $glassPaneTarget); // This is required in touch mode, because FastClick messes up the order\n      // of mouse/click events which is especially important for TouchPopups.\n\n\n      if (Device.get().supportsOnlyTouch()) {\n        $glassPane.addClass('needsclick');\n      } // Glasspanes in popup-windows must be visible, otherwise the user cannot recognize that the popup\n      // is blocked, since the widget that blocks (e.g a message-box) may be opened in the main-window.\n\n\n      if ($glassPane.window(true).popupWindow) {\n        $glassPane.addClass('dark');\n      }\n\n      this._$glassPanes.push($glassPane); // Register 'glassPaneTarget' in focus manager.\n\n\n      this.session.focusManager.registerGlassPaneTarget($glassPaneTarget); // Ensure glass pane is removed properly on remove, especially necessary when display parent is removed while glass pane renderer is still active (navigation collapse case)\n\n      $glassPane.one('remove', this._glassPaneRemoveHandler);\n\n      this._registerDisplayParent();\n    }\n  }, {\n    key: \"_adjustGlassPaneSize\",\n    value: function _adjustGlassPaneSize($glassPane, $glassPaneTarget) {\n      // The glasspane must cover the border and overlapping children\n      var top = -$glassPaneTarget.cssBorderTopWidth(),\n          bottom = -$glassPaneTarget.cssBorderBottomWidth(),\n          left = -$glassPaneTarget.cssBorderLeftWidth(),\n          right = -$glassPaneTarget.cssBorderRightWidth();\n      $glassPaneTarget.children().each(function (idx, elem) {\n        var element = $(elem);\n        top = Math.min(top, (element.cssTop() || 0) + (element.cssMarginTop() || 0));\n        bottom = Math.min(bottom, (element.cssBottom() || 0) + (element.cssMarginBottom() || 0));\n        left = Math.min(left, (element.cssLeft() || 0) + (element.cssMarginLeft() || 0));\n        right = Math.min(right, (element.cssRight() || 0) + (element.cssMarginRight() || 0));\n      });\n      $glassPane.cssTop(top).cssBottom(bottom).cssLeft(left).cssRight(right);\n    }\n  }, {\n    key: \"removeGlassPanes\",\n    value: function removeGlassPanes() {\n      // Remove glass-panes\n      this._$glassPanes.slice().forEach(function ($glassPane) {\n        this._removeGlassPane($glassPane);\n      }, this); // Unregister all deferedGlassPaneTargets\n\n\n      this._deferredGlassPanes.forEach(function (glassPaneTarget) {\n        glassPaneTarget.removeGlassPaneRenderer(this);\n      }, this);\n\n      this._deferredGlassPanes = [];\n\n      this._unregisterDisplayParent();\n\n      this.session.focusManager.unregisterGlassPaneRenderer(this);\n      this._glassPaneRendererRegistered = false;\n    }\n  }, {\n    key: \"_removeGlassPane\",\n    value: function _removeGlassPane($glassPane) {\n      var $glassPaneTarget = $glassPane.parent();\n      $glassPane.off('remove', this._glassPaneRemoveHandler);\n      $glassPane.remove();\n      arrays.$remove(this._$glassPanes, $glassPane);\n      $glassPaneTarget.removeClass('no-hover');\n      this.session.focusManager.unregisterGlassPaneTarget($glassPaneTarget);\n    }\n  }, {\n    key: \"eachGlassPane\",\n    value: function eachGlassPane(func) {\n      this._$glassPanes.forEach(function ($glassPane) {\n        func($glassPane);\n      });\n    }\n  }, {\n    key: \"findGlassPaneTargets\",\n    value: function findGlassPaneTargets() {\n      if (!this._enabled) {\n        return []; // No glasspanes to be rendered, e.g. for none-modal dialogs.\n      }\n\n      var displayParent = this._resolveDisplayParent();\n\n      if (!displayParent || !displayParent.glassPaneTargets) {\n        return []; // Parent is not a valid display parent.\n      }\n\n      return displayParent.glassPaneTargets(this._widget);\n    }\n  }, {\n    key: \"_resolveDisplayParent\",\n    value: function _resolveDisplayParent() {\n      // Note: This has to be done after rendering, because otherwise session.desktop could be undefined!\n      if (!this._resolvedDisplayParent) {\n        this._resolvedDisplayParent = this._widget.displayParent || this.session.desktop;\n      }\n\n      return this._resolvedDisplayParent;\n    }\n  }, {\n    key: \"_registerDisplayParent\",\n    value: function _registerDisplayParent() {\n      // if this._resolvedDisplayParent is not yet resolved, do it now\n      if (!this._resolvedDisplayParent) {\n        this._resolveDisplayParent();\n      } // if this._resolvedDisplayParent is resolved, but not yet registered\n\n\n      if (this._resolvedDisplayParent) {\n        if (!this._registeredDisplayParent) {\n          // register this._resolvedDisplayParent and remember it as this._registeredDisplayParent\n          this.session.focusManager.registerGlassPaneDisplayParent(this._resolvedDisplayParent);\n          this._registeredDisplayParent = this._resolvedDisplayParent;\n\n          this._registeredDisplayParent.on('render', this._displayParentRenderHandler);\n        }\n      }\n    }\n  }, {\n    key: \"_unregisterDisplayParent\",\n    value: function _unregisterDisplayParent() {\n      // if this._registeredDisplayParent is defined, unregister it\n      if (this._registeredDisplayParent) {\n        this.session.focusManager.unregisterGlassPaneDisplayParent(this._registeredDisplayParent);\n\n        this._registeredDisplayParent.off('render', this._displayParentRenderHandler);\n\n        this._registeredDisplayParent = null;\n      }\n    }\n  }, {\n    key: \"_onMouseDown\",\n    value: function _onMouseDown(event) {\n      var $animationTarget = null; // notify the display parent to handle the mouse down on the glass pane.\n\n      var displayParent = this._resolveDisplayParent();\n\n      if (displayParent._onGlassPaneMouseDown) {\n        displayParent._onGlassPaneMouseDown(this._widget, $(event.target));\n      }\n\n      if (this._widget instanceof Form && this._widget.isView()) {\n        // If the blocking widget is a view, the $container cannot be animated (this only works for dialogs). Instead,\n        // highlight the view tab (or the overflow item, if the view tab is not visible).\n        var viewTab = this.session.desktop.bench.getViewTab(this._widget); // View tab may not exist if view has neither a title nor a subtitle\n\n        if (viewTab) {\n          $animationTarget = viewTab.$container;\n\n          if (!$animationTarget.isVisible()) {\n            $animationTarget = $animationTarget.siblings('.overflow-tab-item');\n          }\n        }\n      } else if (this._widget.$container) {\n        $animationTarget = this._widget.$container;\n      }\n\n      if ($animationTarget) {\n        // If the animation target itself is covered by a glasspane, the event is passed on\n        var $glassPane = this._widget.$container.children('.glasspane');\n\n        if ($glassPane.length) {\n          $glassPane.trigger('mousedown');\n        } else {\n          $animationTarget.addClassForAnimation('animate-modality-highlight', {\n            // remove animate-open as well, user may click the glasspane before the widget itself was able to remove the animate-open class\n            classesToRemove: 'animate-modality-highlight animate-open'\n          });\n        }\n      }\n\n      $.suppressEvent(event);\n    }\n  }, {\n    key: \"_onDisplayParentRender\",\n    value: function _onDisplayParentRender(event) {\n      this.renderGlassPanes();\n    }\n  }, {\n    key: \"_onGlassPaneRemove\",\n    value: function _onGlassPaneRemove(event) {\n      var $glassPane = $(event.target);\n\n      this._removeGlassPane($glassPane);\n    }\n  }]);\n\n  return GlassPaneRenderer;\n}();\n\nexport { GlassPaneRenderer as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/glasspane/GlassPaneRenderer.js"],"names":["arrays","DeferredGlassPaneTarget","Device","Form","scout","$","GlassPaneRenderer","widget","enabled","_widget","session","_enabled","nvl","_$glassPanes","_deferredGlassPanes","_resolvedDisplayParent","_registeredDisplayParent","_displayParentRenderHandler","_onDisplayParentRender","bind","_glassPaneRemoveHandler","_onGlassPaneRemove","_glassPaneRendererRegistered","findGlassPaneTargets","forEach","glassPaneTarget","rendererReady","push","renderGlassPane","focusManager","registerGlassPaneRenderer","$glassPaneTarget","ensure","$container","alreadyRendered","some","$pane","parent","$glassPane","appendDiv","on","_onMouseDown","_adjustGlassPaneSize","get","supportsOnlyTouch","addClass","window","popupWindow","registerGlassPaneTarget","one","_registerDisplayParent","top","cssBorderTopWidth","bottom","cssBorderBottomWidth","left","cssBorderLeftWidth","right","cssBorderRightWidth","children","each","idx","elem","element","Math","min","cssTop","cssMarginTop","cssBottom","cssMarginBottom","cssLeft","cssMarginLeft","cssRight","cssMarginRight","slice","_removeGlassPane","removeGlassPaneRenderer","_unregisterDisplayParent","unregisterGlassPaneRenderer","off","remove","$remove","removeClass","unregisterGlassPaneTarget","func","displayParent","_resolveDisplayParent","glassPaneTargets","desktop","registerGlassPaneDisplayParent","unregisterGlassPaneDisplayParent","event","$animationTarget","_onGlassPaneMouseDown","target","isView","viewTab","bench","getViewTab","isVisible","siblings","length","trigger","addClassForAnimation","classesToRemove","suppressEvent","renderGlassPanes"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, DeferredGlassPaneTarget, Device, Form, scout} from '../index';\nimport $ from 'jquery';\n\n/**\n * Renders glassPanes over the 'glassPaneTargets' of a widget.\n */\nexport default class GlassPaneRenderer {\n\n  constructor(widget, enabled) {\n    this._widget = widget;\n    this.session = widget.session;\n    this._enabled = scout.nvl(enabled, true);\n    this._$glassPanes = [];\n    this._deferredGlassPanes = [];\n    this._resolvedDisplayParent = null;\n    this._registeredDisplayParent = null;\n    this._displayParentRenderHandler = this._onDisplayParentRender.bind(this);\n    this._glassPaneRemoveHandler = this._onGlassPaneRemove.bind(this);\n    this._glassPaneRendererRegistered = false;\n  }\n\n  renderGlassPanes() {\n    this.findGlassPaneTargets().forEach(function(glassPaneTarget) {\n      if (glassPaneTarget instanceof DeferredGlassPaneTarget) {\n        glassPaneTarget.rendererReady(this);\n        this._deferredGlassPanes.push(glassPaneTarget);\n      } else {\n        this.renderGlassPane(glassPaneTarget);\n      }\n    }, this);\n    if (!this._glassPaneRendererRegistered) {\n      this.session.focusManager.registerGlassPaneRenderer(this);\n      this._glassPaneRendererRegistered = true;\n    }\n  }\n\n  /**\n   * @param {($|HTMLElement)} $glassPaneTarget\n   */\n  renderGlassPane($glassPaneTarget) {\n    $glassPaneTarget = $.ensure($glassPaneTarget);\n\n    if (this._widget.$container && this._widget.$container[0] === $glassPaneTarget[0]) {\n      // Don't render a glass pane on the widget itself (necessary if glass pane is added after the widget is rendered)\n      return;\n    }\n\n    // If glassPaneTarget already has a glasspane added by this renderer, don't add another one\n    // May happen if a part of the display parent is removed and rendered again while covered by a glass pane\n    // E.g. display parent is set to outline and navigation is made invisible but bench is still there.\n    // When navigation is made visible again, renderGlassPanes is called but only the glass panes of the navigation need to be added and not the ones of the bench (because they are already there)\n    var alreadyRendered = this._$glassPanes.some(function($pane) {\n      return $pane.parent()[0] === $glassPaneTarget[0];\n    });\n    if (alreadyRendered) {\n      return;\n    }\n\n    // Render glasspanes onto glasspane targets.\n    var $glassPane = $glassPaneTarget\n      .appendDiv('glasspane')\n      .on('mousedown', this._onMouseDown.bind(this));\n\n    this._adjustGlassPaneSize($glassPane, $glassPaneTarget);\n\n    // This is required in touch mode, because FastClick messes up the order\n    // of mouse/click events which is especially important for TouchPopups.\n    if (Device.get().supportsOnlyTouch()) {\n      $glassPane.addClass('needsclick');\n    }\n\n    // Glasspanes in popup-windows must be visible, otherwise the user cannot recognize that the popup\n    // is blocked, since the widget that blocks (e.g a message-box) may be opened in the main-window.\n    if ($glassPane.window(true).popupWindow) {\n      $glassPane.addClass('dark');\n    }\n    this._$glassPanes.push($glassPane);\n\n    // Register 'glassPaneTarget' in focus manager.\n    this.session.focusManager.registerGlassPaneTarget($glassPaneTarget);\n\n    // Ensure glass pane is removed properly on remove, especially necessary when display parent is removed while glass pane renderer is still active (navigation collapse case)\n    $glassPane.one('remove', this._glassPaneRemoveHandler);\n\n    this._registerDisplayParent();\n  }\n\n  _adjustGlassPaneSize($glassPane, $glassPaneTarget) {\n    // The glasspane must cover the border and overlapping children\n    var top = -$glassPaneTarget.cssBorderTopWidth(),\n      bottom = -$glassPaneTarget.cssBorderBottomWidth(),\n      left = -$glassPaneTarget.cssBorderLeftWidth(),\n      right = -$glassPaneTarget.cssBorderRightWidth();\n\n    $glassPaneTarget.children().each(function(idx, elem) {\n      var element = $(elem);\n      top = Math.min(top, (element.cssTop() || 0) + (element.cssMarginTop() || 0));\n      bottom = Math.min(bottom, (element.cssBottom() || 0) + (element.cssMarginBottom() || 0));\n      left = Math.min(left, (element.cssLeft() || 0) + (element.cssMarginLeft() || 0));\n      right = Math.min(right, (element.cssRight() || 0) + (element.cssMarginRight() || 0));\n    });\n\n    $glassPane.cssTop(top)\n      .cssBottom(bottom)\n      .cssLeft(left)\n      .cssRight(right);\n  }\n\n  removeGlassPanes() {\n    // Remove glass-panes\n    this._$glassPanes.slice().forEach(function($glassPane) {\n      this._removeGlassPane($glassPane);\n    }, this);\n\n    // Unregister all deferedGlassPaneTargets\n    this._deferredGlassPanes.forEach(function(glassPaneTarget) {\n      glassPaneTarget.removeGlassPaneRenderer(this);\n    }, this);\n    this._deferredGlassPanes = [];\n\n    this._unregisterDisplayParent();\n    this.session.focusManager.unregisterGlassPaneRenderer(this);\n    this._glassPaneRendererRegistered = false;\n  }\n\n  _removeGlassPane($glassPane) {\n    var $glassPaneTarget = $glassPane.parent();\n    $glassPane.off('remove', this._glassPaneRemoveHandler);\n    $glassPane.remove();\n    arrays.$remove(this._$glassPanes, $glassPane);\n\n    $glassPaneTarget.removeClass('no-hover');\n    this.session.focusManager.unregisterGlassPaneTarget($glassPaneTarget);\n  }\n\n  eachGlassPane(func) {\n    this._$glassPanes.forEach(function($glassPane) {\n      func($glassPane);\n    });\n  }\n\n  findGlassPaneTargets() {\n    if (!this._enabled) {\n      return []; // No glasspanes to be rendered, e.g. for none-modal dialogs.\n    }\n\n    var displayParent = this._resolveDisplayParent();\n    if (!displayParent || !displayParent.glassPaneTargets) {\n      return []; // Parent is not a valid display parent.\n    }\n\n    return displayParent.glassPaneTargets(this._widget);\n  }\n\n  _resolveDisplayParent() {\n    // Note: This has to be done after rendering, because otherwise session.desktop could be undefined!\n    if (!this._resolvedDisplayParent) {\n      this._resolvedDisplayParent = this._widget.displayParent || this.session.desktop;\n    }\n    return this._resolvedDisplayParent;\n  }\n\n  _registerDisplayParent() {\n    // if this._resolvedDisplayParent is not yet resolved, do it now\n    if (!this._resolvedDisplayParent) {\n      this._resolveDisplayParent();\n    }\n    // if this._resolvedDisplayParent is resolved, but not yet registered\n    if (this._resolvedDisplayParent) {\n      if (!this._registeredDisplayParent) {\n        // register this._resolvedDisplayParent and remember it as this._registeredDisplayParent\n        this.session.focusManager.registerGlassPaneDisplayParent(this._resolvedDisplayParent);\n        this._registeredDisplayParent = this._resolvedDisplayParent;\n        this._registeredDisplayParent.on('render', this._displayParentRenderHandler);\n      }\n    }\n  }\n\n  _unregisterDisplayParent() {\n    // if this._registeredDisplayParent is defined, unregister it\n    if (this._registeredDisplayParent) {\n      this.session.focusManager.unregisterGlassPaneDisplayParent(this._registeredDisplayParent);\n      this._registeredDisplayParent.off('render', this._displayParentRenderHandler);\n      this._registeredDisplayParent = null;\n    }\n  }\n\n  _onMouseDown(event) {\n    var $animationTarget = null;\n\n    // notify the display parent to handle the mouse down on the glass pane.\n    var displayParent = this._resolveDisplayParent();\n    if (displayParent._onGlassPaneMouseDown) {\n      displayParent._onGlassPaneMouseDown(this._widget, $(event.target));\n    }\n\n    if (this._widget instanceof Form && this._widget.isView()) {\n      // If the blocking widget is a view, the $container cannot be animated (this only works for dialogs). Instead,\n      // highlight the view tab (or the overflow item, if the view tab is not visible).\n\n      var viewTab = this.session.desktop.bench.getViewTab(this._widget);\n      // View tab may not exist if view has neither a title nor a subtitle\n      if (viewTab) {\n        $animationTarget = viewTab.$container;\n        if (!$animationTarget.isVisible()) {\n          $animationTarget = $animationTarget.siblings('.overflow-tab-item');\n        }\n      }\n    } else if (this._widget.$container) {\n      $animationTarget = this._widget.$container;\n    }\n\n    if ($animationTarget) {\n      // If the animation target itself is covered by a glasspane, the event is passed on\n      var $glassPane = this._widget.$container.children('.glasspane');\n      if ($glassPane.length) {\n        $glassPane.trigger('mousedown');\n      } else {\n        $animationTarget.addClassForAnimation('animate-modality-highlight', {\n          // remove animate-open as well, user may click the glasspane before the widget itself was able to remove the animate-open class\n          classesToRemove: 'animate-modality-highlight animate-open'\n        });\n      }\n    }\n\n    $.suppressEvent(event);\n  }\n\n  _onDisplayParentRender(event) {\n    this.renderGlassPanes();\n  }\n\n  _onGlassPaneRemove(event) {\n    var $glassPane = $(event.target);\n    this._removeGlassPane($glassPane);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}