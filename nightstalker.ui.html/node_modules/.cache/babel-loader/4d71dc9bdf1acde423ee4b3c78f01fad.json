{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, ContextMenuPopup, defaultValues, Device, DoubleClickSupport, dragAndDrop, HtmlComponent, keys, KeyStrokeContext, keyStrokeModifier, LazyNodeFilter, MenuBar, MenuDestinations, MenuItemsOrder, menus as menus_1, objects, Range, scout, scrollbars, tooltips, TreeBreadcrumbFilter, TreeCollapseAllKeyStroke, TreeCollapseOrDrillUpKeyStroke, TreeExpandOrDrillDownKeyStroke, TreeLayout, TreeNavigationDownKeyStroke, TreeNavigationEndKeyStroke, TreeNavigationUpKeyStroke, TreeNode, TreeSpaceKeyStroke, Widget } from '../index';\nimport $ from 'jquery';\n/**\n * @class\n * @constructor\n */\n\nvar Tree = /*#__PURE__*/function (_Widget) {\n  _inherits(Tree, _Widget);\n\n  var _super = _createSuper(Tree);\n\n  function Tree() {\n    var _this;\n\n    _classCallCheck(this, Tree);\n\n    _this = _super.call(this);\n    _this.toggleBreadcrumbStyleEnabled = false;\n    _this.breadcrumbTogglingThreshold = null;\n    _this.autoCheckChildren = false;\n    _this.checkable = false;\n    _this.checkableStyle = Tree.CheckableStyle.CHECKBOX_TREE_NODE;\n    _this.displayStyle = Tree.DisplayStyle.DEFAULT;\n    _this.dropType = 0;\n    _this.dropMaximumSize = dragAndDrop.DEFAULT_DROP_MAXIMUM_SIZE;\n    _this.filterEnabled = false;\n    _this.lazyExpandingEnabled = true;\n    _this.menus = [];\n    _this.contextMenu = null;\n    _this.menuBar = null;\n    _this.keyStrokes = [];\n    _this.multiCheck = true;\n    _this.nodes = []; // top-level nodes\n\n    _this.nodesMap = {}; // all nodes by id\n\n    _this.nodePaddingLevelCheckable = 23;\n    /* padding for one tree-level if the tree is checkable */\n\n    _this.nodePaddingLevelNotCheckable = 18;\n    /* padding for one tree-level if the tree is not checkable. this includes outline trees! */\n\n    _this.nodePaddingLeft = null;\n    /* is read from CSS */\n\n    _this.nodeCheckBoxPaddingLeft = 29;\n    _this.nodeControlPaddingLeft = null;\n    /* is read from CSS */\n\n    _this.nodePaddingLevel = _this.nodePaddingLevelNotCheckable;\n    _this.scrollToSelection = false;\n    _this.scrollTop = 0;\n    _this.scrollTopHistory = []; // Only necessary for breadcrumb mode\n\n    _this.selectedNodes = [];\n    _this.prevSelectedNode = null; // The previously selected node, relevant for breadcrumb in compact mode\n    // performance optimization: E.g. rather than iterating over the whole tree when unchecking all nodes,\n    // we explicitly keep track of nodes to uncheck (useful e.g. for single-check mode in very large trees).\n\n    _this.checkedNodes = [];\n    _this.groupedNodes = {};\n    _this.visibleNodesFlat = [];\n    _this.visibleNodesMap = {};\n\n    _this._addWidgetProperties(['menus', 'keyStrokes']);\n\n    _this._additionalContainerClasses = ''; // may be used by subclasses to set additional CSS classes\n\n    _this._filters = [];\n    _this._doubleClickSupport = new DoubleClickSupport();\n    _this._$animationWrapper = null; // used by _renderExpansion()\n\n    _this._$expandAnimationWrappers = [];\n    _this._filterMenusHandler = _this._filterMenus.bind(_assertThisInitialized(_this));\n    _this._popupOpenHandler = _this._onDesktopPopupOpen.bind(_assertThisInitialized(_this)); // contains all parents of a selected node, the selected node and the first level children\n\n    _this._inSelectionPathList = {};\n    _this.viewRangeRendered = new Range(0, 0);\n    _this.viewRangeSize = 20;\n\n    _this.startAnimationFunc = function () {\n      this.runningAnimations++;\n    }.bind(_assertThisInitialized(_this));\n\n    _this.runningAnimations = 0;\n\n    _this.runningAnimationsFinishFunc = function () {\n      this.runningAnimations--;\n\n      if (this.runningAnimations <= 0) {\n        this.runningAnimations = 0;\n        this._renderViewportBlocked = false;\n        this.invalidateLayoutTree();\n      }\n    }.bind(_assertThisInitialized(_this));\n\n    _this.nodeHeight = 0;\n    _this.nodeWidth = 0;\n    _this.maxNodeWidth = 0;\n    _this.nodeWidthDirty = false;\n    _this.$data = null;\n    _this._scrolldirections = 'both';\n    _this.requestFocusOnNodeControlMouseDown = true;\n    return _this;\n  }\n\n  _createClass(Tree, [{\n    key: \"_init\",\n    value: function _init(model) {\n      _get(_getPrototypeOf(Tree.prototype), \"_init\", this).call(this, model);\n\n      this.addFilter(new LazyNodeFilter(this), true);\n      this.breadcrumbFilter = new TreeBreadcrumbFilter(this);\n\n      if (this.displayStyle === Tree.DisplayStyle.BREADCRUMB) {\n        this.addFilter(this.breadcrumbFilter, true, true);\n      }\n\n      this.initialTraversing = true;\n\n      this._setCheckable(this.checkable);\n\n      this._ensureTreeNodes(this.nodes);\n\n      this.visitNodes(this._initTreeNode.bind(this));\n      this.visitNodes(this._updateFlatListAndSelectionPath.bind(this));\n      this.initialTraversing = false;\n      this.selectedNodes = this._nodesByIds(this.selectedNodes);\n      this.menuBar = scout.create('MenuBar', {\n        parent: this,\n        position: MenuBar.Position.BOTTOM,\n        menuOrder: new MenuItemsOrder(this.session, 'Tree'),\n        menuFilter: this._filterMenusHandler\n      });\n\n      this._updateItemPath(true);\n\n      this._setDisplayStyle(this.displayStyle);\n\n      this._setKeyStrokes(this.keyStrokes);\n\n      this._setMenus(this.menus);\n    }\n    /**\n     * Iterates through the given array and converts node-models to instances of TreeNode (or a subclass).\n     * If the array element is already a TreeNode the function leaves the element untouched. This function also\n     * ensures that the attribute childNodeIndex is set. By default we use the order of the nodes array as index\n     * but only if childNodeIndex is undefined.\n     *\n     * @param nodes Array of node-models (plain object) or nodes (instance of TreeNode)\n     */\n\n  }, {\n    key: \"_ensureTreeNodes\",\n    value: function _ensureTreeNodes(nodes) {\n      var i, node;\n\n      for (i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.childNodeIndex = scout.nvl(node.childNodeIndex, i);\n\n        if (node instanceof TreeNode) {\n          continue;\n        }\n\n        nodes[i] = this._createTreeNode(node);\n      }\n    }\n  }, {\n    key: \"_createTreeNode\",\n    value: function _createTreeNode(nodeModel) {\n      nodeModel = scout.nvl(nodeModel, {});\n      nodeModel.parent = this;\n      return scout.create('TreeNode', nodeModel);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_createKeyStrokeContext\",\n    value: function _createKeyStrokeContext() {\n      return new KeyStrokeContext();\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      _get(_getPrototypeOf(Tree.prototype), \"_initKeyStrokeContext\", this).call(this);\n\n      this._initTreeKeyStrokeContext();\n    }\n  }, {\n    key: \"_initTreeKeyStrokeContext\",\n    value: function _initTreeKeyStrokeContext() {\n      var modifierBitMask = keyStrokeModifier.NONE;\n      this.keyStrokeContext.registerKeyStroke([new TreeSpaceKeyStroke(this), new TreeNavigationUpKeyStroke(this, modifierBitMask), new TreeNavigationDownKeyStroke(this, modifierBitMask), new TreeCollapseAllKeyStroke(this, modifierBitMask), new TreeCollapseOrDrillUpKeyStroke(this, modifierBitMask), new TreeNavigationEndKeyStroke(this, modifierBitMask), new TreeExpandOrDrillDownKeyStroke(this, modifierBitMask)]); // Prevent default action and do not propagate ↓ or ↑ keys if ctrl- or alt-modifier is not pressed.\n      // Otherwise, an '↑-event' on the first node, or an '↓-event' on the last row will bubble up (because not consumed by tree navigation keystrokes) and cause a superior tree to move its selection;\n      // Use case: - outline tree with a detail form that contains a tree;\n      //           - preventDefault because of smartfield, so that the cursor is not moved on first or last row;\n\n      this.keyStrokeContext.registerStopPropagationInterceptor(function (event) {\n        if (!event.ctrlKey && !event.altKey && scout.isOneOf(event.which, keys.UP, keys.DOWN)) {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n      });\n    }\n  }, {\n    key: \"_setMenus\",\n    value: function _setMenus(argMenus) {\n      this.updateKeyStrokes(argMenus, this.menus);\n\n      this._setProperty('menus', argMenus);\n\n      this._updateMenuBar();\n    }\n  }, {\n    key: \"_updateMenuBar\",\n    value: function _updateMenuBar() {\n      var menuItems = this._filterMenus(this.menus, MenuDestinations.MENU_BAR, false, true);\n\n      this.menuBar.setMenuItems(menuItems);\n\n      var contextMenuItems = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true);\n\n      if (this.contextMenu) {\n        this.contextMenu.updateMenuItems(contextMenuItems);\n      }\n    }\n  }, {\n    key: \"_setKeyStrokes\",\n    value: function _setKeyStrokes(keyStrokes) {\n      this.updateKeyStrokes(keyStrokes, this.keyStrokes);\n\n      this._setProperty('keyStrokes', keyStrokes);\n    }\n  }, {\n    key: \"_resetTreeNode\",\n    value: function _resetTreeNode(node, parentNode) {\n      node.reset();\n    }\n  }, {\n    key: \"isSelectedNode\",\n    value: function isSelectedNode(node) {\n      if (this.initialTraversing) {\n        return this.selectedNodes.indexOf(node.id) > -1;\n      }\n\n      return this.selectedNodes.indexOf(node) > -1;\n    }\n  }, {\n    key: \"_updateFlatListAndSelectionPath\",\n    value: function _updateFlatListAndSelectionPath(node, parentNode) {\n      // if this node is selected all parent nodes have to be added to selectionPath\n      if (this.isSelectedNode(node) && (node.parentNode && !this.visibleNodesMap[node.parentNode.id] || node.level === 0)) {\n        var p = node;\n\n        while (p) {\n          this._inSelectionPathList[p.id] = true;\n          p.filterDirty = true;\n\n          if (p !== node) {\n            // ensure node is expanded\n            node.expanded = true; // if parent was filtered before, try refilter after adding to selection path.\n\n            if (p.level === 0) {\n              this._applyFiltersForNode(p); // add visible nodes to visible nodes array when they are initialized\n\n\n              this._addToVisibleFlatList(p, false); // process children\n\n\n              this._addChildrenToFlatList(p, this.visibleNodesFlat.length - 1, false, null, true);\n            }\n          }\n\n          p = p.parentNode;\n        }\n      } else if (node.parentNode && this.isSelectedNode(node.parentNode)) {\n        this._inSelectionPathList[node.id] = true;\n      }\n\n      this._applyFiltersForNode(node); // add visible nodes to visible nodes array when they are initialized\n\n\n      this._addToVisibleFlatList(node, false);\n    }\n  }, {\n    key: \"_initTreeNode\",\n    value: function _initTreeNode(node, parentNode) {\n      this.nodesMap[node.id] = node;\n\n      if (parentNode) {\n        node.parentNode = parentNode;\n        node.level = node.parentNode.level + 1;\n      }\n\n      if (node.checked) {\n        this.checkedNodes.push(node);\n      }\n\n      this._initTreeNodeInternal(node, parentNode);\n\n      this._updateMarkChildrenChecked(node, true, node.checked);\n\n      node.initialized = true;\n    }\n  }, {\n    key: \"_applyNodeDefaultValues\",\n    value: function _applyNodeDefaultValues(node) {\n      defaultValues.applyTo(node, 'TreeNode');\n    }\n    /**\n     * Override this function if you want a custom node init before filtering.\n     * The default impl. applies default values to the given node.\n     */\n\n  }, {\n    key: \"_initTreeNodeInternal\",\n    value: function _initTreeNodeInternal(node, parentNode) {\n      this._applyNodeDefaultValues(node);\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      _get(_getPrototypeOf(Tree.prototype), \"_destroy\", this).call(this);\n\n      this.visitNodes(this._destroyTreeNode.bind(this));\n      this.nodes = []; // finally, clear array with root tree-nodes\n    }\n  }, {\n    key: \"_destroyTreeNode\",\n    value: function _destroyTreeNode(node) {\n      delete this.nodesMap[node.id];\n\n      this._removeFromFlatList(node, false); // ensure node is not longer in visible nodes list.\n\n\n      node.destroy();\n\n      if (this._onNodeDeleted) {\n        // Necessary for subclasses\n        this._onNodeDeleted(node);\n      }\n    }\n    /**\n     * pre-order (top-down) traversal of the tree-nodes of this tree.<br>\n     * if func returns true the children of the visited node are not visited.\n     */\n\n  }, {\n    key: \"visitNodes\",\n    value: function visitNodes(func, parentNode) {\n      return Tree.visitNodes(func, this.nodes, parentNode);\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      this.$container = this.$parent.appendDiv('tree');\n\n      if (this._additionalContainerClasses) {\n        this.$container.addClass(this._additionalContainerClasses);\n      }\n\n      var layout = new TreeLayout(this);\n      this.htmlComp = HtmlComponent.install(this.$container, this.session);\n      this.htmlComp.setLayout(layout);\n      this.$data = this.$container.appendDiv('tree-data').on('contextmenu', this._onContextMenu.bind(this)).on('mousedown', '.tree-node', this._onNodeMouseDown.bind(this)).on('mouseup', '.tree-node', this._onNodeMouseUp.bind(this)).on('dblclick', '.tree-node', this._onNodeDoubleClick.bind(this)).on('mousedown', '.tree-node-control', this._onNodeControlMouseDown.bind(this)).on('mouseup', '.tree-node-control', this._onNodeControlMouseUp.bind(this)).on('dblclick', '.tree-node-control', this._onNodeControlDoubleClick.bind(this));\n      HtmlComponent.install(this.$data, this.session);\n\n      if (this.isHorizontalScrollingEnabled()) {\n        this.$data.toggleClass('scrollable-tree', true);\n      }\n\n      this._installScrollbars({\n        axis: this._scrolldirections\n      });\n\n      this._installNodeTooltipSupport();\n\n      this.menuBar.render();\n\n      this._updateNodeDimensions(); // render display style before viewport (not in renderProperties) to have a correct style from the beginning\n\n\n      this._renderDisplayStyle();\n\n      this._renderViewport();\n\n      this.session.desktop.on('popupOpen', this._popupOpenHandler);\n\n      this._renderCheckableStyle();\n    }\n  }, {\n    key: \"_postRender\",\n    value: function _postRender() {\n      _get(_getPrototypeOf(Tree.prototype), \"_postRender\", this).call(this);\n\n      this._renderSelection();\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      // remove listener\n      this.session.desktop.off('popupOpen', this._popupOpenHandler); // stop all animations\n\n      if (this._$animationWrapper) {\n        this._$animationWrapper.stop(false, true);\n      } // Detach nodes from jQuery objects (because those will be removed)\n\n\n      this.visitNodes(this._resetTreeNode.bind(this));\n\n      this._uninstallDragAndDropHandler();\n\n      this._uninstallNodeTooltipSupport();\n\n      this.$fillBefore = null;\n      this.$fillAfter = null;\n      this.$data = null; // reset rendered view range because now range is rendered\n\n      this.viewRangeRendered = new Range(0, 0);\n\n      _get(_getPrototypeOf(Tree.prototype), \"_remove\", this).call(this);\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      _get(_getPrototypeOf(Tree.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderDropType();\n    }\n  }, {\n    key: \"isHorizontalScrollingEnabled\",\n    value: function isHorizontalScrollingEnabled() {\n      return this._scrolldirections === 'both' || this._scrolldirections === 'x';\n    }\n  }, {\n    key: \"isTreeNodeCheckEnabled\",\n    value: function isTreeNodeCheckEnabled() {\n      return this.checkableStyle === Tree.CheckableStyle.CHECKBOX_TREE_NODE;\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll() {\n      var scrollToSelectionBackup = this.scrollToSelection;\n      this.scrollToSelection = false;\n      var scrollTop = this.$data[0].scrollTop;\n      var scrollLeft = this.$data[0].scrollLeft;\n\n      if (this.scrollTop !== scrollTop) {\n        this._renderViewport();\n      }\n\n      this.scrollTop = scrollTop;\n      this.scrollLeft = scrollLeft;\n      this.scrollToSelection = scrollToSelectionBackup;\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"setScrollTop\",\n    value: function setScrollTop(scrollTop) {\n      this.setProperty('scrollTop', scrollTop); // call _renderViewport to make sure nodes are rendered immediately. The browser fires the scroll event handled by onDataScroll delayed\n\n      if (this.rendered) {\n        this._renderViewport(); // Render scroll top again to make sure the data really is at the expected position\n        // This seems only to be necessary for Chrome and the tree, it seems to work for IE and table.\n        // It is not optimal, because actually it should be possible to modify the $data[0].scrollTop without using this function\n        // Some debugging showed that after reducing the height of the afterFiller in _renderFiller the scrollTop will be wrong.\n        // Updating the scrollTop in renderFiller or other view range relevant function is bad because it corrupts smooth scrolling (see also commit c14ce92e0a7bff568d4f2d715e3061a782e728c2)\n\n\n        this._renderScrollTop();\n      }\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_renderScrollTop\",\n    value: function _renderScrollTop() {\n      if (this.rendering) {\n        // Not necessary to do it while rendering since it will be done by the layout\n        return;\n      }\n\n      scrollbars.scrollTop(this.$data, this.scrollTop);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"get$Scrollable\",\n    value: function get$Scrollable() {\n      return this.$data;\n    }\n  }, {\n    key: \"_renderViewport\",\n    value: function _renderViewport() {\n      if (this.runningAnimations > 0 || this._renderViewportBlocked) {\n        // animation pending do not render view port because finishing should rerenderViewport\n        return;\n      }\n\n      if (!this.$container.isEveryParentVisible()) {\n        // If the tree is invisible, the width and height of the nodes cannot be determined\n        // In that case, the tree won't be layouted either -> as soon as it will be layouted, renderViewport will be called again\n        return;\n      }\n\n      var viewRange = this._calculateCurrentViewRange();\n\n      this._renderViewRange(viewRange);\n    }\n  }, {\n    key: \"_calculateCurrentViewRange\",\n    value: function _calculateCurrentViewRange() {\n      var node,\n          scrollTop = this.$data[0].scrollTop,\n          maxScrollTop = this.$data[0].scrollHeight - this.$data[0].clientHeight;\n\n      if (maxScrollTop === 0 && this.visibleNodesFlat.length > 0) {\n        // no scrollbars visible\n        node = this.visibleNodesFlat[0];\n      } else {\n        node = this._nodeAtScrollTop(scrollTop);\n      }\n\n      return this._calculateViewRangeForNode(node);\n    }\n  }, {\n    key: \"_rerenderViewport\",\n    value: function _rerenderViewport() {\n      if (this._renderViewportBlocked) {\n        return;\n      }\n\n      this._removeRenderedNodes();\n\n      this._renderFiller();\n\n      this._updateDomNodeWidth();\n\n      this._updateDomNodeIconWidth();\n\n      this._renderViewport();\n    }\n  }, {\n    key: \"_removeRenderedNodes\",\n    value: function _removeRenderedNodes() {\n      var $nodes = this.$data.find('.tree-node');\n      $nodes.each(function (i, elem) {\n        var $node = $(elem),\n            node = $node.data('node');\n\n        if ($node.hasClass('hiding')) {\n          // Do not remove nodes which are removed using an animation\n          return;\n        }\n\n        this._removeNode(node);\n      }.bind(this));\n      this.viewRangeRendered = new Range(0, 0);\n    }\n  }, {\n    key: \"_renderViewRangeForNode\",\n    value: function _renderViewRangeForNode(node) {\n      var viewRange = this._calculateViewRangeForNode(node);\n\n      this._renderViewRange(viewRange);\n    }\n  }, {\n    key: \"_renderNodesInRange\",\n    value: function _renderNodesInRange(range) {\n      var prepend = false;\n      var nodes = this.visibleNodesFlat;\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var maxRange = new Range(0, nodes.length);\n      range = maxRange.intersect(range);\n\n      if (this.viewRangeRendered.size() > 0 && !range.intersect(this.viewRangeRendered).equals(new Range(0, 0))) {\n        throw new Error('New range must not intersect with existing.');\n      }\n\n      if (range.to <= this.viewRangeRendered.from) {\n        prepend = true;\n      }\n\n      var newRange = this.viewRangeRendered.union(range);\n\n      if (newRange.length === 2) {\n        throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n      }\n\n      this.viewRangeRendered = newRange[0];\n      var numNodesRendered = this.ensureRangeVisible(range);\n      $.log.isTraceEnabled() && $.log.trace(numNodesRendered + ' new nodes rendered from ' + range);\n    }\n  }, {\n    key: \"ensureRangeVisible\",\n    value: function ensureRangeVisible(range) {\n      var nodes = this.visibleNodesFlat;\n      var nodesToInsert = [];\n\n      for (var r = range.from; r < range.to; r++) {\n        var node = nodes[r];\n\n        if (!node.attached) {\n          nodesToInsert.push(node);\n        }\n      }\n\n      this._insertNodesInDOM(nodesToInsert);\n\n      return nodesToInsert.length;\n    }\n  }, {\n    key: \"_renderFiller\",\n    value: function _renderFiller() {\n      if (!this.$fillBefore) {\n        this.$fillBefore = this.$data.prependDiv('tree-data-fill');\n      }\n\n      var fillBeforeDimensions = this._calculateFillerDimension(new Range(0, this.viewRangeRendered.from));\n\n      this.$fillBefore.cssHeight(fillBeforeDimensions.height);\n\n      if (this.isHorizontalScrollingEnabled()) {\n        this.$fillBefore.cssWidth(fillBeforeDimensions.width);\n        this.maxNodeWidth = Math.max(fillBeforeDimensions.width, this.maxNodeWidth);\n      }\n\n      $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeDimensions.height);\n\n      if (!this.$fillAfter) {\n        this.$fillAfter = this.$data.appendDiv('tree-data-fill');\n      }\n\n      var fillAfterDimensions = {\n        height: 0,\n        width: 0\n      };\n      fillAfterDimensions = this._calculateFillerDimension(new Range(this.viewRangeRendered.to, this.visibleNodesFlat.length));\n      this.$fillAfter.cssHeight(fillAfterDimensions.height);\n\n      if (this.isHorizontalScrollingEnabled()) {\n        this.$fillAfter.cssWidth(fillAfterDimensions.width);\n        this.maxNodeWidth = Math.max(fillAfterDimensions.width, this.maxNodeWidth);\n      }\n\n      $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterDimensions.height);\n    }\n  }, {\n    key: \"_calculateFillerDimension\",\n    value: function _calculateFillerDimension(range) {\n      var outerWidth = 0;\n\n      if (this.rendered) {\n        // the outer-width is only correct if this tree is already rendered. otherwise wrong values are returned.\n        outerWidth = this.$data.outerWidth();\n      }\n\n      var dimension = {\n        height: 0,\n        width: Math.max(outerWidth, this.maxNodeWidth)\n      };\n\n      for (var i = range.from; i < range.to; i++) {\n        var node = this.visibleNodesFlat[i];\n        dimension.height += this._heightForNode(node);\n        dimension.width = Math.max(dimension.width, this._widthForNode(node));\n      }\n\n      return dimension;\n    }\n  }, {\n    key: \"_removeNodesInRange\",\n    value: function _removeNodesInRange(range) {\n      var fromNode,\n          toNode,\n          node,\n          i,\n          numNodesRemoved = 0,\n          nodes = this.visibleNodesFlat;\n      var maxRange = new Range(0, nodes.length);\n      range = maxRange.intersect(range);\n      fromNode = nodes[range.from];\n      toNode = nodes[range.to];\n      var newRange = this.viewRangeRendered.subtract(range);\n\n      if (newRange.length === 2) {\n        throw new Error('Can only remove nodes at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n      }\n\n      this.viewRangeRendered = newRange[0];\n\n      for (i = range.from; i < range.to; i++) {\n        node = nodes[i];\n\n        this._removeNode(node);\n\n        numNodesRemoved++;\n      }\n\n      $.log.isTraceEnabled() && $.log.trace(numNodesRemoved + ' nodes removed from ' + range + '.');\n    }\n    /**\n     * Just removes the node, does NOT adjust this.viewRangeRendered\n     */\n\n  }, {\n    key: \"_removeNode\",\n    value: function _removeNode(node) {\n      var $node = node.$node;\n\n      if (!$node) {\n        return;\n      }\n\n      if ($node.hasClass('hiding')) {\n        // Do not remove nodes which are removed using an animation\n        return;\n      } // only remove node\n\n\n      $node.detach();\n      node.attached = false;\n    }\n    /**\n     * Renders the rows visible in the viewport and removes the other rows\n     */\n\n  }, {\n    key: \"_renderViewRange\",\n    value: function _renderViewRange(viewRange) {\n      if (viewRange.from === this.viewRangeRendered.from && viewRange.to === this.viewRangeRendered.to && !this.viewRangeDirty) {\n        // When node with has changed (because of changes in layout) we must at least\n        // update the internal node width even though the view-range has not changed.\n        if (this.nodeWidthDirty) {\n          this._renderFiller();\n\n          this._updateDomNodeWidth();\n\n          this._updateDomNodeIconWidth();\n        } // Range already rendered -> do nothing\n\n\n        return;\n      }\n\n      if (!this.viewRangeDirty) {\n        var rangesToRender = viewRange.subtract(this.viewRangeRendered);\n        var rangesToRemove = this.viewRangeRendered.subtract(viewRange);\n        var maxRange = new Range(0, this.visibleNodesFlat.length);\n        rangesToRemove.forEach(function (range) {\n          this._removeNodesInRange(range);\n\n          if (maxRange.to < range.to) {\n            this.viewRangeRendered = viewRange;\n          }\n        }.bind(this));\n        rangesToRender.forEach(function (range) {\n          this._renderNodesInRange(range);\n        }.bind(this));\n      } else {\n        // expansion changed\n        this.viewRangeRendered = viewRange;\n        this.ensureRangeVisible(viewRange);\n      } // check if at least last and first row in range got correctly rendered\n\n\n      if (this.viewRangeRendered.size() > 0) {\n        var nodes = this.visibleNodesFlat;\n        var firstNode = nodes[this.viewRangeRendered.from];\n        var lastNode = nodes[this.viewRangeRendered.to - 1];\n\n        if (this.viewRangeDirty) {\n          // cleanup nodes before range and after\n          var $nodesBeforFirstNode = firstNode.$node.prevAll('.tree-node');\n          var $nodesAfterLastNode = lastNode.$node.nextAll('.tree-node');\n\n          this._cleanupNodes($nodesBeforFirstNode);\n\n          this._cleanupNodes($nodesAfterLastNode);\n        }\n\n        if (!firstNode.attached || !lastNode.attached) {\n          throw new Error('Nodes not rendered as expected. ' + this.viewRangeRendered + '. First: ' + firstNode.$node + '. Last: ' + lastNode.$node);\n        }\n      }\n\n      this._postRenderViewRange();\n\n      this.viewRangeDirty = false;\n    }\n  }, {\n    key: \"_postRenderViewRange\",\n    value: function _postRenderViewRange() {\n      this._renderFiller();\n\n      this._updateDomNodeWidth();\n\n      this._updateDomNodeIconWidth();\n\n      this._renderSelection();\n    }\n    /**\n     * The handling of the icon-size here depends on two assumptions:\n     *\n     * 1. font icons are always pre-loaded on application startup. This means outerWidth() will always return the correct\n     *    size of the icon at any time.\n     *\n     * 2. bitmap icons are not pre-loaded. This means, when the icon is shown, the size can be unknown because the\n     *    browser has not yet loaded the image resource. Because of that outerWidth() could not return the correct size\n     *    and also layout would have trouble. Because in a tree all icons should have the same size, we simply define\n     *    the min-width and min-height of bitmap icons by CSS. So we always have a proper value when we read the icon\n     *    size. We don't support the case where the same tree has bitmap icons in different sizes. When someone needs\n     *    larger icons, one could simple change the global constant @tree-node-bitmap-icon-size to change the icon size\n     *    for all trees, or set a CSS rule/class when only a single tree must have a different icon size.\n     */\n\n  }, {\n    key: \"_updateDomNodeIconWidth\",\n    value: function _updateDomNodeIconWidth($nodes) {\n      if (!this.rendered && !this.rendering) {\n        return;\n      }\n\n      this._visibleNodesInViewRange().forEach(function (node) {\n        node._updateIconWidth();\n      });\n    }\n  }, {\n    key: \"_visibleNodesInViewRange\",\n    value: function _visibleNodesInViewRange() {\n      return this.visibleNodesFlat.slice(this.viewRangeRendered.from, this.viewRangeRendered.to);\n    }\n  }, {\n    key: \"_updateDomNodeWidth\",\n    value: function _updateDomNodeWidth() {\n      if (!this.isHorizontalScrollingEnabled()) {\n        return;\n      }\n\n      if (!this.rendered || !this.nodeWidthDirty) {\n        return;\n      }\n\n      var nodes = this._visibleNodesInViewRange();\n\n      var maxNodeWidth = this.maxNodeWidth; // find max-width\n\n      maxNodeWidth = nodes.reduce(function (aggr, node) {\n        return Math.max(node.width, aggr);\n      }, scout.nvl(maxNodeWidth, 0)); // set max width on all nodes\n\n      nodes.forEach(function (node) {\n        node.$node.cssWidth(maxNodeWidth);\n      });\n      this.nodeWidthDirty = false;\n    }\n  }, {\n    key: \"_cleanupNodes\",\n    value: function _cleanupNodes($nodes) {\n      for (var i = 0; i < $nodes.length; i++) {\n        this._removeNode($nodes.eq(i).data('node'));\n      }\n    }\n    /**\n     * Returns the index of the node which is at position scrollTop.\n     */\n\n  }, {\n    key: \"_nodeAtScrollTop\",\n    value: function _nodeAtScrollTop(scrollTop) {\n      var height = 0,\n          nodeTop;\n      this.visibleNodesFlat.some(function (node, i) {\n        height += this._heightForNode(node);\n\n        if (scrollTop < height) {\n          nodeTop = node;\n          return true;\n        }\n      }.bind(this));\n      var visibleNodesLength = this.visibleNodesFlat.length;\n\n      if (!nodeTop && visibleNodesLength > 0) {\n        nodeTop = this.visibleNodesFlat[visibleNodesLength - 1];\n      }\n\n      return nodeTop;\n    }\n  }, {\n    key: \"_heightForNode\",\n    value: function _heightForNode(node) {\n      var height = 0;\n\n      if (node.height) {\n        height = node.height;\n      } else {\n        height = this.nodeHeight;\n      }\n\n      return height;\n    }\n  }, {\n    key: \"_widthForNode\",\n    value: function _widthForNode(node) {\n      var width = 0;\n\n      if (node.width) {\n        width = node.width;\n      } else {\n        width = this.nodeWidth;\n      }\n\n      return width;\n    }\n    /**\n     * Returns a range of size this.viewRangeSize. Start of range is nodeIndex - viewRangeSize / 4.\n     * -> 1/4 of the nodes are before the viewport 2/4 in the viewport 1/4 after the viewport,\n     * assuming viewRangeSize is 2*number of possible nodes in the viewport (see calculateViewRangeSize).\n     */\n\n  }, {\n    key: \"_calculateViewRangeForNode\",\n    value: function _calculateViewRangeForNode(node) {\n      var viewRange = new Range(),\n          quarterRange = Math.floor(this.viewRangeSize / Tree.VIEW_RANGE_DIVISOR),\n          diff;\n      var nodeIndex = this.visibleNodesFlat.indexOf(node);\n      viewRange.from = Math.max(nodeIndex - quarterRange, 0);\n      viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.visibleNodesFlat.length);\n\n      if (!node || nodeIndex === -1) {\n        return viewRange;\n      } // Try to use the whole viewRangeSize (extend from if necessary)\n\n\n      diff = this.viewRangeSize - viewRange.size();\n\n      if (diff > 0) {\n        viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);\n      }\n\n      return viewRange;\n    }\n    /**\n     * Calculates the optimal view range size (number of nodes to be rendered).\n     * It uses the default node height to estimate how many nodes fit in the view port.\n     * The view range size is this value * 2.\n     * <p>\n     * Note: the value calculated by this function is important for calculating the\n     * 'insertBatch'. When the value becomes smaller than 4 ({@link Tree.VIEW_RANGE_DIVISOR}) this\n     * will cause errors on inserting nodes at the right position. See #262890.\n     */\n\n  }, {\n    key: \"calculateViewRangeSize\",\n    value: function calculateViewRangeSize() {\n      // Make sure row height is up to date (row height may be different after zooming)\n      this._updateNodeDimensions();\n\n      if (this.nodeHeight === 0) {\n        throw new Error('Cannot calculate view range with nodeHeight = 0');\n      }\n\n      var viewRangeMultiplier = Tree.VIEW_RANGE_DIVISOR / 2; // See  _calculateViewRangeForNode\n\n      var viewRange = Math.ceil(this.$data.outerHeight() / this.nodeHeight) * viewRangeMultiplier;\n      return Math.max(Tree.VIEW_RANGE_DIVISOR, viewRange);\n    }\n  }, {\n    key: \"setViewRangeSize\",\n    value: function setViewRangeSize(viewRangeSize) {\n      if (this.viewRangeSize === viewRangeSize) {\n        return;\n      }\n\n      this._setProperty('viewRangeSize', viewRangeSize);\n\n      if (this.rendered) {\n        this._renderViewport();\n      }\n    }\n  }, {\n    key: \"_updateNodeDimensions\",\n    value: function _updateNodeDimensions() {\n      var emptyNode = this._createTreeNode();\n\n      var $node = this._renderNode(emptyNode).appendTo(this.$data);\n\n      this.nodeHeight = $node.outerHeight(true);\n\n      if (this.isHorizontalScrollingEnabled()) {\n        var oldNodeWidth = this.nodeWidth;\n        this.nodeWidth = $node.outerWidth(true);\n\n        if (oldNodeWidth !== this.nodeWidth) {\n          this.viewRangeDirty = true;\n        }\n      }\n\n      emptyNode.reset();\n    }\n    /**\n     * Updates the node heights for every visible node and clears the height of the others\n     */\n\n  }, {\n    key: \"updateNodeHeights\",\n    value: function updateNodeHeights() {\n      this.visibleNodesFlat.forEach(function (node) {\n        if (!node.attached) {\n          node.height = null;\n        } else {\n          node.height = node.$node.outerHeight(true);\n        }\n      });\n    }\n  }, {\n    key: \"removeAllNodes\",\n    value: function removeAllNodes() {\n      this._removeNodes(this.nodes);\n    }\n    /**\n     * @param parentNode\n     *          Optional. If provided, this node's state will be updated (e.g. it will be collapsed\n     *          if it does no longer have child nodes). Can also be an array, in which case all of\n     *          those nodes are updated.\n     */\n\n  }, {\n    key: \"_removeNodes\",\n    value: function _removeNodes(nodes, parentNode) {\n      if (nodes.length === 0) {\n        return;\n      }\n\n      nodes.forEach(function (node) {\n        this._removeFromFlatList(node, true);\n\n        if (node.childNodes.length > 0) {\n          this._removeNodes(node.childNodes, node);\n        }\n\n        if (node.$node) {\n          if (this._$animationWrapper && this._$animationWrapper.find(node.$node).length > 0) {\n            this._$animationWrapper.stop(false, true);\n          }\n\n          node.reset();\n        }\n      }, this); // If every child node was deleted mark node as collapsed (independent of the model state)\n      // --> makes it consistent with addNodes and expand (expansion is not allowed if there are no child nodes)\n\n      arrays.ensure(parentNode).forEach(function (p) {\n        if (p && p.$node && p.childNodes.length === 0) {\n          p.$node.removeClass('expanded lazy');\n        }\n      });\n\n      if (this.rendered) {\n        this.viewRangeDirty = true;\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_renderNode\",\n    value: function _renderNode(node) {\n      var paddingLeft = this._computeNodePaddingLeft(node);\n\n      node.render(this.$container, paddingLeft, this.checkable, this.enabledComputed);\n      return node.$node;\n    }\n  }, {\n    key: \"_removeMenus\",\n    value: function _removeMenus() {// menubar takes care about removal\n    }\n  }, {\n    key: \"_filterMenus\",\n    value: function _filterMenus(argMenus, destination, onlyVisible, enableDisableKeyStroke) {\n      return menus_1.filterAccordingToSelection('Tree', this.selectedNodes.length, argMenus, destination, onlyVisible, enableDisableKeyStroke);\n    }\n    /**\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_renderEnabled\",\n    value: function _renderEnabled() {\n      _get(_getPrototypeOf(Tree.prototype), \"_renderEnabled\", this).call(this);\n\n      var enabled = this.enabledComputed;\n      this.$data.setEnabled(enabled);\n      this.$container.setTabbable(enabled);\n\n      if (this.rendered) {\n        // Enable/disable all checkboxes\n        this.$nodes().each(function () {\n          var $node = $(this),\n              node = $node.data('node');\n          $node.children('.tree-node-checkbox').children('.check-box').toggleClass('disabled', !(enabled && node.enabled));\n        });\n      }\n    }\n    /**\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_renderDisabledStyle\",\n    value: function _renderDisabledStyle() {\n      _get(_getPrototypeOf(Tree.prototype), \"_renderDisabledStyle\", this).call(this);\n\n      this._renderDisabledStyleInternal(this.$data);\n    }\n  }, {\n    key: \"setCheckable\",\n    value: function setCheckable(checkable) {\n      this.setProperty('checkable', checkable);\n    }\n  }, {\n    key: \"_setCheckable\",\n    value: function _setCheckable(checkable) {\n      this._setProperty('checkable', checkable);\n\n      if (this.checkable) {\n        this.nodePaddingLevel = this.nodePaddingLevelCheckable;\n      } else {\n        this.nodePaddingLevel = this.nodePaddingLevelNotCheckable;\n      }\n    }\n  }, {\n    key: \"setCheckableStyle\",\n    value: function setCheckableStyle(checkableStyle) {\n      this.setProperty('checkableStyle', checkableStyle);\n    }\n  }, {\n    key: \"_renderCheckable\",\n    value: function _renderCheckable() {\n      // Define helper functions\n      var isNodeRendered = function isNodeRendered(node) {\n        return Boolean(node.$node);\n      };\n\n      var updateCheckableStateRec = function (node) {\n        var $node = node.$node;\n        var $control = $node.children('.tree-node-control');\n        var $checkbox = $node.children('.tree-node-checkbox');\n\n        node._updateControl($control, this);\n\n        if (this.checkable) {\n          if ($checkbox.length === 0) {\n            node._renderCheckbox();\n          }\n        } else {\n          $checkbox.remove();\n        }\n\n        $node.css('padding-left', this._computeNodePaddingLeft(node)); // Recursion\n\n        if (node.childNodes) {\n          node.childNodes.filter(isNodeRendered).forEach(updateCheckableStateRec);\n        }\n      }.bind(this); // Start recursion\n\n\n      this.nodes.filter(isNodeRendered).forEach(updateCheckableStateRec);\n    }\n  }, {\n    key: \"_renderDisplayStyle\",\n    value: function _renderDisplayStyle() {\n      this.$container.toggleClass('breadcrumb', this.isBreadcrumbStyleActive());\n\n      this._updateNodePaddingsLeft(); // update scrollbar if mode has changed (from tree to bc or vice versa)\n\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_renderExpansion\",\n    value: function _renderExpansion(node, options) {\n      var opts = {\n        expandLazyChanged: false,\n        expansionChanged: false\n      };\n      $.extend(opts, options);\n      var $node = node.$node,\n          expanded = node.expanded; // Only render if node is rendered to make it possible to expand/collapse currently hidden nodes (used by collapseAll).\n\n      if (!$node || $node.length === 0) {\n        return;\n      } // Only expand / collapse if there are child nodes\n\n\n      if (node.childNodes.length === 0) {\n        return true;\n      }\n\n      $node.toggleClass('lazy', expanded && node.expandedLazy);\n\n      if (!opts.expansionChanged && !opts.expandLazyChanged) {\n        // Expansion state has not changed -> return\n        return;\n      }\n\n      if (expanded) {\n        $node.addClass('expanded');\n      } else {\n        $node.removeClass('expanded');\n      }\n    }\n  }, {\n    key: \"_renderSelection\",\n    value: function _renderSelection() {\n      // Add children class to root nodes if no nodes are selected\n      if (this.selectedNodes.length === 0) {\n        this.nodes.forEach(function (childNode) {\n          if (childNode.rendered) {\n            childNode.$node.addClass('child-of-selected');\n          }\n        }, this);\n      }\n\n      this.selectedNodes.forEach(function (node) {\n        if (!this.visibleNodesMap[node.id]) {\n          return;\n        } // Mark all ancestor nodes, especially necessary for bread crumb mode\n\n\n        var parentNode = node.parentNode;\n\n        if (parentNode && parentNode.rendered) {\n          parentNode.$node.addClass('parent-of-selected');\n        }\n\n        while (parentNode) {\n          if (parentNode.rendered) {\n            parentNode.$node.addClass('ancestor-of-selected');\n          }\n\n          parentNode = parentNode.parentNode;\n        } // Mark all child nodes\n\n\n        if (node.expanded) {\n          node.childNodes.forEach(function (childNode) {\n            if (childNode.rendered) {\n              childNode.$node.addClass('child-of-selected');\n            }\n          }, this);\n        }\n\n        if (node.rendered) {\n          node.$node.select(true);\n        }\n      }, this); // Update 'group' markers for all rendered nodes\n\n      for (var i = this.viewRangeRendered.from; i < this.viewRangeRendered.to; i++) {\n        if (i >= this.visibleNodesFlat.length) {\n          break;\n        }\n\n        var node = this.visibleNodesFlat[i];\n\n        if (node && node.rendered) {\n          node.$node.toggleClass('group', Boolean(this.groupedNodes[node.id]));\n        }\n      }\n\n      this._updateNodePaddingsLeft();\n\n      this._highlightPrevSelectedNode();\n\n      if (this.scrollToSelection) {\n        this.revealSelection();\n      }\n    }\n  }, {\n    key: \"_renderCheckableStyle\",\n    value: function _renderCheckableStyle() {\n      this.$data.toggleClass('checkable', this.isTreeNodeCheckEnabled());\n    }\n  }, {\n    key: \"_highlightPrevSelectedNode\",\n    value: function _highlightPrevSelectedNode() {\n      if (!this.isBreadcrumbStyleActive()) {\n        return;\n      }\n\n      if (!this.prevSelectedNode || !this.prevSelectedNode.rendered || this.prevSelectedNode.prevSelectionAnimationDone) {\n        return;\n      } // Highlight previously selected node, but do it only once\n\n\n      this.prevSelectedNode.$node.addClassForAnimation('animate-prev-selected').oneAnimationEnd(function () {\n        this.prevSelectedNode.prevSelectionAnimationDone = true;\n      }.bind(this));\n    }\n  }, {\n    key: \"_removeSelection\",\n    value: function _removeSelection() {\n      // Remove children class on root nodes if no nodes were selected\n      if (this.selectedNodes.length === 0) {\n        this.nodes.forEach(function (childNode) {\n          if (childNode.rendered) {\n            childNode.$node.removeClass('child-of-selected');\n          }\n        }, this);\n      } // Ensure animate-prev-selected class is removed (in case animation did not start)\n\n\n      if (this.prevSelectedNode && this.prevSelectedNode.rendered) {\n        this.prevSelectedNode.$node.removeClass('animate-prev-selected');\n      }\n\n      this.selectedNodes.forEach(this._removeNodeSelection, this);\n    }\n  }, {\n    key: \"_removeNodeSelection\",\n    value: function _removeNodeSelection(node) {\n      if (node.rendered) {\n        node.$node.select(false);\n      } // remove ancestor and child classes\n\n\n      var parentNode = node.parentNode;\n\n      if (parentNode && parentNode.rendered) {\n        parentNode.$node.removeClass('parent-of-selected');\n      }\n\n      while (parentNode && parentNode.rendered) {\n        parentNode.$node.removeClass('ancestor-of-selected');\n        parentNode = parentNode.parentNode;\n      }\n\n      if (node.expanded) {\n        node.childNodes.forEach(function (childNode) {\n          if (childNode.rendered) {\n            childNode.$node.removeClass('child-of-selected');\n          }\n        }, this);\n      }\n    }\n  }, {\n    key: \"_renderDropType\",\n    value: function _renderDropType() {\n      if (this.dropType) {\n        this._installDragAndDropHandler();\n      } else {\n        this._uninstallDragAndDropHandler();\n      }\n    }\n  }, {\n    key: \"_installDragAndDropHandler\",\n    value: function _installDragAndDropHandler(event) {\n      if (this.dragAndDropHandler) {\n        return;\n      }\n\n      this.dragAndDropHandler = dragAndDrop.handler(this, {\n        supportedScoutTypes: dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n        dropType: function () {\n          return this.dropType;\n        }.bind(this),\n        dropMaximumSize: function () {\n          return this.dropMaximumSize;\n        }.bind(this),\n        additionalDropProperties: function additionalDropProperties(event) {\n          var $target = $(event.currentTarget);\n          var properties = {\n            nodeId: ''\n          };\n\n          if ($target.hasClass('tree-node')) {\n            var node = $target.data('node');\n            properties.nodeId = node.id;\n          }\n\n          return properties;\n        }\n      });\n      this.dragAndDropHandler.install(this.$container, '.tree-data,.tree-node');\n    }\n  }, {\n    key: \"_uninstallDragAndDropHandler\",\n    value: function _uninstallDragAndDropHandler(event) {\n      if (!this.dragAndDropHandler) {\n        return;\n      }\n\n      this.dragAndDropHandler.uninstall();\n      this.dragAndDropHandler = null;\n    }\n  }, {\n    key: \"_updateMarkChildrenChecked\",\n    value: function _updateMarkChildrenChecked(node, init, checked, checkChildrenChecked) {\n      if (!this.checkable) {\n        return;\n      }\n\n      if (checkChildrenChecked) {\n        var childrenFound = false;\n\n        for (var j = 0; j < node.childNodes.length > 0; j++) {\n          var childNode = node.childNodes[j];\n\n          if (childNode.checked || childNode.childrenChecked) {\n            node.childrenChecked = true;\n            checked = true;\n            childrenFound = true;\n\n            if (this.rendered && node.$node) {\n              node.$node.children('.tree-node-checkbox').children('.check-box').toggleClass('children-checked', true);\n            }\n\n            break;\n          }\n        }\n\n        if (!childrenFound) {\n          node.childrenChecked = false;\n\n          if (this.rendered && node.$node) {\n            node.$node.children('.tree-node-checkbox').children('.check-box').toggleClass('children-checked', false);\n          }\n        }\n      }\n\n      if (!node.parentNode || node.parentNode.checked) {\n        return;\n      }\n\n      var stateChanged = false;\n\n      if (!checked && !init) {\n        // node was unchecked check siblings\n        var hasCheckedSiblings = false;\n\n        for (var i = 0; i < node.parentNode.childNodes.length > 0; i++) {\n          var siblingNode = node.parentNode.childNodes[i];\n\n          if (siblingNode.checked || siblingNode.childrenChecked) {\n            hasCheckedSiblings = true;\n            break;\n          }\n        }\n\n        if (hasCheckedSiblings !== node.parentNode.childrenChecked) {\n          // parentNode.checked should be false\n          node.parentNode.childrenChecked = hasCheckedSiblings;\n          stateChanged = true;\n        }\n      }\n\n      if (checked && !node.parentNode.childrenChecked) {\n        node.parentNode.childrenChecked = true;\n        stateChanged = true;\n      }\n\n      if (stateChanged) {\n        this._updateMarkChildrenChecked(node.parentNode, init, checked);\n\n        if (this.rendered && node.parentNode.$node) {\n          if (checked) {\n            node.parentNode.$node.children('.tree-node-checkbox').children('.check-box').toggleClass('children-checked', true);\n          } else {\n            node.parentNode.$node.children('.tree-node-checkbox').children('.check-box').toggleClass('children-checked', false);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_installNodeTooltipSupport\",\n    value: function _installNodeTooltipSupport() {\n      tooltips.install(this.$data, {\n        parent: this,\n        selector: '.tree-node',\n        text: this._nodeTooltipText.bind(this),\n        arrowPosition: 50,\n        arrowPositionUnit: '%',\n        nativeTooltip: !Device.get().isCustomEllipsisTooltipPossible()\n      });\n    }\n  }, {\n    key: \"_uninstallNodeTooltipSupport\",\n    value: function _uninstallNodeTooltipSupport() {\n      tooltips.uninstall(this.$data);\n    }\n  }, {\n    key: \"_nodeTooltipText\",\n    value: function _nodeTooltipText($node) {\n      var node = $node.data('node');\n\n      if (node.tooltipText) {\n        return node.tooltipText;\n      } else if (this._isTruncatedNodeTooltipEnabled() && $node.isContentTruncated()) {\n        return node.$text.text();\n      }\n    }\n  }, {\n    key: \"_isTruncatedNodeTooltipEnabled\",\n    value: function _isTruncatedNodeTooltipEnabled() {\n      return true;\n    }\n  }, {\n    key: \"setDisplayStyle\",\n    value: function setDisplayStyle(displayStyle) {\n      if (this.displayStyle === displayStyle) {\n        return;\n      }\n\n      this._renderViewportBlocked = true;\n\n      this._setDisplayStyle(displayStyle);\n\n      if (this.rendered) {\n        this._renderDisplayStyle();\n      }\n\n      this._renderViewportBlocked = false;\n    }\n  }, {\n    key: \"_setDisplayStyle\",\n    value: function _setDisplayStyle(displayStyle) {\n      this._setProperty('displayStyle', displayStyle);\n\n      if (this.displayStyle === Tree.DisplayStyle.BREADCRUMB) {\n        if (this.selectedNodes.length > 0) {\n          var selectedNode = this.selectedNodes[0];\n\n          if (!selectedNode.expanded) {\n            this.expandNode(selectedNode);\n          }\n        }\n\n        this.addFilter(this.breadcrumbFilter, true, true);\n        this.filterVisibleNodes();\n      } else {\n        this.removeFilter(this.breadcrumbFilter, true);\n        this.filter();\n      }\n    }\n  }, {\n    key: \"_updateNodePaddingsLeft\",\n    value: function _updateNodePaddingsLeft() {\n      this.$nodes().each(function (index, element) {\n        var $node = $(element),\n            node = $node.data('node'),\n            paddingLeft = this._computeNodePaddingLeft(node);\n\n        $node.css('padding-left', objects.isNullOrUndefined(paddingLeft) ? '' : paddingLeft);\n      }.bind(this));\n    }\n  }, {\n    key: \"setBreadcrumbStyleActive\",\n    value: function setBreadcrumbStyleActive(active) {\n      if (active) {\n        this.setDisplayStyle(Tree.DisplayStyle.BREADCRUMB);\n      } else {\n        this.setDisplayStyle(Tree.DisplayStyle.DEFAULT);\n      }\n    }\n  }, {\n    key: \"isNodeInBreadcrumbVisible\",\n    value: function isNodeInBreadcrumbVisible(node) {\n      return this._inSelectionPathList[node.id] === undefined ? false : this._inSelectionPathList[node.id];\n    }\n  }, {\n    key: \"isBreadcrumbStyleActive\",\n    value: function isBreadcrumbStyleActive() {\n      return this.displayStyle === Tree.DisplayStyle.BREADCRUMB;\n    }\n  }, {\n    key: \"setToggleBreadcrumbStyleEnabled\",\n    value: function setToggleBreadcrumbStyleEnabled(enabled) {\n      this.setProperty('toggleBreadcrumbStyleEnabled', enabled);\n    }\n  }, {\n    key: \"setBreadcrumbTogglingThreshold\",\n    value: function setBreadcrumbTogglingThreshold(width) {\n      this.setProperty('breadcrumbTogglingThreshold', width);\n    }\n  }, {\n    key: \"expandNode\",\n    value: function expandNode(node, opts) {\n      this.setNodeExpanded(node, true, opts);\n    }\n  }, {\n    key: \"collapseNode\",\n    value: function collapseNode(node, opts) {\n      this.setNodeExpanded(node, false, opts);\n    }\n  }, {\n    key: \"collapseAll\",\n    value: function collapseAll() {\n      this.rebuildSuppressed = true; // Collapse all expanded child nodes (only model)\n\n      this.visitNodes(function (node) {\n        this.collapseNode(node);\n      }.bind(this));\n\n      if (this.rendered) {\n        // ensure correct rendering\n        this._rerenderViewport();\n      }\n\n      this.rebuildSuppressed = false;\n    }\n  }, {\n    key: \"setNodeExpanded\",\n    value: function setNodeExpanded(node, expanded, opts) {\n      opts = opts || {};\n      var lazy = opts.lazy;\n\n      if (objects.isNullOrUndefined(lazy)) {\n        if (node.expanded === expanded) {\n          // no state change: Keep the current \"expandedLazy\" state\n          lazy = node.expandedLazy;\n        } else if (expanded) {\n          // collapsed -> expanded: Set the \"expandedLazy\" state to the node's \"lazyExpandingEnabled\" flag\n          lazy = node.lazyExpandingEnabled;\n        } else {\n          // expanded -> collapsed: Set the \"expandedLazy\" state to false\n          lazy = false;\n        }\n      }\n\n      var renderAnimated = scout.nvl(opts.renderAnimated, true); // Never do lazy expansion if it is disabled on the tree\n\n      if (!this.lazyExpandingEnabled) {\n        lazy = false;\n      }\n\n      if (this.isBreadcrumbStyleActive()) {\n        // Do not allow to collapse a selected node\n        if (!expanded && this.selectedNodes.indexOf(node) > -1) {\n          this.setNodeExpanded(node, true, opts);\n          return;\n        }\n      } // Optionally collapse all children (recursively)\n\n\n      if (opts.collapseChildNodes) {\n        // Suppress render expansion\n        var childOpts = objects.valueCopy(opts);\n        childOpts.renderExpansion = false;\n        node.childNodes.forEach(function (childNode) {\n          if (childNode.expanded) {\n            this.collapseNode(childNode, childOpts);\n          }\n        }.bind(this));\n      }\n\n      var renderExpansionOpts = {\n        expansionChanged: false,\n        expandLazyChanged: false\n      }; // Set expansion state\n\n      if (node.expanded !== expanded || node.expandedLazy !== lazy) {\n        renderExpansionOpts.expansionChanged = node.expanded !== expanded;\n        renderExpansionOpts.expandLazyChanged = node.expandedLazy !== lazy;\n        node.expanded = expanded;\n        node.expandedLazy = lazy;\n\n        var filterStateChanged = this._applyFiltersForNode(node);\n\n        if (filterStateChanged && renderExpansionOpts.expansionChanged) {\n          if (node.parentNode) {\n            // ensure node is visible under the parent node if there is a parent.\n            this._rebuildParent(node.parentNode, opts);\n          } else if (node.filterAccepted) {\n            this._addToVisibleFlatList(node, false);\n          } else {\n            this._removeFromFlatList(node, false);\n          }\n        } else if (renderExpansionOpts.expandLazyChanged) {\n          node.childNodes.forEach(function (child) {\n            this._applyFiltersForNode(child);\n          }.bind(this));\n        }\n\n        if (this.groupedNodes[node.id]) {\n          this._updateItemPath(false, node);\n        }\n\n        if (node.expanded) {\n          node.ensureLoadChildren().done(this._addChildrenToFlatList.bind(this, node, null, renderAnimated, null, true));\n        } else {\n          this._removeChildrenFromFlatList(node, renderAnimated);\n        }\n\n        this.trigger('nodeExpanded', {\n          node: node,\n          expanded: expanded,\n          expandedLazy: lazy\n        });\n        this.viewRangeDirty = true;\n      } // Render expansion\n\n\n      if (this.rendered && scout.nvl(opts.renderExpansion, true)) {\n        this._renderExpansion(node, renderExpansionOpts);\n      }\n\n      if (this.rendered) {\n        this.ensureExpansionVisible(node);\n      }\n    }\n  }, {\n    key: \"setNodeExpandedRecursive\",\n    value: function setNodeExpandedRecursive(nodes, expanded, opts) {\n      Tree.visitNodes(function (childNode) {\n        this.setNodeExpanded(childNode, expanded, opts);\n      }.bind(this), nodes);\n    }\n  }, {\n    key: \"_rebuildParent\",\n    value: function _rebuildParent(node, opts) {\n      if (this.rebuildSuppressed) {\n        return;\n      }\n\n      if (node.expanded || node.expandedLazy) {\n        this._addChildrenToFlatList(node, null, false, null, true);\n      } else {\n        this._removeChildrenFromFlatList(node, false);\n      } // Render expansion\n\n\n      if (this.rendered && scout.nvl(opts.renderExpansion, true)) {\n        var renderExpansionOpts = {\n          expansionChanged: true\n        };\n\n        this._renderExpansion(node, renderExpansionOpts);\n      }\n    }\n  }, {\n    key: \"_removeChildrenFromFlatList\",\n    value: function _removeChildrenFromFlatList(parentNode, animatedRemove) {\n      // Only if a parent is available the children are available.\n      if (this.visibleNodesMap[parentNode.id]) {\n        var parentIndex = this.visibleNodesFlat.indexOf(parentNode);\n        var elementsToDelete = 0;\n        var parentLevel = parentNode.level;\n        var removedNodes = [];\n        animatedRemove = animatedRemove && this.rendered;\n\n        if (this._$animationWrapper) {\n          // Note: Do _not_ use finish() here! Although documentation states that it is \"similar\" to stop(true, true),\n          // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when\n          // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling\n          // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)\n          this._$animationWrapper.stop(false, true);\n        }\n\n        this._$expandAnimationWrappers.forEach(function ($wrapper) {\n          $wrapper.stop(false, true);\n        });\n\n        for (var i = parentIndex + 1; i < this.visibleNodesFlat.length; i++) {\n          if (this.visibleNodesFlat[i].level > parentLevel) {\n            var node = this.visibleNodesFlat[i];\n\n            if (this.isHorizontalScrollingEnabled()) {\n              // if node is the node which defines the widest width then recalculate width for render\n              if (node.width === this.maxNodeWidth) {\n                this.maxNodeWidth = 0;\n                this.nodeWidthDirty = true;\n              }\n            }\n\n            delete this.visibleNodesMap[this.visibleNodesFlat[i].id];\n\n            if (node.attached && animatedRemove) {\n              if (!this._$animationWrapper) {\n                this._$animationWrapper = $('<div class=\"animation-wrapper\">').insertBefore(node.$node);\n\n                this._$animationWrapper.data('parentNode', parentNode);\n              }\n\n              if (node.isDescendantOf(this._$animationWrapper.data('parentNode'))) {\n                this._$animationWrapper.append(node.$node);\n              }\n\n              node.attached = false;\n              node.displayBackup = node.$node.css('display');\n              removedNodes.push(node);\n            } else if (node.attached && !animatedRemove) {\n              this.hideNode(node, false, false);\n            }\n\n            elementsToDelete++;\n          } else {\n            break;\n          }\n        }\n\n        this.visibleNodesFlat.splice(parentIndex + 1, elementsToDelete); // animate closing\n\n        if (animatedRemove) {\n          // don't animate while rendering (not necessary, or may even lead to timing issues)\n          this._renderViewportBlocked = true;\n\n          if (removedNodes.length > 0) {\n            this._$animationWrapper.animate({\n              height: 0\n            }, {\n              start: this.startAnimationFunc,\n              complete: onAnimationComplete.bind(this, removedNodes),\n              step: this.revalidateLayoutTree.bind(this),\n              duration: 200,\n              queue: false\n            });\n          } else if (this._$animationWrapper) {\n            this._$animationWrapper.remove();\n\n            this._$animationWrapper = null;\n            onAnimationComplete.call(this, removedNodes);\n          } else {\n            this._renderViewportBlocked = false;\n          }\n        }\n\n        return removedNodes;\n      } // ----- Helper functions -----\n\n\n      function onAnimationComplete(affectedNodes) {\n        affectedNodes.forEach(function (node) {\n          node.$node.detach();\n          node.$node.css('display', node.displayBackup);\n          node.displayBackup = null;\n        });\n\n        if (this._$animationWrapper) {\n          this._$animationWrapper.remove();\n\n          this._$animationWrapper = null;\n        }\n\n        this.runningAnimationsFinishFunc();\n      }\n    }\n  }, {\n    key: \"_removeFromFlatList\",\n    value: function _removeFromFlatList(node, animatedRemove) {\n      var removedNodes = [];\n\n      if (this.visibleNodesMap[node.id]) {\n        var index = this.visibleNodesFlat.indexOf(node);\n\n        this._removeChildrenFromFlatList(node, false);\n\n        if (this.isHorizontalScrollingEnabled()) {\n          // if node is the node which defines the widest width then recalculate width for render\n          if (node.width === this.maxNodeWidth) {\n            this.maxNodeWidth = 0;\n            this.nodeWidthDirty = true;\n          }\n        }\n\n        removedNodes = arrays.ensure(this.visibleNodesFlat.splice(index, 1));\n        delete this.visibleNodesMap[node.id];\n        this.hideNode(node, animatedRemove);\n      }\n\n      removedNodes.push(node);\n      return removedNodes;\n    }\n    /**\n     * @returns {boolean} whether or not the function added a node to the flat list\n     */\n\n  }, {\n    key: \"_addToVisibleFlatList\",\n    value: function _addToVisibleFlatList(node, renderingAnimated) {\n      // if node already is in visible list don't do anything. If no parentNode is available this node is on toplevel, if a parent is available\n      // it has to be in visible list and also be expanded\n      if (!this.visibleNodesMap[node.id] && node.isFilterAccepted() && (!node.parentNode || node.parentNode.expanded && this.visibleNodesMap[node.parentNode.id])) {\n        if (this.initialTraversing) {\n          // for faster index calculation\n          this._addToVisibleFlatListNoCheck(node, this.visibleNodesFlat.length, renderingAnimated);\n        } else {\n          var insertIndex = this._findInsertPositionInFlatList(node);\n\n          this._addToVisibleFlatListNoCheck(node, insertIndex, renderingAnimated);\n        }\n      }\n    } // TODO [7.0] CGU applies to all the add/remove to/from flat list methods:\n    // Is it really necessary to update dom on every operation? why not just update the list and renderViewport at the end?\n    // The update of the flat list is currently implemented quite complicated -> it should be simplified.\n    // And: because add to flat list renders all the children the rendered node count is greater than the viewRangeSize until\n    // the layout renders the viewport again -> this must not happen (can be seen when a node gets expanded)\n\n  }, {\n    key: \"_addChildrenToFlatList\",\n    value: function _addChildrenToFlatList(parentNode, parentIndex, animatedRendering, insertBatch, forceFilter) {\n      // add nodes recursively\n      if (!this.visibleNodesMap[parentNode.id]) {\n        return 0;\n      }\n\n      var isSubAdding = Boolean(insertBatch);\n      parentIndex = parentIndex ? parentIndex : this.visibleNodesFlat.indexOf(parentNode);\n      animatedRendering = animatedRendering && this.rendered; // don't animate while rendering (not necessary, or may even lead to timing issues)\n\n      if (this._$animationWrapper && !isSubAdding) {\n        // Note: Do _not_ use finish() here! Although documentation states that it is \"similar\" to stop(true, true),\n        // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when\n        // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling\n        // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)\n        this._$animationWrapper.stop(false, true);\n      }\n\n      if (insertBatch) {\n        insertBatch.setInsertAt(parentIndex);\n      } else {\n        insertBatch = this.newInsertBatch(parentIndex + 1);\n      }\n\n      parentNode.childNodes.forEach(function (node, index) {\n        if (!node.initialized || !node.isFilterAccepted(forceFilter)) {\n          return;\n        }\n\n        var insertIndex,\n            isAlreadyAdded = this.visibleNodesMap[node.id];\n\n        if (isAlreadyAdded) {\n          this.insertBatchInVisibleNodes(insertBatch, this._showNodes(insertBatch), animatedRendering);\n          this.checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch);\n          insertBatch = this.newInsertBatch(insertBatch.nextBatchInsertIndex());\n          insertBatch = this._addChildrenToFlatListIfExpanded(1, node, insertIndex, animatedRendering, insertBatch, forceFilter); // do not animate following\n\n          animatedRendering = false;\n        } else {\n          insertBatch.insertNodes.push(node);\n          this.visibleNodesMap[node.id] = true;\n          insertBatch = this.checkAndHandleBatch(insertBatch, parentNode, animatedRendering);\n          insertBatch = this._addChildrenToFlatListIfExpanded(0, node, insertIndex, animatedRendering, insertBatch, forceFilter);\n        }\n      }.bind(this));\n\n      if (!isSubAdding) {\n        // animation is not done yet and all added nodes are in visible range\n        this.insertBatchInVisibleNodes(insertBatch, this._showNodes(insertBatch), animatedRendering);\n        this.invalidateLayoutTree();\n      }\n\n      return insertBatch;\n    }\n    /**\n     * Checks if the given node is expanded, and if that's the case determine the insert index of the node and add its children to the flat list.\n     *\n     * @param {number} indexOffset either 0 or 1, offset is added to the insert index\n     */\n\n  }, {\n    key: \"_addChildrenToFlatListIfExpanded\",\n    value: function _addChildrenToFlatListIfExpanded(indexOffset, node, insertIndex, animatedRendering, insertBatch, forceFilter) {\n      if (node.expanded && node.childNodes.length) {\n        if (insertBatch.containsNode(node.parentNode) || insertBatch.length() > 1) {\n          // if parent node is already in the batch, do not change the insertIndex,\n          // only append child nodes below that parent node\n          // Also, if the batch is not empty (i.e. contains more nodes than the current node),\n          // the insert index was already calculated previously and must not be changed.\n          insertIndex = insertBatch.insertAt();\n        } else {\n          insertIndex = this._findInsertPositionInFlatList(node);\n        }\n\n        insertIndex += indexOffset;\n        insertBatch = this._addChildrenToFlatList(node, insertIndex, animatedRendering, insertBatch, forceFilter);\n      }\n\n      return insertBatch;\n    }\n  }, {\n    key: \"_showNodes\",\n    value: function _showNodes(insertBatch) {\n      return this.viewRangeRendered.from + this.viewRangeSize >= insertBatch.lastBatchInsertIndex() && this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex();\n    }\n    /**\n     * This function tries to find the correct insert position within the flat list for the given node.\n     * The function must consider the order of child nodes in the original tree structure and then check\n     * where in the flat list this position is.\n     */\n\n  }, {\n    key: \"_findInsertPositionInFlatList\",\n    value: function _findInsertPositionInFlatList(node) {\n      var childNodes,\n          parentNode = node.parentNode; // use root nodes as nodes when no other parent node is available (root case)\n\n      if (parentNode) {\n        childNodes = parentNode.childNodes;\n      } else {\n        childNodes = this.nodes;\n      } // find all visible siblings for our node (incl. our own node, which is probably not yet\n      // in the visible nodes map)\n\n\n      var thatNode = node;\n      var siblings = childNodes.filter(function (node) {\n        return Boolean(this.visibleNodesMap[node.id]) || node === thatNode;\n      }.bind(this)); // when there are no visible siblings, insert below the parent node\n\n      if (siblings.length === 0) {\n        return this._findPositionInFlatList(parentNode) + 1;\n      }\n\n      var nodePos = siblings.indexOf(node); // when there are no prev. siblings in the flat list, insert below the parent node\n\n      if (nodePos === 0) {\n        return this._findPositionInFlatList(parentNode) + 1;\n      }\n\n      var prevSiblingNode = siblings[nodePos - 1];\n\n      var prevSiblingPos = this._findPositionInFlatList(prevSiblingNode); // when the prev. sibling is not in the flat list, insert below the parent node\n\n\n      if (prevSiblingPos === -1) {\n        return this._findPositionInFlatList(parentNode) + 1;\n      } // find the index of the last child element of our prev. sibling node\n      // that's where we want to insert the new node. We go down the flat list\n      // starting from the prev. sibling node, until we hit a node that does not\n      // belong to the sub tree of the prev. sibling node.\n\n\n      var i, checkNode;\n\n      for (i = prevSiblingPos; i < this.visibleNodesFlat.length; i++) {\n        checkNode = this.visibleNodesFlat[i];\n\n        if (!this._isInSameSubTree(prevSiblingNode, checkNode)) {\n          return i;\n        }\n      } // insert at the end of the list\n\n\n      return this.visibleNodesFlat.length;\n    }\n  }, {\n    key: \"_findPositionInFlatList\",\n    value: function _findPositionInFlatList(node) {\n      return this.visibleNodesFlat.indexOf(node);\n    }\n    /**\n     * Checks whether the given checkNode belongs to the same sub tree (or is) the given node.\n     * The function goes up all parentNodes of the checkNode.\n     *\n     * @param {TreeNode} node which is used to for the sub tree comparison\n     * @param {TreeNode} checkNode node which is checked against the given node\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"_isInSameSubTree\",\n    value: function _isInSameSubTree(node, checkNode) {\n      do {\n        if (checkNode === node || checkNode.parentNode === node) {\n          return true;\n        }\n\n        checkNode = checkNode.parentNode;\n      } while (checkNode);\n\n      return false;\n    }\n    /**\n     * Returns true if the given node is a child of one of the selected nodes.\n     * The functions goes up the parent node hierarchy.\n     *\n     * @param {TreeNode} node to check\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"_isChildOfSelectedNodes\",\n    value: function _isChildOfSelectedNodes(node) {\n      while (node) {\n        if (this.selectedNodes.indexOf(node.parentNode) > -1) {\n          return true;\n        }\n\n        node = node.parentNode;\n      }\n\n      return false;\n    }\n    /**\n     * Info: the object created here is a bit weird: the array 'insertNodes' is used as function arguments to the Array#splice function at some point.\n     * The signature of that function is: array.splice(index, deleteCount[, element1[,  element2 [, ...]]])\n     * So the first two elements are numbers and all the following elements are TreeNodes or Pages.\n     */\n\n  }, {\n    key: \"newInsertBatch\",\n    value: function newInsertBatch(insertIndex) {\n      return {\n        insertNodes: [insertIndex, 0],\n        // second element is always 0 (used as argument for deleteCount in Array#splice)\n        $animationWrapper: null,\n        lastBatchInsertIndex: function lastBatchInsertIndex() {\n          if (this.isEmpty()) {\n            return this.insertAt();\n          }\n\n          return this.insertAt() + this.insertNodes.length - 3;\n        },\n        nextBatchInsertIndex: function nextBatchInsertIndex() {\n          // only NBU knows what this means\n          return this.lastBatchInsertIndex() + (this.isEmpty() ? 1 : 2);\n        },\n        isEmpty: function isEmpty() {\n          return this.insertNodes.length === 2;\n        },\n        length: function length() {\n          return this.insertNodes.length - 2;\n        },\n        insertAt: function insertAt() {\n          return this.insertNodes[0];\n        },\n        setInsertAt: function setInsertAt(insertAt) {\n          this.insertNodes[0] = insertAt;\n        },\n        containsNode: function containsNode(node) {\n          return this.insertNodes.indexOf(node) !== -1;\n        }\n      };\n    }\n  }, {\n    key: \"checkAndHandleBatchAnimationWrapper\",\n    value: function checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch) {\n      if (animatedRendering && this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex() && this.viewRangeRendered.to >= insertBatch.lastBatchInsertIndex() && !insertBatch.$animationWrapper) {\n        // we are in visible area so we need a animation wrapper\n        // if parent is in visible area insert after parent else insert before first node.\n        var lastNodeIndex = insertBatch.lastBatchInsertIndex() - 1,\n            nodeBefore = this.viewRangeRendered.from === insertBatch.lastBatchInsertIndex() ? null : this.visibleNodesFlat[lastNodeIndex];\n\n        if (nodeBefore && lastNodeIndex >= this.viewRangeRendered.from && lastNodeIndex < this.viewRangeRendered.to && !nodeBefore.attached) {\n          // ensure node before is visible\n          this.showNode(nodeBefore, false, lastNodeIndex);\n        }\n\n        if (nodeBefore && nodeBefore.attached) {\n          insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(nodeBefore.$node);\n        } else if (parentNode.attached) {\n          insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(parentNode.$node);\n        } else if (this.$fillBefore) {\n          insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(this.$fillBefore);\n        } else {\n          var nodeAfter = this.visibleNodesFlat[insertBatch.lastBatchInsertIndex()];\n          insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertBefore(nodeAfter.$node);\n        }\n\n        insertBatch.animationCompleteFunc = onAnimationComplete;\n\n        this._$expandAnimationWrappers.push(insertBatch.$animationWrapper);\n      } // ----- Helper functions ----- //\n\n\n      function onAnimationComplete() {\n        insertBatch.$animationWrapper.replaceWith(insertBatch.$animationWrapper.contents());\n        arrays.remove(this._$expandAnimationWrappers, insertBatch.$animationWrapper);\n        insertBatch.$animationWrapper = null;\n        this.runningAnimationsFinishFunc();\n      }\n    }\n  }, {\n    key: \"checkAndHandleBatch\",\n    value: function checkAndHandleBatch(insertBatch, parentNode, animatedRendering) {\n      if (this.viewRangeRendered.from - 1 === insertBatch.lastBatchInsertIndex()) {\n        // do immediate rendering because list could be longer\n        this.insertBatchInVisibleNodes(insertBatch, false, false);\n        insertBatch = this.newInsertBatch(insertBatch.lastBatchInsertIndex() + 1);\n      }\n\n      this.checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch);\n\n      if (this.viewRangeRendered.from + this.viewRangeSize - 1 === insertBatch.lastBatchInsertIndex()) {\n        // do immediate rendering because list could be longer\n        this.insertBatchInVisibleNodes(insertBatch, true, animatedRendering);\n        insertBatch = this.newInsertBatch(insertBatch.lastBatchInsertIndex() + 1);\n      }\n\n      return insertBatch;\n    }\n  }, {\n    key: \"insertBatchInVisibleNodes\",\n    value: function insertBatchInVisibleNodes(insertBatch, showNodes, animate) {\n      if (insertBatch.isEmpty()) {\n        // nothing to add\n        return;\n      }\n\n      this.visibleNodesFlat.splice.apply(this.visibleNodesFlat, insertBatch.insertNodes);\n\n      if (showNodes) {\n        var indexHint = insertBatch.insertAt();\n\n        for (var i = 2; i < insertBatch.insertNodes.length; i++) {\n          var node = insertBatch.insertNodes[i];\n          this.showNode(node, false, indexHint);\n\n          if (insertBatch.$animationWrapper) {\n            insertBatch.$animationWrapper.append(node.$node);\n          }\n\n          indexHint++;\n        }\n\n        if (insertBatch.$animationWrapper) {\n          var h = insertBatch.$animationWrapper.outerHeight();\n          insertBatch.$animationWrapper.css('height', 0).animate({\n            height: h\n          }, {\n            start: this.startAnimationFunc,\n            complete: insertBatch.animationCompleteFunc.bind(this),\n            step: this.revalidateLayoutTree.bind(this),\n            duration: 200,\n            queue: false\n          });\n        }\n      } else if (insertBatch.$animationWrapper && insertBatch.animationCompleteFunc) {\n        insertBatch.animationCompleteFunc.call(this);\n      }\n    }\n  }, {\n    key: \"_addToVisibleFlatListNoCheck\",\n    value: function _addToVisibleFlatListNoCheck(node, insertIndex, animatedRendering) {\n      arrays.insert(this.visibleNodesFlat, node, insertIndex);\n      this.visibleNodesMap[node.id] = true;\n\n      if (this.rendered) {\n        this.showNode(node, animatedRendering, insertIndex);\n      }\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(node, options) {\n      if (this.viewRangeRendered.size() === 0) {\n        // Cannot scroll to a node if no node is rendered\n        return;\n      }\n\n      if (!node.attached) {\n        this._renderViewRangeForNode(node);\n      }\n\n      if (!node.attached) {\n        // Node may not be visible due to the filter -> don't try to scroll because it would fail\n        return;\n      }\n\n      scrollbars.scrollTo(this.$data, node.$node, options);\n    }\n  }, {\n    key: \"revealSelection\",\n    value: function revealSelection() {\n      if (!this.rendered) {\n        // Execute delayed because tree may be not layouted yet\n        this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n        return;\n      }\n\n      if (this.selectedNodes.length > 0) {\n        if (!this.visibleNodesMap[this.selectedNodes[0].id]) {\n          this._expandAllParentNodes(this.selectedNodes[0]);\n        }\n\n        this.scrollTo(this.selectedNodes[0]);\n        this.ensureExpansionVisible(this.selectedNodes[0]);\n      }\n    }\n  }, {\n    key: \"ensureExpansionVisible\",\n    value: function ensureExpansionVisible(node) {\n      // only scroll if treenode is in dom and the current node is selected (user triggered expansion change)\n      if (!node || !node.$node || this.selectedNodes[0] !== node) {\n        return;\n      }\n\n      scrollbars.ensureExpansionVisible({\n        element: node,\n        $element: node.$node,\n        $scrollable: this.get$Scrollable(),\n        isExpanded: function isExpanded(element) {\n          return element.expanded;\n        },\n        getChildren: function getChildren(parent) {\n          return parent.childNodes;\n        },\n        nodePaddingLevel: this.nodePaddingLevel,\n        defaultChildHeight: this.nodeHeight\n      });\n    }\n  }, {\n    key: \"deselectAll\",\n    value: function deselectAll() {\n      this.selectNodes([]);\n    }\n  }, {\n    key: \"selectNode\",\n    value: function selectNode(node, debounceSend) {\n      this.selectNodes(node, debounceSend);\n    }\n  }, {\n    key: \"selectNodes\",\n    value: function selectNodes(nodes, debounceSend) {\n      nodes = arrays.ensure(nodes); // TODO [8.0] CGU Actually, the nodes should be filtered here so that invisible nodes may not be selected\n      // But this is currently not possible because the LazyNodeFilter would not accept the nodes\n      // We would have to keep track of the clicked nodes and check them in the lazy node filter (e.g. selectedNode.parentNode.lazySelectedChildNodes[selectedNode.id] = selectedNode).\n      // But since this requires a change in setNodeExpanded as well we decided to not implement it until the TODO at _addChildrenToFlatList is solved\n\n      if (arrays.equalsIgnoreOrder(nodes, this.selectedNodes)) {\n        return;\n      }\n\n      if (this.rendered) {\n        this._rememberScrollTopBeforeSelection();\n\n        this._removeSelection();\n      }\n\n      if (this.prevSelectedNode) {\n        this.prevSelectedNode.prevSelectionAnimationDone = false;\n      }\n\n      this.prevSelectedNode = this.selectedNodes[0];\n\n      this._setSelectedNodes(nodes, debounceSend);\n\n      if (this.rendered) {\n        this._renderSelection();\n\n        this._updateScrollTopAfterSelection();\n      }\n    }\n  }, {\n    key: \"_rememberScrollTopBeforeSelection\",\n    value: function _rememberScrollTopBeforeSelection() {\n      if (this.isBreadcrumbStyleActive()) {\n        // Save the current scrollTop for future up navigation\n        if (this.selectedNodes.length > 0) {\n          this.scrollTopHistory[this.selectedNodes[0].level] = this.$data[0].scrollTop;\n        }\n      } else {\n        // Clear history if user now works with tree to not get confused when returning to bc mode\n        this.scrollTopHistory = [];\n      }\n    }\n  }, {\n    key: \"_updateScrollTopAfterSelection\",\n    value: function _updateScrollTopAfterSelection() {\n      if (!this.isBreadcrumbStyleActive()) {\n        return;\n      }\n\n      var currentLevel = -1;\n\n      if (this.selectedNodes.length > 0) {\n        currentLevel = this.selectedNodes[0].level;\n      } // Remove positions after the current level (no restore when going down, only when going up)\n\n\n      this.scrollTopHistory.splice(currentLevel + 1); // Read the scroll top for the current level and use that one if it is set\n\n      var scrollTopForLevel = this.scrollTopHistory[currentLevel];\n\n      if (scrollTopForLevel >= 0) {\n        this.setScrollTop(scrollTopForLevel);\n      }\n    }\n  }, {\n    key: \"_setSelectedNodes\",\n    value: function _setSelectedNodes(nodes, debounceSend) {\n      // Make a copy so that original array stays untouched\n      this.selectedNodes = nodes.slice();\n\n      this._nodesSelectedInternal();\n\n      this._triggerNodesSelected(debounceSend);\n\n      if (this.selectedNodes.length > 0 && !this.visibleNodesMap[this.selectedNodes[0].id]) {\n        this._expandAllParentNodes(this.selectedNodes[0]);\n      }\n\n      this._updateItemPath(true);\n\n      if (this.isBreadcrumbStyleActive()) {\n        // In breadcrumb mode selected node has to be expanded\n        if (this.selectedNodes.length > 0 && !this.selectedNodes[0].expanded) {\n          this.expandNode(this.selectedNodes[0]);\n          this.selectedNodes[0].filterDirty = true;\n        }\n\n        this.filter(true);\n      }\n\n      this.session.onRequestsDone(this._updateMenuBar.bind(this));\n    }\n    /**\n     * This method is overridden by subclasses of Tree. The default impl. does nothing.\n     */\n\n  }, {\n    key: \"_nodesSelectedInternal\",\n    value: function _nodesSelectedInternal(node) {// NOP\n    }\n  }, {\n    key: \"deselectNode\",\n    value: function deselectNode(node) {\n      this.deselectNodes(node);\n    }\n    /**\n     * @param nodes the nodes to deselect\n     * @param options.collectChildren true to add the selected children to the list of nodes to deselect\n     */\n\n  }, {\n    key: \"deselectNodes\",\n    value: function deselectNodes(nodes, options) {\n      nodes = arrays.ensure(nodes);\n      options = options || {};\n\n      if (options.collectChildren) {\n        nodes = nodes.concat(this._collectNodesIfDescendants(nodes, this.selectedNodes));\n      }\n\n      var selectedNodes = this.selectedNodes.slice(); // copy\n\n      if (arrays.removeAll(selectedNodes, nodes)) {\n        this.selectNodes(selectedNodes);\n      }\n    }\n  }, {\n    key: \"isNodeSelected\",\n    value: function isNodeSelected(node) {\n      return this.selectedNodes.indexOf(node) > -1;\n    }\n  }, {\n    key: \"_computeNodePaddingLeft\",\n    value: function _computeNodePaddingLeft(node) {\n      this._computeNodePaddings();\n\n      if (this.isBreadcrumbStyleActive()) {\n        return null;\n      }\n\n      var padding = node.level * this.nodePaddingLevel + this.nodePaddingLeft;\n\n      if (this.checkable) {\n        padding += this.nodeCheckBoxPaddingLeft;\n      }\n\n      return padding;\n    }\n    /**\n     * Reads the paddings from CSS and stores them in nodePaddingLeft and nodeControlPaddingLeft\n     */\n\n  }, {\n    key: \"_computeNodePaddings\",\n    value: function _computeNodePaddings() {\n      if (this.nodePaddingLeft !== null && this.nodeControlPaddingLeft !== null) {\n        return;\n      }\n\n      var $dummyNode = this.$data.appendDiv('tree-node');\n      var $dummyNodeControl = $dummyNode.appendDiv('tree-node-control');\n\n      if (this.nodePaddingLeft === null) {\n        this.nodePaddingLeft = $dummyNode.cssPaddingLeft();\n      }\n\n      if (this.nodeControlPaddingLeft === null) {\n        this.nodeControlPaddingLeft = $dummyNodeControl.cssPaddingLeft();\n      }\n\n      $dummyNode.remove();\n    }\n  }, {\n    key: \"_expandAllParentNodes\",\n    value: function _expandAllParentNodes(node) {\n      var i,\n          currNode = node,\n          parentNodes = [];\n      currNode = node;\n      var nodesToInsert = [];\n\n      while (currNode.parentNode) {\n        parentNodes.push(currNode.parentNode);\n\n        if (!this.visibleNodesMap[currNode.id]) {\n          nodesToInsert.push(currNode);\n        }\n\n        currNode = currNode.parentNode;\n      }\n\n      for (i = parentNodes.length - 1; i >= 0; i--) {\n        if (nodesToInsert.indexOf(parentNodes[i]) !== -1) {\n          this._addToVisibleFlatList(parentNodes[i], false);\n        }\n\n        if (!parentNodes[i].expanded) {\n          this.expandNode(parentNodes[i], {\n            renderExpansion: false,\n            renderAnimated: false\n          });\n        }\n      }\n\n      if (this.rendered && nodesToInsert.length > 0) {\n        this._rerenderViewport();\n\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_updateChildNodeIndex\",\n    value: function _updateChildNodeIndex(nodes, startIndex) {\n      if (!nodes || !nodes.length) {\n        return;\n      }\n\n      for (var i = scout.nvl(startIndex, 0); i < nodes.length; i++) {\n        nodes[i].childNodeIndex = i;\n      }\n    }\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(node, parentNode) {\n      this.insertNodes([node], parentNode);\n    }\n  }, {\n    key: \"insertNodes\",\n    value: function insertNodes(nodes, parentNode) {\n      nodes = arrays.ensure(nodes).slice();\n\n      this._ensureTreeNodes(nodes);\n\n      if (parentNode && !(parentNode instanceof TreeNode)) {\n        throw new Error('parent has to be a tree node: ' + parentNode);\n      } // Append continuous node blocks\n\n\n      nodes.sort(function (a, b) {\n        return a.childNodeIndex - b.childNodeIndex;\n      }); // Update parent with new child nodes\n\n      if (parentNode) {\n        if (parentNode.childNodes && parentNode.childNodes.length > 0) {\n          nodes.forEach(function (entry) {\n            // only insert node if not already existing\n            if (parentNode.childNodes.indexOf(entry) < 0) {\n              arrays.insert(parentNode.childNodes, entry, entry.childNodeIndex);\n            }\n          });\n\n          this._updateChildNodeIndex(parentNode.childNodes, nodes[0].childNodeIndex);\n        } else {\n          nodes.forEach(function (entry) {\n            parentNode.childNodes.push(entry);\n          });\n        } // initialize node and add to visible list if node is visible\n\n\n        Tree.visitNodes(this._initTreeNode.bind(this), nodes, parentNode);\n        Tree.visitNodes(this._updateFlatListAndSelectionPath.bind(this), nodes, parentNode);\n\n        if (this.groupedNodes[parentNode.id]) {\n          this._updateItemPath(false, parentNode);\n        }\n\n        if (this.rendered) {\n          var opts = {\n            expansionChanged: true\n          };\n\n          this._renderExpansion(parentNode, opts);\n\n          this.ensureExpansionVisible(parentNode);\n        }\n      } else {\n        if (this.nodes && this.nodes.length > 0) {\n          nodes.forEach(function (entry) {\n            // only insert node if not already existing\n            if (this.nodes.indexOf(entry) < 0) {\n              arrays.insert(this.nodes, entry, entry.childNodeIndex);\n            }\n          }.bind(this));\n\n          this._updateChildNodeIndex(this.nodes, nodes[0].childNodeIndex);\n        } else {\n          arrays.pushAll(this.nodes, nodes);\n        } // initialize node and add to visible list if node is visible\n\n\n        Tree.visitNodes(this._initTreeNode.bind(this), nodes, parentNode);\n        Tree.visitNodes(this._updateFlatListAndSelectionPath.bind(this), nodes, parentNode);\n      }\n\n      if (this.rendered) {\n        this.viewRangeDirty = true;\n        this.invalidateLayoutTree();\n      }\n\n      this.trigger('nodesInserted', {\n        nodes: nodes,\n        parentNode: parentNode\n      });\n    }\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(node) {\n      this.updateNodes([node]);\n    }\n  }, {\n    key: \"updateNodes\",\n    value: function updateNodes(nodes) {\n      nodes = arrays.ensure(nodes);\n      nodes.forEach(function (updatedNode) {\n        var propertiesChanged,\n            oldNode = this.nodesMap[updatedNode.id]; // if same instance has been updated we must set the flag always to true\n        // because we cannot compare against an \"old\" node\n\n        if (updatedNode === oldNode) {\n          propertiesChanged = true;\n        } else {\n          this._applyNodeDefaultValues(updatedNode);\n\n          propertiesChanged = this._applyUpdatedNodeProperties(oldNode, updatedNode);\n        }\n\n        if (propertiesChanged) {\n          if (this._applyFiltersForNode(oldNode)) {\n            if (!oldNode.isFilterAccepted()) {\n              this._nodesFiltered([oldNode]);\n\n              this._removeFromFlatList(oldNode, false);\n            } else {\n              this._addToVisibleFlatList(oldNode, false);\n            }\n          }\n\n          this._updateItemPath(false, oldNode.parentNode);\n\n          if (this.rendered) {\n            oldNode._decorate();\n          }\n        }\n      }, this);\n      this.trigger('nodesUpdated', {\n        nodes: nodes\n      });\n    }\n    /**\n     * Called by _onNodesUpdated for every updated node. The function is expected to apply\n     * all updated properties from the updatedNode to the oldNode. May be overridden by\n     * subclasses so update their specific node properties.\n     *\n     * @param oldNode\n     *          The target node to be updated\n     * @param updatedNode\n     *          The new node with potentially updated properties. Default values are already applied!\n     * @returns\n     *          true if at least one property has changed, false otherwise. This value is used to\n     *          determine if the node has to be rendered again.\n     */\n\n  }, {\n    key: \"_applyUpdatedNodeProperties\",\n    value: function _applyUpdatedNodeProperties(oldNode, updatedNode) {\n      // Note: We only update _some_ of the properties, because everything else will be handled\n      // with separate events. --> See also: JsonTree.java/handleModelNodesUpdated()\n      var propertiesChanged = false;\n\n      if (oldNode.leaf !== updatedNode.leaf) {\n        oldNode.leaf = updatedNode.leaf;\n        propertiesChanged = true;\n      }\n\n      if (oldNode.enabled !== updatedNode.enabled) {\n        oldNode.enabled = updatedNode.enabled;\n        propertiesChanged = true;\n      }\n\n      if (oldNode.lazyExpandingEnabled !== updatedNode.lazyExpandingEnabled) {\n        oldNode.lazyExpandingEnabled = updatedNode.lazyExpandingEnabled; // Also make sure expandedLazy is reset to false when lazyExpanding is disabled (same code as in AbstractTreeNode.setLazyExpandingEnabled)\n\n        if (!updatedNode.lazyExpandingEnabled || !this.lazyExpandingEnabled) {\n          oldNode.expandedLazy = false;\n        }\n\n        propertiesChanged = true;\n      }\n\n      return propertiesChanged;\n    }\n  }, {\n    key: \"deleteNode\",\n    value: function deleteNode(node, parentNode) {\n      this.deleteNodes([node], parentNode);\n    }\n  }, {\n    key: \"deleteAllNodes\",\n    value: function deleteAllNodes() {\n      this.deleteAllChildNodes();\n    }\n  }, {\n    key: \"deleteNodes\",\n    value: function deleteNodes(nodes, parentNode) {\n      var deletedNodes = [];\n      var parentNodesToReindex = [];\n      var topLevelNodesToReindex = [];\n      nodes = arrays.ensure(nodes).slice(); // copy\n\n      nodes.forEach(function (node) {\n        var p = parentNode || node.parentNode;\n\n        if (p) {\n          if (node.parentNode !== p) {\n            throw new Error('Unexpected parent. Node.parent: ' + node.parentNode + ', parentNode: ' + parentNode);\n          }\n\n          arrays.remove(p.childNodes, node);\n\n          if (parentNodesToReindex.indexOf(p) === -1) {\n            parentNodesToReindex.push(p);\n          }\n        } else {\n          arrays.remove(this.nodes, node);\n          topLevelNodesToReindex = this.nodes;\n        }\n\n        this._destroyTreeNode(node);\n\n        deletedNodes.push(node);\n\n        this._updateMarkChildrenChecked(node, false, false); // remove children from node map\n\n\n        Tree.visitNodes(this._destroyTreeNode.bind(this), node.childNodes);\n      }, this); // update child node indices\n\n      parentNodesToReindex.forEach(function (p) {\n        this._updateChildNodeIndex(p.childNodes);\n      }, this);\n\n      this._updateChildNodeIndex(topLevelNodesToReindex);\n\n      this.deselectNodes(deletedNodes, {\n        collectChildren: true\n      });\n      this.uncheckNodes(deletedNodes, {\n        collectChildren: true\n      }); // remove node from html document\n\n      if (this.rendered) {\n        this._removeNodes(deletedNodes, parentNode || parentNodesToReindex);\n      }\n\n      this.trigger('nodesDeleted', {\n        nodes: nodes,\n        parentNode: parentNode\n      });\n    }\n  }, {\n    key: \"_collectNodesIfDescendants\",\n    value: function _collectNodesIfDescendants(nodes, nodesToCheck) {\n      var result = [];\n      nodesToCheck.forEach(function (nodeToCheck) {\n        if (nodes.some(function (node) {\n          return node.isAncestorOf(nodeToCheck);\n        })) {\n          result.push(nodeToCheck);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"deleteAllChildNodes\",\n    value: function deleteAllChildNodes(parentNode) {\n      var nodes;\n\n      if (parentNode) {\n        nodes = parentNode.childNodes;\n        parentNode.childNodes = [];\n      } else {\n        nodes = this.nodes;\n        this.nodes = [];\n      }\n\n      Tree.visitNodes(updateNodeMap.bind(this), nodes);\n      this.deselectNodes(nodes, {\n        collectChildren: true\n      });\n      this.uncheckNodes(nodes, {\n        collectChildren: true\n      }); // remove node from html document\n\n      if (this.rendered) {\n        this._removeNodes(nodes, parentNode);\n      }\n\n      this.trigger('allChildNodesDeleted', {\n        parentNode: parentNode\n      }); // --- Helper functions ---\n      // Update model and nodemap\n\n      function updateNodeMap(node) {\n        this._destroyTreeNode(node);\n\n        this._updateMarkChildrenChecked(node, false, false);\n      }\n    }\n  }, {\n    key: \"updateNodeOrder\",\n    value: function updateNodeOrder(childNodes, parentNode) {\n      childNodes = arrays.ensure(childNodes);\n\n      this._updateChildNodeIndex(childNodes);\n\n      if (parentNode) {\n        if (parentNode.childNodes.length !== childNodes.length) {\n          throw new Error('Node order may not be updated because lengths of the arrays differ.');\n        } // Make a copy so that original array stays untouched\n\n\n        parentNode.childNodes = childNodes.slice();\n\n        this._removeChildrenFromFlatList(parentNode, false);\n\n        if (parentNode.expanded) {\n          this._addChildrenToFlatList(parentNode, null, false);\n        }\n      } else {\n        if (this.nodes.length !== childNodes.length) {\n          throw new Error('Node order may not be updated because lengths of the arrays differ.');\n        } // Make a copy so that original array stays untouched\n\n\n        this.nodes = childNodes.slice();\n        this.nodes.forEach(function (node) {\n          this._removeFromFlatList(node, false);\n\n          this._addToVisibleFlatList(node, false);\n\n          if (node.expanded) {\n            this._addChildrenToFlatList(node, null, false);\n          }\n        }, this);\n      }\n\n      this.trigger('childNodeOrderChanged', {\n        parentNode: parentNode\n      });\n    }\n  }, {\n    key: \"checkNode\",\n    value: function checkNode(node, checked, options) {\n      var opts = $.extend(options, {\n        checked: checked\n      });\n      this.checkNodes([node], opts);\n    }\n  }, {\n    key: \"checkNodes\",\n    value: function checkNodes(nodes, options) {\n      var opts = {\n        checked: true,\n        checkOnlyEnabled: true,\n        checkChildren: this.autoCheckChildren,\n        triggerNodesChecked: true\n      };\n      $.extend(opts, options);\n      var updatedNodes = []; // use enabled computed because when the parent of the table is disabled, it should not be allowed to check rows\n\n      if (!this.checkable || !this.enabledComputed && opts.checkOnlyEnabled) {\n        return;\n      }\n\n      nodes = arrays.ensure(nodes);\n      nodes.forEach(function (node) {\n        if (!node.enabled && opts.checkOnlyEnabled || node.checked === opts.checked) {\n          if (opts.checkChildren) {\n            this.checkNodes(node.childNodes, opts);\n          }\n\n          return;\n        }\n\n        if (!this.multiCheck && opts.checked) {\n          for (var i = 0; i < this.checkedNodes.length; i++) {\n            this.checkedNodes[i].checked = false;\n\n            this._updateMarkChildrenChecked(this.checkedNodes[i], false, false, true);\n\n            updatedNodes.push(this.checkedNodes[i]);\n          }\n\n          this.checkedNodes = [];\n        }\n\n        node.checked = opts.checked;\n\n        if (node.checked) {\n          this.checkedNodes.push(node);\n        } else {\n          arrays.remove(this.checkedNodes, node);\n        }\n\n        updatedNodes.push(node);\n\n        this._updateMarkChildrenChecked(node, false, opts.checked, true);\n\n        if (opts.checkChildren) {\n          var childOpts = $.extend({}, opts, {\n            triggerNodesChecked: false\n          });\n          this.checkNodes(node.childNodes, childOpts);\n        }\n      }, this);\n\n      if (opts.triggerNodesChecked && updatedNodes.length > 0) {\n        this.trigger('nodesChecked', {\n          nodes: updatedNodes\n        });\n      }\n\n      if (this.rendered) {\n        updatedNodes.forEach(function (node) {\n          node._renderChecked();\n        });\n      }\n    }\n  }, {\n    key: \"uncheckNode\",\n    value: function uncheckNode(node, options) {\n      var opts = $.extend({\n        checkOnlyEnabled: true\n      }, options);\n      this.uncheckNodes([node], opts);\n    }\n    /**\n     * @param nodes the nodes to uncheck\n     * @param options.collectChildren true to add the checked children to the list of nodes to uncheck\n     */\n\n  }, {\n    key: \"uncheckNodes\",\n    value: function uncheckNodes(nodes, options) {\n      var opts = {\n        checked: false\n      };\n      $.extend(opts, options);\n\n      if (opts.collectChildren) {\n        nodes = nodes.concat(this._collectNodesIfDescendants(nodes, this.checkedNodes));\n      }\n\n      this.checkNodes(nodes, opts);\n    }\n  }, {\n    key: \"_triggerNodesSelected\",\n    value: function _triggerNodesSelected(debounce) {\n      this.trigger('nodesSelected', {\n        debounce: debounce\n      });\n    }\n  }, {\n    key: \"_showContextMenu\",\n    value: function _showContextMenu(event) {\n      var func = function func(event) {\n        if (!this.rendered) {\n          // check needed because function is called asynchronously\n          return;\n        }\n\n        var filteredMenus = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true),\n            $part = $(event.currentTarget);\n\n        if (filteredMenus.length === 0) {\n          return; // at least one menu item must be visible\n        } // Prevent firing of 'onClose'-handler during contextMenu.open()\n        // (Can lead to null-access when adding a new handler to this.contextMenu)\n\n\n        if (this.contextMenu) {\n          this.contextMenu.close();\n        }\n\n        this.contextMenu = scout.create('ContextMenuPopup', {\n          parent: this,\n          menuItems: filteredMenus,\n          location: {\n            x: event.pageX,\n            y: event.pageY\n          },\n          $anchor: $part,\n          menuFilter: this._filterMenusHandler\n        });\n        this.contextMenu.open();\n      };\n\n      this.session.onRequestsDone(func.bind(this), event);\n    }\n  }, {\n    key: \"_onNodeMouseDown\",\n    value: function _onNodeMouseDown(event) {\n      this._doubleClickSupport.mousedown(event);\n\n      if (this._doubleClickSupport.doubleClicked()) {\n        // don't execute on double click events\n        return false;\n      }\n\n      var $node = $(event.currentTarget);\n      var node = $node.data('node');\n\n      if (!this.hasNode(node)) {\n        // if node does not belong to this tree, do nothing (may happen if another tree is embedded inside the node)\n        return;\n      }\n\n      this._$mouseDownNode = $node;\n      $node.window().one('mouseup', function () {\n        this._$mouseDownNode = null;\n      }.bind(this));\n      this.selectNodes(node);\n\n      if (this.checkable && node.enabled && this._isCheckboxClicked(event)) {\n        if (Device.get().loosesFocusIfPseudoElementIsRemoved()) {\n          this.focusAndPreventDefault(event);\n        }\n\n        this.checkNode(node, !node.checked);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_onNodeMouseUp\",\n    value: function _onNodeMouseUp(event) {\n      if (this._doubleClickSupport.doubleClicked()) {\n        // don't execute on double click events\n        return false;\n      }\n\n      var $node = $(event.currentTarget);\n      var node = $node.data('node');\n\n      if (!this._$mouseDownNode || this._$mouseDownNode[0] !== $node[0]) {\n        // Don't accept if mouse up happens on another node than mouse down, or mousedown didn't happen on a node at all\n        return;\n      }\n\n      this.trigger('nodeClick', {\n        node: node\n      });\n      return true;\n    }\n  }, {\n    key: \"_isCheckboxClicked\",\n    value: function _isCheckboxClicked(event) {\n      // with CheckableStyle.CHECKBOX_TREE_NODE a click anywhere on the node should trigger the check\n      if (this.isTreeNodeCheckEnabled()) {\n        return true;\n      }\n\n      return $(event.target).is('.check-box');\n    }\n  }, {\n    key: \"_updateItemPath\",\n    value: function _updateItemPath(selectionChanged, ultimate) {\n      var selectedNodes, node, level;\n\n      if (selectionChanged) {\n        // first remove and select selected\n        this.groupedNodes = {};\n        this._inSelectionPathList = {};\n      }\n\n      if (!ultimate) {\n        // find direct children\n        selectedNodes = this.selectedNodes;\n\n        if (selectedNodes.length === 0) {\n          return;\n        }\n\n        node = selectedNodes[0];\n\n        if (selectionChanged) {\n          this._inSelectionPathList[node.id] = true;\n\n          if (node.childNodes) {\n            node.childNodes.forEach(function (child) {\n              this._inSelectionPathList[child.id] = true;\n            }.bind(this));\n          }\n        }\n\n        level = node.level; // find grouping end (ultimate parent)\n\n        while (node.parentNode) {\n          var parent = node.parentNode;\n\n          if (this._isGroupingEnd(parent) && !ultimate) {\n            ultimate = node;\n\n            if (!selectionChanged) {\n              break;\n            }\n          }\n\n          if (selectionChanged) {\n            this._inSelectionPathList[parent.id] = true;\n          }\n\n          node = parent;\n        } // find group with same ultimate parent\n\n\n        ultimate = ultimate || selectedNodes[0];\n        this.groupedNodes[ultimate.id] = true;\n      }\n\n      node = ultimate;\n\n      if (node && node.expanded && this.groupedNodes[node.id]) {\n        addToGroup.call(this, node.childNodes);\n      } // ------ helper function ------//\n\n\n      function addToGroup(nodes) {\n        nodes.forEach(function (node) {\n          this.groupedNodes[node.id] = true;\n\n          node._decorate();\n\n          if (node.expanded && node.isFilterAccepted()) {\n            addToGroup.call(this, node.childNodes);\n          }\n        }.bind(this));\n      }\n    }\n  }, {\n    key: \"_isGroupingEnd\",\n    value: function _isGroupingEnd(node) {\n      // May be implemented by subclasses, default tree has no grouping parent\n      return false;\n    }\n    /**\n     * @returns {TreeNode} the first selected node or null when no node is selected.\n     */\n\n  }, {\n    key: \"selectedNode\",\n    value: function selectedNode() {\n      if (this.selectedNodes.length === 0) {\n        return null;\n      }\n\n      return this.selectedNodes[0];\n    }\n  }, {\n    key: \"$selectedNodes\",\n    value: function $selectedNodes() {\n      return this.$data.find('.selected');\n    }\n  }, {\n    key: \"$nodes\",\n    value: function $nodes() {\n      return this.$data.find('.tree-node');\n    }\n    /**\n     * @param filter object with createKey() and accept()\n     */\n\n  }, {\n    key: \"addFilter\",\n    value: function addFilter(filter, doNotFilter, notAnimated) {\n      if (this._filters.indexOf(filter) < 0) {\n        this._filters.push(filter);\n\n        if (!doNotFilter) {\n          this.filter(notAnimated);\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"removeFilter\",\n    value: function removeFilter(filter, notAnimated) {\n      if (arrays.remove(this._filters, filter)) {\n        this.filter(notAnimated);\n      }\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(notAnimated) {\n      var useAnimation = Boolean(!notAnimated),\n          newHiddenNodes = []; // Filter nodes\n\n      this.visitNodes(function (node) {\n        var changed = this._applyFiltersForNode(node);\n\n        if (changed) {\n          if (!node.isFilterAccepted()) {\n            arrays.pushAll(newHiddenNodes, this._removeFromFlatList(node, useAnimation));\n          } else {\n            this._addToVisibleFlatList(node, useAnimation);\n          }\n\n          this.viewRangeDirty = true;\n        } else {\n          // this else branch is required when the filter-state of a node has not changed\n          // for instance Node \"Telefon mit Sabrina\" is visible for filter \"tel\" and also\n          // for filter \"abr\". However, it is possible that the node is _not_ attached, when\n          // we switch from one filter to another, because the node was not in the view-range\n          // with the previous filter. That's why we must make sure, the node is attached to\n          // the DOM, even though the filter state hasn't changed. Otherwise we'd have a\n          // problem when we insert nodes in this._insertNodeInDOMAtPlace.\n          if (!node.attached) {\n            this.showNode(node, useAnimation);\n\n            if (node.attached) {\n              // If sibling nodes are hiding at the same time, the nodes to be shown should be added after these nodes to make the animation look correctly -> move them\n              node.$node.insertAfter(node.$node.nextAll('.hiding:last'));\n            }\n          }\n        }\n\n        if ((node.expanded || node.expandedLazy) && node.isFilterAccepted()) {\n          return false;\n        } // don't process children->optimize performance\n\n\n        return true;\n      }.bind(this));\n\n      this._nodesFiltered(newHiddenNodes);\n    }\n    /**\n     * use filtered nodes are removed from visible nodes\n     */\n\n  }, {\n    key: \"filterVisibleNodes\",\n    value: function filterVisibleNodes(animated) {\n      // Filter nodes\n      var newHiddenNodes = [];\n\n      for (var i = 0; i < this.visibleNodesFlat.length; i++) {\n        var node = this.visibleNodesFlat[i];\n\n        var changed = this._applyFiltersForNode(node);\n\n        if (changed) {\n          if (!node.isFilterAccepted()) {\n            i--;\n            arrays.pushAll(newHiddenNodes, this._removeFromFlatList(node, animated));\n          }\n\n          this.viewRangeDirty = true;\n        }\n      }\n\n      this._nodesFiltered(newHiddenNodes);\n    }\n  }, {\n    key: \"_nodesFiltered\",\n    value: function _nodesFiltered(hiddenNodes) {\n      // non visible nodes must be deselected\n      this.deselectNodes(hiddenNodes);\n    }\n  }, {\n    key: \"_nodeAcceptedByFilters\",\n    value: function _nodeAcceptedByFilters(node) {\n      for (var i = 0; i < this._filters.length; i++) {\n        var filter = this._filters[i];\n\n        if (!filter.accept(node)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * @returns {Boolean} true if node state has changed, false if not\n     */\n\n  }, {\n    key: \"_applyFiltersForNode\",\n    value: function _applyFiltersForNode(node) {\n      var changed = node.filterDirty;\n\n      if (this._nodeAcceptedByFilters(node)) {\n        if (!node.filterAccepted) {\n          node.filterAccepted = true;\n          changed = true;\n        }\n      } else if (node.filterAccepted) {\n        node.filterAccepted = false;\n        changed = true;\n      }\n\n      if (changed) {\n        node.filterDirty = false;\n        node.childNodes.forEach(function (childNode) {\n          childNode.filterDirty = true;\n        });\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Just insert node in DOM. NO check if in viewRange\n     */\n\n  }, {\n    key: \"_insertNodesInDOM\",\n    value: function _insertNodesInDOM(nodes, indexHint) {\n      if (!this.rendered && !this.rendering) {\n        return;\n      }\n\n      nodes = nodes.filter(function (node) {\n        var index = indexHint === undefined ? this.visibleNodesFlat.indexOf(node) : indexHint;\n\n        if (index === -1 || !(this.viewRangeRendered.from + this.viewRangeSize >= index && this.viewRangeRendered.from <= index && this.viewRangeRendered.size() > 0) || node.attached) {\n          // node is not visible\n          return false;\n        }\n\n        if (!node.rendered) {\n          this._renderNode(node);\n        }\n\n        node._decorate();\n\n        this._insertNodeInDOMAtPlace(node, index);\n\n        if (this.prevSelectedNode === node) {\n          this._highlightPrevSelectedNode();\n        }\n\n        node.rendered = true;\n        node.attached = true;\n        return true;\n      }, this);\n\n      this._installNodes(nodes);\n    }\n  }, {\n    key: \"_installNodes\",\n    value: function _installNodes(nodes) {\n      // The measuring is separated into 3 blocks for performance reasons -> separates reading and setting of styles\n      // 1. Prepare style for measuring\n      if (this.isHorizontalScrollingEnabled()) {\n        nodes.forEach(function (node) {\n          node.$node.css('width', 'auto');\n          node.$node.css('display', 'inline-block');\n        }, this);\n      } // 2. Measure\n\n\n      nodes.forEach(function (node) {\n        node.height = node.$node.outerHeight(true);\n\n        if (!this.isHorizontalScrollingEnabled()) {\n          return;\n        }\n\n        var newWidth = node.$node.outerWidth();\n        var oldWidth = node.width ? node.width : 0;\n\n        if (oldWidth === this.maxNodeWidth && newWidth < this.maxNodeWidth) {\n          this.maxNodeWidth = 0;\n          this.nodeWidthDirty = true;\n        } else if (newWidth > this.maxNodeWidth) {\n          this.maxNodeWidth = newWidth;\n          this.nodeWidthDirty = true;\n        }\n\n        node.width = newWidth;\n      }, this); // 3. Reset style\n\n      if (this.isHorizontalScrollingEnabled()) {\n        nodes.forEach(function (node) {\n          if (!this.nodeWidthDirty) {\n            node.$node.css('width', this.maxNodeWidth);\n          }\n\n          node.$node.css('display', '');\n        }, this);\n      }\n    }\n    /**\n     * Attaches node to DOM, if it is visible and in view range\n     * */\n\n  }, {\n    key: \"_ensureNodeInDOM\",\n    value: function _ensureNodeInDOM(node, useAnimation, indexHint) {\n      if (node && !node.attached && node === this.visibleNodesFlat[indexHint] && indexHint >= this.viewRangeRendered.from && indexHint < this.viewRangeRendered.to) {\n        this.showNode(node, useAnimation, indexHint);\n      }\n    }\n  }, {\n    key: \"_insertNodeInDOMAtPlace\",\n    value: function _insertNodeInDOMAtPlace(node, index) {\n      var $node = node.$node;\n\n      if (index === 0) {\n        if (this.$fillBefore) {\n          $node.insertAfter(this.$fillBefore);\n        } else {\n          this.$data.prepend($node);\n        }\n\n        return;\n      } // append after index\n\n\n      var nodeBefore = this.visibleNodesFlat[index - 1];\n\n      this._ensureNodeInDOM(nodeBefore, false, index - 1);\n\n      if (nodeBefore.attached) {\n        $node.insertAfter(nodeBefore.$node);\n        return;\n      }\n\n      if (index + 1 < this.visibleNodesFlat.length) {\n        var nodeAfter = this.visibleNodesFlat[index + 1];\n\n        if (nodeAfter.attached) {\n          $node.insertBefore(nodeAfter.$node);\n          return;\n        }\n      } // used when the tree is scrolled\n\n\n      if (this.$fillBefore) {\n        $node.insertAfter(this.$fillBefore);\n      } else {\n        this.$data.prepend($node);\n      }\n    }\n  }, {\n    key: \"showNode\",\n    value: function showNode(node, useAnimation, indexHint) {\n      if (!this.rendered || node.attached && !node.$node.hasClass('hiding')) {\n        return;\n      }\n\n      if (!node.attached) {\n        this._ensureNodeInDOM(node.parentNode, useAnimation, indexHint - 1);\n\n        this._insertNodesInDOM([node], indexHint);\n      }\n\n      if (!node.rendered) {\n        return;\n      }\n\n      var $node = node.$node;\n\n      if ($node.is('.showing')) {\n        return;\n      }\n\n      $node.addClass('showing');\n      $node.removeClass('hiding');\n      var that = this;\n\n      if (useAnimation) {\n        // hide node first and then make it appear using slideDown (setVisible(false) won't work because it would stay invisible during the animation)\n        $node.hide();\n        $node.stop(false, true).slideDown({\n          duration: 250,\n          start: that.startAnimationFunc,\n          complete: function complete() {\n            that.runningAnimationsFinishFunc();\n            $node.removeClass('showing');\n          }\n        });\n      }\n    }\n  }, {\n    key: \"hideNode\",\n    value: function hideNode(node, useAnimation, suppressDetachHandling) {\n      if (!node.attached) {\n        return;\n      }\n\n      this.viewRangeDirty = true;\n      var that = this,\n          $node = node.$node;\n\n      if (!$node) {\n        // node is not rendered\n        return;\n      }\n\n      if ($node.is('.hiding')) {\n        return;\n      }\n\n      $node.addClass('hiding');\n      $node.removeClass('showing');\n\n      if (useAnimation) {\n        this._renderViewportBlocked = true;\n        $node.stop(false, true).slideUp({\n          duration: 250,\n          start: that.startAnimationFunc,\n          complete: function complete() {\n            that.runningAnimationsFinishFunc();\n            $node.removeClass('hiding');\n\n            if (!$node.hasClass('showing')) {\n              $node.detach();\n              node.attached = false;\n            }\n          }\n        });\n      } else if (!suppressDetachHandling) {\n        $node.detach();\n        node.attached = false;\n        that.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_nodesToIds\",\n    value: function _nodesToIds(nodes) {\n      return nodes.map(function (node) {\n        return node.id;\n      });\n    }\n  }, {\n    key: \"_nodesByIds\",\n    value: function _nodesByIds(ids) {\n      return ids.map(function (id) {\n        return this.nodesMap[id];\n      }.bind(this));\n    }\n  }, {\n    key: \"_nodeById\",\n    value: function _nodeById(id) {\n      return this.nodesMap[id];\n    }\n    /**\n     * Checks whether the given node is contained in the tree. Uses the id of the node for the lookup.\n     */\n\n  }, {\n    key: \"hasNode\",\n    value: function hasNode(node) {\n      return Boolean(this._nodeById(node.id));\n    }\n  }, {\n    key: \"_onNodeDoubleClick\",\n    value: function _onNodeDoubleClick(event) {\n      if (this.isBreadcrumbStyleActive()) {\n        return;\n      }\n\n      var $node = $(event.currentTarget);\n      var node = $node.data('node');\n      var expanded = !$node.hasClass('expanded');\n      this.doNodeAction(node, expanded);\n    }\n  }, {\n    key: \"doNodeAction\",\n    value: function doNodeAction(node, expanded) {\n      this.trigger('nodeAction', {\n        node: node\n      }); // For CheckableStyle.CHECKBOX_TREE_NODE expand on double click is only enabled for disabled nodes. Otherwise it would conflict with the \"check on node click\" behavior.\n\n      if (!(this.checkable === true && this.isTreeNodeCheckEnabled() && node.enabled)) {\n        this.setNodeExpanded(node, expanded, {\n          lazy: false // always show all nodes on node double click\n\n        });\n      }\n    }\n  }, {\n    key: \"_onNodeControlMouseDown\",\n    value: function _onNodeControlMouseDown(event) {\n      this._doubleClickSupport.mousedown(event);\n\n      if (this._doubleClickSupport.doubleClicked()) {\n        // don't execute on double click events\n        return false;\n      }\n\n      var $node = $(event.currentTarget).parent();\n      var node = $node.data('node');\n      var expanded = !$node.hasClass('expanded');\n      var expansionOpts = {\n        lazy: false // always show all nodes when the control gets clicked\n\n      }; // Click on \"show all\" control shows all nodes\n\n      if ($node.hasClass('lazy')) {\n        if (event.ctrlKey || event.shiftKey) {\n          // Collapse\n          expanded = false;\n          expansionOpts.collapseChildNodes = true;\n        } else {\n          // Show all nodes\n          this.expandNode(node, expansionOpts);\n          return false;\n        }\n      } // Because we suppress handling by browser we have to set focus manually\n\n\n      if (this.requestFocusOnNodeControlMouseDown) {\n        this.focus();\n      }\n\n      this.selectNodes(node); // <---- ### 1\n\n      this.setNodeExpanded(node, expanded, expansionOpts); // <---- ### 2\n      // prevent bubbling to _onNodeMouseDown()\n\n      $.suppressEvent(event); // ...but return true, so Outline.js can override this method and check if selection has been changed or not\n\n      return true;\n    }\n  }, {\n    key: \"_onNodeControlMouseUp\",\n    value: function _onNodeControlMouseUp(event) {\n      // prevent bubbling to _onNodeMouseUp()\n      return false;\n    }\n  }, {\n    key: \"_onNodeControlDoubleClick\",\n    value: function _onNodeControlDoubleClick(event) {\n      // prevent bubbling to _onNodeDoubleClick()\n      return false;\n    }\n  }, {\n    key: \"_onContextMenu\",\n    value: function _onContextMenu(event) {\n      event.preventDefault();\n\n      this._showContextMenu(event);\n    }\n  }, {\n    key: \"changeNode\",\n    value: function changeNode(node) {\n      if (this._applyFiltersForNode(node)) {\n        if (node.isFilterAccepted()) {\n          this._addToVisibleFlatList(node, false);\n        } else {\n          this._removeFromFlatList(node, false);\n        }\n      }\n\n      if (this.rendered) {\n        node._decorate();\n      }\n\n      this.trigger('nodeChanged', {\n        node: node\n      });\n    } // same as on Table.prototype._onDesktopPopupOpen\n\n  }, {\n    key: \"_onDesktopPopupOpen\",\n    value: function _onDesktopPopupOpen(event) {\n      var popup = event.popup;\n\n      if (!this.enabledComputed) {\n        return;\n      } // Set tree style to focused if a context menu or a menu bar popup opens, so that it looks as it still has the focus\n\n\n      if (this.has(popup) && popup instanceof ContextMenuPopup) {\n        this.$container.addClass('focused');\n        popup.one('destroy', function () {\n          if (this.rendered) {\n            this.$container.removeClass('focused');\n          }\n        }.bind(this));\n      }\n    }\n  }, {\n    key: \"updateScrollbars\",\n    value: function updateScrollbars() {\n      scrollbars.update(this.$data);\n    }\n    /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n    /**\n     * @memberOf Tree\n     */\n\n  }], [{\n    key: \"collectSubtree\",\n    value: function collectSubtree($rootNode, includeRootNodeInResult) {\n      if (!$rootNode) {\n        return $();\n      }\n\n      var rootLevel = parseFloat($rootNode.attr('data-level')); // Find first node after the root element that has the same or a lower level\n\n      var $nextNode = $rootNode.next();\n\n      while ($nextNode.length > 0) {\n        var level = parseFloat($nextNode.attr('data-level'));\n\n        if (isNaN(level) || level <= rootLevel) {\n          break;\n        }\n\n        $nextNode = $nextNode.next();\n      } // The result set consists of all nodes between the root node and the found node\n\n\n      var $result = $rootNode.nextUntil($nextNode);\n\n      if (includeRootNodeInResult === undefined || includeRootNodeInResult) {\n        $result = $result.add($rootNode);\n      }\n\n      return $result;\n    }\n    /**\n     * pre-order (top-down) traversal of the tree-nodes provided.<br>\n     * if func returns true the children of the visited node are not visited.\n     */\n\n  }, {\n    key: \"visitNodes\",\n    value: function visitNodes(func, nodes, parentNode) {\n      var i, node;\n\n      if (!nodes) {\n        return;\n      }\n\n      for (i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        var doNotProcessChildren = func(node, parentNode);\n\n        if (!doNotProcessChildren && node.childNodes.length > 0) {\n          Tree.visitNodes(func, node.childNodes, node);\n        }\n      }\n    }\n  }]);\n\n  return Tree;\n}(Widget);\n\n_defineProperty(Tree, \"DisplayStyle\", {\n  DEFAULT: 'default',\n  BREADCRUMB: 'breadcrumb'\n});\n\n_defineProperty(Tree, \"CheckableStyle\", {\n  /**\n   * Node check is only possible by checking the checkbox.\n   */\n  CHECKBOX: 'checkbox',\n\n  /**\n   * Node check is possible by clicking anywhere on the node.\n   */\n  CHECKBOX_TREE_NODE: 'checkbox_tree_node'\n});\n\n_defineProperty(Tree, \"VIEW_RANGE_DIVISOR\", 4);\n\nexport { Tree as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/tree/Tree.js"],"names":["arrays","ContextMenuPopup","defaultValues","Device","DoubleClickSupport","dragAndDrop","HtmlComponent","keys","KeyStrokeContext","keyStrokeModifier","LazyNodeFilter","MenuBar","MenuDestinations","MenuItemsOrder","menus","menus_1","objects","Range","scout","scrollbars","tooltips","TreeBreadcrumbFilter","TreeCollapseAllKeyStroke","TreeCollapseOrDrillUpKeyStroke","TreeExpandOrDrillDownKeyStroke","TreeLayout","TreeNavigationDownKeyStroke","TreeNavigationEndKeyStroke","TreeNavigationUpKeyStroke","TreeNode","TreeSpaceKeyStroke","Widget","$","Tree","toggleBreadcrumbStyleEnabled","breadcrumbTogglingThreshold","autoCheckChildren","checkable","checkableStyle","CheckableStyle","CHECKBOX_TREE_NODE","displayStyle","DisplayStyle","DEFAULT","dropType","dropMaximumSize","DEFAULT_DROP_MAXIMUM_SIZE","filterEnabled","lazyExpandingEnabled","contextMenu","menuBar","keyStrokes","multiCheck","nodes","nodesMap","nodePaddingLevelCheckable","nodePaddingLevelNotCheckable","nodePaddingLeft","nodeCheckBoxPaddingLeft","nodeControlPaddingLeft","nodePaddingLevel","scrollToSelection","scrollTop","scrollTopHistory","selectedNodes","prevSelectedNode","checkedNodes","groupedNodes","visibleNodesFlat","visibleNodesMap","_addWidgetProperties","_additionalContainerClasses","_filters","_doubleClickSupport","_$animationWrapper","_$expandAnimationWrappers","_filterMenusHandler","_filterMenus","bind","_popupOpenHandler","_onDesktopPopupOpen","_inSelectionPathList","viewRangeRendered","viewRangeSize","startAnimationFunc","runningAnimations","runningAnimationsFinishFunc","_renderViewportBlocked","invalidateLayoutTree","nodeHeight","nodeWidth","maxNodeWidth","nodeWidthDirty","$data","_scrolldirections","requestFocusOnNodeControlMouseDown","model","addFilter","breadcrumbFilter","BREADCRUMB","initialTraversing","_setCheckable","_ensureTreeNodes","visitNodes","_initTreeNode","_updateFlatListAndSelectionPath","_nodesByIds","create","parent","position","Position","BOTTOM","menuOrder","session","menuFilter","_updateItemPath","_setDisplayStyle","_setKeyStrokes","_setMenus","i","node","length","childNodeIndex","nvl","_createTreeNode","nodeModel","_initTreeKeyStrokeContext","modifierBitMask","NONE","keyStrokeContext","registerKeyStroke","registerStopPropagationInterceptor","event","ctrlKey","altKey","isOneOf","which","UP","DOWN","stopPropagation","preventDefault","argMenus","updateKeyStrokes","_setProperty","_updateMenuBar","menuItems","MENU_BAR","setMenuItems","contextMenuItems","CONTEXT_MENU","updateMenuItems","parentNode","reset","indexOf","id","isSelectedNode","level","p","filterDirty","expanded","_applyFiltersForNode","_addToVisibleFlatList","_addChildrenToFlatList","checked","push","_initTreeNodeInternal","_updateMarkChildrenChecked","initialized","applyTo","_applyNodeDefaultValues","_destroyTreeNode","_removeFromFlatList","destroy","_onNodeDeleted","func","$container","$parent","appendDiv","addClass","layout","htmlComp","install","setLayout","on","_onContextMenu","_onNodeMouseDown","_onNodeMouseUp","_onNodeDoubleClick","_onNodeControlMouseDown","_onNodeControlMouseUp","_onNodeControlDoubleClick","isHorizontalScrollingEnabled","toggleClass","_installScrollbars","axis","_installNodeTooltipSupport","render","_updateNodeDimensions","_renderDisplayStyle","_renderViewport","desktop","_renderCheckableStyle","_renderSelection","off","stop","_resetTreeNode","_uninstallDragAndDropHandler","_uninstallNodeTooltipSupport","$fillBefore","$fillAfter","_renderDropType","scrollToSelectionBackup","scrollLeft","setProperty","rendered","_renderScrollTop","rendering","isEveryParentVisible","viewRange","_calculateCurrentViewRange","_renderViewRange","maxScrollTop","scrollHeight","clientHeight","_nodeAtScrollTop","_calculateViewRangeForNode","_removeRenderedNodes","_renderFiller","_updateDomNodeWidth","_updateDomNodeIconWidth","$nodes","find","each","elem","$node","data","hasClass","_removeNode","range","prepend","maxRange","intersect","size","equals","Error","to","from","newRange","union","numNodesRendered","ensureRangeVisible","log","isTraceEnabled","trace","nodesToInsert","r","attached","_insertNodesInDOM","prependDiv","fillBeforeDimensions","_calculateFillerDimension","cssHeight","height","cssWidth","width","Math","max","fillAfterDimensions","outerWidth","dimension","_heightForNode","_widthForNode","fromNode","toNode","numNodesRemoved","subtract","detach","viewRangeDirty","rangesToRender","rangesToRemove","forEach","_removeNodesInRange","_renderNodesInRange","firstNode","lastNode","$nodesBeforFirstNode","prevAll","$nodesAfterLastNode","nextAll","_cleanupNodes","_postRenderViewRange","_visibleNodesInViewRange","_updateIconWidth","slice","reduce","aggr","eq","nodeTop","some","visibleNodesLength","quarterRange","floor","VIEW_RANGE_DIVISOR","diff","nodeIndex","min","viewRangeMultiplier","ceil","outerHeight","emptyNode","_renderNode","appendTo","oldNodeWidth","_removeNodes","childNodes","ensure","removeClass","paddingLeft","_computeNodePaddingLeft","enabledComputed","destination","onlyVisible","enableDisableKeyStroke","filterAccordingToSelection","enabled","setEnabled","setTabbable","children","_renderDisabledStyleInternal","isNodeRendered","Boolean","updateCheckableStateRec","$control","$checkbox","_updateControl","_renderCheckbox","remove","css","filter","isBreadcrumbStyleActive","_updateNodePaddingsLeft","options","opts","expandLazyChanged","expansionChanged","extend","expandedLazy","childNode","select","_highlightPrevSelectedNode","revealSelection","isTreeNodeCheckEnabled","prevSelectionAnimationDone","addClassForAnimation","oneAnimationEnd","_removeNodeSelection","_installDragAndDropHandler","dragAndDropHandler","handler","supportedScoutTypes","SCOUT_TYPES","FILE_TRANSFER","additionalDropProperties","$target","currentTarget","properties","nodeId","uninstall","init","checkChildrenChecked","childrenFound","j","childrenChecked","stateChanged","hasCheckedSiblings","siblingNode","selector","text","_nodeTooltipText","arrowPosition","arrowPositionUnit","nativeTooltip","get","isCustomEllipsisTooltipPossible","tooltipText","_isTruncatedNodeTooltipEnabled","isContentTruncated","$text","selectedNode","expandNode","filterVisibleNodes","removeFilter","index","element","isNullOrUndefined","active","setDisplayStyle","undefined","setNodeExpanded","rebuildSuppressed","collapseNode","_rerenderViewport","lazy","renderAnimated","collapseChildNodes","childOpts","valueCopy","renderExpansion","renderExpansionOpts","filterStateChanged","_rebuildParent","filterAccepted","child","ensureLoadChildren","done","_removeChildrenFromFlatList","trigger","_renderExpansion","ensureExpansionVisible","animatedRemove","parentIndex","elementsToDelete","parentLevel","removedNodes","$wrapper","insertBefore","isDescendantOf","append","displayBackup","hideNode","splice","animate","start","complete","onAnimationComplete","step","revalidateLayoutTree","duration","queue","call","affectedNodes","renderingAnimated","isFilterAccepted","_addToVisibleFlatListNoCheck","insertIndex","_findInsertPositionInFlatList","animatedRendering","insertBatch","forceFilter","isSubAdding","setInsertAt","newInsertBatch","isAlreadyAdded","insertBatchInVisibleNodes","_showNodes","checkAndHandleBatchAnimationWrapper","nextBatchInsertIndex","_addChildrenToFlatListIfExpanded","insertNodes","checkAndHandleBatch","indexOffset","containsNode","insertAt","lastBatchInsertIndex","thatNode","siblings","_findPositionInFlatList","nodePos","prevSiblingNode","prevSiblingPos","checkNode","_isInSameSubTree","$animationWrapper","isEmpty","lastNodeIndex","nodeBefore","showNode","insertAfter","nodeAfter","animationCompleteFunc","replaceWith","contents","showNodes","apply","indexHint","h","insert","_renderViewRangeForNode","scrollTo","layoutValidator","schedulePostValidateFunction","_expandAllParentNodes","$element","$scrollable","get$Scrollable","isExpanded","getChildren","defaultChildHeight","selectNodes","debounceSend","equalsIgnoreOrder","_rememberScrollTopBeforeSelection","_removeSelection","_setSelectedNodes","_updateScrollTopAfterSelection","currentLevel","scrollTopForLevel","setScrollTop","_nodesSelectedInternal","_triggerNodesSelected","onRequestsDone","deselectNodes","collectChildren","concat","_collectNodesIfDescendants","removeAll","_computeNodePaddings","padding","$dummyNode","$dummyNodeControl","cssPaddingLeft","currNode","parentNodes","startIndex","sort","a","b","entry","_updateChildNodeIndex","pushAll","updateNodes","updatedNode","propertiesChanged","oldNode","_applyUpdatedNodeProperties","_nodesFiltered","_decorate","leaf","deleteNodes","deleteAllChildNodes","deletedNodes","parentNodesToReindex","topLevelNodesToReindex","uncheckNodes","nodesToCheck","result","nodeToCheck","isAncestorOf","updateNodeMap","checkNodes","checkOnlyEnabled","checkChildren","triggerNodesChecked","updatedNodes","_renderChecked","debounce","filteredMenus","$part","close","location","x","pageX","y","pageY","$anchor","open","mousedown","doubleClicked","hasNode","_$mouseDownNode","window","one","_isCheckboxClicked","loosesFocusIfPseudoElementIsRemoved","focusAndPreventDefault","target","is","selectionChanged","ultimate","_isGroupingEnd","addToGroup","doNotFilter","notAnimated","useAnimation","newHiddenNodes","changed","animated","hiddenNodes","accept","_nodeAcceptedByFilters","_insertNodeInDOMAtPlace","_installNodes","newWidth","oldWidth","_ensureNodeInDOM","that","hide","slideDown","suppressDetachHandling","slideUp","map","ids","_nodeById","doNodeAction","expansionOpts","shiftKey","focus","suppressEvent","_showContextMenu","popup","has","update","$rootNode","includeRootNodeInResult","rootLevel","parseFloat","attr","$nextNode","next","isNaN","$result","nextUntil","add","doNotProcessChildren","CHECKBOX"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  arrays,\n  ContextMenuPopup,\n  defaultValues,\n  Device,\n  DoubleClickSupport,\n  dragAndDrop,\n  HtmlComponent,\n  keys,\n  KeyStrokeContext,\n  keyStrokeModifier,\n  LazyNodeFilter,\n  MenuBar,\n  MenuDestinations,\n  MenuItemsOrder,\n  menus as menus_1,\n  objects,\n  Range,\n  scout,\n  scrollbars,\n  tooltips,\n  TreeBreadcrumbFilter,\n  TreeCollapseAllKeyStroke,\n  TreeCollapseOrDrillUpKeyStroke,\n  TreeExpandOrDrillDownKeyStroke,\n  TreeLayout,\n  TreeNavigationDownKeyStroke,\n  TreeNavigationEndKeyStroke,\n  TreeNavigationUpKeyStroke,\n  TreeNode,\n  TreeSpaceKeyStroke,\n  Widget\n} from '../index';\nimport $ from 'jquery';\n\n/**\n * @class\n * @constructor\n */\nexport default class Tree extends Widget {\n  constructor() {\n    super();\n\n    this.toggleBreadcrumbStyleEnabled = false;\n    this.breadcrumbTogglingThreshold = null;\n    this.autoCheckChildren = false;\n    this.checkable = false;\n    this.checkableStyle = Tree.CheckableStyle.CHECKBOX_TREE_NODE;\n    this.displayStyle = Tree.DisplayStyle.DEFAULT;\n    this.dropType = 0;\n    this.dropMaximumSize = dragAndDrop.DEFAULT_DROP_MAXIMUM_SIZE;\n    this.filterEnabled = false;\n    this.lazyExpandingEnabled = true;\n    this.menus = [];\n    this.contextMenu = null;\n    this.menuBar = null;\n    this.keyStrokes = [];\n    this.multiCheck = true;\n    this.nodes = []; // top-level nodes\n    this.nodesMap = {}; // all nodes by id\n    this.nodePaddingLevelCheckable = 23; /* padding for one tree-level if the tree is checkable */\n    this.nodePaddingLevelNotCheckable = 18; /* padding for one tree-level if the tree is not checkable. this includes outline trees! */\n    this.nodePaddingLeft = null; /* is read from CSS */\n    this.nodeCheckBoxPaddingLeft = 29;\n    this.nodeControlPaddingLeft = null; /* is read from CSS */\n    this.nodePaddingLevel = this.nodePaddingLevelNotCheckable;\n    this.scrollToSelection = false;\n    this.scrollTop = 0;\n    this.scrollTopHistory = []; // Only necessary for breadcrumb mode\n    this.selectedNodes = [];\n    this.prevSelectedNode = null; // The previously selected node, relevant for breadcrumb in compact mode\n\n    // performance optimization: E.g. rather than iterating over the whole tree when unchecking all nodes,\n    // we explicitly keep track of nodes to uncheck (useful e.g. for single-check mode in very large trees).\n    this.checkedNodes = [];\n\n    this.groupedNodes = {};\n    this.visibleNodesFlat = [];\n    this.visibleNodesMap = {};\n    this._addWidgetProperties(['menus', 'keyStrokes']);\n    this._additionalContainerClasses = ''; // may be used by subclasses to set additional CSS classes\n    this._filters = [];\n    this._doubleClickSupport = new DoubleClickSupport();\n    this._$animationWrapper = null; // used by _renderExpansion()\n    this._$expandAnimationWrappers = [];\n    this._filterMenusHandler = this._filterMenus.bind(this);\n    this._popupOpenHandler = this._onDesktopPopupOpen.bind(this);\n\n    // contains all parents of a selected node, the selected node and the first level children\n    this._inSelectionPathList = {};\n    this.viewRangeRendered = new Range(0, 0);\n    this.viewRangeSize = 20;\n\n    this.startAnimationFunc = function() {\n      this.runningAnimations++;\n    }.bind(this);\n    this.runningAnimations = 0;\n    this.runningAnimationsFinishFunc = function() {\n      this.runningAnimations--;\n      if (this.runningAnimations <= 0) {\n        this.runningAnimations = 0;\n        this._renderViewportBlocked = false;\n        this.invalidateLayoutTree();\n      }\n    }.bind(this);\n\n    this.nodeHeight = 0;\n    this.nodeWidth = 0;\n    this.maxNodeWidth = 0;\n    this.nodeWidthDirty = false;\n    this.$data = null;\n    this._scrolldirections = 'both';\n    this.requestFocusOnNodeControlMouseDown = true;\n  }\n\n  static DisplayStyle = {\n    DEFAULT: 'default',\n    BREADCRUMB: 'breadcrumb'\n  };\n\n  static CheckableStyle = {\n    /**\n     * Node check is only possible by checking the checkbox.\n     */\n    CHECKBOX: 'checkbox',\n    /**\n     * Node check is possible by clicking anywhere on the node.\n     */\n    CHECKBOX_TREE_NODE: 'checkbox_tree_node'\n  };\n\n  /**\n   * Used to calculate the view range size. See {@link calculateViewRangeSize}.\n   */\n  static VIEW_RANGE_DIVISOR = 4;\n\n  _init(model) {\n    super._init(model);\n    this.addFilter(new LazyNodeFilter(this), true);\n    this.breadcrumbFilter = new TreeBreadcrumbFilter(this);\n    if (this.displayStyle === Tree.DisplayStyle.BREADCRUMB) {\n      this.addFilter(this.breadcrumbFilter, true, true);\n    }\n    this.initialTraversing = true;\n    this._setCheckable(this.checkable);\n    this._ensureTreeNodes(this.nodes);\n    this.visitNodes(this._initTreeNode.bind(this));\n    this.visitNodes(this._updateFlatListAndSelectionPath.bind(this));\n    this.initialTraversing = false;\n    this.selectedNodes = this._nodesByIds(this.selectedNodes);\n    this.menuBar = scout.create('MenuBar', {\n      parent: this,\n      position: MenuBar.Position.BOTTOM,\n      menuOrder: new MenuItemsOrder(this.session, 'Tree'),\n      menuFilter: this._filterMenusHandler\n    });\n    this._updateItemPath(true);\n    this._setDisplayStyle(this.displayStyle);\n    this._setKeyStrokes(this.keyStrokes);\n    this._setMenus(this.menus);\n  }\n\n  /**\n   * Iterates through the given array and converts node-models to instances of TreeNode (or a subclass).\n   * If the array element is already a TreeNode the function leaves the element untouched. This function also\n   * ensures that the attribute childNodeIndex is set. By default we use the order of the nodes array as index\n   * but only if childNodeIndex is undefined.\n   *\n   * @param nodes Array of node-models (plain object) or nodes (instance of TreeNode)\n   */\n  _ensureTreeNodes(nodes) {\n    var i, node;\n    for (i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      node.childNodeIndex = scout.nvl(node.childNodeIndex, i);\n      if (node instanceof TreeNode) {\n        continue;\n      }\n      nodes[i] = this._createTreeNode(node);\n    }\n  }\n\n  _createTreeNode(nodeModel) {\n    nodeModel = scout.nvl(nodeModel, {});\n    nodeModel.parent = this;\n    return scout.create('TreeNode', nodeModel);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this._initTreeKeyStrokeContext();\n  }\n\n  _initTreeKeyStrokeContext() {\n    var modifierBitMask = keyStrokeModifier.NONE;\n\n    this.keyStrokeContext.registerKeyStroke([\n      new TreeSpaceKeyStroke(this),\n      new TreeNavigationUpKeyStroke(this, modifierBitMask),\n      new TreeNavigationDownKeyStroke(this, modifierBitMask),\n      new TreeCollapseAllKeyStroke(this, modifierBitMask),\n      new TreeCollapseOrDrillUpKeyStroke(this, modifierBitMask),\n      new TreeNavigationEndKeyStroke(this, modifierBitMask),\n      new TreeExpandOrDrillDownKeyStroke(this, modifierBitMask)\n    ]);\n\n    // Prevent default action and do not propagate ↓ or ↑ keys if ctrl- or alt-modifier is not pressed.\n    // Otherwise, an '↑-event' on the first node, or an '↓-event' on the last row will bubble up (because not consumed by tree navigation keystrokes) and cause a superior tree to move its selection;\n    // Use case: - outline tree with a detail form that contains a tree;\n    //           - preventDefault because of smartfield, so that the cursor is not moved on first or last row;\n    this.keyStrokeContext.registerStopPropagationInterceptor(function(event) {\n      if (!event.ctrlKey && !event.altKey && scout.isOneOf(event.which, keys.UP, keys.DOWN)) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    });\n  }\n\n  _setMenus(argMenus) {\n    this.updateKeyStrokes(argMenus, this.menus);\n    this._setProperty('menus', argMenus);\n    this._updateMenuBar();\n  }\n\n  _updateMenuBar() {\n    var menuItems = this._filterMenus(this.menus, MenuDestinations.MENU_BAR, false, true);\n    this.menuBar.setMenuItems(menuItems);\n    var contextMenuItems = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true);\n    if (this.contextMenu) {\n      this.contextMenu.updateMenuItems(contextMenuItems);\n    }\n  }\n\n  _setKeyStrokes(keyStrokes) {\n    this.updateKeyStrokes(keyStrokes, this.keyStrokes);\n    this._setProperty('keyStrokes', keyStrokes);\n  }\n\n  _resetTreeNode(node, parentNode) {\n    node.reset();\n  }\n\n  isSelectedNode(node) {\n    if (this.initialTraversing) {\n      return this.selectedNodes.indexOf(node.id) > -1;\n    }\n    return this.selectedNodes.indexOf(node) > -1;\n  }\n\n  _updateFlatListAndSelectionPath(node, parentNode) {\n    // if this node is selected all parent nodes have to be added to selectionPath\n    if (this.isSelectedNode(node) && (node.parentNode && !this.visibleNodesMap[node.parentNode.id] || node.level === 0)) {\n      var p = node;\n      while (p) {\n        this._inSelectionPathList[p.id] = true;\n        p.filterDirty = true;\n\n        if (p !== node) {\n          // ensure node is expanded\n          node.expanded = true;\n          // if parent was filtered before, try refilter after adding to selection path.\n          if (p.level === 0) {\n            this._applyFiltersForNode(p);\n\n            // add visible nodes to visible nodes array when they are initialized\n            this._addToVisibleFlatList(p, false);\n\n            // process children\n            this._addChildrenToFlatList(p, this.visibleNodesFlat.length - 1, false, null, true);\n          }\n        }\n        p = p.parentNode;\n      }\n    } else if (node.parentNode && this.isSelectedNode(node.parentNode)) {\n      this._inSelectionPathList[node.id] = true;\n    }\n\n    this._applyFiltersForNode(node);\n\n    // add visible nodes to visible nodes array when they are initialized\n    this._addToVisibleFlatList(node, false);\n  }\n\n  _initTreeNode(node, parentNode) {\n    this.nodesMap[node.id] = node;\n    if (parentNode) {\n      node.parentNode = parentNode;\n      node.level = node.parentNode.level + 1;\n    }\n    if (node.checked) {\n      this.checkedNodes.push(node);\n    }\n    this._initTreeNodeInternal(node, parentNode);\n    this._updateMarkChildrenChecked(node, true, node.checked);\n    node.initialized = true;\n  }\n\n  _applyNodeDefaultValues(node) {\n    defaultValues.applyTo(node, 'TreeNode');\n  }\n\n  /**\n   * Override this function if you want a custom node init before filtering.\n   * The default impl. applies default values to the given node.\n   */\n  _initTreeNodeInternal(node, parentNode) {\n    this._applyNodeDefaultValues(node);\n  }\n\n  _destroy() {\n    super._destroy();\n    this.visitNodes(this._destroyTreeNode.bind(this));\n    this.nodes = []; // finally, clear array with root tree-nodes\n  }\n\n  _destroyTreeNode(node) {\n    delete this.nodesMap[node.id];\n    this._removeFromFlatList(node, false); // ensure node is not longer in visible nodes list.\n    node.destroy();\n\n    if (this._onNodeDeleted) { // Necessary for subclasses\n      this._onNodeDeleted(node);\n    }\n  }\n\n  /**\n   * pre-order (top-down) traversal of the tree-nodes of this tree.<br>\n   * if func returns true the children of the visited node are not visited.\n   */\n  visitNodes(func, parentNode) {\n    return Tree.visitNodes(func, this.nodes, parentNode);\n  }\n\n  _render() {\n    this.$container = this.$parent.appendDiv('tree');\n    if (this._additionalContainerClasses) {\n      this.$container.addClass(this._additionalContainerClasses);\n    }\n\n    var layout = new TreeLayout(this);\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(layout);\n\n    this.$data = this.$container.appendDiv('tree-data')\n      .on('contextmenu', this._onContextMenu.bind(this))\n      .on('mousedown', '.tree-node', this._onNodeMouseDown.bind(this))\n      .on('mouseup', '.tree-node', this._onNodeMouseUp.bind(this))\n      .on('dblclick', '.tree-node', this._onNodeDoubleClick.bind(this))\n      .on('mousedown', '.tree-node-control', this._onNodeControlMouseDown.bind(this))\n      .on('mouseup', '.tree-node-control', this._onNodeControlMouseUp.bind(this))\n      .on('dblclick', '.tree-node-control', this._onNodeControlDoubleClick.bind(this));\n    HtmlComponent.install(this.$data, this.session);\n\n    if (this.isHorizontalScrollingEnabled()) {\n      this.$data.toggleClass('scrollable-tree', true);\n    }\n\n    this._installScrollbars({\n      axis: this._scrolldirections\n    });\n    this._installNodeTooltipSupport();\n    this.menuBar.render();\n    this._updateNodeDimensions();\n    // render display style before viewport (not in renderProperties) to have a correct style from the beginning\n    this._renderDisplayStyle();\n    this._renderViewport();\n    this.session.desktop.on('popupOpen', this._popupOpenHandler);\n    this._renderCheckableStyle();\n  }\n\n  _postRender() {\n    super._postRender();\n    this._renderSelection();\n  }\n\n  _remove() {\n    // remove listener\n    this.session.desktop.off('popupOpen', this._popupOpenHandler);\n\n    // stop all animations\n    if (this._$animationWrapper) {\n      this._$animationWrapper.stop(false, true);\n    }\n    // Detach nodes from jQuery objects (because those will be removed)\n    this.visitNodes(this._resetTreeNode.bind(this));\n\n    this._uninstallDragAndDropHandler();\n    this._uninstallNodeTooltipSupport();\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n    this.$data = null;\n    // reset rendered view range because now range is rendered\n    this.viewRangeRendered = new Range(0, 0);\n    super._remove();\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderDropType();\n  }\n\n  isHorizontalScrollingEnabled() {\n    return this._scrolldirections === 'both' || this._scrolldirections === 'x';\n  }\n\n  isTreeNodeCheckEnabled() {\n    return this.checkableStyle === Tree.CheckableStyle.CHECKBOX_TREE_NODE;\n  }\n\n  /**\n   * @override\n   */\n  _onScroll() {\n    var scrollToSelectionBackup = this.scrollToSelection;\n    this.scrollToSelection = false;\n    var scrollTop = this.$data[0].scrollTop;\n    var scrollLeft = this.$data[0].scrollLeft;\n    if (this.scrollTop !== scrollTop) {\n      this._renderViewport();\n    }\n    this.scrollTop = scrollTop;\n    this.scrollLeft = scrollLeft;\n    this.scrollToSelection = scrollToSelectionBackup;\n  }\n\n  /**\n   * @override\n   */\n  setScrollTop(scrollTop) {\n    this.setProperty('scrollTop', scrollTop);\n    // call _renderViewport to make sure nodes are rendered immediately. The browser fires the scroll event handled by onDataScroll delayed\n    if (this.rendered) {\n      this._renderViewport();\n      // Render scroll top again to make sure the data really is at the expected position\n      // This seems only to be necessary for Chrome and the tree, it seems to work for IE and table.\n      // It is not optimal, because actually it should be possible to modify the $data[0].scrollTop without using this function\n      // Some debugging showed that after reducing the height of the afterFiller in _renderFiller the scrollTop will be wrong.\n      // Updating the scrollTop in renderFiller or other view range relevant function is bad because it corrupts smooth scrolling (see also commit c14ce92e0a7bff568d4f2d715e3061a782e728c2)\n      this._renderScrollTop();\n    }\n  }\n\n  /**\n   * @override\n   */\n  _renderScrollTop() {\n    if (this.rendering) {\n      // Not necessary to do it while rendering since it will be done by the layout\n      return;\n    }\n    scrollbars.scrollTop(this.$data, this.scrollTop);\n  }\n\n  /**\n   * @override\n   */\n  get$Scrollable() {\n    return this.$data;\n  }\n\n  _renderViewport() {\n    if (this.runningAnimations > 0 || this._renderViewportBlocked) {\n      // animation pending do not render view port because finishing should rerenderViewport\n      return;\n    }\n    if (!this.$container.isEveryParentVisible()) {\n      // If the tree is invisible, the width and height of the nodes cannot be determined\n      // In that case, the tree won't be layouted either -> as soon as it will be layouted, renderViewport will be called again\n      return;\n    }\n    var viewRange = this._calculateCurrentViewRange();\n    this._renderViewRange(viewRange);\n  }\n\n  _calculateCurrentViewRange() {\n    var node,\n      scrollTop = this.$data[0].scrollTop,\n      maxScrollTop = this.$data[0].scrollHeight - this.$data[0].clientHeight;\n\n    if (maxScrollTop === 0 && this.visibleNodesFlat.length > 0) {\n      // no scrollbars visible\n      node = this.visibleNodesFlat[0];\n    } else {\n      node = this._nodeAtScrollTop(scrollTop);\n    }\n\n    return this._calculateViewRangeForNode(node);\n  }\n\n  _rerenderViewport() {\n    if (this._renderViewportBlocked) {\n      return;\n    }\n    this._removeRenderedNodes();\n    this._renderFiller();\n    this._updateDomNodeWidth();\n    this._updateDomNodeIconWidth();\n    this._renderViewport();\n  }\n\n  _removeRenderedNodes() {\n    var $nodes = this.$data.find('.tree-node');\n    $nodes.each(function(i, elem) {\n      var $node = $(elem),\n        node = $node.data('node');\n      if ($node.hasClass('hiding')) {\n        // Do not remove nodes which are removed using an animation\n        return;\n      }\n      this._removeNode(node);\n    }.bind(this));\n    this.viewRangeRendered = new Range(0, 0);\n  }\n\n  _renderViewRangeForNode(node) {\n    var viewRange = this._calculateViewRangeForNode(node);\n    this._renderViewRange(viewRange);\n  }\n\n  _renderNodesInRange(range) {\n    var prepend = false;\n\n    var nodes = this.visibleNodesFlat;\n    if (nodes.length === 0) {\n      return;\n    }\n\n    var maxRange = new Range(0, nodes.length);\n    range = maxRange.intersect(range);\n    if (this.viewRangeRendered.size() > 0 && !range.intersect(this.viewRangeRendered).equals(new Range(0, 0))) {\n      throw new Error('New range must not intersect with existing.');\n    }\n    if (range.to <= this.viewRangeRendered.from) {\n      prepend = true;\n    }\n    var newRange = this.viewRangeRendered.union(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n\n    var numNodesRendered = this.ensureRangeVisible(range);\n\n    $.log.isTraceEnabled() && $.log.trace(numNodesRendered + ' new nodes rendered from ' + range);\n  }\n\n  ensureRangeVisible(range) {\n    var nodes = this.visibleNodesFlat;\n    var nodesToInsert = [];\n    for (var r = range.from; r < range.to; r++) {\n      var node = nodes[r];\n      if (!node.attached) {\n        nodesToInsert.push(node);\n      }\n    }\n    this._insertNodesInDOM(nodesToInsert);\n    return nodesToInsert.length;\n  }\n\n  _renderFiller() {\n    if (!this.$fillBefore) {\n      this.$fillBefore = this.$data.prependDiv('tree-data-fill');\n    }\n\n    var fillBeforeDimensions = this._calculateFillerDimension(new Range(0, this.viewRangeRendered.from));\n    this.$fillBefore.cssHeight(fillBeforeDimensions.height);\n    if (this.isHorizontalScrollingEnabled()) {\n      this.$fillBefore.cssWidth(fillBeforeDimensions.width);\n      this.maxNodeWidth = Math.max(fillBeforeDimensions.width, this.maxNodeWidth);\n    }\n    $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeDimensions.height);\n\n    if (!this.$fillAfter) {\n      this.$fillAfter = this.$data.appendDiv('tree-data-fill');\n    }\n\n    var fillAfterDimensions = {\n      height: 0,\n      width: 0\n    };\n    fillAfterDimensions = this._calculateFillerDimension(new Range(this.viewRangeRendered.to, this.visibleNodesFlat.length));\n    this.$fillAfter.cssHeight(fillAfterDimensions.height);\n    if (this.isHorizontalScrollingEnabled()) {\n      this.$fillAfter.cssWidth(fillAfterDimensions.width);\n      this.maxNodeWidth = Math.max(fillAfterDimensions.width, this.maxNodeWidth);\n    }\n    $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterDimensions.height);\n  }\n\n  _calculateFillerDimension(range) {\n    var outerWidth = 0;\n    if (this.rendered) {\n      // the outer-width is only correct if this tree is already rendered. otherwise wrong values are returned.\n      outerWidth = this.$data.outerWidth();\n    }\n    var dimension = {\n      height: 0,\n      width: Math.max(outerWidth, this.maxNodeWidth)\n    };\n    for (var i = range.from; i < range.to; i++) {\n      var node = this.visibleNodesFlat[i];\n      dimension.height += this._heightForNode(node);\n      dimension.width = Math.max(dimension.width, this._widthForNode(node));\n    }\n    return dimension;\n  }\n\n  _removeNodesInRange(range) {\n    var fromNode, toNode, node, i,\n      numNodesRemoved = 0,\n      nodes = this.visibleNodesFlat;\n\n    var maxRange = new Range(0, nodes.length);\n    range = maxRange.intersect(range);\n    fromNode = nodes[range.from];\n    toNode = nodes[range.to];\n\n    var newRange = this.viewRangeRendered.subtract(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only remove nodes at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n\n    for (i = range.from; i < range.to; i++) {\n      node = nodes[i];\n      this._removeNode(node);\n      numNodesRemoved++;\n    }\n\n    $.log.isTraceEnabled() && $.log.trace(numNodesRemoved + ' nodes removed from ' + range + '.');\n  }\n\n  /**\n   * Just removes the node, does NOT adjust this.viewRangeRendered\n   */\n  _removeNode(node) {\n    var $node = node.$node;\n    if (!$node) {\n      return;\n    }\n    if ($node.hasClass('hiding')) {\n      // Do not remove nodes which are removed using an animation\n      return;\n    }\n    // only remove node\n    $node.detach();\n    node.attached = false;\n  }\n\n  /**\n   * Renders the rows visible in the viewport and removes the other rows\n   */\n  _renderViewRange(viewRange) {\n    if (viewRange.from === this.viewRangeRendered.from && viewRange.to === this.viewRangeRendered.to && !this.viewRangeDirty) {\n      // When node with has changed (because of changes in layout) we must at least\n      // update the internal node width even though the view-range has not changed.\n      if (this.nodeWidthDirty) {\n        this._renderFiller();\n        this._updateDomNodeWidth();\n        this._updateDomNodeIconWidth();\n      }\n\n      // Range already rendered -> do nothing\n      return;\n    }\n    if (!this.viewRangeDirty) {\n      var rangesToRender = viewRange.subtract(this.viewRangeRendered);\n      var rangesToRemove = this.viewRangeRendered.subtract(viewRange);\n      var maxRange = new Range(0, this.visibleNodesFlat.length);\n\n      rangesToRemove.forEach(function(range) {\n        this._removeNodesInRange(range);\n        if (maxRange.to < range.to) {\n          this.viewRangeRendered = viewRange;\n        }\n      }.bind(this));\n      rangesToRender.forEach(function(range) {\n        this._renderNodesInRange(range);\n      }.bind(this));\n    } else {\n      // expansion changed\n      this.viewRangeRendered = viewRange;\n      this.ensureRangeVisible(viewRange);\n    }\n\n    // check if at least last and first row in range got correctly rendered\n    if (this.viewRangeRendered.size() > 0) {\n      var nodes = this.visibleNodesFlat;\n      var firstNode = nodes[this.viewRangeRendered.from];\n      var lastNode = nodes[this.viewRangeRendered.to - 1];\n      if (this.viewRangeDirty) {\n        // cleanup nodes before range and after\n        var $nodesBeforFirstNode = firstNode.$node.prevAll('.tree-node');\n        var $nodesAfterLastNode = lastNode.$node.nextAll('.tree-node');\n        this._cleanupNodes($nodesBeforFirstNode);\n        this._cleanupNodes($nodesAfterLastNode);\n      }\n      if (!firstNode.attached || !lastNode.attached) {\n        throw new Error('Nodes not rendered as expected. ' + this.viewRangeRendered + '. First: ' + firstNode.$node + '. Last: ' + lastNode.$node);\n      }\n    }\n\n    this._postRenderViewRange();\n    this.viewRangeDirty = false;\n  }\n\n  _postRenderViewRange() {\n    this._renderFiller();\n    this._updateDomNodeWidth();\n    this._updateDomNodeIconWidth();\n    this._renderSelection();\n  }\n\n  /**\n   * The handling of the icon-size here depends on two assumptions:\n   *\n   * 1. font icons are always pre-loaded on application startup. This means outerWidth() will always return the correct\n   *    size of the icon at any time.\n   *\n   * 2. bitmap icons are not pre-loaded. This means, when the icon is shown, the size can be unknown because the\n   *    browser has not yet loaded the image resource. Because of that outerWidth() could not return the correct size\n   *    and also layout would have trouble. Because in a tree all icons should have the same size, we simply define\n   *    the min-width and min-height of bitmap icons by CSS. So we always have a proper value when we read the icon\n   *    size. We don't support the case where the same tree has bitmap icons in different sizes. When someone needs\n   *    larger icons, one could simple change the global constant @tree-node-bitmap-icon-size to change the icon size\n   *    for all trees, or set a CSS rule/class when only a single tree must have a different icon size.\n   */\n  _updateDomNodeIconWidth($nodes) {\n    if (!this.rendered && !this.rendering) {\n      return;\n    }\n    this._visibleNodesInViewRange().forEach(function(node) {\n      node._updateIconWidth();\n    });\n  }\n\n  _visibleNodesInViewRange() {\n    return this.visibleNodesFlat.slice(this.viewRangeRendered.from, this.viewRangeRendered.to);\n  }\n\n  _updateDomNodeWidth() {\n    if (!this.isHorizontalScrollingEnabled()) {\n      return;\n    }\n    if (!this.rendered || !this.nodeWidthDirty) {\n      return;\n    }\n    var nodes = this._visibleNodesInViewRange();\n    var maxNodeWidth = this.maxNodeWidth;\n    // find max-width\n    maxNodeWidth = nodes.reduce(function(aggr, node) {\n      return Math.max(node.width, aggr);\n    }, scout.nvl(maxNodeWidth, 0));\n    // set max width on all nodes\n    nodes.forEach(function(node) {\n      node.$node.cssWidth(maxNodeWidth);\n    });\n    this.nodeWidthDirty = false;\n  }\n\n  _cleanupNodes($nodes) {\n    for (var i = 0; i < $nodes.length; i++) {\n      this._removeNode($nodes.eq(i).data('node'));\n    }\n  }\n\n  /**\n   * Returns the index of the node which is at position scrollTop.\n   */\n  _nodeAtScrollTop(scrollTop) {\n    var height = 0,\n      nodeTop;\n    this.visibleNodesFlat.some(function(node, i) {\n      height += this._heightForNode(node);\n      if (scrollTop < height) {\n        nodeTop = node;\n        return true;\n      }\n    }.bind(this));\n    var visibleNodesLength = this.visibleNodesFlat.length;\n    if (!nodeTop && visibleNodesLength > 0) {\n      nodeTop = this.visibleNodesFlat[visibleNodesLength - 1];\n    }\n    return nodeTop;\n  }\n\n  _heightForNode(node) {\n    var height = 0;\n    if (node.height) {\n      height = node.height;\n    } else {\n      height = this.nodeHeight;\n    }\n    return height;\n  }\n\n  _widthForNode(node) {\n    var width = 0;\n    if (node.width) {\n      width = node.width;\n    } else {\n      width = this.nodeWidth;\n    }\n    return width;\n  }\n\n  /**\n   * Returns a range of size this.viewRangeSize. Start of range is nodeIndex - viewRangeSize / 4.\n   * -> 1/4 of the nodes are before the viewport 2/4 in the viewport 1/4 after the viewport,\n   * assuming viewRangeSize is 2*number of possible nodes in the viewport (see calculateViewRangeSize).\n   */\n  _calculateViewRangeForNode(node) {\n    var viewRange = new Range(),\n      quarterRange = Math.floor(this.viewRangeSize / Tree.VIEW_RANGE_DIVISOR),\n      diff;\n\n    var nodeIndex = this.visibleNodesFlat.indexOf(node);\n    viewRange.from = Math.max(nodeIndex - quarterRange, 0);\n    viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.visibleNodesFlat.length);\n    if (!node || nodeIndex === -1) {\n      return viewRange;\n    }\n\n    // Try to use the whole viewRangeSize (extend from if necessary)\n    diff = this.viewRangeSize - viewRange.size();\n    if (diff > 0) {\n      viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);\n    }\n    return viewRange;\n  }\n\n  /**\n   * Calculates the optimal view range size (number of nodes to be rendered).\n   * It uses the default node height to estimate how many nodes fit in the view port.\n   * The view range size is this value * 2.\n   * <p>\n   * Note: the value calculated by this function is important for calculating the\n   * 'insertBatch'. When the value becomes smaller than 4 ({@link Tree.VIEW_RANGE_DIVISOR}) this\n   * will cause errors on inserting nodes at the right position. See #262890.\n   */\n  calculateViewRangeSize() {\n    // Make sure row height is up to date (row height may be different after zooming)\n    this._updateNodeDimensions();\n    if (this.nodeHeight === 0) {\n      throw new Error('Cannot calculate view range with nodeHeight = 0');\n    }\n    var viewRangeMultiplier = Tree.VIEW_RANGE_DIVISOR / 2; // See  _calculateViewRangeForNode\n    var viewRange = Math.ceil(this.$data.outerHeight() / this.nodeHeight) * viewRangeMultiplier;\n    return Math.max(Tree.VIEW_RANGE_DIVISOR, viewRange);\n  }\n\n  setViewRangeSize(viewRangeSize) {\n    if (this.viewRangeSize === viewRangeSize) {\n      return;\n    }\n    this._setProperty('viewRangeSize', viewRangeSize);\n    if (this.rendered) {\n      this._renderViewport();\n    }\n  }\n\n  _updateNodeDimensions() {\n    var emptyNode = this._createTreeNode();\n    var $node = this._renderNode(emptyNode).appendTo(this.$data);\n    this.nodeHeight = $node.outerHeight(true);\n    if (this.isHorizontalScrollingEnabled()) {\n      var oldNodeWidth = this.nodeWidth;\n      this.nodeWidth = $node.outerWidth(true);\n      if (oldNodeWidth !== this.nodeWidth) {\n        this.viewRangeDirty = true;\n      }\n    }\n    emptyNode.reset();\n  }\n\n  /**\n   * Updates the node heights for every visible node and clears the height of the others\n   */\n  updateNodeHeights() {\n    this.visibleNodesFlat.forEach(function(node) {\n      if (!node.attached) {\n        node.height = null;\n      } else {\n        node.height = node.$node.outerHeight(true);\n      }\n    });\n  }\n\n  removeAllNodes() {\n    this._removeNodes(this.nodes);\n  }\n\n  /**\n   * @param parentNode\n   *          Optional. If provided, this node's state will be updated (e.g. it will be collapsed\n   *          if it does no longer have child nodes). Can also be an array, in which case all of\n   *          those nodes are updated.\n   */\n  _removeNodes(nodes, parentNode) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    nodes.forEach(function(node) {\n      this._removeFromFlatList(node, true);\n      if (node.childNodes.length > 0) {\n        this._removeNodes(node.childNodes, node);\n      }\n      if (node.$node) {\n        if (this._$animationWrapper && this._$animationWrapper.find(node.$node).length > 0) {\n          this._$animationWrapper.stop(false, true);\n        }\n        node.reset();\n      }\n    }, this);\n\n    // If every child node was deleted mark node as collapsed (independent of the model state)\n    // --> makes it consistent with addNodes and expand (expansion is not allowed if there are no child nodes)\n    arrays.ensure(parentNode).forEach(function(p) {\n      if (p && p.$node && p.childNodes.length === 0) {\n        p.$node.removeClass('expanded lazy');\n      }\n    });\n    if (this.rendered) {\n      this.viewRangeDirty = true;\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _renderNode(node) {\n    var paddingLeft = this._computeNodePaddingLeft(node);\n    node.render(this.$container, paddingLeft, this.checkable, this.enabledComputed);\n    return node.$node;\n  }\n\n  _removeMenus() {\n    // menubar takes care about removal\n  }\n\n  _filterMenus(argMenus, destination, onlyVisible, enableDisableKeyStroke) {\n    return menus_1.filterAccordingToSelection('Tree', this.selectedNodes.length, argMenus, destination, onlyVisible, enableDisableKeyStroke);\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _renderEnabled() {\n    super._renderEnabled();\n\n    var enabled = this.enabledComputed;\n    this.$data.setEnabled(enabled);\n    this.$container.setTabbable(enabled);\n\n    if (this.rendered) {\n      // Enable/disable all checkboxes\n      this.$nodes().each(function() {\n        var $node = $(this),\n          node = $node.data('node');\n\n        $node.children('.tree-node-checkbox')\n          .children('.check-box')\n          .toggleClass('disabled', !(enabled && node.enabled));\n      });\n    }\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _renderDisabledStyle() {\n    super._renderDisabledStyle();\n    this._renderDisabledStyleInternal(this.$data);\n  }\n\n  setCheckable(checkable) {\n    this.setProperty('checkable', checkable);\n  }\n\n  _setCheckable(checkable) {\n    this._setProperty('checkable', checkable);\n    if (this.checkable) {\n      this.nodePaddingLevel = this.nodePaddingLevelCheckable;\n    } else {\n      this.nodePaddingLevel = this.nodePaddingLevelNotCheckable;\n    }\n  }\n\n  setCheckableStyle(checkableStyle) {\n    this.setProperty('checkableStyle', checkableStyle);\n  }\n\n  _renderCheckable() {\n    // Define helper functions\n    var isNodeRendered = function(node) {\n      return Boolean(node.$node);\n    };\n    var updateCheckableStateRec = function(node) {\n      var $node = node.$node;\n      var $control = $node.children('.tree-node-control');\n      var $checkbox = $node.children('.tree-node-checkbox');\n\n      node._updateControl($control, this);\n      if (this.checkable) {\n        if ($checkbox.length === 0) {\n          node._renderCheckbox();\n        }\n      } else {\n        $checkbox.remove();\n      }\n\n      $node.css('padding-left', this._computeNodePaddingLeft(node));\n\n      // Recursion\n      if (node.childNodes) {\n        node.childNodes.filter(isNodeRendered).forEach(updateCheckableStateRec);\n      }\n    }.bind(this);\n\n    // Start recursion\n    this.nodes.filter(isNodeRendered).forEach(updateCheckableStateRec);\n  }\n\n  _renderDisplayStyle() {\n    this.$container.toggleClass('breadcrumb', this.isBreadcrumbStyleActive());\n    this._updateNodePaddingsLeft();\n    // update scrollbar if mode has changed (from tree to bc or vice versa)\n    this.invalidateLayoutTree();\n  }\n\n  _renderExpansion(node, options) {\n    var opts = {\n      expandLazyChanged: false,\n      expansionChanged: false\n    };\n    $.extend(opts, options);\n\n    var $node = node.$node,\n      expanded = node.expanded;\n\n    // Only render if node is rendered to make it possible to expand/collapse currently hidden nodes (used by collapseAll).\n    if (!$node || $node.length === 0) {\n      return;\n    }\n\n    // Only expand / collapse if there are child nodes\n    if (node.childNodes.length === 0) {\n      return true;\n    }\n\n    $node.toggleClass('lazy', expanded && node.expandedLazy);\n    if (!opts.expansionChanged && !opts.expandLazyChanged) {\n      // Expansion state has not changed -> return\n      return;\n    }\n\n    if (expanded) {\n      $node.addClass('expanded');\n    } else {\n      $node.removeClass('expanded');\n    }\n  }\n\n  _renderSelection() {\n    // Add children class to root nodes if no nodes are selected\n    if (this.selectedNodes.length === 0) {\n      this.nodes.forEach(function(childNode) {\n        if (childNode.rendered) {\n          childNode.$node.addClass('child-of-selected');\n        }\n      }, this);\n    }\n\n    this.selectedNodes.forEach(function(node) {\n      if (!this.visibleNodesMap[node.id]) {\n        return;\n      }\n\n      // Mark all ancestor nodes, especially necessary for bread crumb mode\n      var parentNode = node.parentNode;\n      if (parentNode && parentNode.rendered) {\n        parentNode.$node.addClass('parent-of-selected');\n      }\n      while (parentNode) {\n        if (parentNode.rendered) {\n          parentNode.$node.addClass('ancestor-of-selected');\n        }\n        parentNode = parentNode.parentNode;\n      }\n\n      // Mark all child nodes\n      if (node.expanded) {\n        node.childNodes.forEach(function(childNode) {\n          if (childNode.rendered) {\n            childNode.$node.addClass('child-of-selected');\n          }\n        }, this);\n      }\n\n      if (node.rendered) {\n        node.$node.select(true);\n      }\n    }, this);\n\n    // Update 'group' markers for all rendered nodes\n    for (var i = this.viewRangeRendered.from; i < this.viewRangeRendered.to; i++) {\n      if (i >= this.visibleNodesFlat.length) {\n        break;\n      }\n      var node = this.visibleNodesFlat[i];\n      if (node && node.rendered) {\n        node.$node.toggleClass('group', Boolean(this.groupedNodes[node.id]));\n      }\n    }\n\n    this._updateNodePaddingsLeft();\n    this._highlightPrevSelectedNode();\n\n    if (this.scrollToSelection) {\n      this.revealSelection();\n    }\n  }\n\n  _renderCheckableStyle() {\n    this.$data.toggleClass('checkable', this.isTreeNodeCheckEnabled());\n  }\n\n  _highlightPrevSelectedNode() {\n    if (!this.isBreadcrumbStyleActive()) {\n      return;\n    }\n    if (!this.prevSelectedNode || !this.prevSelectedNode.rendered || this.prevSelectedNode.prevSelectionAnimationDone) {\n      return;\n    }\n    // Highlight previously selected node, but do it only once\n    this.prevSelectedNode.$node.addClassForAnimation('animate-prev-selected').oneAnimationEnd(function() {\n      this.prevSelectedNode.prevSelectionAnimationDone = true;\n    }.bind(this));\n  }\n\n  _removeSelection() {\n    // Remove children class on root nodes if no nodes were selected\n    if (this.selectedNodes.length === 0) {\n      this.nodes.forEach(function(childNode) {\n        if (childNode.rendered) {\n          childNode.$node.removeClass('child-of-selected');\n        }\n      }, this);\n    }\n\n    // Ensure animate-prev-selected class is removed (in case animation did not start)\n    if (this.prevSelectedNode && this.prevSelectedNode.rendered) {\n      this.prevSelectedNode.$node.removeClass('animate-prev-selected');\n    }\n\n    this.selectedNodes.forEach(this._removeNodeSelection, this);\n  }\n\n  _removeNodeSelection(node) {\n    if (node.rendered) {\n      node.$node.select(false);\n    }\n\n    // remove ancestor and child classes\n    var parentNode = node.parentNode;\n    if (parentNode && parentNode.rendered) {\n      parentNode.$node.removeClass('parent-of-selected');\n    }\n    while (parentNode && parentNode.rendered) {\n      parentNode.$node.removeClass('ancestor-of-selected');\n      parentNode = parentNode.parentNode;\n    }\n    if (node.expanded) {\n      node.childNodes.forEach(function(childNode) {\n        if (childNode.rendered) {\n          childNode.$node.removeClass('child-of-selected');\n        }\n      }, this);\n    }\n  }\n\n  _renderDropType() {\n    if (this.dropType) {\n      this._installDragAndDropHandler();\n    } else {\n      this._uninstallDragAndDropHandler();\n    }\n  }\n\n  _installDragAndDropHandler(event) {\n    if (this.dragAndDropHandler) {\n      return;\n    }\n    this.dragAndDropHandler = dragAndDrop.handler(this, {\n      supportedScoutTypes: dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n      dropType: function() {\n        return this.dropType;\n      }.bind(this),\n      dropMaximumSize: function() {\n        return this.dropMaximumSize;\n      }.bind(this),\n      additionalDropProperties: function(event) {\n        var $target = $(event.currentTarget);\n        var properties = {\n          nodeId: ''\n        };\n        if ($target.hasClass('tree-node')) {\n          var node = $target.data('node');\n          properties.nodeId = node.id;\n        }\n        return properties;\n      }\n    });\n    this.dragAndDropHandler.install(this.$container, '.tree-data,.tree-node');\n  }\n\n  _uninstallDragAndDropHandler(event) {\n    if (!this.dragAndDropHandler) {\n      return;\n    }\n    this.dragAndDropHandler.uninstall();\n    this.dragAndDropHandler = null;\n  }\n\n  _updateMarkChildrenChecked(node, init, checked, checkChildrenChecked) {\n    if (!this.checkable) {\n      return;\n    }\n\n    if (checkChildrenChecked) {\n      var childrenFound = false;\n      for (var j = 0; j < node.childNodes.length > 0; j++) {\n        var childNode = node.childNodes[j];\n        if (childNode.checked || childNode.childrenChecked) {\n          node.childrenChecked = true;\n          checked = true;\n          childrenFound = true;\n          if (this.rendered && node.$node) {\n            node.$node\n              .children('.tree-node-checkbox')\n              .children('.check-box')\n              .toggleClass('children-checked', true);\n          }\n          break;\n        }\n      }\n      if (!childrenFound) {\n        node.childrenChecked = false;\n        if (this.rendered && node.$node) {\n          node.$node.children('.tree-node-checkbox')\n            .children('.check-box')\n            .toggleClass('children-checked', false);\n        }\n      }\n    }\n\n    if (!node.parentNode || node.parentNode.checked) {\n      return;\n    }\n\n    var stateChanged = false;\n    if (!checked && !init) {\n      // node was unchecked check siblings\n      var hasCheckedSiblings = false;\n      for (var i = 0; i < node.parentNode.childNodes.length > 0; i++) {\n        var siblingNode = node.parentNode.childNodes[i];\n        if (siblingNode.checked || siblingNode.childrenChecked) {\n          hasCheckedSiblings = true;\n          break;\n        }\n      }\n      if (hasCheckedSiblings !== node.parentNode.childrenChecked) {\n        // parentNode.checked should be false\n        node.parentNode.childrenChecked = hasCheckedSiblings;\n        stateChanged = true;\n      }\n    }\n    if (checked && !node.parentNode.childrenChecked) {\n      node.parentNode.childrenChecked = true;\n      stateChanged = true;\n    }\n    if (stateChanged) {\n      this._updateMarkChildrenChecked(node.parentNode, init, checked);\n      if (this.rendered && node.parentNode.$node) {\n        if (checked) {\n          node.parentNode.$node.children('.tree-node-checkbox')\n            .children('.check-box')\n            .toggleClass('children-checked', true);\n        } else {\n          node.parentNode.$node.children('.tree-node-checkbox')\n            .children('.check-box')\n            .toggleClass('children-checked', false);\n        }\n      }\n    }\n  }\n\n  _installNodeTooltipSupport() {\n    tooltips.install(this.$data, {\n      parent: this,\n      selector: '.tree-node',\n      text: this._nodeTooltipText.bind(this),\n      arrowPosition: 50,\n      arrowPositionUnit: '%',\n      nativeTooltip: !Device.get().isCustomEllipsisTooltipPossible()\n    });\n  }\n\n  _uninstallNodeTooltipSupport() {\n    tooltips.uninstall(this.$data);\n  }\n\n  _nodeTooltipText($node) {\n    var node = $node.data('node');\n    if (node.tooltipText) {\n      return node.tooltipText;\n    } else if (this._isTruncatedNodeTooltipEnabled() && $node.isContentTruncated()) {\n      return node.$text.text();\n    }\n  }\n\n  _isTruncatedNodeTooltipEnabled() {\n    return true;\n  }\n\n  setDisplayStyle(displayStyle) {\n    if (this.displayStyle === displayStyle) {\n      return;\n    }\n    this._renderViewportBlocked = true;\n    this._setDisplayStyle(displayStyle);\n    if (this.rendered) {\n      this._renderDisplayStyle();\n    }\n    this._renderViewportBlocked = false;\n  }\n\n  _setDisplayStyle(displayStyle) {\n    this._setProperty('displayStyle', displayStyle);\n\n    if (this.displayStyle === Tree.DisplayStyle.BREADCRUMB) {\n      if (this.selectedNodes.length > 0) {\n        var selectedNode = this.selectedNodes[0];\n        if (!selectedNode.expanded) {\n          this.expandNode(selectedNode);\n        }\n      }\n      this.addFilter(this.breadcrumbFilter, true, true);\n      this.filterVisibleNodes();\n    } else {\n      this.removeFilter(this.breadcrumbFilter, true);\n      this.filter();\n    }\n  }\n\n  _updateNodePaddingsLeft() {\n    this.$nodes().each(function(index, element) {\n      var $node = $(element),\n        node = $node.data('node'),\n        paddingLeft = this._computeNodePaddingLeft(node);\n      $node.css('padding-left', objects.isNullOrUndefined(paddingLeft) ? '' : paddingLeft);\n    }.bind(this));\n  }\n\n  setBreadcrumbStyleActive(active) {\n    if (active) {\n      this.setDisplayStyle(Tree.DisplayStyle.BREADCRUMB);\n    } else {\n      this.setDisplayStyle(Tree.DisplayStyle.DEFAULT);\n    }\n  }\n\n  isNodeInBreadcrumbVisible(node) {\n    return this._inSelectionPathList[node.id] === undefined ? false : this._inSelectionPathList[node.id];\n  }\n\n  isBreadcrumbStyleActive() {\n    return this.displayStyle === Tree.DisplayStyle.BREADCRUMB;\n  }\n\n  setToggleBreadcrumbStyleEnabled(enabled) {\n    this.setProperty('toggleBreadcrumbStyleEnabled', enabled);\n  }\n\n  setBreadcrumbTogglingThreshold(width) {\n    this.setProperty('breadcrumbTogglingThreshold', width);\n  }\n\n  expandNode(node, opts) {\n    this.setNodeExpanded(node, true, opts);\n  }\n\n  collapseNode(node, opts) {\n    this.setNodeExpanded(node, false, opts);\n  }\n\n  collapseAll() {\n    this.rebuildSuppressed = true;\n    // Collapse all expanded child nodes (only model)\n    this.visitNodes(function(node) {\n      this.collapseNode(node);\n    }.bind(this));\n\n    if (this.rendered) {\n      // ensure correct rendering\n      this._rerenderViewport();\n    }\n\n    this.rebuildSuppressed = false;\n  }\n\n  setNodeExpanded(node, expanded, opts) {\n    opts = opts || {};\n    var lazy = opts.lazy;\n    if (objects.isNullOrUndefined(lazy)) {\n      if (node.expanded === expanded) {\n        // no state change: Keep the current \"expandedLazy\" state\n        lazy = node.expandedLazy;\n      } else if (expanded) {\n        // collapsed -> expanded: Set the \"expandedLazy\" state to the node's \"lazyExpandingEnabled\" flag\n        lazy = node.lazyExpandingEnabled;\n      } else {\n        // expanded -> collapsed: Set the \"expandedLazy\" state to false\n        lazy = false;\n      }\n    }\n    var renderAnimated = scout.nvl(opts.renderAnimated, true);\n\n    // Never do lazy expansion if it is disabled on the tree\n    if (!this.lazyExpandingEnabled) {\n      lazy = false;\n    }\n\n    if (this.isBreadcrumbStyleActive()) {\n      // Do not allow to collapse a selected node\n      if (!expanded && this.selectedNodes.indexOf(node) > -1) {\n        this.setNodeExpanded(node, true, opts);\n        return;\n      }\n    }\n\n    // Optionally collapse all children (recursively)\n    if (opts.collapseChildNodes) {\n      // Suppress render expansion\n      var childOpts = objects.valueCopy(opts);\n      childOpts.renderExpansion = false;\n\n      node.childNodes.forEach(function(childNode) {\n        if (childNode.expanded) {\n          this.collapseNode(childNode, childOpts);\n        }\n      }.bind(this));\n    }\n    var renderExpansionOpts = {\n      expansionChanged: false,\n      expandLazyChanged: false\n    };\n\n    // Set expansion state\n    if (node.expanded !== expanded || node.expandedLazy !== lazy) {\n      renderExpansionOpts.expansionChanged = node.expanded !== expanded;\n      renderExpansionOpts.expandLazyChanged = node.expandedLazy !== lazy;\n      node.expanded = expanded;\n      node.expandedLazy = lazy;\n\n      var filterStateChanged = this._applyFiltersForNode(node);\n      if (filterStateChanged && renderExpansionOpts.expansionChanged) {\n        if (node.parentNode) {\n          // ensure node is visible under the parent node if there is a parent.\n          this._rebuildParent(node.parentNode, opts);\n        } else if (node.filterAccepted) {\n          this._addToVisibleFlatList(node, false);\n        } else {\n          this._removeFromFlatList(node, false);\n        }\n      } else if (renderExpansionOpts.expandLazyChanged) {\n        node.childNodes.forEach(function(child) {\n          this._applyFiltersForNode(child);\n        }.bind(this));\n      }\n\n      if (this.groupedNodes[node.id]) {\n        this._updateItemPath(false, node);\n      }\n\n      if (node.expanded) {\n        node.ensureLoadChildren().done(\n          this._addChildrenToFlatList.bind(this, node, null, renderAnimated, null, true));\n      } else {\n        this._removeChildrenFromFlatList(node, renderAnimated);\n      }\n      this.trigger('nodeExpanded', {\n        node: node,\n        expanded: expanded,\n        expandedLazy: lazy\n      });\n      this.viewRangeDirty = true;\n    }\n\n    // Render expansion\n    if (this.rendered && scout.nvl(opts.renderExpansion, true)) {\n      this._renderExpansion(node, renderExpansionOpts);\n    }\n\n    if (this.rendered) {\n      this.ensureExpansionVisible(node);\n    }\n  }\n\n  setNodeExpandedRecursive(nodes, expanded, opts) {\n    Tree.visitNodes(function(childNode) {\n      this.setNodeExpanded(childNode, expanded, opts);\n    }.bind(this), nodes);\n  }\n\n  _rebuildParent(node, opts) {\n    if (this.rebuildSuppressed) {\n      return;\n    }\n    if (node.expanded || node.expandedLazy) {\n      this._addChildrenToFlatList(node, null, false, null, true);\n    } else {\n      this._removeChildrenFromFlatList(node, false);\n    }\n    // Render expansion\n    if (this.rendered && scout.nvl(opts.renderExpansion, true)) {\n      var renderExpansionOpts = {\n        expansionChanged: true\n      };\n      this._renderExpansion(node, renderExpansionOpts);\n    }\n  }\n\n  _removeChildrenFromFlatList(parentNode, animatedRemove) {\n    // Only if a parent is available the children are available.\n    if (this.visibleNodesMap[parentNode.id]) {\n      var parentIndex = this.visibleNodesFlat.indexOf(parentNode);\n      var elementsToDelete = 0;\n      var parentLevel = parentNode.level;\n      var removedNodes = [];\n      animatedRemove = animatedRemove && this.rendered;\n      if (this._$animationWrapper) {\n        // Note: Do _not_ use finish() here! Although documentation states that it is \"similar\" to stop(true, true),\n        // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when\n        // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling\n        // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)\n        this._$animationWrapper.stop(false, true);\n      }\n      this._$expandAnimationWrappers.forEach(function($wrapper) {\n        $wrapper.stop(false, true);\n      });\n      for (var i = parentIndex + 1; i < this.visibleNodesFlat.length; i++) {\n        if (this.visibleNodesFlat[i].level > parentLevel) {\n          var node = this.visibleNodesFlat[i];\n          if (this.isHorizontalScrollingEnabled()) {\n            // if node is the node which defines the widest width then recalculate width for render\n            if (node.width === this.maxNodeWidth) {\n              this.maxNodeWidth = 0;\n              this.nodeWidthDirty = true;\n            }\n          }\n          delete this.visibleNodesMap[this.visibleNodesFlat[i].id];\n          if (node.attached && animatedRemove) {\n            if (!this._$animationWrapper) {\n              this._$animationWrapper = $('<div class=\"animation-wrapper\">').insertBefore(node.$node);\n              this._$animationWrapper.data('parentNode', parentNode);\n            }\n            if (node.isDescendantOf(this._$animationWrapper.data('parentNode'))) {\n              this._$animationWrapper.append(node.$node);\n            }\n            node.attached = false;\n            node.displayBackup = node.$node.css('display');\n            removedNodes.push(node);\n          } else if (node.attached && !animatedRemove) {\n            this.hideNode(node, false, false);\n          }\n          elementsToDelete++;\n        } else {\n          break;\n        }\n      }\n\n      this.visibleNodesFlat.splice(parentIndex + 1, elementsToDelete);\n      // animate closing\n      if (animatedRemove) { // don't animate while rendering (not necessary, or may even lead to timing issues)\n        this._renderViewportBlocked = true;\n        if (removedNodes.length > 0) {\n          this._$animationWrapper.animate({\n            height: 0\n          }, {\n            start: this.startAnimationFunc,\n            complete: onAnimationComplete.bind(this, removedNodes),\n            step: this.revalidateLayoutTree.bind(this),\n            duration: 200,\n            queue: false\n          });\n        } else if (this._$animationWrapper) {\n          this._$animationWrapper.remove();\n          this._$animationWrapper = null;\n          onAnimationComplete.call(this, removedNodes);\n        } else {\n          this._renderViewportBlocked = false;\n        }\n      }\n      return removedNodes;\n    }\n\n    // ----- Helper functions -----\n    function onAnimationComplete(affectedNodes) {\n      affectedNodes.forEach(function(node) {\n        node.$node.detach();\n        node.$node.css('display', node.displayBackup);\n        node.displayBackup = null;\n      });\n      if (this._$animationWrapper) {\n        this._$animationWrapper.remove();\n        this._$animationWrapper = null;\n      }\n      this.runningAnimationsFinishFunc();\n    }\n  }\n\n  _removeFromFlatList(node, animatedRemove) {\n    var removedNodes = [];\n    if (this.visibleNodesMap[node.id]) {\n      var index = this.visibleNodesFlat.indexOf(node);\n      this._removeChildrenFromFlatList(node, false);\n      if (this.isHorizontalScrollingEnabled()) {\n        // if node is the node which defines the widest width then recalculate width for render\n        if (node.width === this.maxNodeWidth) {\n          this.maxNodeWidth = 0;\n          this.nodeWidthDirty = true;\n        }\n      }\n      removedNodes = arrays.ensure(this.visibleNodesFlat.splice(index, 1));\n      delete this.visibleNodesMap[node.id];\n      this.hideNode(node, animatedRemove);\n    }\n    removedNodes.push(node);\n    return removedNodes;\n  }\n\n  /**\n   * @returns {boolean} whether or not the function added a node to the flat list\n   */\n  _addToVisibleFlatList(node, renderingAnimated) {\n    // if node already is in visible list don't do anything. If no parentNode is available this node is on toplevel, if a parent is available\n    // it has to be in visible list and also be expanded\n    if (!this.visibleNodesMap[node.id] && node.isFilterAccepted() && (!node.parentNode ||\n      node.parentNode.expanded && this.visibleNodesMap[node.parentNode.id])) {\n      if (this.initialTraversing) {\n        // for faster index calculation\n        this._addToVisibleFlatListNoCheck(node, this.visibleNodesFlat.length, renderingAnimated);\n      } else {\n        var insertIndex = this._findInsertPositionInFlatList(node);\n        this._addToVisibleFlatListNoCheck(node, insertIndex, renderingAnimated);\n      }\n    }\n  }\n\n  // TODO [7.0] CGU applies to all the add/remove to/from flat list methods:\n  // Is it really necessary to update dom on every operation? why not just update the list and renderViewport at the end?\n  // The update of the flat list is currently implemented quite complicated -> it should be simplified.\n  // And: because add to flat list renders all the children the rendered node count is greater than the viewRangeSize until\n  // the layout renders the viewport again -> this must not happen (can be seen when a node gets expanded)\n  _addChildrenToFlatList(parentNode, parentIndex, animatedRendering, insertBatch, forceFilter) {\n    // add nodes recursively\n    if (!this.visibleNodesMap[parentNode.id]) {\n      return 0;\n    }\n\n    var isSubAdding = Boolean(insertBatch);\n    parentIndex = parentIndex ? parentIndex : this.visibleNodesFlat.indexOf(parentNode);\n    animatedRendering = animatedRendering && this.rendered; // don't animate while rendering (not necessary, or may even lead to timing issues)\n    if (this._$animationWrapper && !isSubAdding) {\n      // Note: Do _not_ use finish() here! Although documentation states that it is \"similar\" to stop(true, true),\n      // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when\n      // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling\n      // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)\n      this._$animationWrapper.stop(false, true);\n    }\n\n    if (insertBatch) {\n      insertBatch.setInsertAt(parentIndex);\n    } else {\n      insertBatch = this.newInsertBatch(parentIndex + 1);\n    }\n\n    parentNode.childNodes.forEach(function(node, index) {\n      if (!node.initialized || !node.isFilterAccepted(forceFilter)) {\n        return;\n      }\n\n      var insertIndex, isAlreadyAdded = this.visibleNodesMap[node.id];\n      if (isAlreadyAdded) {\n        this.insertBatchInVisibleNodes(insertBatch, this._showNodes(insertBatch), animatedRendering);\n        this.checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch);\n        insertBatch = this.newInsertBatch(insertBatch.nextBatchInsertIndex());\n        insertBatch = this._addChildrenToFlatListIfExpanded(1, node, insertIndex, animatedRendering, insertBatch, forceFilter);\n        // do not animate following\n        animatedRendering = false;\n      } else {\n        insertBatch.insertNodes.push(node);\n        this.visibleNodesMap[node.id] = true;\n        insertBatch = this.checkAndHandleBatch(insertBatch, parentNode, animatedRendering);\n        insertBatch = this._addChildrenToFlatListIfExpanded(0, node, insertIndex, animatedRendering, insertBatch, forceFilter);\n      }\n    }.bind(this));\n\n    if (!isSubAdding) {\n      // animation is not done yet and all added nodes are in visible range\n      this.insertBatchInVisibleNodes(insertBatch, this._showNodes(insertBatch), animatedRendering);\n      this.invalidateLayoutTree();\n    }\n\n    return insertBatch;\n  }\n\n  /**\n   * Checks if the given node is expanded, and if that's the case determine the insert index of the node and add its children to the flat list.\n   *\n   * @param {number} indexOffset either 0 or 1, offset is added to the insert index\n   */\n  _addChildrenToFlatListIfExpanded(indexOffset, node, insertIndex, animatedRendering, insertBatch, forceFilter) {\n    if (node.expanded && node.childNodes.length) {\n      if (insertBatch.containsNode(node.parentNode) || insertBatch.length() > 1) {\n        // if parent node is already in the batch, do not change the insertIndex,\n        // only append child nodes below that parent node\n        // Also, if the batch is not empty (i.e. contains more nodes than the current node),\n        // the insert index was already calculated previously and must not be changed.\n        insertIndex = insertBatch.insertAt();\n      } else {\n        insertIndex = this._findInsertPositionInFlatList(node);\n      }\n      insertIndex += indexOffset;\n      insertBatch = this._addChildrenToFlatList(node, insertIndex, animatedRendering, insertBatch, forceFilter);\n    }\n\n    return insertBatch;\n  }\n\n  _showNodes(insertBatch) {\n    return this.viewRangeRendered.from + this.viewRangeSize >= insertBatch.lastBatchInsertIndex() &&\n      this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex();\n  }\n\n  /**\n   * This function tries to find the correct insert position within the flat list for the given node.\n   * The function must consider the order of child nodes in the original tree structure and then check\n   * where in the flat list this position is.\n   */\n  _findInsertPositionInFlatList(node) {\n    var childNodes,\n      parentNode = node.parentNode;\n\n    // use root nodes as nodes when no other parent node is available (root case)\n    if (parentNode) {\n      childNodes = parentNode.childNodes;\n    } else {\n      childNodes = this.nodes;\n    }\n\n    // find all visible siblings for our node (incl. our own node, which is probably not yet\n    // in the visible nodes map)\n    var thatNode = node;\n    var siblings = childNodes.filter(function(node) {\n      return Boolean(this.visibleNodesMap[node.id]) || node === thatNode;\n    }.bind(this));\n\n    // when there are no visible siblings, insert below the parent node\n    if (siblings.length === 0) {\n      return this._findPositionInFlatList(parentNode) + 1;\n    }\n\n    var nodePos = siblings.indexOf(node);\n\n    // when there are no prev. siblings in the flat list, insert below the parent node\n    if (nodePos === 0) {\n      return this._findPositionInFlatList(parentNode) + 1;\n    }\n\n    var prevSiblingNode = siblings[nodePos - 1];\n    var prevSiblingPos = this._findPositionInFlatList(prevSiblingNode);\n\n    // when the prev. sibling is not in the flat list, insert below the parent node\n    if (prevSiblingPos === -1) {\n      return this._findPositionInFlatList(parentNode) + 1;\n    }\n\n    // find the index of the last child element of our prev. sibling node\n    // that's where we want to insert the new node. We go down the flat list\n    // starting from the prev. sibling node, until we hit a node that does not\n    // belong to the sub tree of the prev. sibling node.\n    var i, checkNode;\n    for (i = prevSiblingPos; i < this.visibleNodesFlat.length; i++) {\n      checkNode = this.visibleNodesFlat[i];\n      if (!this._isInSameSubTree(prevSiblingNode, checkNode)) {\n        return i;\n      }\n    }\n\n    // insert at the end of the list\n    return this.visibleNodesFlat.length;\n  }\n\n  _findPositionInFlatList(node) {\n    return this.visibleNodesFlat.indexOf(node);\n  }\n\n  /**\n   * Checks whether the given checkNode belongs to the same sub tree (or is) the given node.\n   * The function goes up all parentNodes of the checkNode.\n   *\n   * @param {TreeNode} node which is used to for the sub tree comparison\n   * @param {TreeNode} checkNode node which is checked against the given node\n   * @returns {boolean}\n   */\n  _isInSameSubTree(node, checkNode) {\n    do {\n      if (checkNode === node || checkNode.parentNode === node) {\n        return true;\n      }\n      checkNode = checkNode.parentNode;\n    } while (checkNode);\n\n    return false;\n  }\n\n  /**\n   * Returns true if the given node is a child of one of the selected nodes.\n   * The functions goes up the parent node hierarchy.\n   *\n   * @param {TreeNode} node to check\n   * @returns {boolean}\n   */\n  _isChildOfSelectedNodes(node) {\n    while (node) {\n      if (this.selectedNodes.indexOf(node.parentNode) > -1) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  /**\n   * Info: the object created here is a bit weird: the array 'insertNodes' is used as function arguments to the Array#splice function at some point.\n   * The signature of that function is: array.splice(index, deleteCount[, element1[,  element2 [, ...]]])\n   * So the first two elements are numbers and all the following elements are TreeNodes or Pages.\n   */\n  newInsertBatch(insertIndex) {\n    return {\n      insertNodes: [insertIndex, 0], // second element is always 0 (used as argument for deleteCount in Array#splice)\n      $animationWrapper: null,\n      lastBatchInsertIndex: function() {\n        if (this.isEmpty()) {\n          return this.insertAt();\n        }\n        return this.insertAt() + this.insertNodes.length - 3;\n      },\n      nextBatchInsertIndex: function() {\n        // only NBU knows what this means\n        return this.lastBatchInsertIndex() + (this.isEmpty() ? 1 : 2);\n      },\n      isEmpty: function() {\n        return this.insertNodes.length === 2;\n      },\n      length: function() {\n        return this.insertNodes.length - 2;\n      },\n      insertAt: function() {\n        return this.insertNodes[0];\n      },\n      setInsertAt: function(insertAt) {\n        this.insertNodes[0] = insertAt;\n      },\n      containsNode: function(node) {\n        return this.insertNodes.indexOf(node) !== -1;\n      }\n    };\n  }\n\n  checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch) {\n    if (animatedRendering && this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex() && this.viewRangeRendered.to >= insertBatch.lastBatchInsertIndex() && !insertBatch.$animationWrapper) {\n      // we are in visible area so we need a animation wrapper\n      // if parent is in visible area insert after parent else insert before first node.\n      var lastNodeIndex = insertBatch.lastBatchInsertIndex() - 1,\n        nodeBefore = this.viewRangeRendered.from === insertBatch.lastBatchInsertIndex() ? null : this.visibleNodesFlat[lastNodeIndex];\n      if (nodeBefore && lastNodeIndex >= this.viewRangeRendered.from && lastNodeIndex < this.viewRangeRendered.to && !nodeBefore.attached) {\n        // ensure node before is visible\n        this.showNode(nodeBefore, false, lastNodeIndex);\n      }\n      if (nodeBefore && nodeBefore.attached) {\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(nodeBefore.$node);\n      } else if (parentNode.attached) {\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(parentNode.$node);\n      } else if (this.$fillBefore) {\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertAfter(this.$fillBefore);\n      } else {\n        var nodeAfter = this.visibleNodesFlat[insertBatch.lastBatchInsertIndex()];\n        insertBatch.$animationWrapper = $('<div class=\"animation-wrapper\">').insertBefore(nodeAfter.$node);\n      }\n      insertBatch.animationCompleteFunc = onAnimationComplete;\n      this._$expandAnimationWrappers.push(insertBatch.$animationWrapper);\n    }\n\n    // ----- Helper functions ----- //\n\n    function onAnimationComplete() {\n      insertBatch.$animationWrapper.replaceWith(insertBatch.$animationWrapper.contents());\n      arrays.remove(this._$expandAnimationWrappers, insertBatch.$animationWrapper);\n      insertBatch.$animationWrapper = null;\n      this.runningAnimationsFinishFunc();\n    }\n  }\n\n  checkAndHandleBatch(insertBatch, parentNode, animatedRendering) {\n    if (this.viewRangeRendered.from - 1 === insertBatch.lastBatchInsertIndex()) {\n      // do immediate rendering because list could be longer\n      this.insertBatchInVisibleNodes(insertBatch, false, false);\n      insertBatch = this.newInsertBatch(insertBatch.lastBatchInsertIndex() + 1);\n    }\n    this.checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch);\n\n    if (this.viewRangeRendered.from + this.viewRangeSize - 1 === insertBatch.lastBatchInsertIndex()) {\n      // do immediate rendering because list could be longer\n      this.insertBatchInVisibleNodes(insertBatch, true, animatedRendering);\n      insertBatch = this.newInsertBatch(insertBatch.lastBatchInsertIndex() + 1);\n    }\n    return insertBatch;\n  }\n\n  insertBatchInVisibleNodes(insertBatch, showNodes, animate) {\n    if (insertBatch.isEmpty()) {\n      // nothing to add\n      return;\n    }\n    this.visibleNodesFlat.splice.apply(this.visibleNodesFlat, insertBatch.insertNodes);\n    if (showNodes) {\n      var indexHint = insertBatch.insertAt();\n      for (var i = 2; i < insertBatch.insertNodes.length; i++) {\n        var node = insertBatch.insertNodes[i];\n        this.showNode(node, false, indexHint);\n        if (insertBatch.$animationWrapper) {\n          insertBatch.$animationWrapper.append(node.$node);\n        }\n        indexHint++;\n      }\n      if (insertBatch.$animationWrapper) {\n        var h = insertBatch.$animationWrapper.outerHeight();\n        insertBatch.$animationWrapper\n          .css('height', 0)\n          .animate({\n            height: h\n          }, {\n            start: this.startAnimationFunc,\n            complete: insertBatch.animationCompleteFunc.bind(this),\n            step: this.revalidateLayoutTree.bind(this),\n            duration: 200,\n            queue: false\n          });\n      }\n    } else if (insertBatch.$animationWrapper && insertBatch.animationCompleteFunc) {\n      insertBatch.animationCompleteFunc.call(this);\n    }\n  }\n\n  _addToVisibleFlatListNoCheck(node, insertIndex, animatedRendering) {\n    arrays.insert(this.visibleNodesFlat, node, insertIndex);\n    this.visibleNodesMap[node.id] = true;\n    if (this.rendered) {\n      this.showNode(node, animatedRendering, insertIndex);\n    }\n  }\n\n  scrollTo(node, options) {\n    if (this.viewRangeRendered.size() === 0) {\n      // Cannot scroll to a node if no node is rendered\n      return;\n    }\n    if (!node.attached) {\n      this._renderViewRangeForNode(node);\n    }\n    if (!node.attached) {\n      // Node may not be visible due to the filter -> don't try to scroll because it would fail\n      return;\n    }\n    scrollbars.scrollTo(this.$data, node.$node, options);\n  }\n\n  revealSelection() {\n    if (!this.rendered) {\n      // Execute delayed because tree may be not layouted yet\n      this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n      return;\n    }\n\n    if (this.selectedNodes.length > 0) {\n      if (!this.visibleNodesMap[this.selectedNodes[0].id]) {\n        this._expandAllParentNodes(this.selectedNodes[0]);\n      }\n      this.scrollTo(this.selectedNodes[0]);\n      this.ensureExpansionVisible(this.selectedNodes[0]);\n    }\n  }\n\n  ensureExpansionVisible(node) {\n    // only scroll if treenode is in dom and the current node is selected (user triggered expansion change)\n    if (!node || !node.$node || this.selectedNodes[0] !== node) {\n      return;\n    }\n    scrollbars.ensureExpansionVisible({\n      element: node,\n      $element: node.$node,\n      $scrollable: this.get$Scrollable(),\n      isExpanded: function(element) {\n        return element.expanded;\n      },\n      getChildren: function(parent) {\n        return parent.childNodes;\n      },\n      nodePaddingLevel: this.nodePaddingLevel,\n      defaultChildHeight: this.nodeHeight\n    });\n  }\n\n  deselectAll() {\n    this.selectNodes([]);\n  }\n\n  selectNode(node, debounceSend) {\n    this.selectNodes(node, debounceSend);\n  }\n\n  selectNodes(nodes, debounceSend) {\n    nodes = arrays.ensure(nodes);\n\n    // TODO [8.0] CGU Actually, the nodes should be filtered here so that invisible nodes may not be selected\n    // But this is currently not possible because the LazyNodeFilter would not accept the nodes\n    // We would have to keep track of the clicked nodes and check them in the lazy node filter (e.g. selectedNode.parentNode.lazySelectedChildNodes[selectedNode.id] = selectedNode).\n    // But since this requires a change in setNodeExpanded as well we decided to not implement it until the TODO at _addChildrenToFlatList is solved\n\n    if (arrays.equalsIgnoreOrder(nodes, this.selectedNodes)) {\n      return;\n    }\n\n    if (this.rendered) {\n      this._rememberScrollTopBeforeSelection();\n      this._removeSelection();\n    }\n    if (this.prevSelectedNode) {\n      this.prevSelectedNode.prevSelectionAnimationDone = false;\n    }\n    this.prevSelectedNode = this.selectedNodes[0];\n    this._setSelectedNodes(nodes, debounceSend);\n    if (this.rendered) {\n      this._renderSelection();\n      this._updateScrollTopAfterSelection();\n    }\n  }\n\n  _rememberScrollTopBeforeSelection() {\n    if (this.isBreadcrumbStyleActive()) {\n      // Save the current scrollTop for future up navigation\n      if (this.selectedNodes.length > 0) {\n        this.scrollTopHistory[this.selectedNodes[0].level] = this.$data[0].scrollTop;\n      }\n    } else {\n      // Clear history if user now works with tree to not get confused when returning to bc mode\n      this.scrollTopHistory = [];\n    }\n  }\n\n  _updateScrollTopAfterSelection() {\n    if (!this.isBreadcrumbStyleActive()) {\n      return;\n    }\n    var currentLevel = -1;\n    if (this.selectedNodes.length > 0) {\n      currentLevel = this.selectedNodes[0].level;\n    }\n    // Remove positions after the current level (no restore when going down, only when going up)\n    this.scrollTopHistory.splice(currentLevel + 1);\n    // Read the scroll top for the current level and use that one if it is set\n    var scrollTopForLevel = this.scrollTopHistory[currentLevel];\n    if (scrollTopForLevel >= 0) {\n      this.setScrollTop(scrollTopForLevel);\n    }\n  }\n\n  _setSelectedNodes(nodes, debounceSend) {\n    // Make a copy so that original array stays untouched\n    this.selectedNodes = nodes.slice();\n    this._nodesSelectedInternal();\n    this._triggerNodesSelected(debounceSend);\n\n    if (this.selectedNodes.length > 0 && !this.visibleNodesMap[this.selectedNodes[0].id]) {\n      this._expandAllParentNodes(this.selectedNodes[0]);\n    }\n\n    this._updateItemPath(true);\n    if (this.isBreadcrumbStyleActive()) {\n      // In breadcrumb mode selected node has to be expanded\n      if (this.selectedNodes.length > 0 && !this.selectedNodes[0].expanded) {\n        this.expandNode(this.selectedNodes[0]);\n        this.selectedNodes[0].filterDirty = true;\n      }\n      this.filter(true);\n    }\n    this.session.onRequestsDone(this._updateMenuBar.bind(this));\n  }\n\n  /**\n   * This method is overridden by subclasses of Tree. The default impl. does nothing.\n   */\n  _nodesSelectedInternal(node) {\n    // NOP\n  }\n\n  deselectNode(node) {\n    this.deselectNodes(node);\n  }\n\n  /**\n   * @param nodes the nodes to deselect\n   * @param options.collectChildren true to add the selected children to the list of nodes to deselect\n   */\n  deselectNodes(nodes, options) {\n    nodes = arrays.ensure(nodes);\n    options = options || {};\n    if (options.collectChildren) {\n      nodes = nodes.concat(this._collectNodesIfDescendants(nodes, this.selectedNodes));\n    }\n    var selectedNodes = this.selectedNodes.slice(); // copy\n    if (arrays.removeAll(selectedNodes, nodes)) {\n      this.selectNodes(selectedNodes);\n    }\n  }\n\n  isNodeSelected(node) {\n    return this.selectedNodes.indexOf(node) > -1;\n  }\n\n  _computeNodePaddingLeft(node) {\n    this._computeNodePaddings();\n    if (this.isBreadcrumbStyleActive()) {\n      return null;\n    }\n    var padding = node.level * this.nodePaddingLevel + this.nodePaddingLeft;\n    if (this.checkable) {\n      padding += this.nodeCheckBoxPaddingLeft;\n    }\n    return padding;\n  }\n\n  /**\n   * Reads the paddings from CSS and stores them in nodePaddingLeft and nodeControlPaddingLeft\n   */\n  _computeNodePaddings() {\n    if (this.nodePaddingLeft !== null && this.nodeControlPaddingLeft !== null) {\n      return;\n    }\n    var $dummyNode = this.$data.appendDiv('tree-node');\n    var $dummyNodeControl = $dummyNode.appendDiv('tree-node-control');\n    if (this.nodePaddingLeft === null) {\n      this.nodePaddingLeft = $dummyNode.cssPaddingLeft();\n    }\n    if (this.nodeControlPaddingLeft === null) {\n      this.nodeControlPaddingLeft = $dummyNodeControl.cssPaddingLeft();\n    }\n    $dummyNode.remove();\n  }\n\n  _expandAllParentNodes(node) {\n    var i, currNode = node,\n      parentNodes = [];\n\n    currNode = node;\n    var nodesToInsert = [];\n    while (currNode.parentNode) {\n      parentNodes.push(currNode.parentNode);\n      if (!this.visibleNodesMap[currNode.id]) {\n        nodesToInsert.push(currNode);\n      }\n      currNode = currNode.parentNode;\n    }\n\n    for (i = parentNodes.length - 1; i >= 0; i--) {\n      if (nodesToInsert.indexOf(parentNodes[i]) !== -1) {\n        this._addToVisibleFlatList(parentNodes[i], false);\n      }\n      if (!parentNodes[i].expanded) {\n        this.expandNode(parentNodes[i], {\n          renderExpansion: false,\n          renderAnimated: false\n        });\n      }\n    }\n    if (this.rendered && nodesToInsert.length > 0) {\n      this._rerenderViewport();\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _updateChildNodeIndex(nodes, startIndex) {\n    if (!nodes || !nodes.length) {\n      return;\n    }\n    for (var i = scout.nvl(startIndex, 0); i < nodes.length; i++) {\n      nodes[i].childNodeIndex = i;\n    }\n  }\n\n  insertNode(node, parentNode) {\n    this.insertNodes([node], parentNode);\n  }\n\n  insertNodes(nodes, parentNode) {\n    nodes = arrays.ensure(nodes).slice();\n    this._ensureTreeNodes(nodes);\n    if (parentNode && !(parentNode instanceof TreeNode)) {\n      throw new Error('parent has to be a tree node: ' + parentNode);\n    }\n\n    // Append continuous node blocks\n    nodes.sort(function(a, b) {\n      return a.childNodeIndex - b.childNodeIndex;\n    });\n\n    // Update parent with new child nodes\n    if (parentNode) {\n      if (parentNode.childNodes && parentNode.childNodes.length > 0) {\n        nodes.forEach(function(entry) {\n          // only insert node if not already existing\n          if (parentNode.childNodes.indexOf(entry) < 0) {\n            arrays.insert(parentNode.childNodes, entry, entry.childNodeIndex);\n          }\n        });\n        this._updateChildNodeIndex(parentNode.childNodes, nodes[0].childNodeIndex);\n      } else {\n        nodes.forEach(function(entry) {\n          parentNode.childNodes.push(entry);\n        });\n      }\n      // initialize node and add to visible list if node is visible\n      Tree.visitNodes(this._initTreeNode.bind(this), nodes, parentNode);\n      Tree.visitNodes(this._updateFlatListAndSelectionPath.bind(this), nodes, parentNode);\n      if (this.groupedNodes[parentNode.id]) {\n        this._updateItemPath(false, parentNode);\n      }\n      if (this.rendered) {\n        var opts = {\n          expansionChanged: true\n        };\n        this._renderExpansion(parentNode, opts);\n        this.ensureExpansionVisible(parentNode);\n      }\n    } else {\n      if (this.nodes && this.nodes.length > 0) {\n        nodes.forEach(function(entry) {\n          // only insert node if not already existing\n          if (this.nodes.indexOf(entry) < 0) {\n            arrays.insert(this.nodes, entry, entry.childNodeIndex);\n          }\n        }.bind(this));\n        this._updateChildNodeIndex(this.nodes, nodes[0].childNodeIndex);\n      } else {\n        arrays.pushAll(this.nodes, nodes);\n      }\n      // initialize node and add to visible list if node is visible\n      Tree.visitNodes(this._initTreeNode.bind(this), nodes, parentNode);\n      Tree.visitNodes(this._updateFlatListAndSelectionPath.bind(this), nodes, parentNode);\n    }\n    if (this.rendered) {\n      this.viewRangeDirty = true;\n      this.invalidateLayoutTree();\n    }\n    this.trigger('nodesInserted', {\n      nodes: nodes,\n      parentNode: parentNode\n    });\n  }\n\n  updateNode(node) {\n    this.updateNodes([node]);\n  }\n\n  updateNodes(nodes) {\n    nodes = arrays.ensure(nodes);\n    nodes.forEach(function(updatedNode) {\n      var propertiesChanged,\n        oldNode = this.nodesMap[updatedNode.id];\n\n      // if same instance has been updated we must set the flag always to true\n      // because we cannot compare against an \"old\" node\n      if (updatedNode === oldNode) {\n        propertiesChanged = true;\n      } else {\n        this._applyNodeDefaultValues(updatedNode);\n        propertiesChanged = this._applyUpdatedNodeProperties(oldNode, updatedNode);\n      }\n\n      if (propertiesChanged) {\n        if (this._applyFiltersForNode(oldNode)) {\n          if (!oldNode.isFilterAccepted()) {\n            this._nodesFiltered([oldNode]);\n            this._removeFromFlatList(oldNode, false);\n          } else {\n            this._addToVisibleFlatList(oldNode, false);\n          }\n        }\n        this._updateItemPath(false, oldNode.parentNode);\n        if (this.rendered) {\n          oldNode._decorate();\n        }\n      }\n    }, this);\n\n    this.trigger('nodesUpdated', {\n      nodes: nodes\n    });\n  }\n\n  /**\n   * Called by _onNodesUpdated for every updated node. The function is expected to apply\n   * all updated properties from the updatedNode to the oldNode. May be overridden by\n   * subclasses so update their specific node properties.\n   *\n   * @param oldNode\n   *          The target node to be updated\n   * @param updatedNode\n   *          The new node with potentially updated properties. Default values are already applied!\n   * @returns\n   *          true if at least one property has changed, false otherwise. This value is used to\n   *          determine if the node has to be rendered again.\n   */\n  _applyUpdatedNodeProperties(oldNode, updatedNode) {\n    // Note: We only update _some_ of the properties, because everything else will be handled\n    // with separate events. --> See also: JsonTree.java/handleModelNodesUpdated()\n    var propertiesChanged = false;\n    if (oldNode.leaf !== updatedNode.leaf) {\n      oldNode.leaf = updatedNode.leaf;\n      propertiesChanged = true;\n    }\n    if (oldNode.enabled !== updatedNode.enabled) {\n      oldNode.enabled = updatedNode.enabled;\n      propertiesChanged = true;\n    }\n    if (oldNode.lazyExpandingEnabled !== updatedNode.lazyExpandingEnabled) {\n      oldNode.lazyExpandingEnabled = updatedNode.lazyExpandingEnabled;\n      // Also make sure expandedLazy is reset to false when lazyExpanding is disabled (same code as in AbstractTreeNode.setLazyExpandingEnabled)\n      if (!updatedNode.lazyExpandingEnabled || !this.lazyExpandingEnabled) {\n        oldNode.expandedLazy = false;\n      }\n      propertiesChanged = true;\n    }\n    return propertiesChanged;\n  }\n\n  deleteNode(node, parentNode) {\n    this.deleteNodes([node], parentNode);\n  }\n\n  deleteAllNodes() {\n    this.deleteAllChildNodes();\n  }\n\n  deleteNodes(nodes, parentNode) {\n    var deletedNodes = [];\n    var parentNodesToReindex = [];\n    var topLevelNodesToReindex = [];\n    nodes = arrays.ensure(nodes).slice(); // copy\n\n    nodes.forEach(function(node) {\n      var p = parentNode || node.parentNode;\n      if (p) {\n        if (node.parentNode !== p) {\n          throw new Error('Unexpected parent. Node.parent: ' + node.parentNode + ', parentNode: ' + parentNode);\n        }\n        arrays.remove(p.childNodes, node);\n        if (parentNodesToReindex.indexOf(p) === -1) {\n          parentNodesToReindex.push(p);\n        }\n      } else {\n        arrays.remove(this.nodes, node);\n        topLevelNodesToReindex = this.nodes;\n      }\n      this._destroyTreeNode(node);\n      deletedNodes.push(node);\n      this._updateMarkChildrenChecked(node, false, false);\n\n      // remove children from node map\n      Tree.visitNodes(this._destroyTreeNode.bind(this), node.childNodes);\n    }, this);\n\n    // update child node indices\n    parentNodesToReindex.forEach(function(p) {\n      this._updateChildNodeIndex(p.childNodes);\n    }, this);\n    this._updateChildNodeIndex(topLevelNodesToReindex);\n\n    this.deselectNodes(deletedNodes, {collectChildren: true});\n    this.uncheckNodes(deletedNodes, {collectChildren: true});\n\n    // remove node from html document\n    if (this.rendered) {\n      this._removeNodes(deletedNodes, parentNode || parentNodesToReindex);\n    }\n\n    this.trigger('nodesDeleted', {\n      nodes: nodes,\n      parentNode: parentNode\n    });\n  }\n\n  _collectNodesIfDescendants(nodes, nodesToCheck) {\n    var result = [];\n    nodesToCheck.forEach(function(nodeToCheck) {\n      if (nodes.some(function(node) {\n        return node.isAncestorOf(nodeToCheck);\n      })) {\n        result.push(nodeToCheck);\n      }\n    });\n    return result;\n  }\n\n  deleteAllChildNodes(parentNode) {\n    var nodes;\n    if (parentNode) {\n      nodes = parentNode.childNodes;\n      parentNode.childNodes = [];\n    } else {\n      nodes = this.nodes;\n      this.nodes = [];\n    }\n    Tree.visitNodes(updateNodeMap.bind(this), nodes);\n\n    this.deselectNodes(nodes, {collectChildren: true});\n    this.uncheckNodes(nodes, {collectChildren: true});\n\n    // remove node from html document\n    if (this.rendered) {\n      this._removeNodes(nodes, parentNode);\n    }\n\n    this.trigger('allChildNodesDeleted', {\n      parentNode: parentNode\n    });\n\n    // --- Helper functions ---\n\n    // Update model and nodemap\n    function updateNodeMap(node) {\n      this._destroyTreeNode(node);\n      this._updateMarkChildrenChecked(node, false, false);\n    }\n  }\n\n  updateNodeOrder(childNodes, parentNode) {\n    childNodes = arrays.ensure(childNodes);\n\n    this._updateChildNodeIndex(childNodes);\n    if (parentNode) {\n      if (parentNode.childNodes.length !== childNodes.length) {\n        throw new Error('Node order may not be updated because lengths of the arrays differ.');\n      }\n      // Make a copy so that original array stays untouched\n      parentNode.childNodes = childNodes.slice();\n      this._removeChildrenFromFlatList(parentNode, false);\n      if (parentNode.expanded) {\n        this._addChildrenToFlatList(parentNode, null, false);\n      }\n    } else {\n      if (this.nodes.length !== childNodes.length) {\n        throw new Error('Node order may not be updated because lengths of the arrays differ.');\n      }\n      // Make a copy so that original array stays untouched\n      this.nodes = childNodes.slice();\n      this.nodes.forEach(function(node) {\n        this._removeFromFlatList(node, false);\n        this._addToVisibleFlatList(node, false);\n        if (node.expanded) {\n          this._addChildrenToFlatList(node, null, false);\n        }\n      }, this);\n    }\n\n    this.trigger('childNodeOrderChanged', {\n      parentNode: parentNode\n    });\n  }\n\n  checkNode(node, checked, options) {\n    var opts = $.extend(options, {\n      checked: checked\n    });\n    this.checkNodes([node], opts);\n  }\n\n  checkNodes(nodes, options) {\n    var opts = {\n      checked: true,\n      checkOnlyEnabled: true,\n      checkChildren: this.autoCheckChildren,\n      triggerNodesChecked: true\n    };\n    $.extend(opts, options);\n    var updatedNodes = [];\n    // use enabled computed because when the parent of the table is disabled, it should not be allowed to check rows\n    if (!this.checkable || !this.enabledComputed && opts.checkOnlyEnabled) {\n      return;\n    }\n    nodes = arrays.ensure(nodes);\n    nodes.forEach(function(node) {\n      if (!node.enabled && opts.checkOnlyEnabled || node.checked === opts.checked) {\n        if (opts.checkChildren) {\n          this.checkNodes(node.childNodes, opts);\n        }\n        return;\n      }\n      if (!this.multiCheck && opts.checked) {\n        for (var i = 0; i < this.checkedNodes.length; i++) {\n          this.checkedNodes[i].checked = false;\n          this._updateMarkChildrenChecked(this.checkedNodes[i], false, false, true);\n          updatedNodes.push(this.checkedNodes[i]);\n        }\n        this.checkedNodes = [];\n      }\n      node.checked = opts.checked;\n      if (node.checked) {\n        this.checkedNodes.push(node);\n      } else {\n        arrays.remove(this.checkedNodes, node);\n      }\n      updatedNodes.push(node);\n      this._updateMarkChildrenChecked(node, false, opts.checked, true);\n      if (opts.checkChildren) {\n        var childOpts = $.extend({}, opts, {\n          triggerNodesChecked: false\n        });\n        this.checkNodes(node.childNodes, childOpts);\n      }\n    }, this);\n\n    if (opts.triggerNodesChecked && updatedNodes.length > 0) {\n      this.trigger('nodesChecked', {\n        nodes: updatedNodes\n      });\n    }\n    if (this.rendered) {\n      updatedNodes.forEach(function(node) {\n        node._renderChecked();\n      });\n    }\n  }\n\n  uncheckNode(node, options) {\n    var opts = $.extend({\n      checkOnlyEnabled: true\n    }, options);\n    this.uncheckNodes([node], opts);\n  }\n\n  /**\n   * @param nodes the nodes to uncheck\n   * @param options.collectChildren true to add the checked children to the list of nodes to uncheck\n   */\n  uncheckNodes(nodes, options) {\n    var opts = {\n      checked: false\n    };\n    $.extend(opts, options);\n    if (opts.collectChildren) {\n      nodes = nodes.concat(this._collectNodesIfDescendants(nodes, this.checkedNodes));\n    }\n    this.checkNodes(nodes, opts);\n  }\n\n  _triggerNodesSelected(debounce) {\n    this.trigger('nodesSelected', {\n      debounce: debounce\n    });\n  }\n\n  _showContextMenu(event) {\n    var func = function(event) {\n      if (!this.rendered) { // check needed because function is called asynchronously\n        return;\n      }\n      var filteredMenus = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true),\n        $part = $(event.currentTarget);\n      if (filteredMenus.length === 0) {\n        return; // at least one menu item must be visible\n      }\n      // Prevent firing of 'onClose'-handler during contextMenu.open()\n      // (Can lead to null-access when adding a new handler to this.contextMenu)\n      if (this.contextMenu) {\n        this.contextMenu.close();\n      }\n      this.contextMenu = scout.create('ContextMenuPopup', {\n        parent: this,\n        menuItems: filteredMenus,\n        location: {\n          x: event.pageX,\n          y: event.pageY\n        },\n        $anchor: $part,\n        menuFilter: this._filterMenusHandler\n      });\n      this.contextMenu.open();\n    };\n\n    this.session.onRequestsDone(func.bind(this), event);\n  }\n\n  _onNodeMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    if (this._doubleClickSupport.doubleClicked()) {\n      // don't execute on double click events\n      return false;\n    }\n\n    var $node = $(event.currentTarget);\n    var node = $node.data('node');\n    if (!this.hasNode(node)) {\n      // if node does not belong to this tree, do nothing (may happen if another tree is embedded inside the node)\n      return;\n    }\n    this._$mouseDownNode = $node;\n    $node.window().one('mouseup', function() {\n      this._$mouseDownNode = null;\n    }.bind(this));\n\n    this.selectNodes(node);\n\n    if (this.checkable && node.enabled && this._isCheckboxClicked(event)) {\n      if (Device.get().loosesFocusIfPseudoElementIsRemoved()) {\n        this.focusAndPreventDefault(event);\n      }\n      this.checkNode(node, !node.checked);\n    }\n    return true;\n  }\n\n  _onNodeMouseUp(event) {\n    if (this._doubleClickSupport.doubleClicked()) {\n      // don't execute on double click events\n      return false;\n    }\n\n    var $node = $(event.currentTarget);\n    var node = $node.data('node');\n    if (!this._$mouseDownNode || this._$mouseDownNode[0] !== $node[0]) {\n      // Don't accept if mouse up happens on another node than mouse down, or mousedown didn't happen on a node at all\n      return;\n    }\n\n    this.trigger('nodeClick', {\n      node: node\n    });\n    return true;\n  }\n\n  _isCheckboxClicked(event) {\n    // with CheckableStyle.CHECKBOX_TREE_NODE a click anywhere on the node should trigger the check\n    if (this.isTreeNodeCheckEnabled()) {\n      return true;\n    }\n    return $(event.target).is('.check-box');\n  }\n\n  _updateItemPath(selectionChanged, ultimate) {\n    var selectedNodes, node, level;\n    if (selectionChanged) {\n      // first remove and select selected\n      this.groupedNodes = {};\n\n      this._inSelectionPathList = {};\n    }\n\n    if (!ultimate) {\n      // find direct children\n      selectedNodes = this.selectedNodes;\n      if (selectedNodes.length === 0) {\n        return;\n      }\n      node = selectedNodes[0];\n\n      if (selectionChanged) {\n        this._inSelectionPathList[node.id] = true;\n        if (node.childNodes) {\n          node.childNodes.forEach(function(child) {\n            this._inSelectionPathList[child.id] = true;\n          }.bind(this));\n        }\n      }\n      level = node.level;\n\n      // find grouping end (ultimate parent)\n      while (node.parentNode) {\n        var parent = node.parentNode;\n        if (this._isGroupingEnd(parent) && !ultimate) {\n          ultimate = node;\n          if (!selectionChanged) {\n            break;\n          }\n        }\n        if (selectionChanged) {\n          this._inSelectionPathList[parent.id] = true;\n        }\n        node = parent;\n      }\n      // find group with same ultimate parent\n      ultimate = ultimate || selectedNodes[0];\n      this.groupedNodes[ultimate.id] = true;\n    }\n    node = ultimate;\n    if (node && node.expanded && this.groupedNodes[node.id]) {\n      addToGroup.call(this, node.childNodes);\n    }\n\n    // ------ helper function ------//\n\n    function addToGroup(nodes) {\n      nodes.forEach(function(node) {\n        this.groupedNodes[node.id] = true;\n        node._decorate();\n        if (node.expanded && node.isFilterAccepted()) {\n          addToGroup.call(this, node.childNodes);\n        }\n      }.bind(this));\n    }\n  }\n\n  _isGroupingEnd(node) {\n    // May be implemented by subclasses, default tree has no grouping parent\n    return false;\n  }\n\n  /**\n   * @returns {TreeNode} the first selected node or null when no node is selected.\n   */\n  selectedNode() {\n    if (this.selectedNodes.length === 0) {\n      return null;\n    }\n    return this.selectedNodes[0];\n  }\n\n  $selectedNodes() {\n    return this.$data.find('.selected');\n  }\n\n  $nodes() {\n    return this.$data.find('.tree-node');\n  }\n\n  /**\n   * @param filter object with createKey() and accept()\n   */\n  addFilter(filter, doNotFilter, notAnimated) {\n    if (this._filters.indexOf(filter) < 0) {\n      this._filters.push(filter);\n      if (!doNotFilter) {\n        this.filter(notAnimated);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  removeFilter(filter, notAnimated) {\n    if (arrays.remove(this._filters, filter)) {\n      this.filter(notAnimated);\n    }\n  }\n\n  filter(notAnimated) {\n    var useAnimation = Boolean(!notAnimated),\n      newHiddenNodes = [];\n    // Filter nodes\n    this.visitNodes(function(node) {\n      var changed = this._applyFiltersForNode(node);\n      if (changed) {\n        if (!node.isFilterAccepted()) {\n          arrays.pushAll(newHiddenNodes, this._removeFromFlatList(node, useAnimation));\n        } else {\n          this._addToVisibleFlatList(node, useAnimation);\n        }\n        this.viewRangeDirty = true;\n      } else {\n        // this else branch is required when the filter-state of a node has not changed\n        // for instance Node \"Telefon mit Sabrina\" is visible for filter \"tel\" and also\n        // for filter \"abr\". However, it is possible that the node is _not_ attached, when\n        // we switch from one filter to another, because the node was not in the view-range\n        // with the previous filter. That's why we must make sure, the node is attached to\n        // the DOM, even though the filter state hasn't changed. Otherwise we'd have a\n        // problem when we insert nodes in this._insertNodeInDOMAtPlace.\n        if (!node.attached) {\n          this.showNode(node, useAnimation);\n          if (node.attached) {\n            // If sibling nodes are hiding at the same time, the nodes to be shown should be added after these nodes to make the animation look correctly -> move them\n            node.$node.insertAfter(node.$node.nextAll('.hiding:last'));\n          }\n        }\n      }\n      if ((node.expanded || node.expandedLazy) && node.isFilterAccepted()) {\n        return false;\n      }\n      // don't process children->optimize performance\n      return true;\n    }.bind(this));\n\n    this._nodesFiltered(newHiddenNodes);\n  }\n\n  /**\n   * use filtered nodes are removed from visible nodes\n   */\n  filterVisibleNodes(animated) {\n    // Filter nodes\n    var newHiddenNodes = [];\n    for (var i = 0; i < this.visibleNodesFlat.length; i++) {\n      var node = this.visibleNodesFlat[i];\n      var changed = this._applyFiltersForNode(node);\n      if (changed) {\n        if (!node.isFilterAccepted()) {\n          i--;\n          arrays.pushAll(newHiddenNodes, this._removeFromFlatList(node, animated));\n        }\n        this.viewRangeDirty = true;\n      }\n    }\n\n    this._nodesFiltered(newHiddenNodes);\n  }\n\n  _nodesFiltered(hiddenNodes) {\n    // non visible nodes must be deselected\n    this.deselectNodes(hiddenNodes);\n  }\n\n  _nodeAcceptedByFilters(node) {\n    for (var i = 0; i < this._filters.length; i++) {\n      var filter = this._filters[i];\n      if (!filter.accept(node)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @returns {Boolean} true if node state has changed, false if not\n   */\n  _applyFiltersForNode(node) {\n    var changed = node.filterDirty;\n    if (this._nodeAcceptedByFilters(node)) {\n      if (!node.filterAccepted) {\n        node.filterAccepted = true;\n        changed = true;\n      }\n    } else if (node.filterAccepted) {\n      node.filterAccepted = false;\n      changed = true;\n    }\n    if (changed) {\n      node.filterDirty = false;\n      node.childNodes.forEach(function(childNode) {\n        childNode.filterDirty = true;\n      });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Just insert node in DOM. NO check if in viewRange\n   */\n  _insertNodesInDOM(nodes, indexHint) {\n    if (!this.rendered && !this.rendering) {\n      return;\n    }\n    nodes = nodes.filter(function(node) {\n      var index = indexHint === undefined ? this.visibleNodesFlat.indexOf(node) : indexHint;\n      if (index === -1 || !(this.viewRangeRendered.from + this.viewRangeSize >= index && this.viewRangeRendered.from <= index && this.viewRangeRendered.size() > 0) || node.attached) {\n        // node is not visible\n        return false;\n      }\n      if (!node.rendered) {\n        this._renderNode(node);\n      }\n      node._decorate();\n      this._insertNodeInDOMAtPlace(node, index);\n      if (this.prevSelectedNode === node) {\n        this._highlightPrevSelectedNode();\n      }\n      node.rendered = true;\n      node.attached = true;\n      return true;\n    }, this);\n    this._installNodes(nodes);\n  }\n\n  _installNodes(nodes) {\n    // The measuring is separated into 3 blocks for performance reasons -> separates reading and setting of styles\n    // 1. Prepare style for measuring\n    if (this.isHorizontalScrollingEnabled()) {\n      nodes.forEach(function(node) {\n        node.$node.css('width', 'auto');\n        node.$node.css('display', 'inline-block');\n      }, this);\n    }\n\n    // 2. Measure\n    nodes.forEach(function(node) {\n      node.height = node.$node.outerHeight(true);\n      if (!this.isHorizontalScrollingEnabled()) {\n        return;\n      }\n      var newWidth = node.$node.outerWidth();\n      var oldWidth = node.width ? node.width : 0;\n      if (oldWidth === this.maxNodeWidth && newWidth < this.maxNodeWidth) {\n        this.maxNodeWidth = 0;\n        this.nodeWidthDirty = true;\n      } else if (newWidth > this.maxNodeWidth) {\n        this.maxNodeWidth = newWidth;\n        this.nodeWidthDirty = true;\n      }\n      node.width = newWidth;\n    }, this);\n\n    // 3. Reset style\n    if (this.isHorizontalScrollingEnabled()) {\n      nodes.forEach(function(node) {\n        if (!this.nodeWidthDirty) {\n          node.$node.css('width', this.maxNodeWidth);\n        }\n        node.$node.css('display', '');\n      }, this);\n    }\n  }\n\n  /**\n   * Attaches node to DOM, if it is visible and in view range\n   * */\n  _ensureNodeInDOM(node, useAnimation, indexHint) {\n    if (node && !node.attached && node === this.visibleNodesFlat[indexHint] && indexHint >= this.viewRangeRendered.from && indexHint < this.viewRangeRendered.to) {\n      this.showNode(node, useAnimation, indexHint);\n    }\n  }\n\n  _insertNodeInDOMAtPlace(node, index) {\n    var $node = node.$node;\n\n    if (index === 0) {\n      if (this.$fillBefore) {\n        $node.insertAfter(this.$fillBefore);\n      } else {\n        this.$data.prepend($node);\n      }\n      return;\n    }\n\n    // append after index\n    var nodeBefore = this.visibleNodesFlat[index - 1];\n    this._ensureNodeInDOM(nodeBefore, false, index - 1);\n    if (nodeBefore.attached) {\n      $node.insertAfter(nodeBefore.$node);\n      return;\n    }\n\n    if (index + 1 < this.visibleNodesFlat.length) {\n      var nodeAfter = this.visibleNodesFlat[index + 1];\n      if (nodeAfter.attached) {\n        $node.insertBefore(nodeAfter.$node);\n        return;\n      }\n    }\n\n    // used when the tree is scrolled\n    if (this.$fillBefore) {\n      $node.insertAfter(this.$fillBefore);\n    } else {\n      this.$data.prepend($node);\n    }\n  }\n\n  showNode(node, useAnimation, indexHint) {\n    if (!this.rendered || (node.attached && !node.$node.hasClass('hiding'))) {\n      return;\n    }\n    if (!node.attached) {\n      this._ensureNodeInDOM(node.parentNode, useAnimation, indexHint - 1);\n      this._insertNodesInDOM([node], indexHint);\n    }\n    if (!node.rendered) {\n      return;\n    }\n    var $node = node.$node;\n    if ($node.is('.showing')) {\n      return;\n    }\n    $node.addClass('showing');\n    $node.removeClass('hiding');\n    var that = this;\n    if (useAnimation) {\n      // hide node first and then make it appear using slideDown (setVisible(false) won't work because it would stay invisible during the animation)\n      $node.hide();\n      $node.stop(false, true).slideDown({\n        duration: 250,\n        start: that.startAnimationFunc,\n        complete: function() {\n          that.runningAnimationsFinishFunc();\n          $node.removeClass('showing');\n        }\n      });\n    }\n  }\n\n  hideNode(node, useAnimation, suppressDetachHandling) {\n    if (!node.attached) {\n      return;\n    }\n    this.viewRangeDirty = true;\n    var that = this,\n      $node = node.$node;\n    if (!$node) {\n      // node is not rendered\n      return;\n    }\n\n    if ($node.is('.hiding')) {\n      return;\n    }\n\n    $node.addClass('hiding');\n    $node.removeClass('showing');\n    if (useAnimation) {\n      this._renderViewportBlocked = true;\n      $node.stop(false, true).slideUp({\n        duration: 250,\n        start: that.startAnimationFunc,\n        complete: function() {\n          that.runningAnimationsFinishFunc();\n          $node.removeClass('hiding');\n          if (!$node.hasClass('showing')) {\n            $node.detach();\n            node.attached = false;\n          }\n        }\n      });\n    } else if (!suppressDetachHandling) {\n      $node.detach();\n      node.attached = false;\n      that.invalidateLayoutTree();\n    }\n  }\n\n  _nodesToIds(nodes) {\n    return nodes.map(function(node) {\n      return node.id;\n    });\n  }\n\n  _nodesByIds(ids) {\n    return ids.map(function(id) {\n      return this.nodesMap[id];\n    }.bind(this));\n  }\n\n  _nodeById(id) {\n    return this.nodesMap[id];\n  }\n\n  /**\n   * Checks whether the given node is contained in the tree. Uses the id of the node for the lookup.\n   */\n  hasNode(node) {\n    return Boolean(this._nodeById(node.id));\n  }\n\n  _onNodeDoubleClick(event) {\n    if (this.isBreadcrumbStyleActive()) {\n      return;\n    }\n\n    var $node = $(event.currentTarget);\n    var node = $node.data('node');\n    var expanded = !$node.hasClass('expanded');\n    this.doNodeAction(node, expanded);\n  }\n\n  doNodeAction(node, expanded) {\n    this.trigger('nodeAction', {\n      node: node\n    });\n\n    // For CheckableStyle.CHECKBOX_TREE_NODE expand on double click is only enabled for disabled nodes. Otherwise it would conflict with the \"check on node click\" behavior.\n    if (!(this.checkable === true && this.isTreeNodeCheckEnabled() && node.enabled)) {\n      this.setNodeExpanded(node, expanded, {\n        lazy: false // always show all nodes on node double click\n      });\n    }\n  }\n\n  _onNodeControlMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    if (this._doubleClickSupport.doubleClicked()) {\n      // don't execute on double click events\n      return false;\n    }\n\n    var $node = $(event.currentTarget).parent();\n    var node = $node.data('node');\n    var expanded = !$node.hasClass('expanded');\n    var expansionOpts = {\n      lazy: false // always show all nodes when the control gets clicked\n    };\n\n    // Click on \"show all\" control shows all nodes\n    if ($node.hasClass('lazy')) {\n      if (event.ctrlKey || event.shiftKey) {\n        // Collapse\n        expanded = false;\n        expansionOpts.collapseChildNodes = true;\n      } else {\n        // Show all nodes\n        this.expandNode(node, expansionOpts);\n        return false;\n      }\n    }\n    // Because we suppress handling by browser we have to set focus manually\n    if (this.requestFocusOnNodeControlMouseDown) {\n      this.focus();\n    }\n    this.selectNodes(node); // <---- ### 1\n    this.setNodeExpanded(node, expanded, expansionOpts); // <---- ### 2\n    // prevent bubbling to _onNodeMouseDown()\n    $.suppressEvent(event);\n\n    // ...but return true, so Outline.js can override this method and check if selection has been changed or not\n    return true;\n  }\n\n  _onNodeControlMouseUp(event) {\n    // prevent bubbling to _onNodeMouseUp()\n    return false;\n  }\n\n  _onNodeControlDoubleClick(event) {\n    // prevent bubbling to _onNodeDoubleClick()\n    return false;\n  }\n\n  _onContextMenu(event) {\n    event.preventDefault();\n    this._showContextMenu(event);\n  }\n\n  changeNode(node) {\n    if (this._applyFiltersForNode(node)) {\n      if (node.isFilterAccepted()) {\n        this._addToVisibleFlatList(node, false);\n      } else {\n        this._removeFromFlatList(node, false);\n      }\n    }\n    if (this.rendered) {\n      node._decorate();\n    }\n    this.trigger('nodeChanged', {\n      node: node\n    });\n  }\n\n  // same as on Table.prototype._onDesktopPopupOpen\n  _onDesktopPopupOpen(event) {\n    var popup = event.popup;\n    if (!this.enabledComputed) {\n      return;\n    }\n    // Set tree style to focused if a context menu or a menu bar popup opens, so that it looks as it still has the focus\n    if (this.has(popup) && popup instanceof ContextMenuPopup) {\n      this.$container.addClass('focused');\n      popup.one('destroy', function() {\n        if (this.rendered) {\n          this.$container.removeClass('focused');\n        }\n      }.bind(this));\n    }\n  }\n\n  updateScrollbars() {\n    scrollbars.update(this.$data);\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * @memberOf Tree\n   */\n  static collectSubtree($rootNode, includeRootNodeInResult) {\n    if (!$rootNode) {\n      return $();\n    }\n    var rootLevel = parseFloat($rootNode.attr('data-level'));\n    // Find first node after the root element that has the same or a lower level\n    var $nextNode = $rootNode.next();\n    while ($nextNode.length > 0) {\n      var level = parseFloat($nextNode.attr('data-level'));\n      if (isNaN(level) || level <= rootLevel) {\n        break;\n      }\n      $nextNode = $nextNode.next();\n    }\n\n    // The result set consists of all nodes between the root node and the found node\n    var $result = $rootNode.nextUntil($nextNode);\n    if (includeRootNodeInResult === undefined || includeRootNodeInResult) {\n      $result = $result.add($rootNode);\n    }\n    return $result;\n  }\n\n  /**\n   * pre-order (top-down) traversal of the tree-nodes provided.<br>\n   * if func returns true the children of the visited node are not visited.\n   */\n  static visitNodes(func, nodes, parentNode) {\n    var i, node;\n    if (!nodes) {\n      return;\n    }\n\n    for (i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      var doNotProcessChildren = func(node, parentNode);\n      if (!doNotProcessChildren && node.childNodes.length > 0) {\n        Tree.visitNodes(func, node.childNodes, node);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}