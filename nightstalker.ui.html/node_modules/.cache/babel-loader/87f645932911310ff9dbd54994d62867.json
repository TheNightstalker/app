{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { objects } from '../index';\n/**\n * The PromiseCreator is used to work with code that creates a lot of promises.\n * In some situations (e.g. file system access) only a few of the created promises can actually do work\n * all other promises must \"wait\" until, the browser finally excecutes the promise. All these promises\n * create some overhead. This class is used to prevent that, by delaying the creation of each promise\n * until the next() function is called. Typically the next function is not called until the previous\n * (one or more) promises have been executed.\n *\n * @constructor\n */\n\nvar PromiseCreator = /*#__PURE__*/function () {\n  function PromiseCreator(items) {\n    _classCallCheck(this, PromiseCreator);\n\n    this.results = [];\n    this.error = null;\n    this.items = items;\n    this.currentItem = 0;\n    this.aborted = false;\n  }\n\n  _createClass(PromiseCreator, [{\n    key: \"hasNext\",\n    value: function hasNext() {\n      if (this.error || this.aborted) {\n        return false;\n      }\n\n      return this.currentItem < this.items.length;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var thisItem = this.currentItem;\n      return this.createPromise().done(function () {\n        this._addResults.apply(this, [thisItem, objects.argumentsToArray(arguments)]);\n      }.bind(this)).fail(function () {\n        this.error = arguments.length > 0 ? arguments : new Error('Promise execution failed');\n      }.bind(this));\n    }\n  }, {\n    key: \"createPromise\",\n    value: function createPromise() {\n      if (this.currentItem >= this.items.length) {\n        throw new Error('items out of bounds');\n      }\n\n      var promise = this._createPromise();\n\n      this.currentItem++;\n      return promise;\n    }\n  }, {\n    key: \"_createPromise\",\n    value: function _createPromise() {\n      return this.items[this.currentItem]();\n    }\n  }, {\n    key: \"_addResults\",\n    value: function _addResults(index, result) {\n      if (result.length === 0) {\n        result = undefined;\n      } else if (result.length === 1) {\n        result = result[0];\n      }\n\n      this.results[index] = result;\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this.aborted = true;\n    }\n  }]);\n\n  return PromiseCreator;\n}();\n\nexport { PromiseCreator as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/util/PromiseCreator.js"],"names":["objects","PromiseCreator","items","results","error","currentItem","aborted","length","thisItem","createPromise","done","_addResults","apply","argumentsToArray","arguments","bind","fail","Error","promise","_createPromise","index","result","undefined"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,OAAR,QAAsB,UAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,c;AAEnB,0BAAYC,KAAZ,EAAmB;AAAA;;AACjB,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,KAAL,GAAa,IAAb;AAEA,SAAKF,KAAL,GAAaA,KAAb;AACA,SAAKG,WAAL,GAAmB,CAAnB;AACA,SAAKC,OAAL,GAAe,KAAf;AACD;;;;8BAES;AACR,UAAI,KAAKF,KAAL,IAAc,KAAKE,OAAvB,EAAgC;AAC9B,eAAO,KAAP;AACD;;AACD,aAAO,KAAKD,WAAL,GAAmB,KAAKH,KAAL,CAAWK,MAArC;AACD;;;2BAEM;AACL,UAAIC,QAAQ,GAAG,KAAKH,WAApB;AACA,aAAO,KAAKI,aAAL,GACJC,IADI,CACC,YAAW;AACf,aAAKC,WAAL,CAAiBC,KAAjB,CAAuB,IAAvB,EAA6B,CAACJ,QAAD,EAAWR,OAAO,CAACa,gBAAR,CAAyBC,SAAzB,CAAX,CAA7B;AACD,OAFK,CAEJC,IAFI,CAEC,IAFD,CADD,EAIJC,IAJI,CAIC,YAAW;AACf,aAAKZ,KAAL,GAAaU,SAAS,CAACP,MAAV,GAAmB,CAAnB,GAAuBO,SAAvB,GAAmC,IAAIG,KAAJ,CAAU,0BAAV,CAAhD;AACD,OAFK,CAEJF,IAFI,CAEC,IAFD,CAJD,CAAP;AAOD;;;oCAEe;AACd,UAAI,KAAKV,WAAL,IAAoB,KAAKH,KAAL,CAAWK,MAAnC,EAA2C;AACzC,cAAM,IAAIU,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAED,UAAIC,OAAO,GAAG,KAAKC,cAAL,EAAd;;AACA,WAAKd,WAAL;AACA,aAAOa,OAAP;AACD;;;qCAEgB;AACf,aAAO,KAAKhB,KAAL,CAAW,KAAKG,WAAhB,GAAP;AACD;;;gCAEWe,K,EAAOC,M,EAAQ;AACzB,UAAIA,MAAM,CAACd,MAAP,KAAkB,CAAtB,EAAyB;AACvBc,QAAAA,MAAM,GAAGC,SAAT;AACD,OAFD,MAEO,IAAID,MAAM,CAACd,MAAP,KAAkB,CAAtB,EAAyB;AAC9Bc,QAAAA,MAAM,GAAGA,MAAM,CAAC,CAAD,CAAf;AACD;;AACD,WAAKlB,OAAL,CAAaiB,KAAb,IAAsBC,MAAtB;AACD;;;4BAEO;AACN,WAAKf,OAAL,GAAe,IAAf;AACD;;;;;;SAtDkBL,c","sourcesContent":["/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {objects} from '../index';\n\n/**\n * The PromiseCreator is used to work with code that creates a lot of promises.\n * In some situations (e.g. file system access) only a few of the created promises can actually do work\n * all other promises must \"wait\" until, the browser finally excecutes the promise. All these promises\n * create some overhead. This class is used to prevent that, by delaying the creation of each promise\n * until the next() function is called. Typically the next function is not called until the previous\n * (one or more) promises have been executed.\n *\n * @constructor\n */\nexport default class PromiseCreator {\n\n  constructor(items) {\n    this.results = [];\n    this.error = null;\n\n    this.items = items;\n    this.currentItem = 0;\n    this.aborted = false;\n  }\n\n  hasNext() {\n    if (this.error || this.aborted) {\n      return false;\n    }\n    return this.currentItem < this.items.length;\n  }\n\n  next() {\n    var thisItem = this.currentItem;\n    return this.createPromise()\n      .done(function() {\n        this._addResults.apply(this, [thisItem, objects.argumentsToArray(arguments)]);\n      }.bind(this))\n      .fail(function() {\n        this.error = arguments.length > 0 ? arguments : new Error('Promise execution failed');\n      }.bind(this));\n  }\n\n  createPromise() {\n    if (this.currentItem >= this.items.length) {\n      throw new Error('items out of bounds');\n    }\n\n    var promise = this._createPromise();\n    this.currentItem++;\n    return promise;\n  }\n\n  _createPromise() {\n    return this.items[this.currentItem]();\n  }\n\n  _addResults(index, result) {\n    if (result.length === 0) {\n      result = undefined;\n    } else if (result.length === 1) {\n      result = result[0];\n    }\n    this.results[index] = result;\n  }\n\n  abort() {\n    this.aborted = true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}