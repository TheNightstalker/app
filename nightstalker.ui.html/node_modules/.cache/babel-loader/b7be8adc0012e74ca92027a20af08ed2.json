{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, objects, scout, strings } from '../index';\nimport $ from 'jquery';\n/**\n * Represents a robust \"call\" that, when it fails, is retried automatically for a specific\n * number of times, before failing ultimately. The call implementation must be provided\n * by a subclass by overriding the _callImpl() method.\n */\n\nvar Call = /*#__PURE__*/function () {\n  function Call() {\n    _classCallCheck(this, Call);\n\n    // Delays in ms between retries (from left to right). The call eventually fails when this list gets empty.\n    // Example: [100, 500, 500, 500]\n    this.retryIntervals = []; // Minimal assumed call duration (throttles consecutive calls)\n\n    this.minCallDuration = 500; // ms\n    // Counts how many times this call was actually performed (normally, only 1 try is expected)\n\n    this.callCounter = 0;\n    this.deferred = $.Deferred();\n    this.aborted = false;\n    this.pendingCall = null;\n    this.type = null; // Identifier for the type of call (default is 'call'), used to build the uniqueName\n\n    this.name = null; // Identifier for the call, used to build the uniqueName\n\n    this.uniqueName = null; // Unique identifier of this call instance for logging and debugging purposes\n\n    this.logPrefix = ''; // All log messages are prefixed with this string. It contains the uniqueName and the current state (e.g. callCounter)\n    // Temporary store for the arguments to the done/fail callbacks of the _callImpl() function.\n    // They will be used be _resolve() and _reject(). We could pass them through the _onCallX functions,\n    // but when a call is aborted while it is only scheduled (setTimeout), we would not have any values\n    // to pass to _reject().\n\n    this.result = null;\n  }\n\n  _createClass(Call, [{\n    key: \"init\",\n    value: function init(model) {\n      $.extend(this, model); // Ensure \"retryIntervals\" is a valid array\n\n      if (typeof this.maxRetries === 'number') {\n        this.retryIntervals = arrays.init(this.maxRetries, 0);\n      } else {\n        // Do not modify the passed value -> create a copy\n        this.retryIntervals = this.retryIntervals ? this.retryIntervals.slice() : []; // Remember initial number of retries (for logging)\n\n        this.maxRetries = this.retryIntervals.length;\n      } // Assign a unique name to the call to help distinguish different calls in the log\n\n\n      this.uniqueName = scout.nvl(this.type, 'call') + '-' + Call.GLOBAL_SEQ++ + strings.box(' ', this.name, '');\n      this.initialized = true;\n    }\n  }, {\n    key: \"_checkInitialized\",\n    value: function _checkInitialized() {\n      if (!this.initialized) {\n        throw new Error('Not initialized');\n      }\n    }\n  }, {\n    key: \"_updateLogPrefix\",\n    value: function _updateLogPrefix() {\n      this.logPrefix = this.callCounter + '/' + (this.maxRetries + 1) + ' [' + this.uniqueName + '] ';\n    }\n  }, {\n    key: \"_resolve\",\n    value: function _resolve() {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + '[RESOLVE]');\n      this.deferred.resolve.apply(this.deferred, arrays.ensure(this.result));\n    }\n  }, {\n    key: \"_reject\",\n    value: function _reject() {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + '[REJECT]');\n      this.deferred.reject.apply(this.deferred, arrays.ensure(this.result));\n    }\n  }, {\n    key: \"_setResult\",\n    value: function _setResult() {\n      this.result = objects.argumentsToArray(arguments);\n    } // ==================================================================================\n\n    /**\n     * Performs the call with retries.\n     *\n     * Returns a promise that is ...\n     * ... RESOLVED when the call was successful (possibly after some retries).\n     * ... REJECTED when the call failed and no more retries are possible.\n     *\n     *\n     *     | (promise)\n     *     |   ^\n     *     v   |\n     *   +--------+           +---------+           .---------------.  (yes)\n     *   | call() | . . . . . | _call() | ------>  <    success?     > ------> [RESOLVE]\n     *   +--------+           +---------+           '---------------'\n     *                             ^                       |(no)\n     *                             |                       |\n     *                             |                       v\n     *                             |                .---------------.  (yes)\n     *                             |               <    aborted?     > ------> [REJECT]\n     *                             |                '---------------'\n     *                             |                       |(no)\n     *                             |                       |\n     *                             |                       v\n     *                             |                .---------------.  (no)\n     *                             |               < retry possible? > ------> [REJECT]\n     *                             |                '---------------'\n     *                             |                       |(yes)\n     *                             |        sleep          |\n     *                             +-------- %%% ----------+\n     */\n\n  }, {\n    key: \"call\",\n    value: function call() {\n      this._checkInitialized();\n\n      this._call();\n\n      return this.deferred.promise();\n    }\n    /**\n     * Aborts the call. If the request is currently running, it is aborted (interrupted).\n     * If a retry is scheduled, that retry is cancelled.\n     *\n     * The promise returned by call() is REJECTED.\n     */\n\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._checkInitialized();\n\n      this._abort();\n    } // ==================================================================================\n\n  }, {\n    key: \"_call\",\n    value: function _call() {\n      if (this.aborted) {\n        throw new Error('Call is aborted');\n      }\n\n      this.callTimeoutId = null;\n      this.callStartTimestamp = Date.now();\n      this.callCounter++;\n\n      this._updateLogPrefix();\n\n      this.pendingCall = this._callImpl().always(function () {\n        this.pendingCall = null;\n      }.bind(this)).done(this._setResultDone.bind(this)).done(this._onCallDone.bind(this)).fail(this._setResultFail.bind(this)).fail(this._onCallFail.bind(this));\n    }\n    /**\n     * Performs the actual request.\n     *\n     * >>> This method MUST be implemented by a subclass. <<<\n     */\n\n  }, {\n    key: \"_callImpl\",\n    value: function _callImpl() {\n      throw new Error('Missing implementation: _callImpl()');\n    }\n  }, {\n    key: \"_setResultDone\",\n    value: function _setResultDone() {\n      this._setResult.apply(this, arguments);\n    }\n  }, {\n    key: \"_setResultFail\",\n    value: function _setResultFail() {\n      this._setResult.apply(this, arguments);\n    }\n  }, {\n    key: \"_onCallDone\",\n    value: function _onCallDone() {\n      // Call successful -> RESOLVE\n      this._resolve();\n    }\n  }, {\n    key: \"_onCallFail\",\n    value: function _onCallFail() {\n      // Aborted? -> REJECT\n      if (this.aborted) {\n        $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Call aborted');\n\n        this._reject();\n\n        return;\n      } // Retry impossible? -> REJECT\n\n\n      var nextInterval = this._nextRetryImpl.apply(this, arguments);\n\n      if (typeof nextInterval !== 'number') {\n        $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'No retries remaining');\n\n        this._reject();\n\n        return;\n      } // Retry\n\n\n      var callDuration = Date.now() - this.callStartTimestamp;\n      var additionalDelay = Math.max(this.minCallDuration - callDuration, 0);\n      var retryInterval = nextInterval + additionalDelay;\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Try again in ' + retryInterval + ' ms...');\n      this.callTimeoutId = setTimeout(this._call.bind(this), retryInterval);\n    }\n    /**\n     * Checks if the call can be retried. If a number is returned, a retry is performed\n     * with a delay of the corresponding amount of milliseconds.\n     *\n     * All other values indicate that no retry must be performed. (It is recommended\n     * to return 'false' or 'null' in this case.)\n     *\n     * >>> This method MAY be overridden by a subclass. <<<\n     */\n\n  }, {\n    key: \"_nextRetryImpl\",\n    value: function _nextRetryImpl() {\n      if (this.retryIntervals.length) {\n        return this.retryIntervals.shift();\n      }\n\n      return false;\n    } // ==================================================================================\n\n  }, {\n    key: \"_abort\",\n    value: function _abort() {\n      this.aborted = true; // Abort while waiting for the next retry (there is no running call)\n\n      if (this.callTimeoutId) {\n        $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Cancelled scheduled retry');\n        clearTimeout(this.callTimeoutId);\n        this.callTimeoutId = null;\n\n        this._reject();\n\n        return;\n      } // Abort a running call\n\n\n      this._abortImpl();\n    }\n    /**\n     * >>> This method MAY be overridden by a subclass. <<<\n     */\n\n  }, {\n    key: \"_abortImpl\",\n    value: function _abortImpl() {\n      if (this.pendingCall && typeof this.pendingCall.abort === 'function') {\n        this.pendingCall.abort();\n      }\n    }\n  }]);\n\n  return Call;\n}();\n\n_defineProperty(Call, \"GLOBAL_SEQ\", 0);\n\nexport { Call as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/util/Call.js"],"names":["arrays","objects","scout","strings","$","Call","retryIntervals","minCallDuration","callCounter","deferred","Deferred","aborted","pendingCall","type","name","uniqueName","logPrefix","result","model","extend","maxRetries","init","slice","length","nvl","GLOBAL_SEQ","box","initialized","Error","log","isTraceEnabled","trace","resolve","apply","ensure","reject","argumentsToArray","arguments","_checkInitialized","_call","promise","_abort","callTimeoutId","callStartTimestamp","Date","now","_updateLogPrefix","_callImpl","always","bind","done","_setResultDone","_onCallDone","fail","_setResultFail","_onCallFail","_setResult","_resolve","_reject","nextInterval","_nextRetryImpl","callDuration","additionalDelay","Math","max","retryInterval","setTimeout","shift","clearTimeout","_abortImpl","abort"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, objects, scout, strings} from '../index';\nimport $ from 'jquery';\n\n/**\n * Represents a robust \"call\" that, when it fails, is retried automatically for a specific\n * number of times, before failing ultimately. The call implementation must be provided\n * by a subclass by overriding the _callImpl() method.\n */\nexport default class Call {\n\n  constructor() {\n    // Delays in ms between retries (from left to right). The call eventually fails when this list gets empty.\n    // Example: [100, 500, 500, 500]\n    this.retryIntervals = [];\n\n    // Minimal assumed call duration (throttles consecutive calls)\n    this.minCallDuration = 500; // ms\n\n    // Counts how many times this call was actually performed (normally, only 1 try is expected)\n    this.callCounter = 0;\n\n    this.deferred = $.Deferred();\n    this.aborted = false;\n    this.pendingCall = null;\n    this.type = null; // Identifier for the type of call (default is 'call'), used to build the uniqueName\n    this.name = null; // Identifier for the call, used to build the uniqueName\n    this.uniqueName = null; // Unique identifier of this call instance for logging and debugging purposes\n    this.logPrefix = ''; // All log messages are prefixed with this string. It contains the uniqueName and the current state (e.g. callCounter)\n\n    // Temporary store for the arguments to the done/fail callbacks of the _callImpl() function.\n    // They will be used be _resolve() and _reject(). We could pass them through the _onCallX functions,\n    // but when a call is aborted while it is only scheduled (setTimeout), we would not have any values\n    // to pass to _reject().\n    this.result = null;\n  }\n\n  static GLOBAL_SEQ = 0;\n\n  init(model) {\n    $.extend(this, model);\n\n    // Ensure \"retryIntervals\" is a valid array\n    if (typeof this.maxRetries === 'number') {\n      this.retryIntervals = arrays.init(this.maxRetries, 0);\n    } else {\n      // Do not modify the passed value -> create a copy\n      this.retryIntervals = (this.retryIntervals ? this.retryIntervals.slice() : []);\n      // Remember initial number of retries (for logging)\n      this.maxRetries = this.retryIntervals.length;\n    }\n\n    // Assign a unique name to the call to help distinguish different calls in the log\n    this.uniqueName = scout.nvl(this.type, 'call') + '-' + (Call.GLOBAL_SEQ++) + strings.box(' ', this.name, '');\n\n    this.initialized = true;\n  }\n\n  _checkInitialized() {\n    if (!this.initialized) {\n      throw new Error('Not initialized');\n    }\n  }\n\n  _updateLogPrefix() {\n    this.logPrefix = this.callCounter + '/' + (this.maxRetries + 1) + ' [' + this.uniqueName + '] ';\n  }\n\n  _resolve() {\n    $.log.isTraceEnabled() && $.log.trace(this.logPrefix + '[RESOLVE]');\n    this.deferred.resolve.apply(this.deferred, arrays.ensure(this.result));\n  }\n\n  _reject() {\n    $.log.isTraceEnabled() && $.log.trace(this.logPrefix + '[REJECT]');\n    this.deferred.reject.apply(this.deferred, arrays.ensure(this.result));\n  }\n\n  _setResult() {\n    this.result = objects.argumentsToArray(arguments);\n  }\n\n  // ==================================================================================\n\n  /**\n   * Performs the call with retries.\n   *\n   * Returns a promise that is ...\n   * ... RESOLVED when the call was successful (possibly after some retries).\n   * ... REJECTED when the call failed and no more retries are possible.\n   *\n   *\n   *     | (promise)\n   *     |   ^\n   *     v   |\n   *   +--------+           +---------+           .---------------.  (yes)\n   *   | call() | . . . . . | _call() | ------>  <    success?     > ------> [RESOLVE]\n   *   +--------+           +---------+           '---------------'\n   *                             ^                       |(no)\n   *                             |                       |\n   *                             |                       v\n   *                             |                .---------------.  (yes)\n   *                             |               <    aborted?     > ------> [REJECT]\n   *                             |                '---------------'\n   *                             |                       |(no)\n   *                             |                       |\n   *                             |                       v\n   *                             |                .---------------.  (no)\n   *                             |               < retry possible? > ------> [REJECT]\n   *                             |                '---------------'\n   *                             |                       |(yes)\n   *                             |        sleep          |\n   *                             +-------- %%% ----------+\n   */\n  call() {\n    this._checkInitialized();\n    this._call();\n    return this.deferred.promise();\n  }\n\n  /**\n   * Aborts the call. If the request is currently running, it is aborted (interrupted).\n   * If a retry is scheduled, that retry is cancelled.\n   *\n   * The promise returned by call() is REJECTED.\n   */\n  abort() {\n    this._checkInitialized();\n    this._abort();\n  }\n\n  // ==================================================================================\n\n  _call() {\n    if (this.aborted) {\n      throw new Error('Call is aborted');\n    }\n\n    this.callTimeoutId = null;\n    this.callStartTimestamp = Date.now();\n    this.callCounter++;\n    this._updateLogPrefix();\n\n    this.pendingCall = this._callImpl()\n      .always(function() {\n        this.pendingCall = null;\n      }.bind(this))\n      .done(this._setResultDone.bind(this))\n      .done(this._onCallDone.bind(this))\n      .fail(this._setResultFail.bind(this))\n      .fail(this._onCallFail.bind(this));\n  }\n\n  /**\n   * Performs the actual request.\n   *\n   * >>> This method MUST be implemented by a subclass. <<<\n   */\n  _callImpl() {\n    throw new Error('Missing implementation: _callImpl()');\n  }\n\n  _setResultDone() {\n    this._setResult.apply(this, arguments);\n  }\n\n  _setResultFail() {\n    this._setResult.apply(this, arguments);\n  }\n\n  _onCallDone() {\n    // Call successful -> RESOLVE\n    this._resolve();\n  }\n\n  _onCallFail() {\n    // Aborted? -> REJECT\n    if (this.aborted) {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Call aborted');\n      this._reject();\n      return;\n    }\n\n    // Retry impossible? -> REJECT\n    var nextInterval = this._nextRetryImpl.apply(this, arguments);\n    if (typeof nextInterval !== 'number') {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'No retries remaining');\n      this._reject();\n      return;\n    }\n\n    // Retry\n    var callDuration = Date.now() - this.callStartTimestamp;\n    var additionalDelay = Math.max(this.minCallDuration - callDuration, 0);\n    var retryInterval = nextInterval + additionalDelay;\n    $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Try again in ' + retryInterval + ' ms...');\n    this.callTimeoutId = setTimeout(this._call.bind(this), retryInterval);\n  }\n\n  /**\n   * Checks if the call can be retried. If a number is returned, a retry is performed\n   * with a delay of the corresponding amount of milliseconds.\n   *\n   * All other values indicate that no retry must be performed. (It is recommended\n   * to return 'false' or 'null' in this case.)\n   *\n   * >>> This method MAY be overridden by a subclass. <<<\n   */\n  _nextRetryImpl() {\n    if (this.retryIntervals.length) {\n      return this.retryIntervals.shift();\n    }\n    return false;\n  }\n\n  // ==================================================================================\n\n  _abort() {\n    this.aborted = true;\n\n    // Abort while waiting for the next retry (there is no running call)\n    if (this.callTimeoutId) {\n      $.log.isTraceEnabled() && $.log.trace(this.logPrefix + 'Cancelled scheduled retry');\n      clearTimeout(this.callTimeoutId);\n      this.callTimeoutId = null;\n      this._reject();\n      return;\n    }\n\n    // Abort a running call\n    this._abortImpl();\n  }\n\n  /**\n   * >>> This method MAY be overridden by a subclass. <<<\n   */\n  _abortImpl() {\n    if (this.pendingCall && typeof this.pendingCall.abort === 'function') {\n      this.pendingCall.abort();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}