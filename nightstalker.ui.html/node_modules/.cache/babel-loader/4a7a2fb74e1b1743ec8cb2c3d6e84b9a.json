{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, ContextMenuPopupLayout, HtmlComponent, MenuDestinations, menuNavigationKeyStrokes, Popup, PopupWithHead, RowLayout, scrollbars } from '../index';\nimport $ from 'jquery';\n\nvar ContextMenuPopup = /*#__PURE__*/function (_PopupWithHead) {\n  _inherits(ContextMenuPopup, _PopupWithHead);\n\n  var _super = _createSuper(ContextMenuPopup);\n\n  function ContextMenuPopup() {\n    var _this;\n\n    _classCallCheck(this, ContextMenuPopup);\n\n    _this = _super.call(this); // Make sure head won't be rendered, there is a css selector which is applied only if there is a head\n\n    _this._headVisible = false;\n    _this.menuItems = [];\n    _this.cloneMenuItems = true;\n    _this._toggleSubMenuQueue = [];\n    _this.repositionEnabled = true;\n    return _this;\n  }\n\n  _createClass(ContextMenuPopup, [{\n    key: \"_init\",\n    value: function _init(options) {\n      options.focusableContainer = true; // In order to allow keyboard navigation, the popup must gain focus. Because menu-items are not focusable, make the container focusable instead.\n      // If menu items are cloned, don't link the original menus with the popup, otherwise they would be removed when the context menu is removed\n\n      if (options.cloneMenuItems === false) {\n        this._addWidgetProperties('menuItems');\n      }\n\n      _get(_getPrototypeOf(ContextMenuPopup.prototype), \"_init\", this).call(this, options);\n    }\n    /**\n     * @override Popup.js\n     */\n\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      _get(_getPrototypeOf(ContextMenuPopup.prototype), \"_initKeyStrokeContext\", this).call(this);\n\n      menuNavigationKeyStrokes.registerKeyStrokes(this.keyStrokeContext, this, 'menu-item');\n    }\n  }, {\n    key: \"_createLayout\",\n    value: function _createLayout() {\n      return new ContextMenuPopupLayout(this);\n    }\n  }, {\n    key: \"_createBodyLayout\",\n    value: function _createBodyLayout() {\n      return new RowLayout({\n        pixelBasedSizing: false\n      });\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      _get(_getPrototypeOf(ContextMenuPopup.prototype), \"_render\", this).call(this);\n\n      this._installScrollbars();\n\n      this._renderMenuItems();\n    }\n    /**\n     * @param [options]\n     * @override\n     */\n\n  }, {\n    key: \"_installScrollbars\",\n    value: function _installScrollbars(options) {\n      _get(_getPrototypeOf(ContextMenuPopup.prototype), \"_installScrollbars\", this).call(this, {\n        axis: 'y'\n      });\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"get$Scrollable\",\n    value: function get$Scrollable() {\n      return this.$body;\n    }\n  }, {\n    key: \"removeSubMenuItems\",\n    value: function removeSubMenuItems(parentMenu, animated) {\n      if (!this.rendered && !this.rendering) {\n        return;\n      }\n\n      if (this.bodyAnimating) {\n        // Let current animation finish and execute afterwards to prevent an unpredictable behavior and inconsistent state\n        this._toggleSubMenuQueue.push(this.removeSubMenuItems.bind(this, parentMenu, animated));\n\n        return;\n      }\n\n      this.$body = parentMenu.__originalParent.$subMenuBody; // move new body to back\n\n      this.$body.insertBefore(parentMenu.$subMenuBody);\n\n      if (parentMenu.__originalParent._doActionTogglesSubMenu) {\n        parentMenu.__originalParent._doActionTogglesSubMenu();\n      }\n\n      var actualBounds = this.htmlComp.offsetBounds().subtractFromDimension(this.htmlComp.insets());\n      this.revalidateLayout();\n      this.position();\n\n      if (animated) {\n        this.bodyAnimating = true;\n        var duration = 300;\n        var position = parentMenu.$placeHolder.position();\n        parentMenu.$subMenuBody.css({\n          width: 'auto',\n          height: 'auto'\n        });\n        var targetBounds = this.htmlComp.offsetBounds().subtractFromDimension(this.htmlComp.insets());\n        parentMenu.$subMenuBody.css('box-shadow', 'none');\n        this.htmlComp.setBounds(actualBounds);\n\n        if (this.verticalAlignment !== Popup.Alignment.TOP) {\n          // set container to element\n          parentMenu.$subMenuBody.cssTop();\n        }\n\n        this._animateTopAndLeft(this.htmlComp.$comp, actualBounds, targetBounds, duration); // move new body to top of popup\n\n\n        parentMenu.$subMenuBody.cssHeightAnimated(actualBounds.height, parentMenu.$container.cssHeight(), {\n          duration: duration,\n          queue: false\n        });\n        var endTopposition = position.top - this.$body.cssHeight(),\n            startTopposition = 0 - actualBounds.height;\n        parentMenu.$subMenuBody.cssTopAnimated(startTopposition, endTopposition, {\n          duration: duration,\n          queue: false,\n          complete: function () {\n            if (parentMenu.$container) {\n              // check if $container is not removed before by closing operation.\n              scrollbars.uninstall(parentMenu.$subMenuBody, this.session);\n              parentMenu.$placeHolder.replaceWith(parentMenu.$container);\n              parentMenu.$container.toggleClass('expanded', false);\n\n              this._updateFirstLastClass();\n\n              this.updateNextToSelected('menu-item', parentMenu.$container);\n              parentMenu.$subMenuBody.detach();\n\n              this._installScrollbars();\n\n              this.$body.css('box-shadow', '');\n              this.bodyAnimating = false; // Do one final layout to fix any potentially wrong sizes (e.g. due to async image loading)\n\n              this._invalidateLayoutTreeAndRepositionPopup();\n\n              var next = this._toggleSubMenuQueue.shift();\n\n              if (next) {\n                next();\n              }\n            }\n          }.bind(this)\n        });\n        this.$body.cssWidthAnimated(actualBounds.width, targetBounds.width, {\n          duration: duration,\n          start: this.revalidateLayout.bind(this, true),\n          progress: this.revalidateLayout.bind(this, false),\n          queue: false\n        });\n\n        if (targetBounds.height !== actualBounds.height) {\n          this.$body.cssHeightAnimated(actualBounds.height, targetBounds.height, {\n            duration: duration,\n            queue: false\n          });\n        }\n      }\n    }\n  }, {\n    key: \"renderSubMenuItems\",\n    value: function renderSubMenuItems(parentMenu, menus, animated, initialSubMenuRendering) {\n      if (!this.session.desktop.rendered && !initialSubMenuRendering) {\n        this.initialSubMenusToRender = {\n          parentMenu: parentMenu,\n          menus: menus\n        };\n        return;\n      }\n\n      if (!this.rendered && !this.rendering) {\n        return;\n      }\n\n      if (this.bodyAnimating) {\n        // Let current animation finish and execute afterwards to prevent an unpredictable behavior and inconsistent state\n        this._toggleSubMenuQueue.push(this.renderSubMenuItems.bind(this, parentMenu, menus, animated, initialSubMenuRendering));\n\n        return;\n      }\n\n      var actualBounds = this.htmlComp.offsetBounds().subtractFromDimension(this.htmlComp.insets());\n      parentMenu.__originalParent.$subMenuBody = this.$body;\n      var $all = this.$body.find('.' + 'menu-item');\n      $all.removeClass('next-to-selected');\n\n      if (!parentMenu.$subMenuBody) {\n        this._$createBody();\n\n        parentMenu.$subMenuBody = this.$body;\n\n        this._renderMenuItems(menus, initialSubMenuRendering);\n      } else {\n        // append $body\n        this.$body = parentMenu.$subMenuBody;\n      }\n\n      var $insertAfterElement = parentMenu.$container.prev();\n      var position = parentMenu.$container.position();\n      parentMenu.$placeHolder = parentMenu.$container.clone(); // HtmlComponent is necessary for the row layout (it would normally be installed by Menu.js, but $placeholder is just a jquery clone of parentMenu.$container and is not managed by a real widget)\n\n      HtmlComponent.install(parentMenu.$placeHolder, this.session);\n\n      if ($insertAfterElement.length) {\n        parentMenu.$placeHolder.insertAfter($insertAfterElement);\n      } else {\n        parentMenu.__originalParent.$subMenuBody.prepend(parentMenu.$placeHolder);\n      }\n\n      this.$body.insertAfter(parentMenu.__originalParent.$subMenuBody);\n      this.$body.prepend(parentMenu.$container);\n      parentMenu.$container.toggleClass('expanded');\n      this.revalidateLayout();\n      this.position();\n      this.updateNextToSelected();\n\n      if (animated) {\n        this.bodyAnimating = true;\n        var duration = 300;\n\n        parentMenu.__originalParent.$subMenuBody.css({\n          width: 'auto',\n          height: 'auto'\n        });\n\n        var targetBounds = this.htmlComp.offsetBounds().subtractFromDimension(this.htmlComp.insets());\n\n        this._animateTopAndLeft(this.htmlComp.$comp, actualBounds, targetBounds, duration);\n\n        this.$body.css('box-shadow', 'none'); // set container to element\n\n        this.$body.cssWidthAnimated(actualBounds.width, targetBounds.width, {\n          duration: duration,\n          start: this.revalidateLayout.bind(this, true),\n          progress: this.revalidateLayout.bind(this, false),\n          queue: false\n        });\n        this.$body.cssHeightAnimated(parentMenu.$container.cssHeight(), targetBounds.height, {\n          duration: duration,\n          queue: false\n        });\n\n        var endTopposition = 0 - targetBounds.height,\n            startTopposition = position.top - parentMenu.__originalParent.$subMenuBody.cssHeight(),\n            topMargin = 0; // move new body to top of popup.\n\n\n        this.$body.cssTopAnimated(startTopposition, endTopposition, {\n          duration: duration,\n          queue: false,\n          complete: function () {\n            this.bodyAnimating = false;\n\n            if (parentMenu.__originalParent.$subMenuBody) {\n              scrollbars.uninstall(parentMenu.__originalParent.$subMenuBody, this.session);\n\n              parentMenu.__originalParent.$subMenuBody.detach();\n\n              this.$body.cssTop(topMargin);\n\n              this._installScrollbars();\n\n              this._updateFirstLastClass();\n\n              this.$body.css('box-shadow', '');\n            } // Do one final layout to fix any potentially wrong sizes (e.g. due to async image loading)\n\n\n            this._invalidateLayoutTreeAndRepositionPopup();\n\n            var next = this._toggleSubMenuQueue.shift();\n\n            if (next) {\n              next();\n            }\n          }.bind(this)\n        });\n\n        if (actualBounds.height !== targetBounds.height) {\n          parentMenu.__originalParent.$subMenuBody.cssHeightAnimated(actualBounds.height, targetBounds.height, {\n            duration: duration,\n            queue: false\n          });\n\n          this.$container.cssHeight(actualBounds.height, targetBounds.height, {\n            duration: duration,\n            queue: false\n          });\n        }\n\n        if (this.verticalAlignment === Popup.Alignment.TOP) {\n          this.$container.cssTopAnimated(actualBounds.y, targetBounds.y, {\n            duration: duration,\n            queue: false\n          }).css('overflow', 'visible'); // ajust top of head and deco\n\n          this.$head.cssTopAnimated(actualBounds.height, targetBounds.height, {\n            duration: duration,\n            queue: false\n          });\n          this.$deco.cssTopAnimated(actualBounds.height - 1, targetBounds.height - 1, {\n            duration: duration,\n            queue: false\n          });\n        }\n      } else {\n        if (!initialSubMenuRendering) {\n          scrollbars.uninstall(parentMenu.__originalParent.$subMenuBody, this.session);\n        }\n\n        parentMenu.__originalParent.$subMenuBody.detach();\n\n        this._installScrollbars();\n\n        this._updateFirstLastClass();\n      }\n    }\n  }, {\n    key: \"_animateTopAndLeft\",\n    value: function _animateTopAndLeft($comp, actualBounds, targetBounds, duration) {\n      var options = {\n        duration: duration,\n        queue: false\n      };\n      $comp.cssTopAnimated(actualBounds.y, targetBounds.y, options).cssLeftAnimated(actualBounds.x, targetBounds.x, options);\n    }\n  }, {\n    key: \"revalidateLayout\",\n    value: function revalidateLayout(repositionEnabled) {\n      this.repositionEnabled = scout.nvl(repositionEnabled, true);\n\n      _get(_getPrototypeOf(ContextMenuPopup.prototype), \"revalidateLayout\", this).call(this);\n\n      this.repositionEnabled = true;\n    }\n  }, {\n    key: \"_renderMenuItems\",\n    value: function _renderMenuItems(menus, initialSubMenuRendering) {\n      menus = menus ? menus : this._getMenuItems();\n\n      if (this.menuFilter) {\n        menus = this.menuFilter(menus, MenuDestinations.CONTEXT_MENU);\n      }\n\n      if (!menus || menus.length === 0) {\n        return;\n      }\n\n      menus.forEach(function (menu) {\n        // Invisible menus are rendered as well because their visibility might change dynamically\n        if (menu.separator) {\n          return;\n        } // prevent loosing original parent\n\n\n        var originalParent = menu.parent;\n\n        if (this.cloneMenuItems && !menu.cloneOf) {\n          // clone will recursively also clone all child actions.\n          menu = menu.clone({\n            parent: this\n          }, {\n            delegateEventsToOriginal: ['acceptInput', 'action', 'click'],\n            delegateAllPropertiesToClone: true,\n            delegateAllPropertiesToOriginal: true,\n            excludePropertiesToOriginal: ['selected', 'logicalGrid', 'tabbable']\n          });\n          menu.setTabbable(false); // attach listener\n\n          this._attachCloneMenuListeners(menu);\n        } // just set once because on second execution of this menu.parent is set to a popup\n\n\n        if (!menu.__originalParent) {\n          menu.__originalParent = originalParent;\n        }\n\n        menu.render(this.$body);\n\n        this._attachMenuListeners(menu); // Invalidate popup layout after images icons have been loaded, because the\n        // correct size might not be known yet. If the layout would not be revalidated, the popup\n        // size will be wrong (text is cut off after image has been loaded).\n        // The menu item actually does it by itself, but the popup needs to be repositioned too.\n\n\n        if (menu.icon) {\n          menu.icon.on('load error', this._invalidateLayoutTreeAndRepositionPopup.bind(this));\n        }\n      }, this);\n\n      this._handleInitialSubMenus(initialSubMenuRendering);\n\n      this._updateFirstLastClass();\n    }\n  }, {\n    key: \"_attachCloneMenuListeners\",\n    value: function _attachCloneMenuListeners(menu) {\n      menu.on('propertyChange', this._onCloneMenuPropertyChange.bind(this));\n      menu.childActions.forEach(this._attachCloneMenuListeners.bind(this));\n    }\n  }, {\n    key: \"_onCloneMenuPropertyChange\",\n    value: function _onCloneMenuPropertyChange(event) {\n      if (event.propertyName === 'selected') {\n        var menu = event.source; // Only trigger property change, setSelected would try to render the selected state which must not happen for the original menu\n\n        menu.cloneOf.triggerPropertyChange('selected', event.oldValue, event.newValue);\n      }\n    }\n  }, {\n    key: \"_handleInitialSubMenus\",\n    value: function _handleInitialSubMenus(initialSubMenuRendering) {\n      if (initialSubMenuRendering) {\n        return;\n      }\n\n      var menusObj;\n\n      while (this.initialSubMenusToRender) {\n        menusObj = this.initialSubMenusToRender;\n        this.initialSubMenusToRender = undefined;\n        this.renderSubMenuItems(menusObj.parentMenu, menusObj.menus, false, true);\n      }\n    }\n  }, {\n    key: \"_attachMenuListeners\",\n    value: function _attachMenuListeners(menu) {\n      var menuItemActionHandler = this._onMenuItemAction.bind(this);\n\n      var menuItemPropertyChange = this._onMenuItemPropertyChange.bind(this);\n\n      menu.on('action', menuItemActionHandler);\n      menu.on('propertyChange', menuItemPropertyChange);\n      this.one('remove', function () {\n        menu.off('action', menuItemActionHandler);\n        menu.off('propertyChange', menuItemPropertyChange);\n      });\n    }\n    /**\n     * @override PopupWithHead.js\n     */\n\n  }, {\n    key: \"_modifyBody\",\n    value: function _modifyBody() {\n      this.$body.addClass('context-menu');\n    }\n  }, {\n    key: \"updateMenuItems\",\n    value: function updateMenuItems(menuItems) {\n      menuItems = arrays.ensure(menuItems); // Only update if list of menus changed. Don't compare this.menuItems, because that list\n      // may contain additional UI separators, and may not be in the same order\n\n      if (!arrays.equals(this.menuItems, menuItems)) {\n        this.close();\n      }\n    }\n    /**\n     * Override this method to return menu items or actions used to render menu items.\n     */\n\n  }, {\n    key: \"_getMenuItems\",\n    value: function _getMenuItems() {\n      return this.menuItems;\n    }\n    /**\n     * Currently rendered $menuItems\n     */\n\n  }, {\n    key: \"$menuItems\",\n    value: function $menuItems() {\n      return this.$body.children('.menu-item');\n    }\n  }, {\n    key: \"$visibleMenuItems\",\n    value: function $visibleMenuItems() {\n      return this.$body.children('.menu-item:visible');\n    }\n    /**\n     * Updates the first and last visible menu items with the according css classes.\n     * Necessary because invisible menu-items are rendered.\n     */\n\n  }, {\n    key: \"_updateFirstLastClass\",\n    value: function _updateFirstLastClass(event) {\n      var $firstMenuItem, $lastMenuItem;\n      this.$body.children('.menu-item').each(function () {\n        var $menuItem = $(this);\n        $menuItem.removeClass('context-menu-item-first context-menu-item-last');\n\n        if ($menuItem.isVisible()) {\n          if (!$firstMenuItem) {\n            $firstMenuItem = $menuItem;\n          }\n\n          $lastMenuItem = $menuItem;\n        }\n      });\n\n      if ($firstMenuItem) {\n        $firstMenuItem.addClass('context-menu-item-first');\n      }\n\n      if ($lastMenuItem) {\n        $lastMenuItem.addClass('context-menu-item-last');\n      }\n    }\n  }, {\n    key: \"updateNextToSelected\",\n    value: function updateNextToSelected(menuItemClass, $selectedItem) {\n      menuItemClass = menuItemClass ? menuItemClass : 'menu-item';\n      var $all = this.$body.find('.' + menuItemClass);\n      $selectedItem = $selectedItem ? $selectedItem : this.$body.find('.' + menuItemClass + '.selected');\n      $all.removeClass('next-to-selected');\n\n      if ($selectedItem.hasClass('selected')) {\n        $selectedItem.nextAll(':visible').first().addClass('next-to-selected');\n      }\n    }\n  }, {\n    key: \"_onMenuItemAction\",\n    value: function _onMenuItemAction(event) {\n      if (event.source.isToggleAction()) {\n        return;\n      }\n\n      this.close();\n    }\n  }, {\n    key: \"_onMenuItemPropertyChange\",\n    value: function _onMenuItemPropertyChange(event) {\n      if (!this.rendered) {\n        return;\n      }\n\n      if (event.propertyName === 'visible') {\n        this._updateFirstLastClass();\n      } else if (event.propertyName === 'selected') {\n        // Key stroke navigation marks the currently focused item as selected.\n        // When a sub menu item is opened while another element is selected (focused), make sure the other element gets unselected.\n        // Otherwise two items would be selected when the sub menu is closed again.\n        this._deselectSiblings(event.source);\n      } // Make sure menu is positioned correctly afterwards (if it is opened upwards hiding/showing a menu item makes it necessary to reposition)\n\n\n      this.position();\n    }\n    /**\n     * Deselects the visible siblings of the given menu item. It just removes the CSS class and does not modify the selected property.\n     */\n\n  }, {\n    key: \"_deselectSiblings\",\n    value: function _deselectSiblings(menuItem) {\n      menuItem.$container.siblings('.menu-item').each(function (i, elem) {\n        var $menuItem = $(elem);\n        $menuItem.select(false);\n      }, this);\n    }\n  }, {\n    key: \"_invalidateLayoutTreeAndRepositionPopup\",\n    value: function _invalidateLayoutTreeAndRepositionPopup() {\n      this.invalidateLayoutTree();\n      this.session.layoutValidator.schedulePostValidateFunction(function () {\n        if (!this.rendered) {\n          // check needed because this is an async callback\n          return;\n        }\n\n        this.position();\n      }.bind(this));\n    }\n  }]);\n\n  return ContextMenuPopup;\n}(PopupWithHead);\n\nexport { ContextMenuPopup as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/menu/ContextMenuPopup.js"],"names":["arrays","ContextMenuPopupLayout","HtmlComponent","MenuDestinations","menuNavigationKeyStrokes","Popup","PopupWithHead","RowLayout","scrollbars","$","ContextMenuPopup","_headVisible","menuItems","cloneMenuItems","_toggleSubMenuQueue","repositionEnabled","options","focusableContainer","_addWidgetProperties","registerKeyStrokes","keyStrokeContext","pixelBasedSizing","_installScrollbars","_renderMenuItems","axis","$body","parentMenu","animated","rendered","rendering","bodyAnimating","push","removeSubMenuItems","bind","__originalParent","$subMenuBody","insertBefore","_doActionTogglesSubMenu","actualBounds","htmlComp","offsetBounds","subtractFromDimension","insets","revalidateLayout","position","duration","$placeHolder","css","width","height","targetBounds","setBounds","verticalAlignment","Alignment","TOP","cssTop","_animateTopAndLeft","$comp","cssHeightAnimated","$container","cssHeight","queue","endTopposition","top","startTopposition","cssTopAnimated","complete","uninstall","session","replaceWith","toggleClass","_updateFirstLastClass","updateNextToSelected","detach","_invalidateLayoutTreeAndRepositionPopup","next","shift","cssWidthAnimated","start","progress","menus","initialSubMenuRendering","desktop","initialSubMenusToRender","renderSubMenuItems","$all","find","removeClass","_$createBody","$insertAfterElement","prev","clone","install","length","insertAfter","prepend","topMargin","y","$head","$deco","cssLeftAnimated","x","scout","nvl","_getMenuItems","menuFilter","CONTEXT_MENU","forEach","menu","separator","originalParent","parent","cloneOf","delegateEventsToOriginal","delegateAllPropertiesToClone","delegateAllPropertiesToOriginal","excludePropertiesToOriginal","setTabbable","_attachCloneMenuListeners","render","_attachMenuListeners","icon","on","_handleInitialSubMenus","_onCloneMenuPropertyChange","childActions","event","propertyName","source","triggerPropertyChange","oldValue","newValue","menusObj","undefined","menuItemActionHandler","_onMenuItemAction","menuItemPropertyChange","_onMenuItemPropertyChange","one","off","addClass","ensure","equals","close","children","$firstMenuItem","$lastMenuItem","each","$menuItem","isVisible","menuItemClass","$selectedItem","hasClass","nextAll","first","isToggleAction","_deselectSiblings","menuItem","siblings","i","elem","select","invalidateLayoutTree","layoutValidator","schedulePostValidateFunction"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, ContextMenuPopupLayout, HtmlComponent, MenuDestinations, menuNavigationKeyStrokes, Popup, PopupWithHead, RowLayout, scrollbars} from '../index';\nimport $ from 'jquery';\n\nexport default class ContextMenuPopup extends PopupWithHead {\n\n  constructor() {\n    super();\n\n    // Make sure head won't be rendered, there is a css selector which is applied only if there is a head\n    this._headVisible = false;\n    this.menuItems = [];\n    this.cloneMenuItems = true;\n    this._toggleSubMenuQueue = [];\n    this.repositionEnabled = true;\n  }\n\n  _init(options) {\n    options.focusableContainer = true; // In order to allow keyboard navigation, the popup must gain focus. Because menu-items are not focusable, make the container focusable instead.\n\n    // If menu items are cloned, don't link the original menus with the popup, otherwise they would be removed when the context menu is removed\n    if (options.cloneMenuItems === false) {\n      this._addWidgetProperties('menuItems');\n    }\n\n    super._init(options);\n  }\n\n  /**\n   * @override Popup.js\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    menuNavigationKeyStrokes.registerKeyStrokes(this.keyStrokeContext, this, 'menu-item');\n  }\n\n  _createLayout() {\n    return new ContextMenuPopupLayout(this);\n  }\n\n  _createBodyLayout() {\n    return new RowLayout({\n      pixelBasedSizing: false\n    });\n  }\n\n  _render() {\n    super._render();\n    this._installScrollbars();\n    this._renderMenuItems();\n  }\n\n  /**\n   * @param [options]\n   * @override\n   */\n  _installScrollbars(options) {\n    super._installScrollbars({\n      axis: 'y'\n    });\n  }\n\n  /**\n   * @override\n   */\n  get$Scrollable() {\n    return this.$body;\n  }\n\n  removeSubMenuItems(parentMenu, animated) {\n    if (!this.rendered && !this.rendering) {\n      return;\n    }\n    if (this.bodyAnimating) {\n      // Let current animation finish and execute afterwards to prevent an unpredictable behavior and inconsistent state\n      this._toggleSubMenuQueue.push(this.removeSubMenuItems.bind(this, parentMenu, animated));\n      return;\n    }\n\n    this.$body = parentMenu.__originalParent.$subMenuBody;\n    // move new body to back\n    this.$body.insertBefore(parentMenu.$subMenuBody);\n\n    if (parentMenu.__originalParent._doActionTogglesSubMenu) {\n      parentMenu.__originalParent._doActionTogglesSubMenu();\n    }\n\n    var actualBounds = this.htmlComp.offsetBounds().subtractFromDimension(this.htmlComp.insets());\n\n    this.revalidateLayout();\n    this.position();\n\n    if (animated) {\n      this.bodyAnimating = true;\n      var duration = 300;\n      var position = parentMenu.$placeHolder.position();\n      parentMenu.$subMenuBody.css({\n        width: 'auto',\n        height: 'auto'\n      });\n      var targetBounds = this.htmlComp.offsetBounds().subtractFromDimension(this.htmlComp.insets());\n      parentMenu.$subMenuBody.css('box-shadow', 'none');\n      this.htmlComp.setBounds(actualBounds);\n      if (this.verticalAlignment !== Popup.Alignment.TOP) {\n        // set container to element\n        parentMenu.$subMenuBody.cssTop();\n      }\n\n      this._animateTopAndLeft(this.htmlComp.$comp, actualBounds, targetBounds, duration);\n\n      // move new body to top of popup\n      parentMenu.$subMenuBody.cssHeightAnimated(actualBounds.height, parentMenu.$container.cssHeight(), {\n        duration: duration,\n        queue: false\n      });\n\n      var endTopposition = position.top - this.$body.cssHeight(),\n        startTopposition = 0 - actualBounds.height;\n\n      parentMenu.$subMenuBody.cssTopAnimated(startTopposition, endTopposition, {\n        duration: duration,\n        queue: false,\n        complete: function() {\n          if (parentMenu.$container) { // check if $container is not removed before by closing operation.\n            scrollbars.uninstall(parentMenu.$subMenuBody, this.session);\n            parentMenu.$placeHolder.replaceWith(parentMenu.$container);\n            parentMenu.$container.toggleClass('expanded', false);\n            this._updateFirstLastClass();\n            this.updateNextToSelected('menu-item', parentMenu.$container);\n\n            parentMenu.$subMenuBody.detach();\n            this._installScrollbars();\n            this.$body.css('box-shadow', '');\n            this.bodyAnimating = false;\n            // Do one final layout to fix any potentially wrong sizes (e.g. due to async image loading)\n            this._invalidateLayoutTreeAndRepositionPopup();\n            var next = this._toggleSubMenuQueue.shift();\n            if (next) {\n              next();\n            }\n          }\n        }.bind(this)\n      });\n\n      this.$body.cssWidthAnimated(actualBounds.width, targetBounds.width, {\n        duration: duration,\n        start: this.revalidateLayout.bind(this, true),\n        progress: this.revalidateLayout.bind(this, false),\n        queue: false\n      });\n\n      if (targetBounds.height !== actualBounds.height) {\n        this.$body.cssHeightAnimated(actualBounds.height, targetBounds.height, {\n          duration: duration,\n          queue: false\n        });\n      }\n    }\n  }\n\n  renderSubMenuItems(parentMenu, menus, animated, initialSubMenuRendering) {\n    if (!this.session.desktop.rendered && !initialSubMenuRendering) {\n      this.initialSubMenusToRender = {\n        parentMenu: parentMenu,\n        menus: menus\n      };\n      return;\n    }\n    if (!this.rendered && !this.rendering) {\n      return;\n    }\n    if (this.bodyAnimating) {\n      // Let current animation finish and execute afterwards to prevent an unpredictable behavior and inconsistent state\n      this._toggleSubMenuQueue.push(this.renderSubMenuItems.bind(this, parentMenu, menus, animated, initialSubMenuRendering));\n      return;\n    }\n\n    var actualBounds = this.htmlComp.offsetBounds().subtractFromDimension(this.htmlComp.insets());\n\n    parentMenu.__originalParent.$subMenuBody = this.$body;\n\n    var $all = this.$body.find('.' + 'menu-item');\n    $all.removeClass('next-to-selected');\n\n    if (!parentMenu.$subMenuBody) {\n      this._$createBody();\n      parentMenu.$subMenuBody = this.$body;\n      this._renderMenuItems(menus, initialSubMenuRendering);\n    } else {\n      // append $body\n      this.$body = parentMenu.$subMenuBody;\n    }\n    var $insertAfterElement = parentMenu.$container.prev();\n    var position = parentMenu.$container.position();\n    parentMenu.$placeHolder = parentMenu.$container.clone();\n    // HtmlComponent is necessary for the row layout (it would normally be installed by Menu.js, but $placeholder is just a jquery clone of parentMenu.$container and is not managed by a real widget)\n    HtmlComponent.install(parentMenu.$placeHolder, this.session);\n    if ($insertAfterElement.length) {\n      parentMenu.$placeHolder.insertAfter($insertAfterElement);\n    } else {\n      parentMenu.__originalParent.$subMenuBody.prepend(parentMenu.$placeHolder);\n    }\n\n    this.$body.insertAfter(parentMenu.__originalParent.$subMenuBody);\n    this.$body.prepend(parentMenu.$container);\n    parentMenu.$container.toggleClass('expanded');\n\n    this.revalidateLayout();\n    this.position();\n\n    this.updateNextToSelected();\n\n    if (animated) {\n      this.bodyAnimating = true;\n      var duration = 300;\n      parentMenu.__originalParent.$subMenuBody.css({\n        width: 'auto',\n        height: 'auto'\n      });\n      var targetBounds = this.htmlComp.offsetBounds().subtractFromDimension(this.htmlComp.insets());\n\n      this._animateTopAndLeft(this.htmlComp.$comp, actualBounds, targetBounds, duration);\n\n      this.$body.css('box-shadow', 'none');\n      // set container to element\n      this.$body.cssWidthAnimated(actualBounds.width, targetBounds.width, {\n        duration: duration,\n        start: this.revalidateLayout.bind(this, true),\n        progress: this.revalidateLayout.bind(this, false),\n        queue: false\n      });\n\n      this.$body.cssHeightAnimated(parentMenu.$container.cssHeight(), targetBounds.height, {\n        duration: duration,\n        queue: false\n      });\n\n      var endTopposition = 0 - targetBounds.height,\n        startTopposition = position.top - parentMenu.__originalParent.$subMenuBody.cssHeight(),\n        topMargin = 0;\n\n      // move new body to top of popup.\n      this.$body.cssTopAnimated(startTopposition, endTopposition, {\n        duration: duration,\n        queue: false,\n        complete: function() {\n          this.bodyAnimating = false;\n          if (parentMenu.__originalParent.$subMenuBody) {\n            scrollbars.uninstall(parentMenu.__originalParent.$subMenuBody, this.session);\n            parentMenu.__originalParent.$subMenuBody.detach();\n            this.$body.cssTop(topMargin);\n            this._installScrollbars();\n            this._updateFirstLastClass();\n            this.$body.css('box-shadow', '');\n          }\n          // Do one final layout to fix any potentially wrong sizes (e.g. due to async image loading)\n          this._invalidateLayoutTreeAndRepositionPopup();\n          var next = this._toggleSubMenuQueue.shift();\n          if (next) {\n            next();\n          }\n        }.bind(this)\n      });\n\n      if (actualBounds.height !== targetBounds.height) {\n        parentMenu.__originalParent.$subMenuBody.cssHeightAnimated(actualBounds.height, targetBounds.height, {\n          duration: duration,\n          queue: false\n        });\n        this.$container.cssHeight(actualBounds.height, targetBounds.height, {\n          duration: duration,\n          queue: false\n        });\n      }\n      if (this.verticalAlignment === Popup.Alignment.TOP) {\n        this.$container.cssTopAnimated(actualBounds.y, targetBounds.y, {\n          duration: duration,\n          queue: false\n        }).css('overflow', 'visible');\n        // ajust top of head and deco\n        this.$head.cssTopAnimated(actualBounds.height, targetBounds.height, {\n          duration: duration,\n          queue: false\n        });\n        this.$deco.cssTopAnimated(actualBounds.height - 1, targetBounds.height - 1, {\n          duration: duration,\n          queue: false\n        });\n      }\n    } else {\n      if (!initialSubMenuRendering) {\n        scrollbars.uninstall(parentMenu.__originalParent.$subMenuBody, this.session);\n      }\n      parentMenu.__originalParent.$subMenuBody.detach();\n      this._installScrollbars();\n      this._updateFirstLastClass();\n    }\n  }\n\n  _animateTopAndLeft($comp, actualBounds, targetBounds, duration) {\n    var options = {\n      duration: duration,\n      queue: false\n    };\n    $comp\n      .cssTopAnimated(actualBounds.y, targetBounds.y, options)\n      .cssLeftAnimated(actualBounds.x, targetBounds.x, options);\n  }\n\n  revalidateLayout(repositionEnabled) {\n    this.repositionEnabled = scout.nvl(repositionEnabled, true);\n    super.revalidateLayout();\n    this.repositionEnabled = true;\n  }\n\n  _renderMenuItems(menus, initialSubMenuRendering) {\n    menus = menus ? menus : this._getMenuItems();\n    if (this.menuFilter) {\n      menus = this.menuFilter(menus, MenuDestinations.CONTEXT_MENU);\n    }\n\n    if (!menus || menus.length === 0) {\n      return;\n    }\n\n    menus.forEach(function(menu) {\n      // Invisible menus are rendered as well because their visibility might change dynamically\n      if (menu.separator) {\n        return;\n      }\n\n      // prevent loosing original parent\n      var originalParent = menu.parent;\n      if (this.cloneMenuItems && !menu.cloneOf) {\n        // clone will recursively also clone all child actions.\n        menu = menu.clone({\n          parent: this\n        }, {\n          delegateEventsToOriginal: ['acceptInput', 'action', 'click'],\n          delegateAllPropertiesToClone: true,\n          delegateAllPropertiesToOriginal: true,\n          excludePropertiesToOriginal: ['selected', 'logicalGrid', 'tabbable']\n        });\n        menu.setTabbable(false);\n        // attach listener\n        this._attachCloneMenuListeners(menu);\n      }\n\n      // just set once because on second execution of this menu.parent is set to a popup\n      if (!menu.__originalParent) {\n        menu.__originalParent = originalParent;\n      }\n      menu.render(this.$body);\n      this._attachMenuListeners(menu);\n\n      // Invalidate popup layout after images icons have been loaded, because the\n      // correct size might not be known yet. If the layout would not be revalidated, the popup\n      // size will be wrong (text is cut off after image has been loaded).\n      // The menu item actually does it by itself, but the popup needs to be repositioned too.\n      if (menu.icon) {\n        menu.icon.on('load error', this._invalidateLayoutTreeAndRepositionPopup.bind(this));\n      }\n    }, this);\n\n    this._handleInitialSubMenus(initialSubMenuRendering);\n    this._updateFirstLastClass();\n  }\n\n  _attachCloneMenuListeners(menu) {\n    menu.on('propertyChange', this._onCloneMenuPropertyChange.bind(this));\n    menu.childActions.forEach(this._attachCloneMenuListeners.bind(this));\n  }\n\n  _onCloneMenuPropertyChange(event) {\n    if (event.propertyName === 'selected') {\n      var menu = event.source;\n      // Only trigger property change, setSelected would try to render the selected state which must not happen for the original menu\n      menu.cloneOf.triggerPropertyChange('selected', event.oldValue, event.newValue);\n    }\n  }\n\n  _handleInitialSubMenus(initialSubMenuRendering) {\n    if (initialSubMenuRendering) {\n      return;\n    }\n    var menusObj;\n    while (this.initialSubMenusToRender) {\n      menusObj = this.initialSubMenusToRender;\n      this.initialSubMenusToRender = undefined;\n      this.renderSubMenuItems(menusObj.parentMenu, menusObj.menus, false, true);\n    }\n  }\n\n  _attachMenuListeners(menu) {\n    var menuItemActionHandler = this._onMenuItemAction.bind(this);\n    var menuItemPropertyChange = this._onMenuItemPropertyChange.bind(this);\n    menu.on('action', menuItemActionHandler);\n    menu.on('propertyChange', menuItemPropertyChange);\n    this.one('remove', function() {\n      menu.off('action', menuItemActionHandler);\n      menu.off('propertyChange', menuItemPropertyChange);\n    });\n  }\n\n  /**\n   * @override PopupWithHead.js\n   */\n  _modifyBody() {\n    this.$body.addClass('context-menu');\n  }\n\n  updateMenuItems(menuItems) {\n    menuItems = arrays.ensure(menuItems);\n    // Only update if list of menus changed. Don't compare this.menuItems, because that list\n    // may contain additional UI separators, and may not be in the same order\n    if (!arrays.equals(this.menuItems, menuItems)) {\n      this.close();\n    }\n  }\n\n  /**\n   * Override this method to return menu items or actions used to render menu items.\n   */\n  _getMenuItems() {\n    return this.menuItems;\n  }\n\n  /**\n   * Currently rendered $menuItems\n   */\n  $menuItems() {\n    return this.$body.children('.menu-item');\n  }\n\n  $visibleMenuItems() {\n    return this.$body.children('.menu-item:visible');\n  }\n\n  /**\n   * Updates the first and last visible menu items with the according css classes.\n   * Necessary because invisible menu-items are rendered.\n   */\n  _updateFirstLastClass(event) {\n    var $firstMenuItem, $lastMenuItem;\n\n    this.$body.children('.menu-item').each(function() {\n      var $menuItem = $(this);\n      $menuItem.removeClass('context-menu-item-first context-menu-item-last');\n\n      if ($menuItem.isVisible()) {\n        if (!$firstMenuItem) {\n          $firstMenuItem = $menuItem;\n        }\n        $lastMenuItem = $menuItem;\n      }\n    });\n    if ($firstMenuItem) {\n      $firstMenuItem.addClass('context-menu-item-first');\n    }\n    if ($lastMenuItem) {\n      $lastMenuItem.addClass('context-menu-item-last');\n    }\n  }\n\n  updateNextToSelected(menuItemClass, $selectedItem) {\n    menuItemClass = menuItemClass ? menuItemClass : 'menu-item';\n    var $all = this.$body.find('.' + menuItemClass);\n    $selectedItem = $selectedItem ? $selectedItem : this.$body.find('.' + menuItemClass + '.selected');\n\n    $all.removeClass('next-to-selected');\n    if ($selectedItem.hasClass('selected')) {\n      $selectedItem.nextAll(':visible').first().addClass('next-to-selected');\n    }\n  }\n\n  _onMenuItemAction(event) {\n    if (event.source.isToggleAction()) {\n      return;\n    }\n    this.close();\n  }\n\n  _onMenuItemPropertyChange(event) {\n    if (!this.rendered) {\n      return;\n    }\n    if (event.propertyName === 'visible') {\n      this._updateFirstLastClass();\n    } else if (event.propertyName === 'selected') {\n      // Key stroke navigation marks the currently focused item as selected.\n      // When a sub menu item is opened while another element is selected (focused), make sure the other element gets unselected.\n      // Otherwise two items would be selected when the sub menu is closed again.\n      this._deselectSiblings(event.source);\n    }\n    // Make sure menu is positioned correctly afterwards (if it is opened upwards hiding/showing a menu item makes it necessary to reposition)\n    this.position();\n  }\n\n  /**\n   * Deselects the visible siblings of the given menu item. It just removes the CSS class and does not modify the selected property.\n   */\n  _deselectSiblings(menuItem) {\n    menuItem.$container.siblings('.menu-item').each(function(i, elem) {\n      var $menuItem = $(elem);\n      $menuItem.select(false);\n    }, this);\n  }\n\n  _invalidateLayoutTreeAndRepositionPopup() {\n    this.invalidateLayoutTree();\n    this.session.layoutValidator.schedulePostValidateFunction(function() {\n      if (!this.rendered) { // check needed because this is an async callback\n        return;\n      }\n      this.position();\n    }.bind(this));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}