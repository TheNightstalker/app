{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function webpackUniversalModuleDefinition(root, factory) {\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') exports[\"sourceMappedStackTrace\"] = factory();else root[\"sourceMappedStackTrace\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"\";\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n      /*\n      * sourcemapped-stacktrace.js\n      * created by James Salter <iteration@gmail.com> (2014)\n      *\n      * https://github.com/novocaine/sourcemapped-stacktrace\n      *\n      * Licensed under the New BSD license. See LICENSE or:\n      * http://opensource.org/licenses/BSD-3-Clause\n      */\n\n      /*global define */\n      // note we only include source-map-consumer, not the whole source-map library,\n      // which includes gear for generating source maps that we don't need\n\n\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (source_map_consumer) {\n        var global_mapForUri = {};\n        /**\n         * Re-map entries in a stacktrace using sourcemaps if available.\n         *\n         * @param {str} stack - The stacktrace from the browser.\n         * @param {function} done - Callback invoked with the transformed stacktrace\n         *                          (an Array of Strings) passed as the first\n         *                          argument\n         * @param {Object} [opts] - Optional options object.\n         * @param {Function} [opts.filter] - Filter function applied to each stackTrace line.\n         *                                   Lines which do not pass the filter won't be processesd.\n         * @param {boolean} [opts.cacheGlobally] - Whether to cache sourcemaps globally across multiple calls.\n         * @param {boolean} [opts.sync] - Whether to use synchronous ajax to load the sourcemaps.\n         * @param {string} [opts.traceFormat] - If `error.stack` is formatted according to chrome or\n         *                                      Firefox's style.  Can be either `\"chrome\"`, `\"firefox\"`\n         *                                      or `undefined` (default).  If `undefined`, this library\n         *                                      will guess based on `navigator.userAgent`.\n         */\n\n        var mapStackTrace = function mapStackTrace(stack, done, opts) {\n          var lines;\n          var line;\n          var mapForUri = {};\n          var rows = {};\n          var fields;\n          var uri;\n          var expected_fields;\n          var regex;\n          var skip_lines;\n          var fetcher = new Fetcher(opts);\n          var traceFormat = opts && opts.traceFormat;\n\n          if (traceFormat !== \"chrome\" && traceFormat !== \"firefox\") {\n            if (traceFormat) {\n              throw new Error(\"unknown traceFormat \\\"\" + traceFormat + \"\\\" :(\");\n            } else if (isChromeOrEdge() || isIE11Plus()) {\n              traceFormat = \"chrome\";\n            } else if (isFirefox() || isSafari()) {\n              traceFormat = \"firefox\";\n            } else {\n              throw new Error(\"unknown browser :(\");\n            }\n          }\n\n          if (traceFormat === \"chrome\") {\n            regex = /^ +at.+\\((.*):([0-9]+):([0-9]+)/;\n            expected_fields = 4; // (skip first line containing exception message)\n\n            skip_lines = 1;\n          } else {\n            regex = /@(.*):([0-9]+):([0-9]+)/;\n            expected_fields = 4;\n            skip_lines = 0;\n          }\n\n          lines = stack.split(\"\\n\").slice(skip_lines);\n\n          for (var i = 0; i < lines.length; i++) {\n            line = lines[i];\n            if (opts && opts.filter && !opts.filter(line)) continue;\n            fields = line.match(regex);\n\n            if (fields && fields.length === expected_fields) {\n              rows[i] = fields;\n              uri = fields[1];\n\n              if (!uri.match(/<anonymous>/)) {\n                fetcher.fetchScript(uri);\n              }\n            }\n          }\n\n          fetcher.sem.whenReady(function () {\n            var result = processSourceMaps(lines, rows, fetcher.mapForUri, traceFormat);\n            done(result);\n          });\n        };\n\n        var isChromeOrEdge = function isChromeOrEdge() {\n          return navigator.userAgent.toLowerCase().indexOf('chrome') > -1;\n        };\n\n        var isFirefox = function isFirefox() {\n          return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n        };\n\n        var isSafari = function isSafari() {\n          return navigator.userAgent.toLowerCase().indexOf('safari') > -1;\n        };\n\n        var isIE11Plus = function isIE11Plus() {\n          return document.documentMode && document.documentMode >= 11;\n        };\n\n        var Semaphore = function Semaphore() {\n          this.count = 0;\n          this.pending = [];\n        };\n\n        Semaphore.prototype.incr = function () {\n          this.count++;\n        };\n\n        Semaphore.prototype.decr = function () {\n          this.count--;\n          this.flush();\n        };\n\n        Semaphore.prototype.whenReady = function (fn) {\n          this.pending.push(fn);\n          this.flush();\n        };\n\n        Semaphore.prototype.flush = function () {\n          if (this.count === 0) {\n            this.pending.forEach(function (fn) {\n              fn();\n            });\n            this.pending = [];\n          }\n        };\n\n        var Fetcher = function Fetcher(opts) {\n          this.sem = new Semaphore();\n          this.sync = opts && opts.sync;\n          this.mapForUri = opts && opts.cacheGlobally ? global_mapForUri : {};\n        };\n\n        Fetcher.prototype.ajax = function (uri, callback) {\n          var xhr = createXMLHTTPObject();\n          var that = this;\n\n          xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n              callback.call(that, xhr, uri);\n            }\n          };\n\n          xhr.open(\"GET\", uri, !this.sync);\n          xhr.send();\n        };\n\n        Fetcher.prototype.fetchScript = function (uri) {\n          if (!(uri in this.mapForUri)) {\n            this.sem.incr();\n            this.mapForUri[uri] = null;\n          } else {\n            return;\n          }\n\n          this.ajax(uri, this.onScriptLoad);\n        };\n\n        var absUrlRegex = new RegExp('^(?:[a-z]+:)?//', 'i');\n\n        Fetcher.prototype.onScriptLoad = function (xhr, uri) {\n          if (xhr.status === 200 || uri.slice(0, 7) === \"file://\" && xhr.status === 0) {\n            // find .map in file.\n            //\n            // attempt to find it at the very end of the file, but tolerate trailing\n            // whitespace inserted by some packers.\n            var match = xhr.responseText.match(\"//# [s]ourceMappingURL=(.*)[\\\\s]*$\", \"m\");\n\n            if (match && match.length === 2) {\n              // get the map\n              var mapUri = match[1];\n              var embeddedSourceMap = mapUri.match(\"data:application/json;(charset=[^;]+;)?base64,(.*)\");\n\n              if (embeddedSourceMap && embeddedSourceMap[2]) {\n                this.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(atob(embeddedSourceMap[2]));\n                this.sem.decr();\n              } else {\n                if (!absUrlRegex.test(mapUri)) {\n                  // relative url; according to sourcemaps spec is 'source origin'\n                  var origin;\n                  var lastSlash = uri.lastIndexOf('/');\n\n                  if (lastSlash !== -1) {\n                    origin = uri.slice(0, lastSlash + 1);\n                    mapUri = origin + mapUri; // note if lastSlash === -1, actual script uri has no slash\n                    // somehow, so no way to use it as a prefix... we give up and try\n                    // as absolute\n                  }\n                }\n\n                this.ajax(mapUri, function (xhr) {\n                  if (xhr.status === 200 || mapUri.slice(0, 7) === \"file://\" && xhr.status === 0) {\n                    this.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(xhr.responseText);\n                  }\n\n                  this.sem.decr();\n                });\n              }\n            } else {\n              // no map\n              this.sem.decr();\n            }\n          } else {\n            // HTTP error fetching uri of the script\n            this.sem.decr();\n          }\n        };\n\n        var processSourceMaps = function processSourceMaps(lines, rows, mapForUri, traceFormat) {\n          var result = [];\n          var map;\n          var origName = traceFormat === \"chrome\" ? origNameChrome : origNameFirefox;\n\n          for (var i = 0; i < lines.length; i++) {\n            var row = rows[i];\n\n            if (row) {\n              var uri = row[1];\n              var line = parseInt(row[2], 10);\n              var column = parseInt(row[3], 10);\n              map = mapForUri[uri];\n\n              if (map) {\n                // we think we have a map for that uri. call source-map library\n                var origPos = map.originalPositionFor({\n                  line: line,\n                  column: column\n                });\n                result.push(formatOriginalPosition(origPos.source, origPos.line, origPos.column, origPos.name || origName(lines[i])));\n              } else {\n                // we can't find a map for that url, but we parsed the row.\n                // reformat unchanged line for consistency with the sourcemapped\n                // lines.\n                result.push(formatOriginalPosition(uri, line, column, origName(lines[i])));\n              }\n            } else {\n              // we weren't able to parse the row, push back what we were given\n              result.push(lines[i]);\n            }\n          }\n\n          return result;\n        };\n\n        function origNameChrome(origLine) {\n          var match = / +at +([^ ]*).*/.exec(origLine);\n          return match && match[1];\n        }\n\n        function origNameFirefox(origLine) {\n          var match = /([^@]*)@.*/.exec(origLine);\n          return match && match[1];\n        }\n\n        var formatOriginalPosition = function formatOriginalPosition(source, line, column, name) {\n          // mimic chrome's format\n          return \"    at \" + (name ? name : \"(unknown)\") + \" (\" + source + \":\" + line + \":\" + column + \")\";\n        }; // xmlhttprequest boilerplate\n\n\n        var XMLHttpFactories = [function () {\n          return new XMLHttpRequest();\n        }, function () {\n          return new ActiveXObject(\"Msxml2.XMLHTTP\");\n        }, function () {\n          return new ActiveXObject(\"Msxml3.XMLHTTP\");\n        }, function () {\n          return new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }];\n\n        function createXMLHTTPObject() {\n          var xmlhttp = false;\n\n          for (var i = 0; i < XMLHttpFactories.length; i++) {\n            try {\n              xmlhttp = XMLHttpFactories[i]();\n            } catch (e) {\n              continue;\n            }\n\n            break;\n          }\n\n          return xmlhttp;\n        }\n\n        return {\n          mapStackTrace: mapStackTrace\n        };\n      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(2);\n\n      var binarySearch = __webpack_require__(3);\n\n      var ArraySet = __webpack_require__(4).ArraySet;\n\n      var base64VLQ = __webpack_require__(5);\n\n      var quickSort = __webpack_require__(7).quickSort;\n\n      function SourceMapConsumer(aSourceMap) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n        }\n\n        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);\n      }\n\n      SourceMapConsumer.fromSourceMap = function (aSourceMap) {\n        return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n      };\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n\n      SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the\n      // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n      // are lazily instantiated, accessed via the `_generatedMappings` and\n      // `_originalMappings` getters respectively, and we only parse the mappings\n      // and create these arrays once queried for a source location. We jump through\n      // these hoops because there can be many thousands of mappings, and parsing\n      // them is expensive, so we only want to do it if we must.\n      //\n      // Each object in the arrays is of the form:\n      //\n      //     {\n      //       generatedLine: The line number in the generated code,\n      //       generatedColumn: The column number in the generated code,\n      //       source: The path to the original source file that generated this\n      //               chunk of code,\n      //       originalLine: The line number in the original source that\n      //                     corresponds to this chunk of generated code,\n      //       originalColumn: The column number in the original source that\n      //                       corresponds to this chunk of generated code,\n      //       name: The name of the original symbol which generated this chunk of\n      //             code.\n      //     }\n      //\n      // All properties except for `generatedLine` and `generatedColumn` can be\n      // `null`.\n      //\n      // `_generatedMappings` is ordered by the generated positions.\n      //\n      // `_originalMappings` is ordered by the original positions.\n\n      SourceMapConsumer.prototype.__generatedMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n        get: function get() {\n          if (!this.__generatedMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n\n          return this.__generatedMappings;\n        }\n      });\n      SourceMapConsumer.prototype.__originalMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n        get: function get() {\n          if (!this.__originalMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n\n          return this.__originalMappings;\n        }\n      });\n\n      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n        var c = aStr.charAt(index);\n        return c === \";\" || c === \",\";\n      };\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        throw new Error(\"Subclasses must implement _parseMappings\");\n      };\n\n      SourceMapConsumer.GENERATED_ORDER = 1;\n      SourceMapConsumer.ORIGINAL_ORDER = 2;\n      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n      SourceMapConsumer.LEAST_UPPER_BOUND = 2;\n      /**\n       * Iterate over each mapping between an original source/line/column and a\n       * generated line/column in this source map.\n       *\n       * @param Function aCallback\n       *        The function that is called with each mapping.\n       * @param Object aContext\n       *        Optional. If specified, this object will be the value of `this` every\n       *        time that `aCallback` is called.\n       * @param aOrder\n       *        Either `SourceMapConsumer.GENERATED_ORDER` or\n       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n       *        iterate over the mappings sorted by the generated file's line/column\n       *        order or the original's source/line/column order, respectively. Defaults to\n       *        `SourceMapConsumer.GENERATED_ORDER`.\n       */\n\n      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n        var context = aContext || null;\n        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n        var mappings;\n\n        switch (order) {\n          case SourceMapConsumer.GENERATED_ORDER:\n            mappings = this._generatedMappings;\n            break;\n\n          case SourceMapConsumer.ORIGINAL_ORDER:\n            mappings = this._originalMappings;\n            break;\n\n          default:\n            throw new Error(\"Unknown order of iteration.\");\n        }\n\n        var sourceRoot = this.sourceRoot;\n        mappings.map(function (mapping) {\n          var source = mapping.source === null ? null : this._sources.at(mapping.source);\n\n          if (source != null && sourceRoot != null) {\n            source = util.join(sourceRoot, source);\n          }\n\n          return {\n            source: source,\n            generatedLine: mapping.generatedLine,\n            generatedColumn: mapping.generatedColumn,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name === null ? null : this._names.at(mapping.name)\n          };\n        }, this).forEach(aCallback, context);\n      };\n      /**\n       * Returns all generated line and column information for the original source,\n       * line, and column provided. If no column is provided, returns all mappings\n       * corresponding to a either the line we are searching for or the next\n       * closest line that has any mappings. Otherwise, returns all mappings\n       * corresponding to the given line and either the column we are searching for\n       * or the next closest column that has any offsets.\n       *\n       * The only argument is an object with the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.\n       *   - column: Optional. the column number in the original source.\n       *\n       * and an array of objects is returned, each with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.\n       *   - column: The column number in the generated source, or null.\n       */\n\n\n      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n        var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n        // returns the index of the closest mapping less than the needle. By\n        // setting needle.originalColumn to 0, we thus find the last mapping for\n        // the given line, provided such a mapping exists.\n\n        var needle = {\n          source: util.getArg(aArgs, 'source'),\n          originalLine: line,\n          originalColumn: util.getArg(aArgs, 'column', 0)\n        };\n\n        if (this.sourceRoot != null) {\n          needle.source = util.relative(this.sourceRoot, needle.source);\n        }\n\n        if (!this._sources.has(needle.source)) {\n          return [];\n        }\n\n        needle.source = this._sources.indexOf(needle.source);\n        var mappings = [];\n\n        var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n\n        if (index >= 0) {\n          var mapping = this._originalMappings[index];\n\n          if (aArgs.column === undefined) {\n            var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we found. Since\n            // mappings are sorted, this is guaranteed to find all mappings for\n            // the line we found.\n\n            while (mapping && mapping.originalLine === originalLine) {\n              mappings.push({\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n              });\n              mapping = this._originalMappings[++index];\n            }\n          } else {\n            var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we were searching for.\n            // Since mappings are sorted, this is guaranteed to find all mappings for\n            // the line we are searching for.\n\n            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {\n              mappings.push({\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n              });\n              mapping = this._originalMappings[++index];\n            }\n          }\n        }\n\n        return mappings;\n      };\n\n      exports.SourceMapConsumer = SourceMapConsumer;\n      /**\n       * A BasicSourceMapConsumer instance represents a parsed source map which we can\n       * query for information about the original file positions by giving it a file\n       * position in the generated source.\n       *\n       * The only parameter is the raw source map (either as a JSON string, or\n       * already parsed to an object). According to the spec, source maps have the\n       * following attributes:\n       *\n       *   - version: Which version of the source map spec this map is following.\n       *   - sources: An array of URLs to the original source files.\n       *   - names: An array of identifiers which can be referrenced by individual mappings.\n       *   - sourceRoot: Optional. The URL root from which all sources are relative.\n       *   - sourcesContent: Optional. An array of contents of the original source files.\n       *   - mappings: A string of base64 VLQs which contain the actual mappings.\n       *   - file: Optional. The generated file this source map is associated with.\n       *\n       * Here is an example source map, taken from the source map spec[0]:\n       *\n       *     {\n       *       version : 3,\n       *       file: \"out.js\",\n       *       sourceRoot : \"\",\n       *       sources: [\"foo.js\", \"bar.js\"],\n       *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n       *       mappings: \"AA,AB;;ABCDE;\"\n       *     }\n       *\n       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n       */\n\n      function BasicSourceMapConsumer(aSourceMap) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n        }\n\n        var version = util.getArg(sourceMap, 'version');\n        var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n        // requires the array) to play nice here.\n\n        var names = util.getArg(sourceMap, 'names', []);\n        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n        var mappings = util.getArg(sourceMap, 'mappings');\n        var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a\n        // string rather than a number, so we use loose equality checking here.\n\n        if (version != this._version) {\n          throw new Error('Unsupported version: ' + version);\n        }\n\n        sources = sources.map(String) // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize) // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function (source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n        }); // Pass `true` below to allow duplicate names and sources. While source maps\n        // are intended to be compressed and deduplicated, the TypeScript compiler\n        // sometimes generates source maps with duplicates in them. See Github issue\n        // #72 and bugzil.la/889492.\n\n        this._names = ArraySet.fromArray(names.map(String), true);\n        this._sources = ArraySet.fromArray(sources, true);\n        this.sourceRoot = sourceRoot;\n        this.sourcesContent = sourcesContent;\n        this._mappings = mappings;\n        this.file = file;\n      }\n\n      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n      /**\n       * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n       *\n       * @param SourceMapGenerator aSourceMap\n       *        The source map that will be consumed.\n       * @returns BasicSourceMapConsumer\n       */\n\n      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {\n        var smc = Object.create(BasicSourceMapConsumer.prototype);\n        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n        smc.sourceRoot = aSourceMap._sourceRoot;\n        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n        smc.file = aSourceMap._file; // Because we are modifying the entries (by converting string sources and\n        // names to indices into the sources and names ArraySets), we have to make\n        // a copy of the entry or else bad things happen. Shared mutable state\n        // strikes again! See github issue #191.\n\n        var generatedMappings = aSourceMap._mappings.toArray().slice();\n\n        var destGeneratedMappings = smc.__generatedMappings = [];\n        var destOriginalMappings = smc.__originalMappings = [];\n\n        for (var i = 0, length = generatedMappings.length; i < length; i++) {\n          var srcMapping = generatedMappings[i];\n          var destMapping = new Mapping();\n          destMapping.generatedLine = srcMapping.generatedLine;\n          destMapping.generatedColumn = srcMapping.generatedColumn;\n\n          if (srcMapping.source) {\n            destMapping.source = sources.indexOf(srcMapping.source);\n            destMapping.originalLine = srcMapping.originalLine;\n            destMapping.originalColumn = srcMapping.originalColumn;\n\n            if (srcMapping.name) {\n              destMapping.name = names.indexOf(srcMapping.name);\n            }\n\n            destOriginalMappings.push(destMapping);\n          }\n\n          destGeneratedMappings.push(destMapping);\n        }\n\n        quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n        return smc;\n      };\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n\n      BasicSourceMapConsumer.prototype._version = 3;\n      /**\n       * The list of original sources.\n       */\n\n      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n        get: function get() {\n          return this._sources.toArray().map(function (s) {\n            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n          }, this);\n        }\n      });\n      /**\n       * Provide the JIT with a nice shape / hidden class.\n       */\n\n      function Mapping() {\n        this.generatedLine = 0;\n        this.generatedColumn = 0;\n        this.source = null;\n        this.originalLine = null;\n        this.originalColumn = null;\n        this.name = null;\n      }\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        var generatedLine = 1;\n        var previousGeneratedColumn = 0;\n        var previousOriginalLine = 0;\n        var previousOriginalColumn = 0;\n        var previousSource = 0;\n        var previousName = 0;\n        var length = aStr.length;\n        var index = 0;\n        var cachedSegments = {};\n        var temp = {};\n        var originalMappings = [];\n        var generatedMappings = [];\n        var mapping, str, segment, end, value;\n\n        while (index < length) {\n          if (aStr.charAt(index) === ';') {\n            generatedLine++;\n            index++;\n            previousGeneratedColumn = 0;\n          } else if (aStr.charAt(index) === ',') {\n            index++;\n          } else {\n            mapping = new Mapping();\n            mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,\n            // many segments often have the same encoding. We can exploit this\n            // fact by caching the parsed variable length fields of each segment,\n            // allowing us to avoid a second parse if we encounter the same\n            // segment again.\n\n            for (end = index; end < length; end++) {\n              if (this._charIsMappingSeparator(aStr, end)) {\n                break;\n              }\n            }\n\n            str = aStr.slice(index, end);\n            segment = cachedSegments[str];\n\n            if (segment) {\n              index += str.length;\n            } else {\n              segment = [];\n\n              while (index < end) {\n                base64VLQ.decode(aStr, index, temp);\n                value = temp.value;\n                index = temp.rest;\n                segment.push(value);\n              }\n\n              if (segment.length === 2) {\n                throw new Error('Found a source, but no line and column');\n              }\n\n              if (segment.length === 3) {\n                throw new Error('Found a source and line, but no column');\n              }\n\n              cachedSegments[str] = segment;\n            } // Generated column.\n\n\n            mapping.generatedColumn = previousGeneratedColumn + segment[0];\n            previousGeneratedColumn = mapping.generatedColumn;\n\n            if (segment.length > 1) {\n              // Original source.\n              mapping.source = previousSource + segment[1];\n              previousSource += segment[1]; // Original line.\n\n              mapping.originalLine = previousOriginalLine + segment[2];\n              previousOriginalLine = mapping.originalLine; // Lines are stored 0-based\n\n              mapping.originalLine += 1; // Original column.\n\n              mapping.originalColumn = previousOriginalColumn + segment[3];\n              previousOriginalColumn = mapping.originalColumn;\n\n              if (segment.length > 4) {\n                // Original name.\n                mapping.name = previousName + segment[4];\n                previousName += segment[4];\n              }\n            }\n\n            generatedMappings.push(mapping);\n\n            if (typeof mapping.originalLine === 'number') {\n              originalMappings.push(mapping);\n            }\n          }\n        }\n\n        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n        this.__generatedMappings = generatedMappings;\n        quickSort(originalMappings, util.compareByOriginalPositions);\n        this.__originalMappings = originalMappings;\n      };\n      /**\n       * Find the mapping that best matches the hypothetical \"needle\" mapping that\n       * we are searching for in the given \"haystack\" of mappings.\n       */\n\n\n      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n        // To return the position we are searching for, we must first find the\n        // mapping for the given position and then return the opposite position it\n        // points to. Because the mappings are sorted, we can use binary search to\n        // find the best mapping.\n        if (aNeedle[aLineName] <= 0) {\n          throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n        }\n\n        if (aNeedle[aColumnName] < 0) {\n          throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n        }\n\n        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n      };\n      /**\n       * Compute the last column for each generated mapping. The last column is\n       * inclusive.\n       */\n\n\n      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n        for (var index = 0; index < this._generatedMappings.length; ++index) {\n          var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We\n          // can come up with an optimistic estimate, however, by assuming that\n          // mappings are contiguous (i.e. given two consecutive mappings, the\n          // first mapping ends where the second one starts).\n\n          if (index + 1 < this._generatedMappings.length) {\n            var nextMapping = this._generatedMappings[index + 1];\n\n            if (mapping.generatedLine === nextMapping.generatedLine) {\n              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n              continue;\n            }\n          } // The last mapping for each line spans the entire line.\n\n\n          mapping.lastGeneratedColumn = Infinity;\n        }\n      };\n      /**\n       * Returns the original source, line, and column information for the generated\n       * source's line and column positions provided. The only argument is an object\n       * with the following properties:\n       *\n       *   - line: The line number in the generated source.\n       *   - column: The column number in the generated source.\n       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - source: The original source file, or null.\n       *   - line: The line number in the original source, or null.\n       *   - column: The column number in the original source, or null.\n       *   - name: The original identifier, or null.\n       */\n\n\n      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n          generatedLine: util.getArg(aArgs, 'line'),\n          generatedColumn: util.getArg(aArgs, 'column')\n        };\n\n        var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n        if (index >= 0) {\n          var mapping = this._generatedMappings[index];\n\n          if (mapping.generatedLine === needle.generatedLine) {\n            var source = util.getArg(mapping, 'source', null);\n\n            if (source !== null) {\n              source = this._sources.at(source);\n\n              if (this.sourceRoot != null) {\n                source = util.join(this.sourceRoot, source);\n              }\n            }\n\n            var name = util.getArg(mapping, 'name', null);\n\n            if (name !== null) {\n              name = this._names.at(name);\n            }\n\n            return {\n              source: source,\n              line: util.getArg(mapping, 'originalLine', null),\n              column: util.getArg(mapping, 'originalColumn', null),\n              name: name\n            };\n          }\n        }\n\n        return {\n          source: null,\n          line: null,\n          column: null,\n          name: null\n        };\n      };\n      /**\n       * Return true if we have the source content for every source in the source\n       * map, false otherwise.\n       */\n\n\n      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n        if (!this.sourcesContent) {\n          return false;\n        }\n\n        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n          return sc == null;\n        });\n      };\n      /**\n       * Returns the original source content. The only argument is the url of the\n       * original source file. Returns null if no original source content is\n       * available.\n       */\n\n\n      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        if (!this.sourcesContent) {\n          return null;\n        }\n\n        if (this.sourceRoot != null) {\n          aSource = util.relative(this.sourceRoot, aSource);\n        }\n\n        if (this._sources.has(aSource)) {\n          return this.sourcesContent[this._sources.indexOf(aSource)];\n        }\n\n        var url;\n\n        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n          // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n          // many users. We can help them out when they expect file:// URIs to\n          // behave like it would if they were running a local HTTP server. See\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n          var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\n          if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n          }\n\n          if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + aSource)) {\n            return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n          }\n        } // This function is used recursively from\n        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n        // don't want to throw if we can't find the source - we just want to\n        // return null, so we provide a flag to exit gracefully.\n\n\n        if (nullOnMissing) {\n          return null;\n        } else {\n          throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n        }\n      };\n      /**\n       * Returns the generated line and column information for the original source,\n       * line, and column positions provided. The only argument is an object with\n       * the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.\n       *   - column: The column number in the original source.\n       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.\n       *   - column: The column number in the generated source, or null.\n       */\n\n\n      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n        var source = util.getArg(aArgs, 'source');\n\n        if (this.sourceRoot != null) {\n          source = util.relative(this.sourceRoot, source);\n        }\n\n        if (!this._sources.has(source)) {\n          return {\n            line: null,\n            column: null,\n            lastColumn: null\n          };\n        }\n\n        source = this._sources.indexOf(source);\n        var needle = {\n          source: source,\n          originalLine: util.getArg(aArgs, 'line'),\n          originalColumn: util.getArg(aArgs, 'column')\n        };\n\n        var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n        if (index >= 0) {\n          var mapping = this._originalMappings[index];\n\n          if (mapping.source === needle.source) {\n            return {\n              line: util.getArg(mapping, 'generatedLine', null),\n              column: util.getArg(mapping, 'generatedColumn', null),\n              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n            };\n          }\n        }\n\n        return {\n          line: null,\n          column: null,\n          lastColumn: null\n        };\n      };\n\n      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n      /**\n       * An IndexedSourceMapConsumer instance represents a parsed source map which\n       * we can query for information. It differs from BasicSourceMapConsumer in\n       * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n       * input.\n       *\n       * The only parameter is a raw source map (either as a JSON string, or already\n       * parsed to an object). According to the spec for indexed source maps, they\n       * have the following attributes:\n       *\n       *   - version: Which version of the source map spec this map is following.\n       *   - file: Optional. The generated file this source map is associated with.\n       *   - sections: A list of section definitions.\n       *\n       * Each value under the \"sections\" field has two fields:\n       *   - offset: The offset into the original specified at which this section\n       *       begins to apply, defined as an object with a \"line\" and \"column\"\n       *       field.\n       *   - map: A source map definition. This source map could also be indexed,\n       *       but doesn't have to be.\n       *\n       * Instead of the \"map\" field, it's also possible to have a \"url\" field\n       * specifying a URL to retrieve a source map from, but that's currently\n       * unsupported.\n       *\n       * Here's an example source map, taken from the source map spec[0], but\n       * modified to omit a section which uses the \"url\" field.\n       *\n       *  {\n       *    version : 3,\n       *    file: \"app.js\",\n       *    sections: [{\n       *      offset: {line:100, column:10},\n       *      map: {\n       *        version : 3,\n       *        file: \"section.js\",\n       *        sources: [\"foo.js\", \"bar.js\"],\n       *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n       *        mappings: \"AAAA,E;;ABCDE;\"\n       *      }\n       *    }],\n       *  }\n       *\n       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n       */\n\n      function IndexedSourceMapConsumer(aSourceMap) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n        }\n\n        var version = util.getArg(sourceMap, 'version');\n        var sections = util.getArg(sourceMap, 'sections');\n\n        if (version != this._version) {\n          throw new Error('Unsupported version: ' + version);\n        }\n\n        this._sources = new ArraySet();\n        this._names = new ArraySet();\n        var lastOffset = {\n          line: -1,\n          column: 0\n        };\n        this._sections = sections.map(function (s) {\n          if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error('Support for url field in sections not implemented.');\n          }\n\n          var offset = util.getArg(s, 'offset');\n          var offsetLine = util.getArg(offset, 'line');\n          var offsetColumn = util.getArg(offset, 'column');\n\n          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n            throw new Error('Section offsets must be ordered and non-overlapping.');\n          }\n\n          lastOffset = offset;\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n          };\n        });\n      }\n\n      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n      IndexedSourceMapConsumer.prototype._version = 3;\n      /**\n       * The list of original sources.\n       */\n\n      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n        get: function get() {\n          var sources = [];\n\n          for (var i = 0; i < this._sections.length; i++) {\n            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n              sources.push(this._sections[i].consumer.sources[j]);\n            }\n          }\n\n          return sources;\n        }\n      });\n      /**\n       * Returns the original source, line, and column information for the generated\n       * source's line and column positions provided. The only argument is an object\n       * with the following properties:\n       *\n       *   - line: The line number in the generated source.\n       *   - column: The column number in the generated source.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - source: The original source file, or null.\n       *   - line: The line number in the original source, or null.\n       *   - column: The column number in the original source, or null.\n       *   - name: The original identifier, or null.\n       */\n\n      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n          generatedLine: util.getArg(aArgs, 'line'),\n          generatedColumn: util.getArg(aArgs, 'column')\n        }; // Find the section containing the generated position we're trying to map\n        // to an original position.\n\n        var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {\n          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\n          if (cmp) {\n            return cmp;\n          }\n\n          return needle.generatedColumn - section.generatedOffset.generatedColumn;\n        });\n        var section = this._sections[sectionIndex];\n\n        if (!section) {\n          return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n          };\n        }\n\n        return section.consumer.originalPositionFor({\n          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n          bias: aArgs.bias\n        });\n      };\n      /**\n       * Return true if we have the source content for every source in the source\n       * map, false otherwise.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n        return this._sections.every(function (s) {\n          return s.consumer.hasContentsOfAllSources();\n        });\n      };\n      /**\n       * Returns the original source content. The only argument is the url of the\n       * original source file. Returns null if no original source content is\n       * available.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i];\n          var content = section.consumer.sourceContentFor(aSource, true);\n\n          if (content) {\n            return content;\n          }\n        }\n\n        if (nullOnMissing) {\n          return null;\n        } else {\n          throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n        }\n      };\n      /**\n       * Returns the generated line and column information for the original source,\n       * line, and column positions provided. The only argument is an object with\n       * the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.\n       *   - column: The column number in the original source.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.\n       *   - column: The column number in the generated source, or null.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i]; // Only consider this section if the requested source is in the list of\n          // sources of the consumer.\n\n          if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n            continue;\n          }\n\n          var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\n          if (generatedPosition) {\n            var ret = {\n              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n            };\n            return ret;\n          }\n        }\n\n        return {\n          line: null,\n          column: null\n        };\n      };\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i];\n          var sectionMappings = section.consumer._generatedMappings;\n\n          for (var j = 0; j < sectionMappings.length; j++) {\n            var mapping = sectionMappings[j];\n\n            var source = section.consumer._sources.at(mapping.source);\n\n            if (section.consumer.sourceRoot !== null) {\n              source = util.join(section.consumer.sourceRoot, source);\n            }\n\n            this._sources.add(source);\n\n            source = this._sources.indexOf(source);\n\n            var name = section.consumer._names.at(mapping.name);\n\n            this._names.add(name);\n\n            name = this._names.indexOf(name); // The mappings coming from the consumer for the section have\n            // generated positions relative to the start of the section, so we\n            // need to offset them to be relative to the start of the concatenated\n            // generated file.\n\n            var adjustedMapping = {\n              source: source,\n              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n              originalLine: mapping.originalLine,\n              originalColumn: mapping.originalColumn,\n              name: name\n            };\n\n            this.__generatedMappings.push(adjustedMapping);\n\n            if (typeof adjustedMapping.originalLine === 'number') {\n              this.__originalMappings.push(adjustedMapping);\n            }\n          }\n        }\n\n        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n        quickSort(this.__originalMappings, util.compareByOriginalPositions);\n      };\n\n      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n\n      /**\n       * This is a helper function for getting values from parameter/options\n       * objects.\n       *\n       * @param args The object we are extracting values from\n       * @param name The name of the property we are getting.\n       * @param defaultValue An optional value to return if the property is missing\n       * from the object. If this is not specified and the property is missing, an\n       * error will be thrown.\n       */\n      function getArg(aArgs, aName, aDefaultValue) {\n        if (aName in aArgs) {\n          return aArgs[aName];\n        } else if (arguments.length === 3) {\n          return aDefaultValue;\n        } else {\n          throw new Error('\"' + aName + '\" is a required argument.');\n        }\n      }\n\n      exports.getArg = getArg;\n      var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n      var dataUrlRegexp = /^data:.+\\,.+$/;\n\n      function urlParse(aUrl) {\n        var match = aUrl.match(urlRegexp);\n\n        if (!match) {\n          return null;\n        }\n\n        return {\n          scheme: match[1],\n          auth: match[2],\n          host: match[3],\n          port: match[4],\n          path: match[5]\n        };\n      }\n\n      exports.urlParse = urlParse;\n\n      function urlGenerate(aParsedUrl) {\n        var url = '';\n\n        if (aParsedUrl.scheme) {\n          url += aParsedUrl.scheme + ':';\n        }\n\n        url += '//';\n\n        if (aParsedUrl.auth) {\n          url += aParsedUrl.auth + '@';\n        }\n\n        if (aParsedUrl.host) {\n          url += aParsedUrl.host;\n        }\n\n        if (aParsedUrl.port) {\n          url += \":\" + aParsedUrl.port;\n        }\n\n        if (aParsedUrl.path) {\n          url += aParsedUrl.path;\n        }\n\n        return url;\n      }\n\n      exports.urlGenerate = urlGenerate;\n      /**\n       * Normalizes a path, or the path portion of a URL:\n       *\n       * - Replaces consecutive slashes with one slash.\n       * - Removes unnecessary '.' parts.\n       * - Removes unnecessary '<dir>/..' parts.\n       *\n       * Based on code in the Node.js 'path' core module.\n       *\n       * @param aPath The path or url to normalize.\n       */\n\n      function normalize(aPath) {\n        var path = aPath;\n        var url = urlParse(aPath);\n\n        if (url) {\n          if (!url.path) {\n            return aPath;\n          }\n\n          path = url.path;\n        }\n\n        var isAbsolute = exports.isAbsolute(path);\n        var parts = path.split(/\\/+/);\n\n        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n          part = parts[i];\n\n          if (part === '.') {\n            parts.splice(i, 1);\n          } else if (part === '..') {\n            up++;\n          } else if (up > 0) {\n            if (part === '') {\n              // The first part is blank if the path is absolute. Trying to go\n              // above the root is a no-op. Therefore we can remove all '..' parts\n              // directly after the root.\n              parts.splice(i + 1, up);\n              up = 0;\n            } else {\n              parts.splice(i, 2);\n              up--;\n            }\n          }\n        }\n\n        path = parts.join('/');\n\n        if (path === '') {\n          path = isAbsolute ? '/' : '.';\n        }\n\n        if (url) {\n          url.path = path;\n          return urlGenerate(url);\n        }\n\n        return path;\n      }\n\n      exports.normalize = normalize;\n      /**\n       * Joins two paths/URLs.\n       *\n       * @param aRoot The root path or URL.\n       * @param aPath The path or URL to be joined with the root.\n       *\n       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n       *   first.\n       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n       *   is updated with the result and aRoot is returned. Otherwise the result\n       *   is returned.\n       *   - If aPath is absolute, the result is aPath.\n       *   - Otherwise the two paths are joined with a slash.\n       * - Joining for example 'http://' and 'www.example.com' is also supported.\n       */\n\n      function join(aRoot, aPath) {\n        if (aRoot === \"\") {\n          aRoot = \".\";\n        }\n\n        if (aPath === \"\") {\n          aPath = \".\";\n        }\n\n        var aPathUrl = urlParse(aPath);\n        var aRootUrl = urlParse(aRoot);\n\n        if (aRootUrl) {\n          aRoot = aRootUrl.path || '/';\n        } // `join(foo, '//www.example.org')`\n\n\n        if (aPathUrl && !aPathUrl.scheme) {\n          if (aRootUrl) {\n            aPathUrl.scheme = aRootUrl.scheme;\n          }\n\n          return urlGenerate(aPathUrl);\n        }\n\n        if (aPathUrl || aPath.match(dataUrlRegexp)) {\n          return aPath;\n        } // `join('http://', 'www.example.com')`\n\n\n        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n          aRootUrl.host = aPath;\n          return urlGenerate(aRootUrl);\n        }\n\n        var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n        if (aRootUrl) {\n          aRootUrl.path = joined;\n          return urlGenerate(aRootUrl);\n        }\n\n        return joined;\n      }\n\n      exports.join = join;\n\n      exports.isAbsolute = function (aPath) {\n        return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n      };\n      /**\n       * Make a path relative to a URL or another path.\n       *\n       * @param aRoot The root path or URL.\n       * @param aPath The path or URL to be made relative to aRoot.\n       */\n\n\n      function relative(aRoot, aPath) {\n        if (aRoot === \"\") {\n          aRoot = \".\";\n        }\n\n        aRoot = aRoot.replace(/\\/$/, ''); // It is possible for the path to be above the root. In this case, simply\n        // checking whether the root is a prefix of the path won't work. Instead, we\n        // need to remove components from the root one by one, until either we find\n        // a prefix that fits, or we run out of components to remove.\n\n        var level = 0;\n\n        while (aPath.indexOf(aRoot + '/') !== 0) {\n          var index = aRoot.lastIndexOf(\"/\");\n\n          if (index < 0) {\n            return aPath;\n          } // If the only part of the root that is left is the scheme (i.e. http://,\n          // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n          // have exhausted all components, so the path is not relative to the root.\n\n\n          aRoot = aRoot.slice(0, index);\n\n          if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n            return aPath;\n          }\n\n          ++level;\n        } // Make sure we add a \"../\" for each component we removed from the root.\n\n\n        return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n      }\n\n      exports.relative = relative;\n\n      var supportsNullProto = function () {\n        var obj = Object.create(null);\n        return !('__proto__' in obj);\n      }();\n\n      function identity(s) {\n        return s;\n      }\n      /**\n       * Because behavior goes wacky when you set `__proto__` on objects, we\n       * have to prefix all the strings in our set with an arbitrary character.\n       *\n       * See https://github.com/mozilla/source-map/pull/31 and\n       * https://github.com/mozilla/source-map/issues/30\n       *\n       * @param String aStr\n       */\n\n\n      function toSetString(aStr) {\n        if (isProtoString(aStr)) {\n          return '$' + aStr;\n        }\n\n        return aStr;\n      }\n\n      exports.toSetString = supportsNullProto ? identity : toSetString;\n\n      function fromSetString(aStr) {\n        if (isProtoString(aStr)) {\n          return aStr.slice(1);\n        }\n\n        return aStr;\n      }\n\n      exports.fromSetString = supportsNullProto ? identity : fromSetString;\n\n      function isProtoString(s) {\n        if (!s) {\n          return false;\n        }\n\n        var length = s.length;\n\n        if (length < 9\n        /* \"__proto__\".length */\n        ) {\n            return false;\n          }\n\n        if (s.charCodeAt(length - 1) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 2) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 3) !== 111\n        /* 'o' */\n        || s.charCodeAt(length - 4) !== 116\n        /* 't' */\n        || s.charCodeAt(length - 5) !== 111\n        /* 'o' */\n        || s.charCodeAt(length - 6) !== 114\n        /* 'r' */\n        || s.charCodeAt(length - 7) !== 112\n        /* 'p' */\n        || s.charCodeAt(length - 8) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 9) !== 95\n        /* '_' */\n        ) {\n            return false;\n          }\n\n        for (var i = length - 10; i >= 0; i--) {\n          if (s.charCodeAt(i) !== 36\n          /* '$' */\n          ) {\n              return false;\n            }\n        }\n\n        return true;\n      }\n      /**\n       * Comparator between two mappings where the original positions are compared.\n       *\n       * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n       * mappings with the same original source/line/column, but different generated\n       * line and column the same. Useful when searching for a mapping with a\n       * stubbed out mapping.\n       */\n\n\n      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n        var cmp = mappingA.source - mappingB.source;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0 || onlyCompareOriginal) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return mappingA.name - mappingB.name;\n      }\n\n      exports.compareByOriginalPositions = compareByOriginalPositions;\n      /**\n       * Comparator between two mappings with deflated source and name indices where\n       * the generated positions are compared.\n       *\n       * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n       * mappings with the same generated line and column, but different\n       * source/name/original line and column the same. Useful when searching for a\n       * mapping with a stubbed out mapping.\n       */\n\n      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0 || onlyCompareGenerated) {\n          return cmp;\n        }\n\n        cmp = mappingA.source - mappingB.source;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return mappingA.name - mappingB.name;\n      }\n\n      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n      function strcmp(aStr1, aStr2) {\n        if (aStr1 === aStr2) {\n          return 0;\n        }\n\n        if (aStr1 > aStr2) {\n          return 1;\n        }\n\n        return -1;\n      }\n      /**\n       * Comparator between two mappings with inflated source and name strings where\n       * the generated positions are compared.\n       */\n\n\n      function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = strcmp(mappingA.source, mappingB.source);\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return strcmp(mappingA.name, mappingB.name);\n      }\n\n      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      exports.GREATEST_LOWER_BOUND = 1;\n      exports.LEAST_UPPER_BOUND = 2;\n      /**\n       * Recursive implementation of binary search.\n       *\n       * @param aLow Indices here and lower do not contain the needle.\n       * @param aHigh Indices here and higher do not contain the needle.\n       * @param aNeedle The element being searched for.\n       * @param aHaystack The non-empty array being searched.\n       * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       */\n\n      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n        // This function terminates when one of the following is true:\n        //\n        //   1. We find the exact element we are looking for.\n        //\n        //   2. We did not find the exact element, but we can return the index of\n        //      the next-closest element.\n        //\n        //   3. We did not find the exact element, and there is no next-closest\n        //      element than the one we are searching for, so we return -1.\n        var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n        var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\n        if (cmp === 0) {\n          // Found the element we are looking for.\n          return mid;\n        } else if (cmp > 0) {\n          // Our needle is greater than aHaystack[mid].\n          if (aHigh - mid > 1) {\n            // The element is in the upper half.\n            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n          } // The exact needle element was not found in this haystack. Determine if\n          // we are in termination case (3) or (2) and return the appropriate thing.\n\n\n          if (aBias == exports.LEAST_UPPER_BOUND) {\n            return aHigh < aHaystack.length ? aHigh : -1;\n          } else {\n            return mid;\n          }\n        } else {\n          // Our needle is less than aHaystack[mid].\n          if (mid - aLow > 1) {\n            // The element is in the lower half.\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n          } // we are in termination case (3) or (2) and return the appropriate thing.\n\n\n          if (aBias == exports.LEAST_UPPER_BOUND) {\n            return mid;\n          } else {\n            return aLow < 0 ? -1 : aLow;\n          }\n        }\n      }\n      /**\n       * This is an implementation of binary search which will always try and return\n       * the index of the closest element if there is no exact hit. This is because\n       * mappings between original and generated line/col pairs are single points,\n       * and there is an implicit region between each of them, so a miss just means\n       * that you aren't on the very start of a region.\n       *\n       * @param aNeedle The element you are looking for.\n       * @param aHaystack The array that is being searched.\n       * @param aCompare A function which takes the needle and an element in the\n       *     array and returns -1, 0, or 1 depending on whether the needle is less\n       *     than, equal to, or greater than the element, respectively.\n       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n       */\n\n\n      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n        if (aHaystack.length === 0) {\n          return -1;\n        }\n\n        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\n        if (index < 0) {\n          return -1;\n        } // We have found either the exact element, or the next-closest element than\n        // the one we are searching for. However, there may be more than one such\n        // element. Make sure we always return the smallest of these.\n\n\n        while (index - 1 >= 0) {\n          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n            break;\n          }\n\n          --index;\n        }\n\n        return index;\n      };\n      /***/\n\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(2);\n\n      var has = Object.prototype.hasOwnProperty;\n      /**\n       * A data structure which is a combination of an array and a set. Adding a new\n       * member is O(1), testing for membership is O(1), and finding the index of an\n       * element is O(1). Removing elements from the set is not supported. Only\n       * strings are supported for membership.\n       */\n\n      function ArraySet() {\n        this._array = [];\n        this._set = Object.create(null);\n      }\n      /**\n       * Static method for creating ArraySet instances from an existing array.\n       */\n\n\n      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n        var set = new ArraySet();\n\n        for (var i = 0, len = aArray.length; i < len; i++) {\n          set.add(aArray[i], aAllowDuplicates);\n        }\n\n        return set;\n      };\n      /**\n       * Return how many unique items are in this ArraySet. If duplicates have been\n       * added, than those do not count towards the size.\n       *\n       * @returns Number\n       */\n\n\n      ArraySet.prototype.size = function ArraySet_size() {\n        return Object.getOwnPropertyNames(this._set).length;\n      };\n      /**\n       * Add the given string to this set.\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n        var sStr = util.toSetString(aStr);\n        var isDuplicate = has.call(this._set, sStr);\n        var idx = this._array.length;\n\n        if (!isDuplicate || aAllowDuplicates) {\n          this._array.push(aStr);\n        }\n\n        if (!isDuplicate) {\n          this._set[sStr] = idx;\n        }\n      };\n      /**\n       * Is the given string a member of this set?\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.has = function ArraySet_has(aStr) {\n        var sStr = util.toSetString(aStr);\n        return has.call(this._set, sStr);\n      };\n      /**\n       * What is the index of the given string in the array?\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n        var sStr = util.toSetString(aStr);\n\n        if (has.call(this._set, sStr)) {\n          return this._set[sStr];\n        }\n\n        throw new Error('\"' + aStr + '\" is not in the set.');\n      };\n      /**\n       * What is the element at the given index?\n       *\n       * @param Number aIdx\n       */\n\n\n      ArraySet.prototype.at = function ArraySet_at(aIdx) {\n        if (aIdx >= 0 && aIdx < this._array.length) {\n          return this._array[aIdx];\n        }\n\n        throw new Error('No element indexed by ' + aIdx);\n      };\n      /**\n       * Returns the array representation of this set (which has the proper indices\n       * indicated by indexOf). Note that this is a copy of the internal array used\n       * for storing the members so that no one can mess with internal state.\n       */\n\n\n      ArraySet.prototype.toArray = function ArraySet_toArray() {\n        return this._array.slice();\n      };\n\n      exports.ArraySet = ArraySet;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       *\n       * Based on the Base 64 VLQ implementation in Closure Compiler:\n       * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n       *\n       * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n       * Redistribution and use in source and binary forms, with or without\n       * modification, are permitted provided that the following conditions are\n       * met:\n       *\n       *  * Redistributions of source code must retain the above copyright\n       *    notice, this list of conditions and the following disclaimer.\n       *  * Redistributions in binary form must reproduce the above\n       *    copyright notice, this list of conditions and the following\n       *    disclaimer in the documentation and/or other materials provided\n       *    with the distribution.\n       *  * Neither the name of Google Inc. nor the names of its\n       *    contributors may be used to endorse or promote products derived\n       *    from this software without specific prior written permission.\n       *\n       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n       * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n       * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n       * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n       * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n       * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n       * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n       * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n       * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n       * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n       * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n       */\n      var base64 = __webpack_require__(6); // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n      // length quantities we use in the source map spec, the first bit is the sign,\n      // the next four bits are the actual value, and the 6th bit is the\n      // continuation bit. The continuation bit tells us whether there are more\n      // digits in this value following this digit.\n      //\n      //   Continuation\n      //   |    Sign\n      //   |    |\n      //   V    V\n      //   101011\n\n\n      var VLQ_BASE_SHIFT = 5; // binary: 100000\n\n      var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111\n\n      var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000\n\n      var VLQ_CONTINUATION_BIT = VLQ_BASE;\n      /**\n       * Converts from a two-complement value to a value where the sign bit is\n       * placed in the least significant bit.  For example, as decimals:\n       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n       */\n\n      function toVLQSigned(aValue) {\n        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n      }\n      /**\n       * Converts to a two-complement value from a value where the sign bit is\n       * placed in the least significant bit.  For example, as decimals:\n       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n       */\n\n\n      function fromVLQSigned(aValue) {\n        var isNegative = (aValue & 1) === 1;\n        var shifted = aValue >> 1;\n        return isNegative ? -shifted : shifted;\n      }\n      /**\n       * Returns the base 64 VLQ encoded value.\n       */\n\n\n      exports.encode = function base64VLQ_encode(aValue) {\n        var encoded = \"\";\n        var digit;\n        var vlq = toVLQSigned(aValue);\n\n        do {\n          digit = vlq & VLQ_BASE_MASK;\n          vlq >>>= VLQ_BASE_SHIFT;\n\n          if (vlq > 0) {\n            // There are still more digits in this value, so we must make sure the\n            // continuation bit is marked.\n            digit |= VLQ_CONTINUATION_BIT;\n          }\n\n          encoded += base64.encode(digit);\n        } while (vlq > 0);\n\n        return encoded;\n      };\n      /**\n       * Decodes the next base 64 VLQ value from the given string and returns the\n       * value and the rest of the string via the out parameter.\n       */\n\n\n      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n        var strLen = aStr.length;\n        var result = 0;\n        var shift = 0;\n        var continuation, digit;\n\n        do {\n          if (aIndex >= strLen) {\n            throw new Error(\"Expected more digits in base 64 VLQ value.\");\n          }\n\n          digit = base64.decode(aStr.charCodeAt(aIndex++));\n\n          if (digit === -1) {\n            throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n          }\n\n          continuation = !!(digit & VLQ_CONTINUATION_BIT);\n          digit &= VLQ_BASE_MASK;\n          result = result + (digit << shift);\n          shift += VLQ_BASE_SHIFT;\n        } while (continuation);\n\n        aOutParam.value = fromVLQSigned(result);\n        aOutParam.rest = aIndex;\n      };\n      /***/\n\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n      /**\n       * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n       */\n\n      exports.encode = function (number) {\n        if (0 <= number && number < intToCharMap.length) {\n          return intToCharMap[number];\n        }\n\n        throw new TypeError(\"Must be between 0 and 63: \" + number);\n      };\n      /**\n       * Decode a single base 64 character code digit to an integer. Returns -1 on\n       * failure.\n       */\n\n\n      exports.decode = function (charCode) {\n        var bigA = 65; // 'A'\n\n        var bigZ = 90; // 'Z'\n\n        var littleA = 97; // 'a'\n\n        var littleZ = 122; // 'z'\n\n        var zero = 48; // '0'\n\n        var nine = 57; // '9'\n\n        var plus = 43; // '+'\n\n        var slash = 47; // '/'\n\n        var littleOffset = 26;\n        var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n        if (bigA <= charCode && charCode <= bigZ) {\n          return charCode - bigA;\n        } // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\n\n        if (littleA <= charCode && charCode <= littleZ) {\n          return charCode - littleA + littleOffset;\n        } // 52 - 61: 0123456789\n\n\n        if (zero <= charCode && charCode <= nine) {\n          return charCode - zero + numberOffset;\n        } // 62: +\n\n\n        if (charCode == plus) {\n          return 62;\n        } // 63: /\n\n\n        if (charCode == slash) {\n          return 63;\n        } // Invalid base64 digit.\n\n\n        return -1;\n      };\n      /***/\n\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      // It turns out that some (most?) JavaScript engines don't self-host\n      // `Array.prototype.sort`. This makes sense because C++ will likely remain\n      // faster than JS when doing raw CPU-intensive sorting. However, when using a\n      // custom comparator function, calling back and forth between the VM's C++ and\n      // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n      // worse generated code for the comparator function than would be optimal. In\n      // fact, when sorting with a comparator, these costs outweigh the benefits of\n      // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n      // a ~3500ms mean speed-up in `bench/bench.html`.\n\n      /**\n       * Swap the elements indexed by `x` and `y` in the array `ary`.\n       *\n       * @param {Array} ary\n       *        The array.\n       * @param {Number} x\n       *        The index of the first item.\n       * @param {Number} y\n       *        The index of the second item.\n       */\n      function swap(ary, x, y) {\n        var temp = ary[x];\n        ary[x] = ary[y];\n        ary[y] = temp;\n      }\n      /**\n       * Returns a random integer within the range `low .. high` inclusive.\n       *\n       * @param {Number} low\n       *        The lower bound on the range.\n       * @param {Number} high\n       *        The upper bound on the range.\n       */\n\n\n      function randomIntInRange(low, high) {\n        return Math.round(low + Math.random() * (high - low));\n      }\n      /**\n       * The Quick Sort algorithm.\n       *\n       * @param {Array} ary\n       *        An array to sort.\n       * @param {function} comparator\n       *        Function to use to compare two items.\n       * @param {Number} p\n       *        Start index of the array\n       * @param {Number} r\n       *        End index of the array\n       */\n\n\n      function doQuickSort(ary, comparator, p, r) {\n        // If our lower bound is less than our upper bound, we (1) partition the\n        // array into two pieces and (2) recurse on each half. If it is not, this is\n        // the empty array and our base case.\n        if (p < r) {\n          // (1) Partitioning.\n          //\n          // The partitioning chooses a pivot between `p` and `r` and moves all\n          // elements that are less than or equal to the pivot to the before it, and\n          // all the elements that are greater than it after it. The effect is that\n          // once partition is done, the pivot is in the exact place it will be when\n          // the array is put in sorted order, and it will not need to be moved\n          // again. This runs in O(n) time.\n          // Always choose a random pivot so that an input array which is reverse\n          // sorted does not cause O(n^2) running time.\n          var pivotIndex = randomIntInRange(p, r);\n          var i = p - 1;\n          swap(ary, pivotIndex, r);\n          var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold\n          // true:\n          //\n          //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n          //\n          //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\n          for (var j = p; j < r; j++) {\n            if (comparator(ary[j], pivot) <= 0) {\n              i += 1;\n              swap(ary, i, j);\n            }\n          }\n\n          swap(ary, i + 1, j);\n          var q = i + 1; // (2) Recurse on each half.\n\n          doQuickSort(ary, comparator, p, q - 1);\n          doQuickSort(ary, comparator, q + 1, r);\n        }\n      }\n      /**\n       * Sort the given array in-place with the given comparator function.\n       *\n       * @param {Array} ary\n       *        An array to sort.\n       * @param {function} comparator\n       *        Function to use to compare two items.\n       */\n\n\n      exports.quickSort = function (ary, comparator) {\n        doQuickSort(ary, comparator, 0, ary.length - 1);\n      };\n      /***/\n\n    }\n    /******/\n    ])\n  );\n});\n\n;","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/sourcemapped-stacktrace/dist/sourcemapped-stacktrace.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","installedModules","__webpack_require__","moduleId","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","source_map_consumer","global_mapForUri","mapStackTrace","stack","done","opts","lines","line","mapForUri","rows","fields","uri","expected_fields","regex","skip_lines","fetcher","Fetcher","traceFormat","Error","isChromeOrEdge","isIE11Plus","isFirefox","isSafari","split","slice","i","length","filter","match","fetchScript","sem","whenReady","result","processSourceMaps","navigator","userAgent","toLowerCase","indexOf","document","documentMode","Semaphore","count","pending","prototype","incr","decr","flush","fn","push","forEach","sync","cacheGlobally","ajax","callback","xhr","createXMLHTTPObject","that","onreadystatechange","readyState","open","send","onScriptLoad","absUrlRegex","RegExp","status","responseText","mapUri","embeddedSourceMap","SourceMapConsumer","atob","test","origin","lastSlash","lastIndexOf","map","origName","origNameChrome","origNameFirefox","row","parseInt","column","origPos","originalPositionFor","formatOriginalPosition","source","name","origLine","exec","XMLHttpFactories","XMLHttpRequest","ActiveXObject","xmlhttp","e","apply","undefined","util","binarySearch","ArraySet","base64VLQ","quickSort","aSourceMap","sourceMap","JSON","parse","replace","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","fromSourceMap","_version","__generatedMappings","Object","defineProperty","get","_parseMappings","_mappings","sourceRoot","__originalMappings","_charIsMappingSeparator","SourceMapConsumer_charIsMappingSeparator","aStr","index","charAt","SourceMapConsumer_parseMappings","aSourceRoot","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","eachMapping","SourceMapConsumer_eachMapping","aCallback","aContext","aOrder","context","order","mappings","_generatedMappings","_originalMappings","mapping","_sources","at","join","generatedLine","generatedColumn","originalLine","originalColumn","_names","allGeneratedPositionsFor","SourceMapConsumer_allGeneratedPositionsFor","aArgs","getArg","needle","relative","has","_findMapping","compareByOriginalPositions","lastColumn","version","sources","names","sourcesContent","file","String","normalize","isAbsolute","fromArray","create","consumer","SourceMapConsumer_fromSourceMap","smc","toArray","_sourceRoot","_generateSourcesContent","_file","generatedMappings","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","Mapping","s","previousGeneratedColumn","previousOriginalLine","previousOriginalColumn","previousSource","previousName","cachedSegments","temp","originalMappings","str","segment","end","value","decode","rest","compareByGeneratedPositionsDeflated","SourceMapConsumer_findMapping","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","TypeError","search","computeColumnSpans","SourceMapConsumer_computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","SourceMapConsumer_originalPositionFor","hasContentsOfAllSources","BasicSourceMapConsumer_hasContentsOfAllSources","size","some","sc","sourceContentFor","SourceMapConsumer_sourceContentFor","aSource","nullOnMissing","url","urlParse","fileUriAbsPath","scheme","path","generatedPositionFor","SourceMapConsumer_generatedPositionFor","lastOffset","_sections","offset","offsetLine","offsetColumn","generatedOffset","constructor","j","IndexedSourceMapConsumer_originalPositionFor","sectionIndex","section","cmp","bias","IndexedSourceMapConsumer_hasContentsOfAllSources","every","IndexedSourceMapConsumer_sourceContentFor","content","IndexedSourceMapConsumer_generatedPositionFor","generatedPosition","ret","IndexedSourceMapConsumer_parseMappings","sectionMappings","add","adjustedMapping","aName","aDefaultValue","arguments","urlRegexp","dataUrlRegexp","aUrl","auth","host","port","urlGenerate","aParsedUrl","aPath","parts","part","up","splice","aRoot","aPathUrl","aRootUrl","joined","level","Array","substr","supportsNullProto","obj","identity","toSetString","isProtoString","fromSetString","charCodeAt","mappingA","mappingB","onlyCompareOriginal","onlyCompareGenerated","strcmp","aStr1","aStr2","compareByGeneratedPositionsInflated","recursiveSearch","aLow","aHigh","aHaystack","aCompare","mid","Math","floor","hasOwnProperty","_array","_set","ArraySet_fromArray","aArray","aAllowDuplicates","set","len","ArraySet_size","getOwnPropertyNames","ArraySet_add","sStr","isDuplicate","idx","ArraySet_has","ArraySet_indexOf","ArraySet_at","aIdx","ArraySet_toArray","base64","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","toVLQSigned","aValue","fromVLQSigned","isNegative","shifted","encode","base64VLQ_encode","encoded","digit","vlq","base64VLQ_decode","aIndex","aOutParam","strLen","shift","continuation","intToCharMap","number","charCode","bigA","bigZ","littleA","littleZ","zero","nine","plus","slash","littleOffset","numberOffset","swap","ary","x","y","randomIntInRange","low","high","round","random","doQuickSort","comparator","r","pivotIndex","pivot","q"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sourceMappedStackTrace\"] = factory();\n\telse\n\t\troot[\"sourceMappedStackTrace\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\t * sourcemapped-stacktrace.js\n\t * created by James Salter <iteration@gmail.com> (2014)\n\t *\n\t * https://github.com/novocaine/sourcemapped-stacktrace\n\t *\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\t/*global define */\n\n\t// note we only include source-map-consumer, not the whole source-map library,\n\t// which includes gear for generating source maps that we don't need\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(source_map_consumer) {\n\n\t  var global_mapForUri = {};\n\n\t  /**\n\t   * Re-map entries in a stacktrace using sourcemaps if available.\n\t   *\n\t   * @param {str} stack - The stacktrace from the browser.\n\t   * @param {function} done - Callback invoked with the transformed stacktrace\n\t   *                          (an Array of Strings) passed as the first\n\t   *                          argument\n\t   * @param {Object} [opts] - Optional options object.\n\t   * @param {Function} [opts.filter] - Filter function applied to each stackTrace line.\n\t   *                                   Lines which do not pass the filter won't be processesd.\n\t   * @param {boolean} [opts.cacheGlobally] - Whether to cache sourcemaps globally across multiple calls.\n\t   * @param {boolean} [opts.sync] - Whether to use synchronous ajax to load the sourcemaps.\n\t   * @param {string} [opts.traceFormat] - If `error.stack` is formatted according to chrome or\n\t   *                                      Firefox's style.  Can be either `\"chrome\"`, `\"firefox\"`\n\t   *                                      or `undefined` (default).  If `undefined`, this library\n\t   *                                      will guess based on `navigator.userAgent`.\n\t   */\n\t  var mapStackTrace = function(stack, done, opts) {\n\t    var lines;\n\t    var line;\n\t    var mapForUri = {};\n\t    var rows = {};\n\t    var fields;\n\t    var uri;\n\t    var expected_fields;\n\t    var regex;\n\t    var skip_lines;\n\n\t    var fetcher = new Fetcher(opts);\n\n\t    var traceFormat = opts && opts.traceFormat;\n\t    if (traceFormat !== \"chrome\" && traceFormat !== \"firefox\") {\n\t      if (traceFormat) {\n\t        throw new Error(\"unknown traceFormat \\\"\" + traceFormat + \"\\\" :(\");\n\t      } else if (isChromeOrEdge() || isIE11Plus()) {\n\t        traceFormat = \"chrome\";\n\t      } else if (isFirefox() || isSafari()) {\n\t        traceFormat = \"firefox\";\n\t      } else {\n\t        throw new Error(\"unknown browser :(\");\n\t      }\n\t    }\n\n\t    if (traceFormat === \"chrome\") {\n\t      regex = /^ +at.+\\((.*):([0-9]+):([0-9]+)/;\n\t      expected_fields = 4;\n\t      // (skip first line containing exception message)\n\t      skip_lines = 1;\n\t    } else {\n\t      regex = /@(.*):([0-9]+):([0-9]+)/;\n\t      expected_fields = 4;\n\t      skip_lines = 0;\n\t    }\n\n\t    lines = stack.split(\"\\n\").slice(skip_lines);\n\n\t    for (var i=0; i < lines.length; i++) {\n\t      line = lines[i];\n\t      if ( opts && opts.filter && !opts.filter(line) ) continue;\n\t      \n\t      fields = line.match(regex);\n\t      if (fields && fields.length === expected_fields) {\n\t        rows[i] = fields;\n\t        uri = fields[1];\n\t        if (!uri.match(/<anonymous>/)) {\n\t          fetcher.fetchScript(uri);\n\t        }\n\t      }\n\t    }\n\n\t    fetcher.sem.whenReady(function() {\n\t      var result = processSourceMaps(lines, rows, fetcher.mapForUri, traceFormat);\n\t      done(result);\n\t    });\n\t  };\n\n\t  var isChromeOrEdge = function() {\n\t    return navigator.userAgent.toLowerCase().indexOf('chrome') > -1;\n\t  };\n\n\t  var isFirefox = function() {\n\t    return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\t  };  \n\n\t  var isSafari = function() {\n\t    return navigator.userAgent.toLowerCase().indexOf('safari') > -1;\n\t  };\n\t\t\t\n\t  var isIE11Plus = function() {\n\t   \treturn document.documentMode && document.documentMode >= 11;\n\t  };\n\n\n\t  var Semaphore = function() {\n\t    this.count = 0;\n\t    this.pending = [];\n\t  };\n\n\t  Semaphore.prototype.incr = function() {\n\t    this.count++;\n\t  };\n\n\t  Semaphore.prototype.decr = function() {\n\t    this.count--;\n\t    this.flush();\n\t  };\n\n\t  Semaphore.prototype.whenReady = function(fn) {\n\t    this.pending.push(fn);\n\t    this.flush();\n\t  };\n\n\t  Semaphore.prototype.flush = function() {\n\t    if (this.count === 0) {\n\t        this.pending.forEach(function(fn) { fn(); });\n\t        this.pending = [];\n\t    }\n\t  };\n\n\n\t  var Fetcher = function(opts) {\n\t    this.sem = new Semaphore();\n\t    this.sync = opts && opts.sync;\n\t    this.mapForUri = opts && opts.cacheGlobally ? global_mapForUri : {};\n\t  };\n\n\t  Fetcher.prototype.ajax = function(uri, callback) {\n\t    var xhr = createXMLHTTPObject();\n\t    var that = this;\n\t    xhr.onreadystatechange = function() {\n\t      if (xhr.readyState == 4) {\n\t        callback.call(that, xhr, uri);\n\t      }\n\t    };\n\t    xhr.open(\"GET\", uri, !this.sync);\n\t    xhr.send();\n\t  }\n\n\t  Fetcher.prototype.fetchScript = function(uri) {\n\t    if (!(uri in this.mapForUri)) {\n\t      this.sem.incr();\n\t      this.mapForUri[uri] = null;\n\t    } else {\n\t      return;\n\t    }\n\n\t    this.ajax(uri, this.onScriptLoad);\n\t  };\n\n\t  var absUrlRegex = new RegExp('^(?:[a-z]+:)?//', 'i');\n\n\t  Fetcher.prototype.onScriptLoad = function(xhr, uri) {\n\t    if (xhr.status === 200 || (uri.slice(0, 7) === \"file://\" && xhr.status === 0)) {\n\t      // find .map in file.\n\t      //\n\t      // attempt to find it at the very end of the file, but tolerate trailing\n\t      // whitespace inserted by some packers.\n\t      var match = xhr.responseText.match(\"//# [s]ourceMappingURL=(.*)[\\\\s]*$\", \"m\");\n\t      if (match && match.length === 2) {\n\t        // get the map\n\t        var mapUri = match[1];\n\n\t        var embeddedSourceMap = mapUri.match(\"data:application/json;(charset=[^;]+;)?base64,(.*)\");\n\n\t        if (embeddedSourceMap && embeddedSourceMap[2]) {\n\t          this.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(atob(embeddedSourceMap[2]));\n\t          this.sem.decr();\n\t        } else {\n\t          if (!absUrlRegex.test(mapUri)) {\n\t            // relative url; according to sourcemaps spec is 'source origin'\n\t            var origin;\n\t            var lastSlash = uri.lastIndexOf('/');\n\t            if (lastSlash !== -1) {\n\t              origin = uri.slice(0, lastSlash + 1);\n\t              mapUri = origin + mapUri;\n\t              // note if lastSlash === -1, actual script uri has no slash\n\t              // somehow, so no way to use it as a prefix... we give up and try\n\t              // as absolute\n\t            }\n\t          }\n\n\t          this.ajax(mapUri, function(xhr) {\n\t            if (xhr.status === 200 || (mapUri.slice(0, 7) === \"file://\" && xhr.status === 0)) {\n\t              this.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(xhr.responseText);\n\t            }\n\t            this.sem.decr();\n\t          });\n\t        }\n\t      } else {\n\t        // no map\n\t        this.sem.decr();\n\t      }\n\t    } else {\n\t      // HTTP error fetching uri of the script\n\t      this.sem.decr();\n\t    }\n\t  };\n\n\t  var processSourceMaps = function(lines, rows, mapForUri, traceFormat) {\n\t    var result = [];\n\t    var map;\n\t    var origName = traceFormat === \"chrome\" ? origNameChrome : origNameFirefox;\n\t    for (var i=0; i < lines.length; i++) {\n\t      var row = rows[i];\n\t      if (row) {\n\t        var uri = row[1];\n\t        var line = parseInt(row[2], 10);\n\t        var column = parseInt(row[3], 10);\n\t        map = mapForUri[uri];\n\n\t        if (map) {\n\t          // we think we have a map for that uri. call source-map library\n\t          var origPos = map.originalPositionFor(\n\t            { line: line, column: column });\n\t          result.push(formatOriginalPosition(origPos.source,\n\t            origPos.line, origPos.column, origPos.name || origName(lines[i])));\n\t        } else {\n\t          // we can't find a map for that url, but we parsed the row.\n\t          // reformat unchanged line for consistency with the sourcemapped\n\t          // lines.\n\t          result.push(formatOriginalPosition(uri, line, column, origName(lines[i])));\n\t        }\n\t      } else {\n\t        // we weren't able to parse the row, push back what we were given\n\t        result.push(lines[i]);\n\t      }\n\t    }\n\n\t    return result;\n\t  };\n\n\t  function origNameChrome(origLine) {\n\t    var match = / +at +([^ ]*).*/.exec(origLine);\n\t    return match && match[1];\n\t  }\n\n\t  function origNameFirefox(origLine) {\n\t    var match = /([^@]*)@.*/.exec(origLine);\n\t    return match && match[1];\n\t  }\n\n\t  var formatOriginalPosition = function(source, line, column, name) {\n\t    // mimic chrome's format\n\t    return \"    at \" + (name ? name : \"(unknown)\") +\n\t      \" (\" + source + \":\" + line + \":\" + column + \")\";\n\t  };\n\n\t  // xmlhttprequest boilerplate\n\t  var XMLHttpFactories = [\n\t\tfunction () {return new XMLHttpRequest();},\n\t\tfunction () {return new ActiveXObject(\"Msxml2.XMLHTTP\");},\n\t\tfunction () {return new ActiveXObject(\"Msxml3.XMLHTTP\");},\n\t\tfunction () {return new ActiveXObject(\"Microsoft.XMLHTTP\");}\n\t  ];\n\n\t  function createXMLHTTPObject() {\n\t      var xmlhttp = false;\n\t      for (var i=0;i<XMLHttpFactories.length;i++) {\n\t          try {\n\t              xmlhttp = XMLHttpFactories[i]();\n\t          }\n\t          catch (e) {\n\t              continue;\n\t          }\n\t          break;\n\t      }\n\t      return xmlhttp;\n\t  }\n\n\t  return {\n\t    mapStackTrace: mapStackTrace\n\t  }\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\tvar util = __webpack_require__(2);\n\tvar binarySearch = __webpack_require__(3);\n\tvar ArraySet = __webpack_require__(4).ArraySet;\n\tvar base64VLQ = __webpack_require__(5);\n\tvar quickSort = __webpack_require__(7).quickSort;\n\n\tfunction SourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\n\t  return sourceMap.sections != null\n\t    ? new IndexedSourceMapConsumer(sourceMap)\n\t    : new BasicSourceMapConsumer(sourceMap);\n\t}\n\n\tSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n\t  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n\t}\n\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tSourceMapConsumer.prototype._version = 3;\n\n\t// `__generatedMappings` and `__originalMappings` are arrays that hold the\n\t// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n\t// are lazily instantiated, accessed via the `_generatedMappings` and\n\t// `_originalMappings` getters respectively, and we only parse the mappings\n\t// and create these arrays once queried for a source location. We jump through\n\t// these hoops because there can be many thousands of mappings, and parsing\n\t// them is expensive, so we only want to do it if we must.\n\t//\n\t// Each object in the arrays is of the form:\n\t//\n\t//     {\n\t//       generatedLine: The line number in the generated code,\n\t//       generatedColumn: The column number in the generated code,\n\t//       source: The path to the original source file that generated this\n\t//               chunk of code,\n\t//       originalLine: The line number in the original source that\n\t//                     corresponds to this chunk of generated code,\n\t//       originalColumn: The column number in the original source that\n\t//                       corresponds to this chunk of generated code,\n\t//       name: The name of the original symbol which generated this chunk of\n\t//             code.\n\t//     }\n\t//\n\t// All properties except for `generatedLine` and `generatedColumn` can be\n\t// `null`.\n\t//\n\t// `_generatedMappings` is ordered by the generated positions.\n\t//\n\t// `_originalMappings` is ordered by the original positions.\n\n\tSourceMapConsumer.prototype.__generatedMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n\t  get: function () {\n\t    if (!this.__generatedMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\n\t    return this.__generatedMappings;\n\t  }\n\t});\n\n\tSourceMapConsumer.prototype.__originalMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n\t  get: function () {\n\t    if (!this.__originalMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\n\t    return this.__originalMappings;\n\t  }\n\t});\n\n\tSourceMapConsumer.prototype._charIsMappingSeparator =\n\t  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n\t    var c = aStr.charAt(index);\n\t    return c === \";\" || c === \",\";\n\t  };\n\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    throw new Error(\"Subclasses must implement _parseMappings\");\n\t  };\n\n\tSourceMapConsumer.GENERATED_ORDER = 1;\n\tSourceMapConsumer.ORIGINAL_ORDER = 2;\n\n\tSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n\tSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n\t/**\n\t * Iterate over each mapping between an original source/line/column and a\n\t * generated line/column in this source map.\n\t *\n\t * @param Function aCallback\n\t *        The function that is called with each mapping.\n\t * @param Object aContext\n\t *        Optional. If specified, this object will be the value of `this` every\n\t *        time that `aCallback` is called.\n\t * @param aOrder\n\t *        Either `SourceMapConsumer.GENERATED_ORDER` or\n\t *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n\t *        iterate over the mappings sorted by the generated file's line/column\n\t *        order or the original's source/line/column order, respectively. Defaults to\n\t *        `SourceMapConsumer.GENERATED_ORDER`.\n\t */\n\tSourceMapConsumer.prototype.eachMapping =\n\t  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n\t    var context = aContext || null;\n\t    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n\t    var mappings;\n\t    switch (order) {\n\t    case SourceMapConsumer.GENERATED_ORDER:\n\t      mappings = this._generatedMappings;\n\t      break;\n\t    case SourceMapConsumer.ORIGINAL_ORDER:\n\t      mappings = this._originalMappings;\n\t      break;\n\t    default:\n\t      throw new Error(\"Unknown order of iteration.\");\n\t    }\n\n\t    var sourceRoot = this.sourceRoot;\n\t    mappings.map(function (mapping) {\n\t      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n\t      if (source != null && sourceRoot != null) {\n\t        source = util.join(sourceRoot, source);\n\t      }\n\t      return {\n\t        source: source,\n\t        generatedLine: mapping.generatedLine,\n\t        generatedColumn: mapping.generatedColumn,\n\t        originalLine: mapping.originalLine,\n\t        originalColumn: mapping.originalColumn,\n\t        name: mapping.name === null ? null : this._names.at(mapping.name)\n\t      };\n\t    }, this).forEach(aCallback, context);\n\t  };\n\n\t/**\n\t * Returns all generated line and column information for the original source,\n\t * line, and column provided. If no column is provided, returns all mappings\n\t * corresponding to a either the line we are searching for or the next\n\t * closest line that has any mappings. Otherwise, returns all mappings\n\t * corresponding to the given line and either the column we are searching for\n\t * or the next closest column that has any offsets.\n\t *\n\t * The only argument is an object with the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: Optional. the column number in the original source.\n\t *\n\t * and an array of objects is returned, each with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tSourceMapConsumer.prototype.allGeneratedPositionsFor =\n\t  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n\t    var line = util.getArg(aArgs, 'line');\n\n\t    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n\t    // returns the index of the closest mapping less than the needle. By\n\t    // setting needle.originalColumn to 0, we thus find the last mapping for\n\t    // the given line, provided such a mapping exists.\n\t    var needle = {\n\t      source: util.getArg(aArgs, 'source'),\n\t      originalLine: line,\n\t      originalColumn: util.getArg(aArgs, 'column', 0)\n\t    };\n\n\t    if (this.sourceRoot != null) {\n\t      needle.source = util.relative(this.sourceRoot, needle.source);\n\t    }\n\t    if (!this._sources.has(needle.source)) {\n\t      return [];\n\t    }\n\t    needle.source = this._sources.indexOf(needle.source);\n\n\t    var mappings = [];\n\n\t    var index = this._findMapping(needle,\n\t                                  this._originalMappings,\n\t                                  \"originalLine\",\n\t                                  \"originalColumn\",\n\t                                  util.compareByOriginalPositions,\n\t                                  binarySearch.LEAST_UPPER_BOUND);\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\n\t      if (aArgs.column === undefined) {\n\t        var originalLine = mapping.originalLine;\n\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we found. Since\n\t        // mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we found.\n\t        while (mapping && mapping.originalLine === originalLine) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      } else {\n\t        var originalColumn = mapping.originalColumn;\n\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we were searching for.\n\t        // Since mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we are searching for.\n\t        while (mapping &&\n\t               mapping.originalLine === line &&\n\t               mapping.originalColumn == originalColumn) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      }\n\t    }\n\n\t    return mappings;\n\t  };\n\n\texports.SourceMapConsumer = SourceMapConsumer;\n\n\t/**\n\t * A BasicSourceMapConsumer instance represents a parsed source map which we can\n\t * query for information about the original file positions by giving it a file\n\t * position in the generated source.\n\t *\n\t * The only parameter is the raw source map (either as a JSON string, or\n\t * already parsed to an object). According to the spec, source maps have the\n\t * following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - sources: An array of URLs to the original source files.\n\t *   - names: An array of identifiers which can be referrenced by individual mappings.\n\t *   - sourceRoot: Optional. The URL root from which all sources are relative.\n\t *   - sourcesContent: Optional. An array of contents of the original source files.\n\t *   - mappings: A string of base64 VLQs which contain the actual mappings.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *\n\t * Here is an example source map, taken from the source map spec[0]:\n\t *\n\t *     {\n\t *       version : 3,\n\t *       file: \"out.js\",\n\t *       sourceRoot : \"\",\n\t *       sources: [\"foo.js\", \"bar.js\"],\n\t *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *       mappings: \"AA,AB;;ABCDE;\"\n\t *     }\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n\t */\n\tfunction BasicSourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sources = util.getArg(sourceMap, 'sources');\n\t  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n\t  // requires the array) to play nice here.\n\t  var names = util.getArg(sourceMap, 'names', []);\n\t  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n\t  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n\t  var mappings = util.getArg(sourceMap, 'mappings');\n\t  var file = util.getArg(sourceMap, 'file', null);\n\n\t  // Once again, Sass deviates from the spec and supplies the version as a\n\t  // string rather than a number, so we use loose equality checking here.\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\n\t  sources = sources\n\t    .map(String)\n\t    // Some source maps produce relative source paths like \"./foo.js\" instead of\n\t    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n\t    // See bugzil.la/1090768.\n\t    .map(util.normalize)\n\t    // Always ensure that absolute sources are internally stored relative to\n\t    // the source root, if the source root is absolute. Not doing this would\n\t    // be particularly problematic when the source root is a prefix of the\n\t    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n\t    .map(function (source) {\n\t      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n\t        ? util.relative(sourceRoot, source)\n\t        : source;\n\t    });\n\n\t  // Pass `true` below to allow duplicate names and sources. While source maps\n\t  // are intended to be compressed and deduplicated, the TypeScript compiler\n\t  // sometimes generates source maps with duplicates in them. See Github issue\n\t  // #72 and bugzil.la/889492.\n\t  this._names = ArraySet.fromArray(names.map(String), true);\n\t  this._sources = ArraySet.fromArray(sources, true);\n\n\t  this.sourceRoot = sourceRoot;\n\t  this.sourcesContent = sourcesContent;\n\t  this._mappings = mappings;\n\t  this.file = file;\n\t}\n\n\tBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n\t/**\n\t * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n\t *\n\t * @param SourceMapGenerator aSourceMap\n\t *        The source map that will be consumed.\n\t * @returns BasicSourceMapConsumer\n\t */\n\tBasicSourceMapConsumer.fromSourceMap =\n\t  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n\t    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n\t    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n\t    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n\t    smc.sourceRoot = aSourceMap._sourceRoot;\n\t    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n\t                                                            smc.sourceRoot);\n\t    smc.file = aSourceMap._file;\n\n\t    // Because we are modifying the entries (by converting string sources and\n\t    // names to indices into the sources and names ArraySets), we have to make\n\t    // a copy of the entry or else bad things happen. Shared mutable state\n\t    // strikes again! See github issue #191.\n\n\t    var generatedMappings = aSourceMap._mappings.toArray().slice();\n\t    var destGeneratedMappings = smc.__generatedMappings = [];\n\t    var destOriginalMappings = smc.__originalMappings = [];\n\n\t    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n\t      var srcMapping = generatedMappings[i];\n\t      var destMapping = new Mapping;\n\t      destMapping.generatedLine = srcMapping.generatedLine;\n\t      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n\t      if (srcMapping.source) {\n\t        destMapping.source = sources.indexOf(srcMapping.source);\n\t        destMapping.originalLine = srcMapping.originalLine;\n\t        destMapping.originalColumn = srcMapping.originalColumn;\n\n\t        if (srcMapping.name) {\n\t          destMapping.name = names.indexOf(srcMapping.name);\n\t        }\n\n\t        destOriginalMappings.push(destMapping);\n\t      }\n\n\t      destGeneratedMappings.push(destMapping);\n\t    }\n\n\t    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n\t    return smc;\n\t  };\n\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tBasicSourceMapConsumer.prototype._version = 3;\n\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    return this._sources.toArray().map(function (s) {\n\t      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n\t    }, this);\n\t  }\n\t});\n\n\t/**\n\t * Provide the JIT with a nice shape / hidden class.\n\t */\n\tfunction Mapping() {\n\t  this.generatedLine = 0;\n\t  this.generatedColumn = 0;\n\t  this.source = null;\n\t  this.originalLine = null;\n\t  this.originalColumn = null;\n\t  this.name = null;\n\t}\n\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tBasicSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    var generatedLine = 1;\n\t    var previousGeneratedColumn = 0;\n\t    var previousOriginalLine = 0;\n\t    var previousOriginalColumn = 0;\n\t    var previousSource = 0;\n\t    var previousName = 0;\n\t    var length = aStr.length;\n\t    var index = 0;\n\t    var cachedSegments = {};\n\t    var temp = {};\n\t    var originalMappings = [];\n\t    var generatedMappings = [];\n\t    var mapping, str, segment, end, value;\n\n\t    while (index < length) {\n\t      if (aStr.charAt(index) === ';') {\n\t        generatedLine++;\n\t        index++;\n\t        previousGeneratedColumn = 0;\n\t      }\n\t      else if (aStr.charAt(index) === ',') {\n\t        index++;\n\t      }\n\t      else {\n\t        mapping = new Mapping();\n\t        mapping.generatedLine = generatedLine;\n\n\t        // Because each offset is encoded relative to the previous one,\n\t        // many segments often have the same encoding. We can exploit this\n\t        // fact by caching the parsed variable length fields of each segment,\n\t        // allowing us to avoid a second parse if we encounter the same\n\t        // segment again.\n\t        for (end = index; end < length; end++) {\n\t          if (this._charIsMappingSeparator(aStr, end)) {\n\t            break;\n\t          }\n\t        }\n\t        str = aStr.slice(index, end);\n\n\t        segment = cachedSegments[str];\n\t        if (segment) {\n\t          index += str.length;\n\t        } else {\n\t          segment = [];\n\t          while (index < end) {\n\t            base64VLQ.decode(aStr, index, temp);\n\t            value = temp.value;\n\t            index = temp.rest;\n\t            segment.push(value);\n\t          }\n\n\t          if (segment.length === 2) {\n\t            throw new Error('Found a source, but no line and column');\n\t          }\n\n\t          if (segment.length === 3) {\n\t            throw new Error('Found a source and line, but no column');\n\t          }\n\n\t          cachedSegments[str] = segment;\n\t        }\n\n\t        // Generated column.\n\t        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n\t        previousGeneratedColumn = mapping.generatedColumn;\n\n\t        if (segment.length > 1) {\n\t          // Original source.\n\t          mapping.source = previousSource + segment[1];\n\t          previousSource += segment[1];\n\n\t          // Original line.\n\t          mapping.originalLine = previousOriginalLine + segment[2];\n\t          previousOriginalLine = mapping.originalLine;\n\t          // Lines are stored 0-based\n\t          mapping.originalLine += 1;\n\n\t          // Original column.\n\t          mapping.originalColumn = previousOriginalColumn + segment[3];\n\t          previousOriginalColumn = mapping.originalColumn;\n\n\t          if (segment.length > 4) {\n\t            // Original name.\n\t            mapping.name = previousName + segment[4];\n\t            previousName += segment[4];\n\t          }\n\t        }\n\n\t        generatedMappings.push(mapping);\n\t        if (typeof mapping.originalLine === 'number') {\n\t          originalMappings.push(mapping);\n\t        }\n\t      }\n\t    }\n\n\t    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    this.__generatedMappings = generatedMappings;\n\n\t    quickSort(originalMappings, util.compareByOriginalPositions);\n\t    this.__originalMappings = originalMappings;\n\t  };\n\n\t/**\n\t * Find the mapping that best matches the hypothetical \"needle\" mapping that\n\t * we are searching for in the given \"haystack\" of mappings.\n\t */\n\tBasicSourceMapConsumer.prototype._findMapping =\n\t  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n\t                                         aColumnName, aComparator, aBias) {\n\t    // To return the position we are searching for, we must first find the\n\t    // mapping for the given position and then return the opposite position it\n\t    // points to. Because the mappings are sorted, we can use binary search to\n\t    // find the best mapping.\n\n\t    if (aNeedle[aLineName] <= 0) {\n\t      throw new TypeError('Line must be greater than or equal to 1, got '\n\t                          + aNeedle[aLineName]);\n\t    }\n\t    if (aNeedle[aColumnName] < 0) {\n\t      throw new TypeError('Column must be greater than or equal to 0, got '\n\t                          + aNeedle[aColumnName]);\n\t    }\n\n\t    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n\t  };\n\n\t/**\n\t * Compute the last column for each generated mapping. The last column is\n\t * inclusive.\n\t */\n\tBasicSourceMapConsumer.prototype.computeColumnSpans =\n\t  function SourceMapConsumer_computeColumnSpans() {\n\t    for (var index = 0; index < this._generatedMappings.length; ++index) {\n\t      var mapping = this._generatedMappings[index];\n\n\t      // Mappings do not contain a field for the last generated columnt. We\n\t      // can come up with an optimistic estimate, however, by assuming that\n\t      // mappings are contiguous (i.e. given two consecutive mappings, the\n\t      // first mapping ends where the second one starts).\n\t      if (index + 1 < this._generatedMappings.length) {\n\t        var nextMapping = this._generatedMappings[index + 1];\n\n\t        if (mapping.generatedLine === nextMapping.generatedLine) {\n\t          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n\t          continue;\n\t        }\n\t      }\n\n\t      // The last mapping for each line spans the entire line.\n\t      mapping.lastGeneratedColumn = Infinity;\n\t    }\n\t  };\n\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.\n\t *   - column: The column number in the generated source.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.\n\t *   - column: The column number in the original source, or null.\n\t *   - name: The original identifier, or null.\n\t */\n\tBasicSourceMapConsumer.prototype.originalPositionFor =\n\t  function SourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._generatedMappings,\n\t      \"generatedLine\",\n\t      \"generatedColumn\",\n\t      util.compareByGeneratedPositionsDeflated,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\n\t    if (index >= 0) {\n\t      var mapping = this._generatedMappings[index];\n\n\t      if (mapping.generatedLine === needle.generatedLine) {\n\t        var source = util.getArg(mapping, 'source', null);\n\t        if (source !== null) {\n\t          source = this._sources.at(source);\n\t          if (this.sourceRoot != null) {\n\t            source = util.join(this.sourceRoot, source);\n\t          }\n\t        }\n\t        var name = util.getArg(mapping, 'name', null);\n\t        if (name !== null) {\n\t          name = this._names.at(name);\n\t        }\n\t        return {\n\t          source: source,\n\t          line: util.getArg(mapping, 'originalLine', null),\n\t          column: util.getArg(mapping, 'originalColumn', null),\n\t          name: name\n\t        };\n\t      }\n\t    }\n\n\t    return {\n\t      source: null,\n\t      line: null,\n\t      column: null,\n\t      name: null\n\t    };\n\t  };\n\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n\t    if (!this.sourcesContent) {\n\t      return false;\n\t    }\n\t    return this.sourcesContent.length >= this._sources.size() &&\n\t      !this.sourcesContent.some(function (sc) { return sc == null; });\n\t  };\n\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tBasicSourceMapConsumer.prototype.sourceContentFor =\n\t  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    if (!this.sourcesContent) {\n\t      return null;\n\t    }\n\n\t    if (this.sourceRoot != null) {\n\t      aSource = util.relative(this.sourceRoot, aSource);\n\t    }\n\n\t    if (this._sources.has(aSource)) {\n\t      return this.sourcesContent[this._sources.indexOf(aSource)];\n\t    }\n\n\t    var url;\n\t    if (this.sourceRoot != null\n\t        && (url = util.urlParse(this.sourceRoot))) {\n\t      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n\t      // many users. We can help them out when they expect file:// URIs to\n\t      // behave like it would if they were running a local HTTP server. See\n\t      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n\t      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\t      if (url.scheme == \"file\"\n\t          && this._sources.has(fileUriAbsPath)) {\n\t        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n\t      }\n\n\t      if ((!url.path || url.path == \"/\")\n\t          && this._sources.has(\"/\" + aSource)) {\n\t        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n\t      }\n\t    }\n\n\t    // This function is used recursively from\n\t    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n\t    // don't want to throw if we can't find the source - we just want to\n\t    // return null, so we provide a flag to exit gracefully.\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: The column number in the original source.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tBasicSourceMapConsumer.prototype.generatedPositionFor =\n\t  function SourceMapConsumer_generatedPositionFor(aArgs) {\n\t    var source = util.getArg(aArgs, 'source');\n\t    if (this.sourceRoot != null) {\n\t      source = util.relative(this.sourceRoot, source);\n\t    }\n\t    if (!this._sources.has(source)) {\n\t      return {\n\t        line: null,\n\t        column: null,\n\t        lastColumn: null\n\t      };\n\t    }\n\t    source = this._sources.indexOf(source);\n\n\t    var needle = {\n\t      source: source,\n\t      originalLine: util.getArg(aArgs, 'line'),\n\t      originalColumn: util.getArg(aArgs, 'column')\n\t    };\n\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._originalMappings,\n\t      \"originalLine\",\n\t      \"originalColumn\",\n\t      util.compareByOriginalPositions,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\n\t      if (mapping.source === needle.source) {\n\t        return {\n\t          line: util.getArg(mapping, 'generatedLine', null),\n\t          column: util.getArg(mapping, 'generatedColumn', null),\n\t          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t        };\n\t      }\n\t    }\n\n\t    return {\n\t      line: null,\n\t      column: null,\n\t      lastColumn: null\n\t    };\n\t  };\n\n\texports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n\t/**\n\t * An IndexedSourceMapConsumer instance represents a parsed source map which\n\t * we can query for information. It differs from BasicSourceMapConsumer in\n\t * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n\t * input.\n\t *\n\t * The only parameter is a raw source map (either as a JSON string, or already\n\t * parsed to an object). According to the spec for indexed source maps, they\n\t * have the following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *   - sections: A list of section definitions.\n\t *\n\t * Each value under the \"sections\" field has two fields:\n\t *   - offset: The offset into the original specified at which this section\n\t *       begins to apply, defined as an object with a \"line\" and \"column\"\n\t *       field.\n\t *   - map: A source map definition. This source map could also be indexed,\n\t *       but doesn't have to be.\n\t *\n\t * Instead of the \"map\" field, it's also possible to have a \"url\" field\n\t * specifying a URL to retrieve a source map from, but that's currently\n\t * unsupported.\n\t *\n\t * Here's an example source map, taken from the source map spec[0], but\n\t * modified to omit a section which uses the \"url\" field.\n\t *\n\t *  {\n\t *    version : 3,\n\t *    file: \"app.js\",\n\t *    sections: [{\n\t *      offset: {line:100, column:10},\n\t *      map: {\n\t *        version : 3,\n\t *        file: \"section.js\",\n\t *        sources: [\"foo.js\", \"bar.js\"],\n\t *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *        mappings: \"AAAA,E;;ABCDE;\"\n\t *      }\n\t *    }],\n\t *  }\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n\t */\n\tfunction IndexedSourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sections = util.getArg(sourceMap, 'sections');\n\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\n\t  this._sources = new ArraySet();\n\t  this._names = new ArraySet();\n\n\t  var lastOffset = {\n\t    line: -1,\n\t    column: 0\n\t  };\n\t  this._sections = sections.map(function (s) {\n\t    if (s.url) {\n\t      // The url field will require support for asynchronicity.\n\t      // See https://github.com/mozilla/source-map/issues/16\n\t      throw new Error('Support for url field in sections not implemented.');\n\t    }\n\t    var offset = util.getArg(s, 'offset');\n\t    var offsetLine = util.getArg(offset, 'line');\n\t    var offsetColumn = util.getArg(offset, 'column');\n\n\t    if (offsetLine < lastOffset.line ||\n\t        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n\t      throw new Error('Section offsets must be ordered and non-overlapping.');\n\t    }\n\t    lastOffset = offset;\n\n\t    return {\n\t      generatedOffset: {\n\t        // The offset fields are 0-based, but we use 1-based indices when\n\t        // encoding/decoding from VLQ.\n\t        generatedLine: offsetLine + 1,\n\t        generatedColumn: offsetColumn + 1\n\t      },\n\t      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n\t    }\n\t  });\n\t}\n\n\tIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tIndexedSourceMapConsumer.prototype._version = 3;\n\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    var sources = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n\t        sources.push(this._sections[i].consumer.sources[j]);\n\t      }\n\t    }\n\t    return sources;\n\t  }\n\t});\n\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.\n\t *   - column: The column number in the generated source.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.\n\t *   - column: The column number in the original source, or null.\n\t *   - name: The original identifier, or null.\n\t */\n\tIndexedSourceMapConsumer.prototype.originalPositionFor =\n\t  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\n\t    // Find the section containing the generated position we're trying to map\n\t    // to an original position.\n\t    var sectionIndex = binarySearch.search(needle, this._sections,\n\t      function(needle, section) {\n\t        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\t        if (cmp) {\n\t          return cmp;\n\t        }\n\n\t        return (needle.generatedColumn -\n\t                section.generatedOffset.generatedColumn);\n\t      });\n\t    var section = this._sections[sectionIndex];\n\n\t    if (!section) {\n\t      return {\n\t        source: null,\n\t        line: null,\n\t        column: null,\n\t        name: null\n\t      };\n\t    }\n\n\t    return section.consumer.originalPositionFor({\n\t      line: needle.generatedLine -\n\t        (section.generatedOffset.generatedLine - 1),\n\t      column: needle.generatedColumn -\n\t        (section.generatedOffset.generatedLine === needle.generatedLine\n\t         ? section.generatedOffset.generatedColumn - 1\n\t         : 0),\n\t      bias: aArgs.bias\n\t    });\n\t  };\n\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n\t    return this._sections.every(function (s) {\n\t      return s.consumer.hasContentsOfAllSources();\n\t    });\n\t  };\n\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tIndexedSourceMapConsumer.prototype.sourceContentFor =\n\t  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\n\t      var content = section.consumer.sourceContentFor(aSource, true);\n\t      if (content) {\n\t        return content;\n\t      }\n\t    }\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: The column number in the original source.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tIndexedSourceMapConsumer.prototype.generatedPositionFor =\n\t  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\n\t      // Only consider this section if the requested source is in the list of\n\t      // sources of the consumer.\n\t      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n\t        continue;\n\t      }\n\t      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\t      if (generatedPosition) {\n\t        var ret = {\n\t          line: generatedPosition.line +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          column: generatedPosition.column +\n\t            (section.generatedOffset.generatedLine === generatedPosition.line\n\t             ? section.generatedOffset.generatedColumn - 1\n\t             : 0)\n\t        };\n\t        return ret;\n\t      }\n\t    }\n\n\t    return {\n\t      line: null,\n\t      column: null\n\t    };\n\t  };\n\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tIndexedSourceMapConsumer.prototype._parseMappings =\n\t  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    this.__generatedMappings = [];\n\t    this.__originalMappings = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t      var sectionMappings = section.consumer._generatedMappings;\n\t      for (var j = 0; j < sectionMappings.length; j++) {\n\t        var mapping = sectionMappings[j];\n\n\t        var source = section.consumer._sources.at(mapping.source);\n\t        if (section.consumer.sourceRoot !== null) {\n\t          source = util.join(section.consumer.sourceRoot, source);\n\t        }\n\t        this._sources.add(source);\n\t        source = this._sources.indexOf(source);\n\n\t        var name = section.consumer._names.at(mapping.name);\n\t        this._names.add(name);\n\t        name = this._names.indexOf(name);\n\n\t        // The mappings coming from the consumer for the section have\n\t        // generated positions relative to the start of the section, so we\n\t        // need to offset them to be relative to the start of the concatenated\n\t        // generated file.\n\t        var adjustedMapping = {\n\t          source: source,\n\t          generatedLine: mapping.generatedLine +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          generatedColumn: mapping.generatedColumn +\n\t            (section.generatedOffset.generatedLine === mapping.generatedLine\n\t            ? section.generatedOffset.generatedColumn - 1\n\t            : 0),\n\t          originalLine: mapping.originalLine,\n\t          originalColumn: mapping.originalColumn,\n\t          name: name\n\t        };\n\n\t        this.__generatedMappings.push(adjustedMapping);\n\t        if (typeof adjustedMapping.originalLine === 'number') {\n\t          this.__originalMappings.push(adjustedMapping);\n\t        }\n\t      }\n\t    }\n\n\t    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n\t  };\n\n\texports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\t/**\n\t * This is a helper function for getting values from parameter/options\n\t * objects.\n\t *\n\t * @param args The object we are extracting values from\n\t * @param name The name of the property we are getting.\n\t * @param defaultValue An optional value to return if the property is missing\n\t * from the object. If this is not specified and the property is missing, an\n\t * error will be thrown.\n\t */\n\tfunction getArg(aArgs, aName, aDefaultValue) {\n\t  if (aName in aArgs) {\n\t    return aArgs[aName];\n\t  } else if (arguments.length === 3) {\n\t    return aDefaultValue;\n\t  } else {\n\t    throw new Error('\"' + aName + '\" is a required argument.');\n\t  }\n\t}\n\texports.getArg = getArg;\n\n\tvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n\tvar dataUrlRegexp = /^data:.+\\,.+$/;\n\n\tfunction urlParse(aUrl) {\n\t  var match = aUrl.match(urlRegexp);\n\t  if (!match) {\n\t    return null;\n\t  }\n\t  return {\n\t    scheme: match[1],\n\t    auth: match[2],\n\t    host: match[3],\n\t    port: match[4],\n\t    path: match[5]\n\t  };\n\t}\n\texports.urlParse = urlParse;\n\n\tfunction urlGenerate(aParsedUrl) {\n\t  var url = '';\n\t  if (aParsedUrl.scheme) {\n\t    url += aParsedUrl.scheme + ':';\n\t  }\n\t  url += '//';\n\t  if (aParsedUrl.auth) {\n\t    url += aParsedUrl.auth + '@';\n\t  }\n\t  if (aParsedUrl.host) {\n\t    url += aParsedUrl.host;\n\t  }\n\t  if (aParsedUrl.port) {\n\t    url += \":\" + aParsedUrl.port\n\t  }\n\t  if (aParsedUrl.path) {\n\t    url += aParsedUrl.path;\n\t  }\n\t  return url;\n\t}\n\texports.urlGenerate = urlGenerate;\n\n\t/**\n\t * Normalizes a path, or the path portion of a URL:\n\t *\n\t * - Replaces consecutive slashes with one slash.\n\t * - Removes unnecessary '.' parts.\n\t * - Removes unnecessary '<dir>/..' parts.\n\t *\n\t * Based on code in the Node.js 'path' core module.\n\t *\n\t * @param aPath The path or url to normalize.\n\t */\n\tfunction normalize(aPath) {\n\t  var path = aPath;\n\t  var url = urlParse(aPath);\n\t  if (url) {\n\t    if (!url.path) {\n\t      return aPath;\n\t    }\n\t    path = url.path;\n\t  }\n\t  var isAbsolute = exports.isAbsolute(path);\n\n\t  var parts = path.split(/\\/+/);\n\t  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n\t    part = parts[i];\n\t    if (part === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (part === '..') {\n\t      up++;\n\t    } else if (up > 0) {\n\t      if (part === '') {\n\t        // The first part is blank if the path is absolute. Trying to go\n\t        // above the root is a no-op. Therefore we can remove all '..' parts\n\t        // directly after the root.\n\t        parts.splice(i + 1, up);\n\t        up = 0;\n\t      } else {\n\t        parts.splice(i, 2);\n\t        up--;\n\t      }\n\t    }\n\t  }\n\t  path = parts.join('/');\n\n\t  if (path === '') {\n\t    path = isAbsolute ? '/' : '.';\n\t  }\n\n\t  if (url) {\n\t    url.path = path;\n\t    return urlGenerate(url);\n\t  }\n\t  return path;\n\t}\n\texports.normalize = normalize;\n\n\t/**\n\t * Joins two paths/URLs.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be joined with the root.\n\t *\n\t * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n\t *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n\t *   first.\n\t * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n\t *   is updated with the result and aRoot is returned. Otherwise the result\n\t *   is returned.\n\t *   - If aPath is absolute, the result is aPath.\n\t *   - Otherwise the two paths are joined with a slash.\n\t * - Joining for example 'http://' and 'www.example.com' is also supported.\n\t */\n\tfunction join(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\t  if (aPath === \"\") {\n\t    aPath = \".\";\n\t  }\n\t  var aPathUrl = urlParse(aPath);\n\t  var aRootUrl = urlParse(aRoot);\n\t  if (aRootUrl) {\n\t    aRoot = aRootUrl.path || '/';\n\t  }\n\n\t  // `join(foo, '//www.example.org')`\n\t  if (aPathUrl && !aPathUrl.scheme) {\n\t    if (aRootUrl) {\n\t      aPathUrl.scheme = aRootUrl.scheme;\n\t    }\n\t    return urlGenerate(aPathUrl);\n\t  }\n\n\t  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t    return aPath;\n\t  }\n\n\t  // `join('http://', 'www.example.com')`\n\t  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t    aRootUrl.host = aPath;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\n\t  var joined = aPath.charAt(0) === '/'\n\t    ? aPath\n\t    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n\t  if (aRootUrl) {\n\t    aRootUrl.path = joined;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t  return joined;\n\t}\n\texports.join = join;\n\n\texports.isAbsolute = function (aPath) {\n\t  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n\t};\n\n\t/**\n\t * Make a path relative to a URL or another path.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be made relative to aRoot.\n\t */\n\tfunction relative(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\n\t  aRoot = aRoot.replace(/\\/$/, '');\n\n\t  // It is possible for the path to be above the root. In this case, simply\n\t  // checking whether the root is a prefix of the path won't work. Instead, we\n\t  // need to remove components from the root one by one, until either we find\n\t  // a prefix that fits, or we run out of components to remove.\n\t  var level = 0;\n\t  while (aPath.indexOf(aRoot + '/') !== 0) {\n\t    var index = aRoot.lastIndexOf(\"/\");\n\t    if (index < 0) {\n\t      return aPath;\n\t    }\n\n\t    // If the only part of the root that is left is the scheme (i.e. http://,\n\t    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n\t    // have exhausted all components, so the path is not relative to the root.\n\t    aRoot = aRoot.slice(0, index);\n\t    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n\t      return aPath;\n\t    }\n\n\t    ++level;\n\t  }\n\n\t  // Make sure we add a \"../\" for each component we removed from the root.\n\t  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n\t}\n\texports.relative = relative;\n\n\tvar supportsNullProto = (function () {\n\t  var obj = Object.create(null);\n\t  return !('__proto__' in obj);\n\t}());\n\n\tfunction identity (s) {\n\t  return s;\n\t}\n\n\t/**\n\t * Because behavior goes wacky when you set `__proto__` on objects, we\n\t * have to prefix all the strings in our set with an arbitrary character.\n\t *\n\t * See https://github.com/mozilla/source-map/pull/31 and\n\t * https://github.com/mozilla/source-map/issues/30\n\t *\n\t * @param String aStr\n\t */\n\tfunction toSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return '$' + aStr;\n\t  }\n\n\t  return aStr;\n\t}\n\texports.toSetString = supportsNullProto ? identity : toSetString;\n\n\tfunction fromSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return aStr.slice(1);\n\t  }\n\n\t  return aStr;\n\t}\n\texports.fromSetString = supportsNullProto ? identity : fromSetString;\n\n\tfunction isProtoString(s) {\n\t  if (!s) {\n\t    return false;\n\t  }\n\n\t  var length = s.length;\n\n\t  if (length < 9 /* \"__proto__\".length */) {\n\t    return false;\n\t  }\n\n\t  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n\t      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n\t      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n\t      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n\t    return false;\n\t  }\n\n\t  for (var i = length - 10; i >= 0; i--) {\n\t    if (s.charCodeAt(i) !== 36 /* '$' */) {\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t}\n\n\t/**\n\t * Comparator between two mappings where the original positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same original source/line/column, but different generated\n\t * line and column the same. Useful when searching for a mapping with a\n\t * stubbed out mapping.\n\t */\n\tfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n\t  var cmp = mappingA.source - mappingB.source;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0 || onlyCompareOriginal) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  return mappingA.name - mappingB.name;\n\t}\n\texports.compareByOriginalPositions = compareByOriginalPositions;\n\n\t/**\n\t * Comparator between two mappings with deflated source and name indices where\n\t * the generated positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same generated line and column, but different\n\t * source/name/original line and column the same. Useful when searching for a\n\t * mapping with a stubbed out mapping.\n\t */\n\tfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0 || onlyCompareGenerated) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.source - mappingB.source;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  return mappingA.name - mappingB.name;\n\t}\n\texports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n\tfunction strcmp(aStr1, aStr2) {\n\t  if (aStr1 === aStr2) {\n\t    return 0;\n\t  }\n\n\t  if (aStr1 > aStr2) {\n\t    return 1;\n\t  }\n\n\t  return -1;\n\t}\n\n\t/**\n\t * Comparator between two mappings with inflated source and name strings where\n\t * the generated positions are compared.\n\t */\n\tfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\texports.GREATEST_LOWER_BOUND = 1;\n\texports.LEAST_UPPER_BOUND = 2;\n\n\t/**\n\t * Recursive implementation of binary search.\n\t *\n\t * @param aLow Indices here and lower do not contain the needle.\n\t * @param aHigh Indices here and higher do not contain the needle.\n\t * @param aNeedle The element being searched for.\n\t * @param aHaystack The non-empty array being searched.\n\t * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t */\n\tfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n\t  // This function terminates when one of the following is true:\n\t  //\n\t  //   1. We find the exact element we are looking for.\n\t  //\n\t  //   2. We did not find the exact element, but we can return the index of\n\t  //      the next-closest element.\n\t  //\n\t  //   3. We did not find the exact element, and there is no next-closest\n\t  //      element than the one we are searching for, so we return -1.\n\t  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n\t  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\t  if (cmp === 0) {\n\t    // Found the element we are looking for.\n\t    return mid;\n\t  }\n\t  else if (cmp > 0) {\n\t    // Our needle is greater than aHaystack[mid].\n\t    if (aHigh - mid > 1) {\n\t      // The element is in the upper half.\n\t      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\n\t    // The exact needle element was not found in this haystack. Determine if\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return aHigh < aHaystack.length ? aHigh : -1;\n\t    } else {\n\t      return mid;\n\t    }\n\t  }\n\t  else {\n\t    // Our needle is less than aHaystack[mid].\n\t    if (mid - aLow > 1) {\n\t      // The element is in the lower half.\n\t      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return mid;\n\t    } else {\n\t      return aLow < 0 ? -1 : aLow;\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * This is an implementation of binary search which will always try and return\n\t * the index of the closest element if there is no exact hit. This is because\n\t * mappings between original and generated line/col pairs are single points,\n\t * and there is an implicit region between each of them, so a miss just means\n\t * that you aren't on the very start of a region.\n\t *\n\t * @param aNeedle The element you are looking for.\n\t * @param aHaystack The array that is being searched.\n\t * @param aCompare A function which takes the needle and an element in the\n\t *     array and returns -1, 0, or 1 depending on whether the needle is less\n\t *     than, equal to, or greater than the element, respectively.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n\t */\n\texports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n\t  if (aHaystack.length === 0) {\n\t    return -1;\n\t  }\n\n\t  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n\t                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\t  if (index < 0) {\n\t    return -1;\n\t  }\n\n\t  // We have found either the exact element, or the next-closest element than\n\t  // the one we are searching for. However, there may be more than one such\n\t  // element. Make sure we always return the smallest of these.\n\t  while (index - 1 >= 0) {\n\t    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n\t      break;\n\t    }\n\t    --index;\n\t  }\n\n\t  return index;\n\t};\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\tvar util = __webpack_require__(2);\n\tvar has = Object.prototype.hasOwnProperty;\n\n\t/**\n\t * A data structure which is a combination of an array and a set. Adding a new\n\t * member is O(1), testing for membership is O(1), and finding the index of an\n\t * element is O(1). Removing elements from the set is not supported. Only\n\t * strings are supported for membership.\n\t */\n\tfunction ArraySet() {\n\t  this._array = [];\n\t  this._set = Object.create(null);\n\t}\n\n\t/**\n\t * Static method for creating ArraySet instances from an existing array.\n\t */\n\tArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n\t  var set = new ArraySet();\n\t  for (var i = 0, len = aArray.length; i < len; i++) {\n\t    set.add(aArray[i], aAllowDuplicates);\n\t  }\n\t  return set;\n\t};\n\n\t/**\n\t * Return how many unique items are in this ArraySet. If duplicates have been\n\t * added, than those do not count towards the size.\n\t *\n\t * @returns Number\n\t */\n\tArraySet.prototype.size = function ArraySet_size() {\n\t  return Object.getOwnPropertyNames(this._set).length;\n\t};\n\n\t/**\n\t * Add the given string to this set.\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n\t  var sStr = util.toSetString(aStr);\n\t  var isDuplicate = has.call(this._set, sStr);\n\t  var idx = this._array.length;\n\t  if (!isDuplicate || aAllowDuplicates) {\n\t    this._array.push(aStr);\n\t  }\n\t  if (!isDuplicate) {\n\t    this._set[sStr] = idx;\n\t  }\n\t};\n\n\t/**\n\t * Is the given string a member of this set?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.has = function ArraySet_has(aStr) {\n\t  var sStr = util.toSetString(aStr);\n\t  return has.call(this._set, sStr);\n\t};\n\n\t/**\n\t * What is the index of the given string in the array?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n\t  var sStr = util.toSetString(aStr);\n\t  if (has.call(this._set, sStr)) {\n\t    return this._set[sStr];\n\t  }\n\t  throw new Error('\"' + aStr + '\" is not in the set.');\n\t};\n\n\t/**\n\t * What is the element at the given index?\n\t *\n\t * @param Number aIdx\n\t */\n\tArraySet.prototype.at = function ArraySet_at(aIdx) {\n\t  if (aIdx >= 0 && aIdx < this._array.length) {\n\t    return this._array[aIdx];\n\t  }\n\t  throw new Error('No element indexed by ' + aIdx);\n\t};\n\n\t/**\n\t * Returns the array representation of this set (which has the proper indices\n\t * indicated by indexOf). Note that this is a copy of the internal array used\n\t * for storing the members so that no one can mess with internal state.\n\t */\n\tArraySet.prototype.toArray = function ArraySet_toArray() {\n\t  return this._array.slice();\n\t};\n\n\texports.ArraySet = ArraySet;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t *\n\t * Based on the Base 64 VLQ implementation in Closure Compiler:\n\t * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n\t *\n\t * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *  * Redistributions of source code must retain the above copyright\n\t *    notice, this list of conditions and the following disclaimer.\n\t *  * Redistributions in binary form must reproduce the above\n\t *    copyright notice, this list of conditions and the following\n\t *    disclaimer in the documentation and/or other materials provided\n\t *    with the distribution.\n\t *  * Neither the name of Google Inc. nor the names of its\n\t *    contributors may be used to endorse or promote products derived\n\t *    from this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\tvar base64 = __webpack_require__(6);\n\n\t// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n\t// length quantities we use in the source map spec, the first bit is the sign,\n\t// the next four bits are the actual value, and the 6th bit is the\n\t// continuation bit. The continuation bit tells us whether there are more\n\t// digits in this value following this digit.\n\t//\n\t//   Continuation\n\t//   |    Sign\n\t//   |    |\n\t//   V    V\n\t//   101011\n\n\tvar VLQ_BASE_SHIFT = 5;\n\n\t// binary: 100000\n\tvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n\t// binary: 011111\n\tvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n\t// binary: 100000\n\tvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n\t/**\n\t * Converts from a two-complement value to a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n\t *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n\t */\n\tfunction toVLQSigned(aValue) {\n\t  return aValue < 0\n\t    ? ((-aValue) << 1) + 1\n\t    : (aValue << 1) + 0;\n\t}\n\n\t/**\n\t * Converts to a two-complement value from a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n\t *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n\t */\n\tfunction fromVLQSigned(aValue) {\n\t  var isNegative = (aValue & 1) === 1;\n\t  var shifted = aValue >> 1;\n\t  return isNegative\n\t    ? -shifted\n\t    : shifted;\n\t}\n\n\t/**\n\t * Returns the base 64 VLQ encoded value.\n\t */\n\texports.encode = function base64VLQ_encode(aValue) {\n\t  var encoded = \"\";\n\t  var digit;\n\n\t  var vlq = toVLQSigned(aValue);\n\n\t  do {\n\t    digit = vlq & VLQ_BASE_MASK;\n\t    vlq >>>= VLQ_BASE_SHIFT;\n\t    if (vlq > 0) {\n\t      // There are still more digits in this value, so we must make sure the\n\t      // continuation bit is marked.\n\t      digit |= VLQ_CONTINUATION_BIT;\n\t    }\n\t    encoded += base64.encode(digit);\n\t  } while (vlq > 0);\n\n\t  return encoded;\n\t};\n\n\t/**\n\t * Decodes the next base 64 VLQ value from the given string and returns the\n\t * value and the rest of the string via the out parameter.\n\t */\n\texports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n\t  var strLen = aStr.length;\n\t  var result = 0;\n\t  var shift = 0;\n\t  var continuation, digit;\n\n\t  do {\n\t    if (aIndex >= strLen) {\n\t      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n\t    }\n\n\t    digit = base64.decode(aStr.charCodeAt(aIndex++));\n\t    if (digit === -1) {\n\t      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n\t    }\n\n\t    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n\t    digit &= VLQ_BASE_MASK;\n\t    result = result + (digit << shift);\n\t    shift += VLQ_BASE_SHIFT;\n\t  } while (continuation);\n\n\t  aOutParam.value = fromVLQSigned(result);\n\t  aOutParam.rest = aIndex;\n\t};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\tvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n\t/**\n\t * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n\t */\n\texports.encode = function (number) {\n\t  if (0 <= number && number < intToCharMap.length) {\n\t    return intToCharMap[number];\n\t  }\n\t  throw new TypeError(\"Must be between 0 and 63: \" + number);\n\t};\n\n\t/**\n\t * Decode a single base 64 character code digit to an integer. Returns -1 on\n\t * failure.\n\t */\n\texports.decode = function (charCode) {\n\t  var bigA = 65;     // 'A'\n\t  var bigZ = 90;     // 'Z'\n\n\t  var littleA = 97;  // 'a'\n\t  var littleZ = 122; // 'z'\n\n\t  var zero = 48;     // '0'\n\t  var nine = 57;     // '9'\n\n\t  var plus = 43;     // '+'\n\t  var slash = 47;    // '/'\n\n\t  var littleOffset = 26;\n\t  var numberOffset = 52;\n\n\t  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\t  if (bigA <= charCode && charCode <= bigZ) {\n\t    return (charCode - bigA);\n\t  }\n\n\t  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\t  if (littleA <= charCode && charCode <= littleZ) {\n\t    return (charCode - littleA + littleOffset);\n\t  }\n\n\t  // 52 - 61: 0123456789\n\t  if (zero <= charCode && charCode <= nine) {\n\t    return (charCode - zero + numberOffset);\n\t  }\n\n\t  // 62: +\n\t  if (charCode == plus) {\n\t    return 62;\n\t  }\n\n\t  // 63: /\n\t  if (charCode == slash) {\n\t    return 63;\n\t  }\n\n\t  // Invalid base64 digit.\n\t  return -1;\n\t};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\t// It turns out that some (most?) JavaScript engines don't self-host\n\t// `Array.prototype.sort`. This makes sense because C++ will likely remain\n\t// faster than JS when doing raw CPU-intensive sorting. However, when using a\n\t// custom comparator function, calling back and forth between the VM's C++ and\n\t// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n\t// worse generated code for the comparator function than would be optimal. In\n\t// fact, when sorting with a comparator, these costs outweigh the benefits of\n\t// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n\t// a ~3500ms mean speed-up in `bench/bench.html`.\n\n\t/**\n\t * Swap the elements indexed by `x` and `y` in the array `ary`.\n\t *\n\t * @param {Array} ary\n\t *        The array.\n\t * @param {Number} x\n\t *        The index of the first item.\n\t * @param {Number} y\n\t *        The index of the second item.\n\t */\n\tfunction swap(ary, x, y) {\n\t  var temp = ary[x];\n\t  ary[x] = ary[y];\n\t  ary[y] = temp;\n\t}\n\n\t/**\n\t * Returns a random integer within the range `low .. high` inclusive.\n\t *\n\t * @param {Number} low\n\t *        The lower bound on the range.\n\t * @param {Number} high\n\t *        The upper bound on the range.\n\t */\n\tfunction randomIntInRange(low, high) {\n\t  return Math.round(low + (Math.random() * (high - low)));\n\t}\n\n\t/**\n\t * The Quick Sort algorithm.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t * @param {Number} p\n\t *        Start index of the array\n\t * @param {Number} r\n\t *        End index of the array\n\t */\n\tfunction doQuickSort(ary, comparator, p, r) {\n\t  // If our lower bound is less than our upper bound, we (1) partition the\n\t  // array into two pieces and (2) recurse on each half. If it is not, this is\n\t  // the empty array and our base case.\n\n\t  if (p < r) {\n\t    // (1) Partitioning.\n\t    //\n\t    // The partitioning chooses a pivot between `p` and `r` and moves all\n\t    // elements that are less than or equal to the pivot to the before it, and\n\t    // all the elements that are greater than it after it. The effect is that\n\t    // once partition is done, the pivot is in the exact place it will be when\n\t    // the array is put in sorted order, and it will not need to be moved\n\t    // again. This runs in O(n) time.\n\n\t    // Always choose a random pivot so that an input array which is reverse\n\t    // sorted does not cause O(n^2) running time.\n\t    var pivotIndex = randomIntInRange(p, r);\n\t    var i = p - 1;\n\n\t    swap(ary, pivotIndex, r);\n\t    var pivot = ary[r];\n\n\t    // Immediately after `j` is incremented in this loop, the following hold\n\t    // true:\n\t    //\n\t    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n\t    //\n\t    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\t    for (var j = p; j < r; j++) {\n\t      if (comparator(ary[j], pivot) <= 0) {\n\t        i += 1;\n\t        swap(ary, i, j);\n\t      }\n\t    }\n\n\t    swap(ary, i + 1, j);\n\t    var q = i + 1;\n\n\t    // (2) Recurse on each half.\n\n\t    doQuickSort(ary, comparator, p, q - 1);\n\t    doQuickSort(ary, comparator, q + 1, r);\n\t  }\n\t}\n\n\t/**\n\t * Sort the given array in-place with the given comparator function.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t */\n\texports.quickSort = function (ary, comparator) {\n\t  doQuickSort(ary, comparator, 0, ary.length - 1);\n\t};\n\n\n/***/ })\n/******/ ])\n});\n;"]},"metadata":{},"sourceType":"module"}