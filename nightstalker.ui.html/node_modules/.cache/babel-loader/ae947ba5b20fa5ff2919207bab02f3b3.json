{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Action, arrays, EventSupport, filters as filters_1, keys, KeyStroke, ValueField, VirtualKeyStrokeEvent } from '../index';\nimport $ from 'jquery';\n\nvar KeyStrokeManager = /*#__PURE__*/function () {\n  function KeyStrokeManager() {\n    _classCallCheck(this, KeyStrokeManager);\n\n    this.session = null;\n    this.helpKeyStroke = KeyStroke.parseKeyStroke('F1');\n    this.swallowF1 = true;\n    this._helpRendered = false;\n    this._renderedKeys = [];\n    this.events = this._createEventSupport();\n    this.filters = [];\n  }\n\n  _createClass(KeyStrokeManager, [{\n    key: \"init\",\n    value: function init(model) {\n      this.session = model.session;\n      this.installTopLevelKeyStrokeHandlers(this.session.$entryPoint);\n    }\n  }, {\n    key: \"installTopLevelKeyStrokeHandlers\",\n    value: function installTopLevelKeyStrokeHandlers($container) {\n      var myWindow = $container.window(true),\n          // Swallow F1 (online help) key stroke\n      helpHandler = function helpHandler(event) {\n        return event.which !== keys.F1;\n      },\n          // Swallow Backspace (browser navigation) key stroke\n      backspaceHandler = function backspaceHandler(event) {\n        return event.which !== keys.BACKSPACE;\n      };\n\n      if (this.swallowF1) {\n        $container.keydown(helpHandler).keyup(helpHandler);\n      }\n\n      $container.keydown(backspaceHandler).keyup(backspaceHandler);\n\n      if ('onhelp' in myWindow) {\n        myWindow.onhelp = filters_1.returnFalse;\n      }\n    }\n    /**\n     * Installs the given keystroke context. This method has no effect if the context is null, or already installed.\n     */\n\n  }, {\n    key: \"installKeyStrokeContext\",\n    value: function installKeyStrokeContext(keyStrokeContext) {\n      if (!keyStrokeContext) {\n        return;\n      }\n\n      if (keyStrokeContext._handler) {\n        return; // context already installed\n      }\n\n      if (!keyStrokeContext.$getBindTarget()) {\n        throw new Error('missing bind-target for KeyStrokeContext: ' + keyStrokeContext);\n      }\n\n      keyStrokeContext._handler = this._onKeyEvent.bind(this, keyStrokeContext);\n      keyStrokeContext._handler.$target = keyStrokeContext.$getBindTarget();\n\n      keyStrokeContext._handler.$target.on('keydown', keyStrokeContext._handler);\n\n      keyStrokeContext._handler.$target.on('keyup', keyStrokeContext._handler);\n    }\n    /**\n     * Uninstalls the given keystroke context. This method has no effect if the context is null, or not installed.\n     */\n\n  }, {\n    key: \"uninstallKeyStrokeContext\",\n    value: function uninstallKeyStrokeContext(keyStrokeContext) {\n      if (!keyStrokeContext) {\n        return;\n      }\n\n      if (!keyStrokeContext._handler) {\n        return; // context not installed\n      }\n\n      keyStrokeContext._handler.$target.off('keydown', keyStrokeContext._handler);\n\n      keyStrokeContext._handler.$target.off('keyup', keyStrokeContext._handler);\n\n      keyStrokeContext._handler.$target = null;\n      keyStrokeContext._handler = null;\n    }\n    /**\n     * Visualizes the keys supported by the given keyStrokeContext.\n     */\n\n  }, {\n    key: \"_renderKeys\",\n    value: function _renderKeys(keyStrokeContext, event) {\n      var descendantContexts = event.originalEvent.keyStrokeContexts || [];\n      var immediatePropagationStoppedKeys = [];\n      keyStrokeContext.keyStrokes.filter(function (keyStroke) {\n        var render = keyStroke.renderingHints.render;\n        return typeof render === 'function' ? render.call(keyStroke) : render;\n      }).forEach(function (keyStroke) {\n        keyStroke.enabledByFilter = this._filter(keyStroke);\n        var $drawingArea = (keyStroke.field ? keyStroke.field.$container : null) || keyStrokeContext.$getScopeTarget(); // Precedence: keystroke's field container, or the scope target otherwise.\n\n        var keys = keyStroke.keys(); // Get all keys which are handled by the keystroke. Typically, this is a single key.\n\n        keys.forEach(function (key) {\n          var virtualKeyStrokeEvent = new VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, event.target);\n\n          if (immediatePropagationStoppedKeys.indexOf(key.toKeyStrokeString()) < 0 && keyStrokeContext.accept(virtualKeyStrokeEvent) && keyStroke.accept(virtualKeyStrokeEvent) && !this._isPreventedByDescendantContext(key, event.target, descendantContexts)) {\n            if (key.render($drawingArea, virtualKeyStrokeEvent)) {\n              this._renderedKeys.push(key);\n            } // If immediate propagation is stopped, key strokes on the same level which react to the same key won't be executed -> make sure they won't be displayed either\n\n\n            if (virtualKeyStrokeEvent.isImmediatePropagationStopped()) {\n              immediatePropagationStoppedKeys.push(key.toKeyStrokeString());\n            }\n          }\n        }, this);\n      }, this);\n      descendantContexts.push(keyStrokeContext); // Register this keyStrokeContext within the event, so that superior keyStrokeContexts can validate their keys (e.g. not swallowed by a descendant keyStrokeContext).\n\n      event.originalEvent.keyStrokeContexts = descendantContexts;\n    }\n  }, {\n    key: \"_isPreventedByDescendantContext\",\n    value: function _isPreventedByDescendantContext(key, target, descendantContexts) {\n      var virtualKeyStrokeEvent = new VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, target); // Check whether any descendant keyStrokeContext prevents this keystroke from execution.\n\n      return descendantContexts.some(function (descendantContext) {\n        // Ask descendant keyStrokeContext whether this event is swallowed.\n        descendantContext.accept(virtualKeyStrokeEvent);\n\n        if (virtualKeyStrokeEvent.isAnyPropagationStopped()) {\n          return true;\n        } // Ask keystrokes of descendant keyStrokeContext whether this event is swallowed.\n\n\n        return descendantContext.keyStrokes.some(function (descendantKeyStroke) {\n          descendantKeyStroke.accept(virtualKeyStrokeEvent);\n          return virtualKeyStrokeEvent.isAnyPropagationStopped();\n        }, this);\n      }, this);\n    }\n    /**\n     * Handles the keystroke event by the keyStrokeContext's keystroke handlers, but returns immediately once a keystroke requests immediate stop of propagation.\n     */\n\n  }, {\n    key: \"_handleKeyStrokeEvent\",\n    value: function _handleKeyStrokeEvent(keyStrokeContext, event) {\n      if (!keyStrokeContext.accept(event)) {\n        return;\n      }\n\n      if (keyStrokeContext.keyStrokes.length < 1) {\n        return;\n      } // Handle numpad keystroke\n\n\n      if (event.which >= 96 && event.which <= 105) {\n        event.which = event.which - 48;\n      } // We create a copy of the keyStrokes array, because when a widget is disposed in the handle function\n      // of a keystroke, all its keystrokes on the context are deleted. Which means no key stroke is processed\n      // anymore. However: creating a copy can be dangerous too, because the handle function must deal with\n      // the situation that the widget to which the keystroke belongs, is suddenly destroyed.\n\n\n      var keyStrokesCopy = keyStrokeContext.keyStrokes.slice();\n      keyStrokesCopy.some(function (keyStroke) {\n        if (!keyStroke.accept(event)) {\n          return false;\n        } // Before handling the keystroke, accept the input of a potential active value field\n\n\n        if (this.invokeAcceptInputOnActiveValueField(keyStroke, keyStrokeContext)) {\n          ValueField.invokeValueFieldAcceptInput(event.target);\n        }\n\n        if (!this._filter(keyStroke)) {\n          return true; // 'some-loop' breaks on true\n        }\n\n        this.trigger('keyStroke', {\n          keyStroke: keyStroke,\n          keyStrokeContext: keyStrokeContext\n        }); // Handle the keystroke\n\n        keyStroke.invokeHandle(event); // Break on 'stopImmediate'.\n\n        return event.isImmediatePropagationStopped(); // 'some-loop' breaks on true\n      }, this);\n    }\n  }, {\n    key: \"_filter\",\n    value: function _filter(keyStroke) {\n      for (var i = 0; i < this.filters.length; i++) {\n        if (!this.filters[i].filter(keyStroke)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"invokeAcceptInputOnActiveValueField\",\n    value: function invokeAcceptInputOnActiveValueField(keyStroke, keyStrokeContext) {\n      return !keyStroke.preventInvokeAcceptInputOnActiveValueField && (keyStroke.invokeAcceptInputOnActiveValueField || keyStrokeContext.invokeAcceptInputOnActiveValueField);\n    }\n  }, {\n    key: \"_isHelpKeyStroke\",\n    value: function _isHelpKeyStroke(event) {\n      return KeyStroke.acceptEvent(this.helpKeyStroke, event);\n    }\n  }, {\n    key: \"_installHelpDisposeListener\",\n    value: function _installHelpDisposeListener(event) {\n      var helpDisposeHandler,\n          $currentTarget = $(event.currentTarget),\n          $myWindow = $currentTarget.window(),\n          $topLevelContainer = $currentTarget.entryPoint();\n\n      helpDisposeHandler = function () {\n        $topLevelContainer.off('keyup', helpDisposeHandler);\n        $myWindow.off('blur', helpDisposeHandler);\n        this._helpRendered = false;\n\n        this._renderedKeys.forEach(function (key) {\n          key.remove();\n        });\n\n        this._renderedKeys = [];\n      }.bind(this);\n\n      $topLevelContainer.on('keyup', helpDisposeHandler);\n      $myWindow.on('blur', helpDisposeHandler); // once the current browser tab/window is left\n\n      return false;\n    }\n  }, {\n    key: \"_onKeyEvent\",\n    value: function _onKeyEvent(keyStrokeContext, event) {\n      // check if scopeTarget is covered by glass pane\n      if (this.session.focusManager.isElementCovertByGlassPane(keyStrokeContext.$getScopeTarget())) {\n        // check if any action with 'keyStrokeFirePolicy=IAction.KeyStrokeFirePolicy.ALWAYS' is in keyStrokeContext\n        var keyStrokeFirePolicyAlways = $.grep(keyStrokeContext.keyStrokes, function (k) {\n          // (will at least return an empty array)\n          return k.keyStrokeFirePolicy === Action.KeyStrokeFirePolicy.ALWAYS;\n        });\n\n        if (keyStrokeFirePolicyAlways.length === 0) {\n          return;\n        } // copy current keyStrokeContext and replace keyStrokes with filtered array 'keyStrokeFirePolicyAlways'\n\n\n        keyStrokeContext = keyStrokeContext.clone();\n        keyStrokeContext.keyStrokes = keyStrokeFirePolicyAlways;\n      }\n\n      if (this._isHelpKeyStroke(event)) {\n        if (event.originalEvent.renderingHelp || !this._helpRendered) {\n          event.originalEvent.renderingHelp = true; // flag to let superior keyStrokeContexts render their help keys\n\n          this._helpRendered = true; // flag to only render help once, if help key is held down\n\n          this._installHelpDisposeListener(event);\n\n          this._renderKeys(keyStrokeContext, event);\n        }\n      } else {\n        this._handleKeyStrokeEvent(keyStrokeContext, event);\n      }\n    }\n  }, {\n    key: \"addFilter\",\n    value: function addFilter(filter) {\n      arrays.pushSet(this.filters, filter);\n    }\n  }, {\n    key: \"removeFilter\",\n    value: function removeFilter(filter) {\n      arrays.remove(this.filters, filter);\n    } // --- Event handling methods ---\n\n  }, {\n    key: \"_createEventSupport\",\n    value: function _createEventSupport() {\n      return new EventSupport();\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(type, event) {\n      event = event || {};\n      event.source = this;\n      this.events.trigger(type, event);\n    }\n  }, {\n    key: \"one\",\n    value: function one(type, func) {\n      this.events.one(type, func);\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, func) {\n      return this.events.on(type, func);\n    }\n  }, {\n    key: \"off\",\n    value: function off(type, func) {\n      this.events.off(type, func);\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener(listener) {\n      this.events.addListener(listener);\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(listener) {\n      this.events.removeListener(listener);\n    }\n  }]);\n\n  return KeyStrokeManager;\n}();\n\nexport { KeyStrokeManager as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/keystroke/KeyStrokeManager.js"],"names":["Action","arrays","EventSupport","filters","filters_1","keys","KeyStroke","ValueField","VirtualKeyStrokeEvent","$","KeyStrokeManager","session","helpKeyStroke","parseKeyStroke","swallowF1","_helpRendered","_renderedKeys","events","_createEventSupport","model","installTopLevelKeyStrokeHandlers","$entryPoint","$container","myWindow","window","helpHandler","event","which","F1","backspaceHandler","BACKSPACE","keydown","keyup","onhelp","returnFalse","keyStrokeContext","_handler","$getBindTarget","Error","_onKeyEvent","bind","$target","on","off","descendantContexts","originalEvent","keyStrokeContexts","immediatePropagationStoppedKeys","keyStrokes","filter","keyStroke","render","renderingHints","call","forEach","enabledByFilter","_filter","$drawingArea","field","$getScopeTarget","key","virtualKeyStrokeEvent","ctrl","alt","shift","keyStrokeMode","target","indexOf","toKeyStrokeString","accept","_isPreventedByDescendantContext","push","isImmediatePropagationStopped","some","descendantContext","isAnyPropagationStopped","descendantKeyStroke","length","keyStrokesCopy","slice","invokeAcceptInputOnActiveValueField","invokeValueFieldAcceptInput","trigger","invokeHandle","i","preventInvokeAcceptInputOnActiveValueField","acceptEvent","helpDisposeHandler","$currentTarget","currentTarget","$myWindow","$topLevelContainer","entryPoint","remove","focusManager","isElementCovertByGlassPane","keyStrokeFirePolicyAlways","grep","k","keyStrokeFirePolicy","KeyStrokeFirePolicy","ALWAYS","clone","_isHelpKeyStroke","renderingHelp","_installHelpDisposeListener","_renderKeys","_handleKeyStrokeEvent","pushSet","type","source","func","one","listener","addListener","removeListener"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Action, arrays, EventSupport, filters as filters_1, keys, KeyStroke, ValueField, VirtualKeyStrokeEvent} from '../index';\nimport $ from 'jquery';\n\nexport default class KeyStrokeManager {\n\n  constructor() {\n    this.session = null;\n    this.helpKeyStroke = KeyStroke.parseKeyStroke('F1');\n    this.swallowF1 = true;\n    this._helpRendered = false;\n    this._renderedKeys = [];\n    this.events = this._createEventSupport();\n    this.filters = [];\n  }\n\n  init(model) {\n    this.session = model.session;\n    this.installTopLevelKeyStrokeHandlers(this.session.$entryPoint);\n  }\n\n  installTopLevelKeyStrokeHandlers($container) {\n    var\n      myWindow = $container.window(true),\n      // Swallow F1 (online help) key stroke\n      helpHandler = function(event) {\n        return event.which !== keys.F1;\n      },\n      // Swallow Backspace (browser navigation) key stroke\n      backspaceHandler = function(event) {\n        return event.which !== keys.BACKSPACE;\n      };\n\n    if (this.swallowF1) {\n      $container\n        .keydown(helpHandler)\n        .keyup(helpHandler);\n    }\n    $container\n      .keydown(backspaceHandler)\n      .keyup(backspaceHandler);\n\n    if ('onhelp' in myWindow) {\n      myWindow.onhelp = filters_1.returnFalse;\n    }\n  }\n\n  /**\n   * Installs the given keystroke context. This method has no effect if the context is null, or already installed.\n   */\n  installKeyStrokeContext(keyStrokeContext) {\n    if (!keyStrokeContext) {\n      return;\n    }\n\n    if (keyStrokeContext._handler) {\n      return; // context already installed\n    }\n\n    if (!keyStrokeContext.$getBindTarget()) {\n      throw new Error('missing bind-target for KeyStrokeContext: ' + keyStrokeContext);\n    }\n\n    keyStrokeContext._handler = this._onKeyEvent.bind(this, keyStrokeContext);\n    keyStrokeContext._handler.$target = keyStrokeContext.$getBindTarget();\n    keyStrokeContext._handler.$target.on('keydown', keyStrokeContext._handler);\n    keyStrokeContext._handler.$target.on('keyup', keyStrokeContext._handler);\n  }\n\n  /**\n   * Uninstalls the given keystroke context. This method has no effect if the context is null, or not installed.\n   */\n  uninstallKeyStrokeContext(keyStrokeContext) {\n    if (!keyStrokeContext) {\n      return;\n    }\n    if (!keyStrokeContext._handler) {\n      return; // context not installed\n    }\n\n    keyStrokeContext._handler.$target.off('keydown', keyStrokeContext._handler);\n    keyStrokeContext._handler.$target.off('keyup', keyStrokeContext._handler);\n    keyStrokeContext._handler.$target = null;\n    keyStrokeContext._handler = null;\n  }\n\n  /**\n   * Visualizes the keys supported by the given keyStrokeContext.\n   */\n  _renderKeys(keyStrokeContext, event) {\n    var descendantContexts = event.originalEvent.keyStrokeContexts || [];\n    var immediatePropagationStoppedKeys = [];\n\n    keyStrokeContext.keyStrokes\n      .filter(function(keyStroke) {\n        var render = keyStroke.renderingHints.render;\n        return (typeof render === 'function' ? render.call(keyStroke) : render);\n      })\n      .forEach(function(keyStroke) {\n        keyStroke.enabledByFilter = this._filter(keyStroke);\n        var $drawingArea = (keyStroke.field ? keyStroke.field.$container : null) || keyStrokeContext.$getScopeTarget(); // Precedence: keystroke's field container, or the scope target otherwise.\n        var keys = keyStroke.keys(); // Get all keys which are handled by the keystroke. Typically, this is a single key.\n        keys.forEach(function(key) {\n          var virtualKeyStrokeEvent = new VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, event.target);\n\n          if (immediatePropagationStoppedKeys.indexOf(key.toKeyStrokeString()) < 0 && keyStrokeContext.accept(virtualKeyStrokeEvent) &&\n            keyStroke.accept(virtualKeyStrokeEvent) && !this._isPreventedByDescendantContext(key, event.target, descendantContexts)) {\n            if (key.render($drawingArea, virtualKeyStrokeEvent)) {\n              this._renderedKeys.push(key);\n            }\n            // If immediate propagation is stopped, key strokes on the same level which react to the same key won't be executed -> make sure they won't be displayed either\n            if (virtualKeyStrokeEvent.isImmediatePropagationStopped()) {\n              immediatePropagationStoppedKeys.push(key.toKeyStrokeString());\n            }\n          }\n        }, this);\n      }, this);\n\n    descendantContexts.push(keyStrokeContext); // Register this keyStrokeContext within the event, so that superior keyStrokeContexts can validate their keys (e.g. not swallowed by a descendant keyStrokeContext).\n    event.originalEvent.keyStrokeContexts = descendantContexts;\n  }\n\n  _isPreventedByDescendantContext(key, target, descendantContexts) {\n    var virtualKeyStrokeEvent = new VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, target);\n\n    // Check whether any descendant keyStrokeContext prevents this keystroke from execution.\n    return descendantContexts.some(function(descendantContext) {\n      // Ask descendant keyStrokeContext whether this event is swallowed.\n      descendantContext.accept(virtualKeyStrokeEvent);\n      if (virtualKeyStrokeEvent.isAnyPropagationStopped()) {\n        return true;\n      }\n\n      // Ask keystrokes of descendant keyStrokeContext whether this event is swallowed.\n      return descendantContext.keyStrokes.some(function(descendantKeyStroke) {\n        descendantKeyStroke.accept(virtualKeyStrokeEvent);\n        return virtualKeyStrokeEvent.isAnyPropagationStopped();\n      }, this);\n    }, this);\n  }\n\n  /**\n   * Handles the keystroke event by the keyStrokeContext's keystroke handlers, but returns immediately once a keystroke requests immediate stop of propagation.\n   */\n  _handleKeyStrokeEvent(keyStrokeContext, event) {\n    if (!keyStrokeContext.accept(event)) {\n      return;\n    }\n\n    if (keyStrokeContext.keyStrokes.length < 1) {\n      return;\n    }\n\n    // Handle numpad keystroke\n    if (event.which >= 96 && event.which <= 105) {\n      event.which = event.which - 48;\n    }\n\n    // We create a copy of the keyStrokes array, because when a widget is disposed in the handle function\n    // of a keystroke, all its keystrokes on the context are deleted. Which means no key stroke is processed\n    // anymore. However: creating a copy can be dangerous too, because the handle function must deal with\n    // the situation that the widget to which the keystroke belongs, is suddenly destroyed.\n    var keyStrokesCopy = keyStrokeContext.keyStrokes.slice();\n    keyStrokesCopy.some(function(keyStroke) {\n      if (!keyStroke.accept(event)) {\n        return false;\n      }\n\n      // Before handling the keystroke, accept the input of a potential active value field\n      if (this.invokeAcceptInputOnActiveValueField(keyStroke, keyStrokeContext)) {\n        ValueField.invokeValueFieldAcceptInput(event.target);\n      }\n\n      if (!this._filter(keyStroke)) {\n        return true; // 'some-loop' breaks on true\n      }\n\n      this.trigger('keyStroke', {\n        keyStroke: keyStroke,\n        keyStrokeContext: keyStrokeContext\n      });\n\n      // Handle the keystroke\n      keyStroke.invokeHandle(event);\n\n      // Break on 'stopImmediate'.\n      return event.isImmediatePropagationStopped(); // 'some-loop' breaks on true\n    }, this);\n  }\n\n  _filter(keyStroke) {\n    for (var i = 0; i < this.filters.length; i++) {\n      if (!this.filters[i].filter(keyStroke)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  invokeAcceptInputOnActiveValueField(keyStroke, keyStrokeContext) {\n    return !keyStroke.preventInvokeAcceptInputOnActiveValueField && (keyStroke.invokeAcceptInputOnActiveValueField || keyStrokeContext.invokeAcceptInputOnActiveValueField);\n  }\n\n  _isHelpKeyStroke(event) {\n    return KeyStroke.acceptEvent(this.helpKeyStroke, event);\n  }\n\n  _installHelpDisposeListener(event) {\n    var helpDisposeHandler,\n      $currentTarget = $(event.currentTarget),\n      $myWindow = $currentTarget.window(),\n      $topLevelContainer = $currentTarget.entryPoint();\n\n    helpDisposeHandler = function() {\n      $topLevelContainer.off('keyup', helpDisposeHandler);\n      $myWindow.off('blur', helpDisposeHandler);\n      this._helpRendered = false;\n      this._renderedKeys.forEach(function(key) {\n        key.remove();\n      });\n      this._renderedKeys = [];\n    }.bind(this);\n\n    $topLevelContainer.on('keyup', helpDisposeHandler);\n    $myWindow.on('blur', helpDisposeHandler); // once the current browser tab/window is left\n\n    return false;\n  }\n\n  _onKeyEvent(keyStrokeContext, event) {\n    // check if scopeTarget is covered by glass pane\n    if (this.session.focusManager.isElementCovertByGlassPane(keyStrokeContext.$getScopeTarget())) {\n      // check if any action with 'keyStrokeFirePolicy=IAction.KeyStrokeFirePolicy.ALWAYS' is in keyStrokeContext\n      var keyStrokeFirePolicyAlways = $.grep(keyStrokeContext.keyStrokes, function(k) { // (will at least return an empty array)\n        return k.keyStrokeFirePolicy === Action.KeyStrokeFirePolicy.ALWAYS;\n      });\n      if (keyStrokeFirePolicyAlways.length === 0) {\n        return;\n      }\n      // copy current keyStrokeContext and replace keyStrokes with filtered array 'keyStrokeFirePolicyAlways'\n      keyStrokeContext = keyStrokeContext.clone();\n      keyStrokeContext.keyStrokes = keyStrokeFirePolicyAlways;\n    }\n\n    if (this._isHelpKeyStroke(event)) {\n      if (event.originalEvent.renderingHelp || !this._helpRendered) {\n        event.originalEvent.renderingHelp = true; // flag to let superior keyStrokeContexts render their help keys\n        this._helpRendered = true; // flag to only render help once, if help key is held down\n        this._installHelpDisposeListener(event);\n        this._renderKeys(keyStrokeContext, event);\n      }\n    } else {\n      this._handleKeyStrokeEvent(keyStrokeContext, event);\n    }\n  }\n\n  addFilter(filter) {\n    arrays.pushSet(this.filters, filter);\n  }\n\n  removeFilter(filter) {\n    arrays.remove(this.filters, filter);\n  }\n\n  // --- Event handling methods ---\n  _createEventSupport() {\n    return new EventSupport();\n  }\n\n  trigger(type, event) {\n    event = event || {};\n    event.source = this;\n    this.events.trigger(type, event);\n  }\n\n  one(type, func) {\n    this.events.one(type, func);\n  }\n\n  on(type, func) {\n    return this.events.on(type, func);\n  }\n\n  off(type, func) {\n    this.events.off(type, func);\n  }\n\n  addListener(listener) {\n    this.events.addListener(listener);\n  }\n\n  removeListener(listener) {\n    this.events.removeListener(listener);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}