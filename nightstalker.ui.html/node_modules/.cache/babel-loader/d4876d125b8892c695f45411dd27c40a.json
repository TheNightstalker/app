{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Accordion, arrays, EventDelegator, Group, objects, scout, TileAccordionSelectionHandler } from '../../index';\n\nvar TileAccordion = /*#__PURE__*/function (_Accordion) {\n  _inherits(TileAccordion, _Accordion);\n\n  var _super = _createSuper(TileAccordion);\n\n  function TileAccordion() {\n    var _this;\n\n    _classCallCheck(this, TileAccordion);\n\n    _this = _super.call(this);\n    _this.exclusiveExpand = false;\n    _this.gridColumnCount = null;\n    _this.multiSelect = null;\n    _this.selectable = null;\n    _this.takeTileFiltersFromGroup = true;\n    _this.tileComparator = null;\n    _this.tileFilters = [];\n    _this.tileGridLayoutConfig = null;\n    _this.tileGridSelectionHandler = new TileAccordionSelectionHandler(_assertThisInitialized(_this));\n    _this.withPlaceholders = null;\n    _this.virtual = null;\n    _this._selectionUpdateLocked = false;\n    _this._tileGridPropertyChangeHandler = _this._onTileGridPropertyChange.bind(_assertThisInitialized(_this));\n    _this._groupBodyHeightChangeHandler = _this._onGroupBodyHeightChange.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * @override\n   */\n\n\n  _createClass(TileAccordion, [{\n    key: \"_render\",\n    value: function _render() {\n      _get(_getPrototypeOf(TileAccordion.prototype), \"_render\", this).call(this);\n\n      this.$container.addClass('tile-accordion');\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_initGroup\",\n    value: function _initGroup(group) {\n      _get(_getPrototypeOf(TileAccordion.prototype), \"_initGroup\", this).call(this, group);\n\n      group.body.setSelectionHandler(this.tileGridSelectionHandler); // Copy properties from accordion to new group. If the properties are not set yet, copy them from the group to the accordion\n      // This gives the possibility to either define the properties on the accordion or on the tileGrid initially\n\n      if (this.gridColumnCount !== null) {\n        group.body.setGridColumnCount(this.gridColumnCount);\n      }\n\n      this.setProperty('gridColumnCount', group.body.gridColumnCount);\n\n      if (this.multiSelect !== null) {\n        group.body.setMultiSelect(this.multiSelect);\n      }\n\n      this.setProperty('multiSelect', group.body.multiSelect);\n\n      if (this.selectable !== null) {\n        group.body.setSelectable(this.selectable);\n      }\n\n      this.setProperty('selectable', group.body.selectable);\n\n      if (this.tileGridLayoutConfig !== null) {\n        group.body.setLayoutConfig(this.tileGridLayoutConfig);\n      }\n\n      this.setProperty('tileGridLayoutConfig', group.body.layoutConfig);\n\n      if (this.tileComparator !== null) {\n        group.body.setComparator(this.tileComparator);\n        group.body.sort();\n      }\n\n      this.setProperty('tileComparator', group.body.comparator);\n\n      if (this.tileFilters.length > 0) {\n        group.body.addFilters(this.tileFilters);\n        group.body.filter();\n      }\n\n      if (this.takeTileFiltersFromGroup) {\n        this.setProperty('tileFilters', group.body.filters);\n      }\n\n      if (this.withPlaceholders !== null) {\n        group.body.setWithPlaceholders(this.withPlaceholders);\n      }\n\n      this.setProperty('withPlaceholders', group.body.withPlaceholders);\n\n      if (this.virtual !== null) {\n        group.body.setVirtual(this.virtual);\n      }\n\n      this.setProperty('virtual', group.body.virtual);\n\n      if (group.body.selectedTiles.length > 0) {\n        this._handleSelectionChanged(group.body);\n      }\n\n      group.body.on('propertyChange', this._tileGridPropertyChangeHandler);\n\n      this._handleCollapsed(group); // Delegate events so that consumers don't need to attach a listener to each tile grid by themselves\n\n\n      group.body.__tileAccordionEventDelegator = EventDelegator.create(group.body, this, {\n        delegateEvents: ['tileClick', 'tileAction']\n      });\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_deleteGroup\",\n    value: function _deleteGroup(group) {\n      if (group.body) {\n        group.body.off('propertyChange', this._tileGridPropertyChangeHandler);\n\n        group.body.__tileAccordionEventDelegator.destroy();\n\n        group.body.__tileAccordionEventDelegator = null;\n      }\n\n      _get(_getPrototypeOf(TileAccordion.prototype), \"_deleteGroup\", this).call(this, group);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"setGroups\",\n    value: function setGroups(groups) {\n      var oldTileCount = this.getTileCount();\n      var oldFilteredTileCount = this.getFilteredTileCount();\n      var oldSelectedTileCount = this.getSelectedTileCount();\n\n      _get(_getPrototypeOf(TileAccordion.prototype), \"setGroups\", this).call(this, groups);\n\n      var tileCount = this.getTileCount();\n      var filteredTileCount = this.getFilteredTileCount();\n      var selectedTileCount = this.getSelectedTileCount(); // Trigger artificial property changes if necessary\n      // See _onTileGridPropertyChange why parameters are null\n\n      if (tileCount !== oldTileCount) {\n        this.triggerPropertyChange('tiles', null, null);\n      }\n\n      if (filteredTileCount !== oldFilteredTileCount) {\n        this.triggerPropertyChange('filteredTiles', null, null);\n      }\n\n      if (selectedTileCount !== oldSelectedTileCount) {\n        this.triggerPropertyChange('selectedTiles', null, null);\n      }\n    }\n  }, {\n    key: \"setGridColumnCount\",\n    value: function setGridColumnCount(gridColumnCount) {\n      this.groups.forEach(function (group) {\n        group.body.setGridColumnCount(gridColumnCount);\n      });\n      this.setProperty('gridColumnCount', gridColumnCount);\n    }\n  }, {\n    key: \"setTileGridLayoutConfig\",\n    value: function setTileGridLayoutConfig(layoutConfig) {\n      this.groups.forEach(function (group) {\n        group.body.setLayoutConfig(layoutConfig);\n        layoutConfig = group.body.layoutConfig; // May be converted from plain object to TileGridLayoutConfig\n      });\n      this.setProperty('tileGridLayoutConfig', layoutConfig);\n    }\n  }, {\n    key: \"setWithPlaceholders\",\n    value: function setWithPlaceholders(withPlaceholders) {\n      this.groups.forEach(function (group) {\n        group.body.setWithPlaceholders(withPlaceholders);\n      });\n      this.setProperty('withPlaceholders', withPlaceholders);\n    }\n  }, {\n    key: \"setVirtual\",\n    value: function setVirtual(virtual) {\n      this.groups.forEach(function (group) {\n        group.body.setVirtual(virtual);\n      });\n      this.setProperty('virtual', virtual);\n    }\n  }, {\n    key: \"setSelectable\",\n    value: function setSelectable(selectable) {\n      this.groups.forEach(function (group) {\n        group.body.setSelectable(selectable);\n      });\n      this.setProperty('selectable', selectable);\n    }\n  }, {\n    key: \"setMultiSelect\",\n    value: function setMultiSelect(multiSelect) {\n      this.groups.forEach(function (group) {\n        group.body.setMultiSelect(multiSelect);\n      });\n      this.setProperty('multiSelect', multiSelect);\n    }\n  }, {\n    key: \"getGroupById\",\n    value: function getGroupById(id) {\n      return arrays.find(this.groups, function (group) {\n        return group.id === id;\n      });\n    }\n  }, {\n    key: \"getGroupByTile\",\n    value: function getGroupByTile(tile) {\n      return tile.findParent(function (parent) {\n        return parent instanceof Group;\n      });\n    }\n    /**\n     * Distribute the tiles to the corresponding groups and returns an object with group id as key and array of tiles as value.\n     * Always returns all current groups even if the given tiles may not be distributed to all groups.\n     */\n\n  }, {\n    key: \"_groupTiles\",\n    value: function _groupTiles(tiles) {\n      // Create a map of groups, key is the id, value is an array of tiles\n      var tilesPerGroup = {};\n      this.groups.forEach(function (group) {\n        tilesPerGroup[group.id] = [];\n      }); // Distribute the tiles to the corresponding groups\n\n      tiles.forEach(function (tile) {\n        var group = this.getGroupByTile(tile);\n\n        if (!group) {\n          throw new Error('No group found for tile ' + tile.id);\n        }\n\n        if (!tilesPerGroup[group.id]) {\n          tilesPerGroup[group.id] = [];\n        }\n\n        tilesPerGroup[group.id].push(tile);\n      }, this);\n      return tilesPerGroup;\n    }\n  }, {\n    key: \"deleteTile\",\n    value: function deleteTile(tile) {\n      this.deleteTiles([tile]);\n    }\n  }, {\n    key: \"deleteTiles\",\n    value: function deleteTiles(tilesToDelete, appendPlaceholders) {\n      tilesToDelete = arrays.ensure(tilesToDelete);\n\n      if (tilesToDelete.length === 0) {\n        return;\n      }\n\n      var tiles = this.getTiles();\n      arrays.removeAll(tiles, tilesToDelete);\n      this.setTiles(tiles, appendPlaceholders);\n    }\n  }, {\n    key: \"deleteAllTiles\",\n    value: function deleteAllTiles() {\n      this.setTiles([]);\n    }\n    /**\n     * Distributes the given tiles to their corresponding groups.\n     * <p>\n     * If the list contains new tiles not assigned to a group yet, an exception will be thrown.\n     */\n\n  }, {\n    key: \"setTiles\",\n    value: function setTiles(tiles) {\n      tiles = arrays.ensure(tiles);\n\n      if (objects.equals(this.getTiles(), tiles)) {\n        return;\n      } // Ensure given tiles are real tiles (of type Tile)\n\n\n      tiles = this._createChildren(tiles); // Distribute the tiles to the corresponding groups (result may contain groups without tiles)\n\n      var tilesPerGroup = this._groupTiles(tiles); // Update the tile grids\n\n\n      for (var id in tilesPerGroup) {\n        // NOSONAR\n        var group = this.getGroupById(id);\n        group.body.setTiles(tilesPerGroup[id]);\n      }\n    }\n  }, {\n    key: \"getTiles\",\n    value: function getTiles() {\n      var tiles = [];\n      this.groups.forEach(function (group) {\n        arrays.pushAll(tiles, group.body.tiles);\n      });\n      return tiles;\n    }\n  }, {\n    key: \"getTileCount\",\n    value: function getTileCount() {\n      var count = 0;\n      this.groups.forEach(function (group) {\n        count += group.body.tiles.length;\n      });\n      return count;\n    }\n  }, {\n    key: \"addTileFilter\",\n    value: function addTileFilter(filter) {\n      var filters = this.tileFilters.slice();\n\n      if (filters.indexOf(filter) >= 0) {\n        return;\n      }\n\n      filters.push(filter);\n      this.setTileFilters(filters);\n    }\n  }, {\n    key: \"removeTileFilter\",\n    value: function removeTileFilter(filter) {\n      var filters = this.tileFilters.slice();\n\n      if (!arrays.remove(filters, filter)) {\n        return;\n      }\n\n      this.setTileFilters(filters);\n    }\n  }, {\n    key: \"setTileFilters\",\n    value: function setTileFilters(filters) {\n      filters = arrays.ensure(filters);\n      this.groups.forEach(function (group) {\n        group.body.setFilters(filters);\n      });\n      this.setProperty('tileFilters', filters.slice());\n    }\n  }, {\n    key: \"filterTiles\",\n    value: function filterTiles() {\n      this.groups.forEach(function (group) {\n        group.body.filter();\n      });\n    }\n  }, {\n    key: \"getFilteredTiles\",\n    value: function getFilteredTiles() {\n      var tiles = [];\n      this.groups.forEach(function (group) {\n        arrays.pushAll(tiles, group.body.filteredTiles);\n      });\n      return tiles;\n    }\n  }, {\n    key: \"getFilteredTileCount\",\n    value: function getFilteredTileCount() {\n      var count = 0;\n      this.groups.forEach(function (group) {\n        count += group.body.filteredTiles.length;\n      });\n      return count;\n    }\n    /**\n     * Compared to #getFilteredTiles(), this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are returned.\n     */\n\n  }, {\n    key: \"getVisibleTiles\",\n    value: function getVisibleTiles() {\n      var tiles = [];\n      this.expandedGroups().forEach(function (group) {\n        arrays.pushAll(tiles, group.body.filteredTiles);\n      });\n      return tiles;\n    }\n    /**\n     * Compared to #getFilteredTiles(), this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are counted.\n     */\n\n  }, {\n    key: \"getVisibleTileCount\",\n    value: function getVisibleTileCount() {\n      var count = 0;\n      this.expandedGroups().forEach(function (group) {\n        count += group.body.filteredTiles.length;\n      });\n      return count;\n    }\n  }, {\n    key: \"findVisibleTileIndexAt\",\n    value: function findVisibleTileIndexAt(x, y, startIndex, reverse) {\n      startIndex = scout.nvl(startIndex, 0);\n      return arrays.findIndexFrom(this.getVisibleTiles(), startIndex, function (tile, i) {\n        return this.getVisibleGridX(tile) === x && this.getVisibleGridY(tile) === y;\n      }.bind(this), reverse);\n    }\n    /**\n     * Selects the given tiles and deselects the previously selected ones.\n     */\n\n  }, {\n    key: \"selectTiles\",\n    value: function selectTiles(tiles) {\n      tiles = arrays.ensure(tiles); // Ensure given tiles are real tiles (of type Tile)\n\n      tiles = this._createChildren(tiles); // Split tiles into separate lists for each group (result may contain groups without tiles)\n\n      var tilesPerGroup = this._groupTiles(tiles); // Select the tiles in the the corresponding tile grids\n\n\n      for (var id in tilesPerGroup) {\n        // NOSONAR\n        var group = this.getGroupById(id);\n        group.body.selectTiles(tilesPerGroup[id]);\n      }\n    }\n  }, {\n    key: \"selectTile\",\n    value: function selectTile(tile) {\n      this.selectTiles([tile]);\n    }\n    /**\n     * Selects all tiles. As for every selection operation: only considers filtered tiles and tiles of expanded groups\n     */\n\n  }, {\n    key: \"selectAllTiles\",\n    value: function selectAllTiles() {\n      this.selectTiles(this.getVisibleTiles());\n    }\n  }, {\n    key: \"deselectTiles\",\n    value: function deselectTiles(tiles) {\n      tiles = arrays.ensure(tiles);\n      var selectedTiles = this.getSelectedTiles().slice();\n\n      if (arrays.removeAll(selectedTiles, tiles)) {\n        this.selectTiles(selectedTiles);\n      }\n    }\n  }, {\n    key: \"deselectTile\",\n    value: function deselectTile(tile) {\n      this.deselectTiles([tile]);\n    }\n  }, {\n    key: \"deselectAllTiles\",\n    value: function deselectAllTiles() {\n      this.selectTiles([]);\n    }\n  }, {\n    key: \"addTilesToSelection\",\n    value: function addTilesToSelection(tiles) {\n      tiles = arrays.ensure(tiles);\n      this.selectTiles(this.getSelectedTiles().concat(tiles));\n    }\n  }, {\n    key: \"addTileToSelection\",\n    value: function addTileToSelection(tile) {\n      this.addTilesToSelection([tile]);\n    }\n  }, {\n    key: \"getSelectedTiles\",\n    value: function getSelectedTiles() {\n      var selectedTiles = [];\n      this.groups.forEach(function (group) {\n        arrays.pushAll(selectedTiles, group.body.selectedTiles);\n      });\n      return selectedTiles;\n    }\n  }, {\n    key: \"getSelectedTile\",\n    value: function getSelectedTile() {\n      return this.getSelectedTiles()[0];\n    }\n  }, {\n    key: \"getSelectedTileCount\",\n    value: function getSelectedTileCount() {\n      var count = 0;\n      this.groups.forEach(function (group) {\n        count += group.body.selectedTiles.length;\n      });\n      return count;\n    }\n  }, {\n    key: \"toggleSelection\",\n    value: function toggleSelection() {\n      if (this.getSelectedTileCount() === this.getVisibleTileCount()) {\n        this.deselectAllTiles();\n      } else {\n        this.selectAllTiles();\n      }\n    }\n  }, {\n    key: \"setTileComparator\",\n    value: function setTileComparator(comparator) {\n      this.groups.forEach(function (group) {\n        group.body.setComparator(comparator);\n      });\n      this.setProperty('tileComparator', comparator);\n    }\n  }, {\n    key: \"sortTiles\",\n    value: function sortTiles() {\n      this.groups.forEach(function (group) {\n        group.body.sort();\n      });\n    }\n  }, {\n    key: \"setFocusedTile\",\n    value: function setFocusedTile(tile) {\n      var groupForTile = null;\n\n      if (tile !== null) {\n        groupForTile = this.getGroupByTile(tile);\n      }\n\n      this.groups.forEach(function (group) {\n        if (group === groupForTile) {\n          group.body.setFocusedTile(tile);\n        } else {\n          group.body.setFocusedTile(null);\n        }\n      });\n    }\n  }, {\n    key: \"getFocusedTile\",\n    value: function getFocusedTile() {\n      var focusedTile = null;\n      this.groups.some(function (group) {\n        if (group.body.focusedTile) {\n          focusedTile = group.body.focusedTile;\n          return true;\n        }\n\n        return false;\n      });\n      return focusedTile;\n    }\n  }, {\n    key: \"getVisibleGridRowCount\",\n    value: function getVisibleGridRowCount() {\n      return this.expandedGroups().reduce(function (acc, group) {\n        return acc + group.body.logicalGrid.gridRows;\n      }, 0);\n    }\n  }, {\n    key: \"getVisibleGridX\",\n    value: function getVisibleGridX(tile) {\n      return tile.gridData.x;\n    }\n  }, {\n    key: \"getVisibleGridY\",\n    value: function getVisibleGridY(tile) {\n      var group = this.getGroupByTile(tile);\n      var yCorr = this.getVisibleRowByGroup(group);\n      return tile.gridData.y + yCorr;\n    }\n  }, {\n    key: \"getGroupByVisibleRow\",\n    value: function getGroupByVisibleRow(rowToFind) {\n      if (rowToFind < 0 || rowToFind >= this.getVisibleGridRowCount()) {\n        return null;\n      }\n\n      var currentIndex = 0;\n      return arrays.find(this.expandedGroups(), function (group) {\n        var rowCount = group.body.logicalGrid.gridRows;\n\n        if (currentIndex <= rowToFind && rowToFind < currentIndex + rowCount) {\n          return true;\n        }\n\n        currentIndex += rowCount;\n      });\n    }\n    /**\n     * @returns {number} the index of the row where the group is located.<p>\n     *          Example: There are 3 rows and 2 groups. The first group contains 2 rows, the second 1 row.\n     *          The index of the first group is 0, the index of the second group is 2.\n     */\n\n  }, {\n    key: \"getVisibleRowByGroup\",\n    value: function getVisibleRowByGroup(groupToFind) {\n      var currentIndex = 0;\n      var found = this.expandedGroups().some(function (group) {\n        var rowCount = group.body.logicalGrid.gridRows;\n\n        if (group === groupToFind) {\n          return true;\n        }\n\n        currentIndex += rowCount;\n        return false;\n      });\n\n      if (!found) {\n        return -1;\n      }\n\n      return currentIndex;\n    }\n  }, {\n    key: \"expandedGroups\",\n    value: function expandedGroups() {\n      return this.groups.filter(function (group) {\n        return !group.collapsed;\n      });\n    }\n  }, {\n    key: \"_handleSelectionChanged\",\n    value: function _handleSelectionChanged(tileGrid) {\n      if (this._selectionUpdateLocked) {\n        // Don't execute when deselecting other tiles to minimize the amount of property change events\n        return;\n      }\n\n      var group = tileGrid.parent;\n\n      if (tileGrid.selectedTiles.length > 0 && group.collapsed) {\n        // Do not allow selection in a collapsed group (breaks keyboard navigation and is confusing for the user if invisible tiles are selected)\n        tileGrid.deselectAllTiles();\n        return;\n      }\n\n      if (!this.multiSelect && tileGrid.selectedTiles.length > 0) {\n        this._selectionUpdateLocked = true; // Ensure only one grid has a selected tile if multiSelect is false\n\n        this.groups.forEach(function (group) {\n          if (group.body !== tileGrid) {\n            group.body.deselectAllTiles();\n          }\n        });\n        this._selectionUpdateLocked = false;\n      }\n    }\n  }, {\n    key: \"_onTileGridPropertyChange\",\n    value: function _onTileGridPropertyChange(event) {\n      // Trigger artificial property changes with newValue set to null.\n      // Reason: these property changes are fired for each grid. Creating the compound arrays using getFilteredTiles() etc.\n      // costs some time (even if only some ms) but may not be necessary at all. The consumer can still call these functions by himself.\n      // Also: oldValue cannot be estimated either way which makes it consistent\n      if (event.propertyName === 'selectedTiles') {\n        this._handleSelectionChanged(event.source);\n\n        this.triggerPropertyChange('selectedTiles', null, null);\n      } else if (event.propertyName === 'filteredTiles') {\n        this.triggerPropertyChange('filteredTiles', null, null);\n      } else if (event.propertyName === 'tiles') {\n        this.triggerPropertyChange('tiles', null, null);\n      }\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_onGroupCollapsedChange\",\n    value: function _onGroupCollapsedChange(event) {\n      _get(_getPrototypeOf(TileAccordion.prototype), \"_onGroupCollapsedChange\", this).call(this, event);\n\n      this._handleCollapsed(event.source);\n    }\n  }, {\n    key: \"_handleCollapsed\",\n    value: function _handleCollapsed(group) {\n      if (group.collapsed) {\n        // Deselect tiles of a collapsed group (this will also set focusedTile to null) -> actions on invisible elements is confusing, and key strokes only operate on visible elements, too\n        group.body.deselectAllTiles();\n      }\n\n      if (group.rendered) {\n        group.on('bodyHeightChange', this._groupBodyHeightChangeHandler);\n        group.one('bodyHeightChangeDone', this._onGroupBodyHeightChangeDone.bind(this));\n      }\n    }\n  }, {\n    key: \"_onGroupBodyHeightChange\",\n    value: function _onGroupBodyHeightChange(event) {\n      this.groups.forEach(function (group) {\n        if (event.source === group || group.bodyAnimating) {\n          // No need to layout body for the group which is already expanding / collapsing since it does it anyway\n          // Btw: another group may be doing it as well at the same time (e.g. because of exclusiveExpand)\n          return;\n        }\n\n        if (group.body.virtual) {\n          group.body.scrolling = true;\n          group.body.revalidateLayout();\n          group.body.scrolling = false;\n        }\n      });\n    }\n  }, {\n    key: \"_onGroupBodyHeightChangeDone\",\n    value: function _onGroupBodyHeightChangeDone(event) {\n      event.source.off('bodyHeightChange', this._groupBodyHeightChangeHandler);\n    }\n    /**\n     * @returns {Tile} the first fully visible tile at the scrollTop.\n     */\n\n  }, {\n    key: \"_tileAtScrollTop\",\n    value: function _tileAtScrollTop(scrollTop) {\n      return arrays.find(this.getTiles().filter(function (tile) {\n        return tile.rendered;\n      }), function (tile) {\n        return tile.$container.position().top >= scrollTop;\n      }, this);\n    }\n  }]);\n\n  return TileAccordion;\n}(Accordion);\n\nexport { TileAccordion as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/tile/accordion/TileAccordion.js"],"names":["Accordion","arrays","EventDelegator","Group","objects","scout","TileAccordionSelectionHandler","TileAccordion","exclusiveExpand","gridColumnCount","multiSelect","selectable","takeTileFiltersFromGroup","tileComparator","tileFilters","tileGridLayoutConfig","tileGridSelectionHandler","withPlaceholders","virtual","_selectionUpdateLocked","_tileGridPropertyChangeHandler","_onTileGridPropertyChange","bind","_groupBodyHeightChangeHandler","_onGroupBodyHeightChange","$container","addClass","group","body","setSelectionHandler","setGridColumnCount","setProperty","setMultiSelect","setSelectable","setLayoutConfig","layoutConfig","setComparator","sort","comparator","length","addFilters","filter","filters","setWithPlaceholders","setVirtual","selectedTiles","_handleSelectionChanged","on","_handleCollapsed","__tileAccordionEventDelegator","create","delegateEvents","off","destroy","groups","oldTileCount","getTileCount","oldFilteredTileCount","getFilteredTileCount","oldSelectedTileCount","getSelectedTileCount","tileCount","filteredTileCount","selectedTileCount","triggerPropertyChange","forEach","id","find","tile","findParent","parent","tiles","tilesPerGroup","getGroupByTile","Error","push","deleteTiles","tilesToDelete","appendPlaceholders","ensure","getTiles","removeAll","setTiles","equals","_createChildren","_groupTiles","getGroupById","pushAll","count","slice","indexOf","setTileFilters","remove","setFilters","filteredTiles","expandedGroups","x","y","startIndex","reverse","nvl","findIndexFrom","getVisibleTiles","i","getVisibleGridX","getVisibleGridY","selectTiles","getSelectedTiles","deselectTiles","concat","addTilesToSelection","getVisibleTileCount","deselectAllTiles","selectAllTiles","groupForTile","setFocusedTile","focusedTile","some","reduce","acc","logicalGrid","gridRows","gridData","yCorr","getVisibleRowByGroup","rowToFind","getVisibleGridRowCount","currentIndex","rowCount","groupToFind","found","collapsed","tileGrid","event","propertyName","source","rendered","one","_onGroupBodyHeightChangeDone","bodyAnimating","scrolling","revalidateLayout","scrollTop","position","top"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Accordion, arrays, EventDelegator, Group, objects, scout, TileAccordionSelectionHandler} from '../../index';\n\nexport default class TileAccordion extends Accordion {\n  constructor() {\n    super();\n    this.exclusiveExpand = false;\n    this.gridColumnCount = null;\n    this.multiSelect = null;\n    this.selectable = null;\n    this.takeTileFiltersFromGroup = true;\n    this.tileComparator = null;\n    this.tileFilters = [];\n    this.tileGridLayoutConfig = null;\n    this.tileGridSelectionHandler = new TileAccordionSelectionHandler(this);\n    this.withPlaceholders = null;\n    this.virtual = null;\n    this._selectionUpdateLocked = false;\n    this._tileGridPropertyChangeHandler = this._onTileGridPropertyChange.bind(this);\n    this._groupBodyHeightChangeHandler = this._onGroupBodyHeightChange.bind(this);\n  }\n\n  /**\n   * @override\n   */\n  _render() {\n    super._render();\n    this.$container.addClass('tile-accordion');\n  }\n\n  /**\n   * @override\n   */\n  _initGroup(group) {\n    super._initGroup(group);\n    group.body.setSelectionHandler(this.tileGridSelectionHandler);\n\n    // Copy properties from accordion to new group. If the properties are not set yet, copy them from the group to the accordion\n    // This gives the possibility to either define the properties on the accordion or on the tileGrid initially\n    if (this.gridColumnCount !== null) {\n      group.body.setGridColumnCount(this.gridColumnCount);\n    }\n    this.setProperty('gridColumnCount', group.body.gridColumnCount);\n\n    if (this.multiSelect !== null) {\n      group.body.setMultiSelect(this.multiSelect);\n    }\n    this.setProperty('multiSelect', group.body.multiSelect);\n\n    if (this.selectable !== null) {\n      group.body.setSelectable(this.selectable);\n    }\n    this.setProperty('selectable', group.body.selectable);\n\n    if (this.tileGridLayoutConfig !== null) {\n      group.body.setLayoutConfig(this.tileGridLayoutConfig);\n    }\n    this.setProperty('tileGridLayoutConfig', group.body.layoutConfig);\n\n    if (this.tileComparator !== null) {\n      group.body.setComparator(this.tileComparator);\n      group.body.sort();\n    }\n    this.setProperty('tileComparator', group.body.comparator);\n\n    if (this.tileFilters.length > 0) {\n      group.body.addFilters(this.tileFilters);\n      group.body.filter();\n    }\n    if (this.takeTileFiltersFromGroup) {\n      this.setProperty('tileFilters', group.body.filters);\n    }\n\n    if (this.withPlaceholders !== null) {\n      group.body.setWithPlaceholders(this.withPlaceholders);\n    }\n    this.setProperty('withPlaceholders', group.body.withPlaceholders);\n\n    if (this.virtual !== null) {\n      group.body.setVirtual(this.virtual);\n    }\n    this.setProperty('virtual', group.body.virtual);\n\n    if (group.body.selectedTiles.length > 0) {\n      this._handleSelectionChanged(group.body);\n    }\n\n    group.body.on('propertyChange', this._tileGridPropertyChangeHandler);\n    this._handleCollapsed(group);\n\n    // Delegate events so that consumers don't need to attach a listener to each tile grid by themselves\n    group.body.__tileAccordionEventDelegator = EventDelegator.create(group.body, this, {\n      delegateEvents: ['tileClick', 'tileAction']\n    });\n  }\n\n  /**\n   * @override\n   */\n  _deleteGroup(group) {\n    if (group.body) {\n      group.body.off('propertyChange', this._tileGridPropertyChangeHandler);\n      group.body.__tileAccordionEventDelegator.destroy();\n      group.body.__tileAccordionEventDelegator = null;\n    }\n    super._deleteGroup(group);\n  }\n\n  /**\n   * @override\n   */\n  setGroups(groups) {\n    var oldTileCount = this.getTileCount();\n    var oldFilteredTileCount = this.getFilteredTileCount();\n    var oldSelectedTileCount = this.getSelectedTileCount();\n    super.setGroups(groups);\n\n    var tileCount = this.getTileCount();\n    var filteredTileCount = this.getFilteredTileCount();\n    var selectedTileCount = this.getSelectedTileCount();\n\n    // Trigger artificial property changes if necessary\n    // See _onTileGridPropertyChange why parameters are null\n    if (tileCount !== oldTileCount) {\n      this.triggerPropertyChange('tiles', null, null);\n    }\n    if (filteredTileCount !== oldFilteredTileCount) {\n      this.triggerPropertyChange('filteredTiles', null, null);\n    }\n    if (selectedTileCount !== oldSelectedTileCount) {\n      this.triggerPropertyChange('selectedTiles', null, null);\n    }\n  }\n\n  setGridColumnCount(gridColumnCount) {\n    this.groups.forEach(function(group) {\n      group.body.setGridColumnCount(gridColumnCount);\n    });\n    this.setProperty('gridColumnCount', gridColumnCount);\n  }\n\n  setTileGridLayoutConfig(layoutConfig) {\n    this.groups.forEach(function(group) {\n      group.body.setLayoutConfig(layoutConfig);\n      layoutConfig = group.body.layoutConfig; // May be converted from plain object to TileGridLayoutConfig\n    });\n    this.setProperty('tileGridLayoutConfig', layoutConfig);\n  }\n\n  setWithPlaceholders(withPlaceholders) {\n    this.groups.forEach(function(group) {\n      group.body.setWithPlaceholders(withPlaceholders);\n    });\n    this.setProperty('withPlaceholders', withPlaceholders);\n  }\n\n  setVirtual(virtual) {\n    this.groups.forEach(function(group) {\n      group.body.setVirtual(virtual);\n    });\n    this.setProperty('virtual', virtual);\n  }\n\n  setSelectable(selectable) {\n    this.groups.forEach(function(group) {\n      group.body.setSelectable(selectable);\n    });\n    this.setProperty('selectable', selectable);\n  }\n\n  setMultiSelect(multiSelect) {\n    this.groups.forEach(function(group) {\n      group.body.setMultiSelect(multiSelect);\n    });\n    this.setProperty('multiSelect', multiSelect);\n  }\n\n  getGroupById(id) {\n    return arrays.find(this.groups, function(group) {\n      return group.id === id;\n    });\n  }\n\n  getGroupByTile(tile) {\n    return tile.findParent(function(parent) {\n      return parent instanceof Group;\n    });\n  }\n\n  /**\n   * Distribute the tiles to the corresponding groups and returns an object with group id as key and array of tiles as value.\n   * Always returns all current groups even if the given tiles may not be distributed to all groups.\n   */\n  _groupTiles(tiles) {\n    // Create a map of groups, key is the id, value is an array of tiles\n    var tilesPerGroup = {};\n    this.groups.forEach(function(group) {\n      tilesPerGroup[group.id] = [];\n    });\n\n    // Distribute the tiles to the corresponding groups\n    tiles.forEach(function(tile) {\n      var group = this.getGroupByTile(tile);\n      if (!group) {\n        throw new Error('No group found for tile ' + tile.id);\n      }\n      if (!tilesPerGroup[group.id]) {\n        tilesPerGroup[group.id] = [];\n      }\n      tilesPerGroup[group.id].push(tile);\n    }, this);\n\n    return tilesPerGroup;\n  }\n\n  deleteTile(tile) {\n    this.deleteTiles([tile]);\n  }\n\n  deleteTiles(tilesToDelete, appendPlaceholders) {\n    tilesToDelete = arrays.ensure(tilesToDelete);\n    if (tilesToDelete.length === 0) {\n      return;\n    }\n    var tiles = this.getTiles();\n    arrays.removeAll(tiles, tilesToDelete);\n    this.setTiles(tiles, appendPlaceholders);\n  }\n\n  deleteAllTiles() {\n    this.setTiles([]);\n  }\n\n  /**\n   * Distributes the given tiles to their corresponding groups.\n   * <p>\n   * If the list contains new tiles not assigned to a group yet, an exception will be thrown.\n   */\n  setTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    if (objects.equals(this.getTiles(), tiles)) {\n      return;\n    }\n\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n\n    // Distribute the tiles to the corresponding groups (result may contain groups without tiles)\n    var tilesPerGroup = this._groupTiles(tiles);\n\n    // Update the tile grids\n    for (var id in tilesPerGroup) { // NOSONAR\n      var group = this.getGroupById(id);\n      group.body.setTiles(tilesPerGroup[id]);\n    }\n  }\n\n  getTiles() {\n    var tiles = [];\n    this.groups.forEach(function(group) {\n      arrays.pushAll(tiles, group.body.tiles);\n    });\n    return tiles;\n  }\n\n  getTileCount() {\n    var count = 0;\n    this.groups.forEach(function(group) {\n      count += group.body.tiles.length;\n    });\n    return count;\n  }\n\n  addTileFilter(filter) {\n    var filters = this.tileFilters.slice();\n    if (filters.indexOf(filter) >= 0) {\n      return;\n    }\n    filters.push(filter);\n    this.setTileFilters(filters);\n  }\n\n  removeTileFilter(filter) {\n    var filters = this.tileFilters.slice();\n    if (!arrays.remove(filters, filter)) {\n      return;\n    }\n    this.setTileFilters(filters);\n  }\n\n  setTileFilters(filters) {\n    filters = arrays.ensure(filters);\n    this.groups.forEach(function(group) {\n      group.body.setFilters(filters);\n    });\n    this.setProperty('tileFilters', filters.slice());\n  }\n\n  filterTiles() {\n    this.groups.forEach(function(group) {\n      group.body.filter();\n    });\n  }\n\n  getFilteredTiles() {\n    var tiles = [];\n    this.groups.forEach(function(group) {\n      arrays.pushAll(tiles, group.body.filteredTiles);\n    });\n    return tiles;\n  }\n\n  getFilteredTileCount() {\n    var count = 0;\n    this.groups.forEach(function(group) {\n      count += group.body.filteredTiles.length;\n    });\n    return count;\n  }\n\n  /**\n   * Compared to #getFilteredTiles(), this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are returned.\n   */\n  getVisibleTiles() {\n    var tiles = [];\n    this.expandedGroups().forEach(function(group) {\n      arrays.pushAll(tiles, group.body.filteredTiles);\n    });\n    return tiles;\n  }\n\n  /**\n   * Compared to #getFilteredTiles(), this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are counted.\n   */\n  getVisibleTileCount() {\n    var count = 0;\n    this.expandedGroups().forEach(function(group) {\n      count += group.body.filteredTiles.length;\n    });\n    return count;\n  }\n\n  findVisibleTileIndexAt(x, y, startIndex, reverse) {\n    startIndex = scout.nvl(startIndex, 0);\n    return arrays.findIndexFrom(this.getVisibleTiles(), startIndex, function(tile, i) {\n      return this.getVisibleGridX(tile) === x && this.getVisibleGridY(tile) === y;\n    }.bind(this), reverse);\n  }\n\n  /**\n   * Selects the given tiles and deselects the previously selected ones.\n   */\n  selectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n\n    // Split tiles into separate lists for each group (result may contain groups without tiles)\n    var tilesPerGroup = this._groupTiles(tiles);\n\n    // Select the tiles in the the corresponding tile grids\n    for (var id in tilesPerGroup) { // NOSONAR\n      var group = this.getGroupById(id);\n      group.body.selectTiles(tilesPerGroup[id]);\n    }\n  }\n\n  selectTile(tile) {\n    this.selectTiles([tile]);\n  }\n\n  /**\n   * Selects all tiles. As for every selection operation: only considers filtered tiles and tiles of expanded groups\n   */\n  selectAllTiles() {\n    this.selectTiles(this.getVisibleTiles());\n  }\n\n  deselectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    var selectedTiles = this.getSelectedTiles().slice();\n    if (arrays.removeAll(selectedTiles, tiles)) {\n      this.selectTiles(selectedTiles);\n    }\n  }\n\n  deselectTile(tile) {\n    this.deselectTiles([tile]);\n  }\n\n  deselectAllTiles() {\n    this.selectTiles([]);\n  }\n\n  addTilesToSelection(tiles) {\n    tiles = arrays.ensure(tiles);\n    this.selectTiles(this.getSelectedTiles().concat(tiles));\n  }\n\n  addTileToSelection(tile) {\n    this.addTilesToSelection([tile]);\n  }\n\n  getSelectedTiles() {\n    var selectedTiles = [];\n    this.groups.forEach(function(group) {\n      arrays.pushAll(selectedTiles, group.body.selectedTiles);\n    });\n    return selectedTiles;\n  }\n\n  getSelectedTile() {\n    return this.getSelectedTiles()[0];\n  }\n\n  getSelectedTileCount() {\n    var count = 0;\n    this.groups.forEach(function(group) {\n      count += group.body.selectedTiles.length;\n    });\n    return count;\n  }\n\n  toggleSelection() {\n    if (this.getSelectedTileCount() === this.getVisibleTileCount()) {\n      this.deselectAllTiles();\n    } else {\n      this.selectAllTiles();\n    }\n  }\n\n  setTileComparator(comparator) {\n    this.groups.forEach(function(group) {\n      group.body.setComparator(comparator);\n    });\n    this.setProperty('tileComparator', comparator);\n  }\n\n  sortTiles() {\n    this.groups.forEach(function(group) {\n      group.body.sort();\n    });\n  }\n\n  setFocusedTile(tile) {\n    var groupForTile = null;\n    if (tile !== null) {\n      groupForTile = this.getGroupByTile(tile);\n    }\n    this.groups.forEach(function(group) {\n      if (group === groupForTile) {\n        group.body.setFocusedTile(tile);\n      } else {\n        group.body.setFocusedTile(null);\n      }\n    });\n  }\n\n  getFocusedTile() {\n    var focusedTile = null;\n    this.groups.some(function(group) {\n      if (group.body.focusedTile) {\n        focusedTile = group.body.focusedTile;\n        return true;\n      }\n      return false;\n    });\n    return focusedTile;\n  }\n\n  getVisibleGridRowCount() {\n    return this.expandedGroups().reduce(function(acc, group) {\n      return acc + group.body.logicalGrid.gridRows;\n    }, 0);\n  }\n\n  getVisibleGridX(tile) {\n    return tile.gridData.x;\n  }\n\n  getVisibleGridY(tile) {\n    var group = this.getGroupByTile(tile);\n    var yCorr = this.getVisibleRowByGroup(group);\n    return tile.gridData.y + yCorr;\n  }\n\n  getGroupByVisibleRow(rowToFind) {\n    if (rowToFind < 0 || rowToFind >= this.getVisibleGridRowCount()) {\n      return null;\n    }\n    var currentIndex = 0;\n    return arrays.find(this.expandedGroups(), function(group) {\n      var rowCount = group.body.logicalGrid.gridRows;\n      if (currentIndex <= rowToFind && rowToFind < currentIndex + rowCount) {\n        return true;\n      }\n      currentIndex += rowCount;\n    });\n  }\n\n  /**\n   * @returns {number} the index of the row where the group is located.<p>\n   *          Example: There are 3 rows and 2 groups. The first group contains 2 rows, the second 1 row.\n   *          The index of the first group is 0, the index of the second group is 2.\n   */\n  getVisibleRowByGroup(groupToFind) {\n    var currentIndex = 0;\n    var found = this.expandedGroups().some(function(group) {\n      var rowCount = group.body.logicalGrid.gridRows;\n      if (group === groupToFind) {\n        return true;\n      }\n      currentIndex += rowCount;\n      return false;\n    });\n    if (!found) {\n      return -1;\n    }\n    return currentIndex;\n  }\n\n  expandedGroups() {\n    return this.groups.filter(function(group) {\n      return !group.collapsed;\n    });\n  }\n\n  _handleSelectionChanged(tileGrid) {\n    if (this._selectionUpdateLocked) {\n      // Don't execute when deselecting other tiles to minimize the amount of property change events\n      return;\n    }\n    var group = tileGrid.parent;\n    if (tileGrid.selectedTiles.length > 0 && group.collapsed) {\n      // Do not allow selection in a collapsed group (breaks keyboard navigation and is confusing for the user if invisible tiles are selected)\n      tileGrid.deselectAllTiles();\n      return;\n    }\n    if (!this.multiSelect && tileGrid.selectedTiles.length > 0) {\n      this._selectionUpdateLocked = true;\n      // Ensure only one grid has a selected tile if multiSelect is false\n      this.groups.forEach(function(group) {\n        if (group.body !== tileGrid) {\n          group.body.deselectAllTiles();\n        }\n      });\n      this._selectionUpdateLocked = false;\n    }\n  }\n\n  _onTileGridPropertyChange(event) {\n    // Trigger artificial property changes with newValue set to null.\n    // Reason: these property changes are fired for each grid. Creating the compound arrays using getFilteredTiles() etc.\n    // costs some time (even if only some ms) but may not be necessary at all. The consumer can still call these functions by himself.\n    // Also: oldValue cannot be estimated either way which makes it consistent\n    if (event.propertyName === 'selectedTiles') {\n      this._handleSelectionChanged(event.source);\n      this.triggerPropertyChange('selectedTiles', null, null);\n    } else if (event.propertyName === 'filteredTiles') {\n      this.triggerPropertyChange('filteredTiles', null, null);\n    } else if (event.propertyName === 'tiles') {\n      this.triggerPropertyChange('tiles', null, null);\n    }\n  }\n\n  /**\n   * @override\n   */\n  _onGroupCollapsedChange(event) {\n    super._onGroupCollapsedChange(event);\n\n    this._handleCollapsed(event.source);\n  }\n\n  _handleCollapsed(group) {\n    if (group.collapsed) {\n      // Deselect tiles of a collapsed group (this will also set focusedTile to null) -> actions on invisible elements is confusing, and key strokes only operate on visible elements, too\n      group.body.deselectAllTiles();\n    }\n    if (group.rendered) {\n      group.on('bodyHeightChange', this._groupBodyHeightChangeHandler);\n      group.one('bodyHeightChangeDone', this._onGroupBodyHeightChangeDone.bind(this));\n    }\n  }\n\n  _onGroupBodyHeightChange(event) {\n    this.groups.forEach(function(group) {\n      if (event.source === group || group.bodyAnimating) {\n        // No need to layout body for the group which is already expanding / collapsing since it does it anyway\n        // Btw: another group may be doing it as well at the same time (e.g. because of exclusiveExpand)\n        return;\n      }\n      if (group.body.virtual) {\n        group.body.scrolling = true;\n        group.body.revalidateLayout();\n        group.body.scrolling = false;\n      }\n    });\n  }\n\n  _onGroupBodyHeightChangeDone(event) {\n    event.source.off('bodyHeightChange', this._groupBodyHeightChangeHandler);\n  }\n\n  /**\n   * @returns {Tile} the first fully visible tile at the scrollTop.\n   */\n  _tileAtScrollTop(scrollTop) {\n    return arrays.find(this.getTiles().filter(function(tile) {\n      return tile.rendered;\n    }), function(tile) {\n      return tile.$container.position().top >= scrollTop;\n    }, this);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}