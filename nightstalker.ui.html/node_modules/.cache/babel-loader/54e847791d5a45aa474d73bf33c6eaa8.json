{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Action, arrays, ContextMenuPopup, Event, HtmlComponent, icons, MenuExecKeyStroke, MenuKeyStroke, objects, scout, strings, tooltips, TreeVisitResult } from '../index';\n\nvar Menu = /*#__PURE__*/function (_Action) {\n  _inherits(Menu, _Action);\n\n  var _super = _createSuper(Menu);\n\n  function Menu() {\n    var _this;\n\n    _classCallCheck(this, Menu);\n\n    _this = _super.call(this);\n    _this.childActions = [];\n    _this.defaultMenu = null; // null = determined by the menu bar\n\n    _this.excludedByFilter = false;\n    _this.menuTypes = [];\n    _this.menuStyle = Menu.MenuStyle.NONE;\n    /**\n     * This property is true when the menu instance was moved into a overflow-menu\n     * when there's not enough space on the screen (see MenuBarLayout.js). When set\n     * to true, button style menus must be displayed as regular menus.\n     */\n\n    _this.overflown = false;\n    /**\n     * This property is set if this is a subMenu\n     */\n\n    _this.parentMenu = null;\n    _this.popup = null;\n    _this.popupHorizontalAlignment = undefined;\n    _this.popupVerticalAlignment = undefined;\n    _this.stackable = true;\n    _this.separator = false;\n    _this.shrinkable = false;\n    _this.subMenuVisibility = Menu.SubMenuVisibility.DEFAULT;\n    _this.menuFilter = null;\n\n    _this._addCloneProperties(['defaultMenu', 'menuTypes', 'overflow', 'stackable', 'separator', 'shrinkable', 'parentMenu', 'menuFilter']);\n\n    _this._addWidgetProperties('childActions');\n\n    return _this;\n  }\n\n  _createClass(Menu, [{\n    key: \"_init\",\n    value: function _init(options) {\n      _get(_getPrototypeOf(Menu.prototype), \"_init\", this).call(this, options);\n\n      this._setChildActions(this.childActions);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      _get(_getPrototypeOf(Menu.prototype), \"_initKeyStrokeContext\", this).call(this);\n\n      this.keyStrokeContext.registerKeyStroke(new MenuExecKeyStroke(this));\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      if (this.separator) {\n        this._renderSeparator();\n      } else {\n        this._renderItem();\n      }\n\n      this.$container.unfocusable();\n      this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      _get(_getPrototypeOf(Menu.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderOverflown();\n\n      this._renderMenuStyle();\n\n      this._renderActionStyle();\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      _get(_getPrototypeOf(Menu.prototype), \"_remove\", this).call(this);\n\n      this.$submenuIcon = null;\n      this.$subMenuBody = null;\n    }\n  }, {\n    key: \"_renderSeparator\",\n    value: function _renderSeparator() {\n      this.$container = this.$parent.appendDiv('menu-separator');\n    }\n  }, {\n    key: \"_renderItem\",\n    value: function _renderItem() {\n      this.$container = this.$parent.appendDiv('menu-item');\n\n      if (this.uiCssClass) {\n        this.$container.addClass(this.uiCssClass);\n      }\n\n      var mouseEventHandler = this._onMouseEvent.bind(this);\n\n      this.$container.on('mousedown', mouseEventHandler).on('contextmenu', mouseEventHandler).on('click', mouseEventHandler);\n\n      this._renderSubMenuIcon();\n    }\n  }, {\n    key: \"_renderActionStyle\",\n    value: function _renderActionStyle() {\n      this.$container.toggleClass('menu-button', this.isButton() && !this.overflown);\n    }\n  }, {\n    key: \"_renderSelected\",\n    value: function _renderSelected() {\n      if (!this._doActionTogglesSubMenu()) {\n        _get(_getPrototypeOf(Menu.prototype), \"_renderSelected\", this).call(this); // Cannot be done in ContextMenuPopup,\n        // because the property change event is fired before renderSelected is called,\n        // and updateNextToSelected depends on the UI state\n\n\n        if (this.parent instanceof ContextMenuPopup) {\n          this.parent.updateNextToSelected();\n        }\n      }\n\n      if (this.selected) {\n        if (this._doActionTogglesSubMenu()) {\n          this._renderSubMenuItems(this, this.childActions);\n        } else if (this._doActionTogglesPopup()) {\n          this._openPopup();\n        }\n      } else {\n        if (this._doActionTogglesSubMenu() && this.rendered) {\n          this._removeSubMenuItems(this);\n        } else {\n          this._closePopup();\n\n          this._closeSubMenues();\n        }\n      }\n    }\n  }, {\n    key: \"_closeSubMenues\",\n    value: function _closeSubMenues() {\n      this.childActions.forEach(function (menu) {\n        if (menu._doActionTogglesPopup()) {\n          menu._closeSubMenues();\n\n          menu.setSelected(false);\n        }\n      });\n    }\n  }, {\n    key: \"_removeSubMenuItems\",\n    value: function _removeSubMenuItems(parentMenu) {\n      if (this.parent instanceof ContextMenuPopup) {\n        this.parent.removeSubMenuItems(parentMenu, true);\n      } else if (this.parent instanceof Menu) {\n        this.parent._removeSubMenuItems(parentMenu);\n      }\n    }\n  }, {\n    key: \"_renderSubMenuItems\",\n    value: function _renderSubMenuItems(parentMenu, menus) {\n      if (this.parent instanceof ContextMenuPopup) {\n        this.parent.renderSubMenuItems(parentMenu, menus, true);\n\n        var closeHandler = function closeHandler(event) {\n          parentMenu.setSelected(false);\n        };\n\n        var propertyChangeHandler = function (event) {\n          if (event.propertyName === 'selected' && event.newValue === false) {\n            this.parent.off('close', closeHandler);\n            parentMenu.off('propertyChange', propertyChangeHandler);\n          }\n        }.bind(this);\n\n        this.parent.on('close', closeHandler);\n        parentMenu.on('propertyChange', propertyChangeHandler);\n      } else if (this.parent instanceof Menu) {\n        this.parent._renderSubMenuItems(parentMenu, menus);\n      }\n    }\n    /**\n     * Override this method to control the toggles sub-menu behavior when this menu instance is used as parent.\n     * Some menu sub-classes like the ComboMenu need to show the popup menu instead.\n     * @see: #_doActionTogglesSubMenu\n     */\n\n  }, {\n    key: \"_togglesSubMenu\",\n    value: function _togglesSubMenu() {\n      return true;\n    }\n  }, {\n    key: \"_doActionTogglesSubMenu\",\n    value: function _doActionTogglesSubMenu() {\n      if (!this.childActions.length) {\n        return false;\n      }\n\n      if (this.parent instanceof ContextMenuPopup) {\n        return true;\n      }\n\n      if (this.parent instanceof Menu) {\n        return this.parent._togglesSubMenu();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_getSubMenuLevel\",\n    value: function _getSubMenuLevel() {\n      if (this.parent instanceof ContextMenuPopup) {\n        return 0;\n      }\n\n      return _get(_getPrototypeOf(Menu.prototype), \"_getSubMenuLevel\", this).call(this) + 1;\n    }\n  }, {\n    key: \"_onMouseEvent\",\n    value: function _onMouseEvent(event) {\n      if (event.type === 'mousedown') {\n        this._doubleClickSupport.mousedown(event);\n      }\n\n      if (!this._allowMouseEvent(event)) {\n        return;\n      } // When the action is clicked the user wants to execute the action and not see the tooltip -> cancel the task\n      // If it is already displayed it will stay\n\n\n      tooltips.cancel(this.$container); // If menu has childActions, a popup should be rendered on click. To create\n      // the impression of a faster UI, open the popup already on 'mousedown', not\n      // on 'click'. All other actions are handled on 'click'.\n\n      if (event.type === 'mousedown' && this._doActionTogglesPopup()) {\n        this.doAction();\n      } else if ((event.type === 'click' || event.type === 'contextmenu') && !this._doActionTogglesPopup()) {\n        this.doAction();\n      }\n    }\n    /**\n     * May be overridden if the criteria to open a popup differs\n     */\n\n  }, {\n    key: \"_doActionTogglesPopup\",\n    value: function _doActionTogglesPopup() {\n      return this.childActions.length > 0;\n    }\n    /**\n     * Only render child actions if the sub-menu popup is open.\n     */\n\n  }, {\n    key: \"_renderChildActions\",\n    value: function _renderChildActions() {\n      if (objects.optProperty(this.popup, 'rendered')) {\n        var $popup = this.popup.$container;\n        this.childActions.forEach(function (menu) {\n          menu.render($popup);\n        });\n      }\n\n      this._renderSubMenuIcon();\n    }\n  }, {\n    key: \"_renderSubMenuIcon\",\n    value: function _renderSubMenuIcon() {\n      var visible = false; // calculate visibility of sub-menu icon\n\n      if (this.childActions.length > 0) {\n        switch (this.subMenuVisibility) {\n          case Menu.SubMenuVisibility.DEFAULT:\n            visible = this._hasText();\n            break;\n\n          case Menu.SubMenuVisibility.TEXT_OR_ICON:\n            visible = this._hasText() || this.iconId;\n            break;\n\n          case Menu.SubMenuVisibility.ALWAYS:\n            visible = true;\n            break;\n        }\n      }\n\n      if (visible) {\n        if (!this.$submenuIcon) {\n          var icon = icons.parseIconId(Menu.SUBMENU_ICON);\n          this.$submenuIcon = this.$container.appendSpan('submenu-icon').text(icon.iconCharacter);\n          this.invalidateLayoutTree();\n        }\n      } else {\n        if (this.$submenuIcon) {\n          this.$submenuIcon.remove();\n          this.$submenuIcon = null;\n          this.invalidateLayoutTree();\n        }\n      }\n    }\n  }, {\n    key: \"_renderText\",\n    value: function _renderText(text) {\n      _get(_getPrototypeOf(Menu.prototype), \"_renderText\", this).call(this, text); // Ensure submenu-icon is the last element in the DOM\n\n\n      if (this.$submenuIcon) {\n        this.$submenuIcon.appendTo(this.$container);\n      }\n\n      this.$container.toggleClass('has-text', strings.hasText(this.text) && this.textVisible);\n\n      this._updateIconAndTextStyle();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_renderIconId\",\n    value: function _renderIconId() {\n      _get(_getPrototypeOf(Menu.prototype), \"_renderIconId\", this).call(this);\n\n      this.$container.toggleClass('has-icon', !!this.iconId);\n\n      this._updateIconAndTextStyle();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"isTabTarget\",\n    value: function isTabTarget() {\n      return this.enabledComputed && this.visible && !this.overflown && (this.isButton() || !this.separator);\n    }\n    /**\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"recomputeEnabled\",\n    value: function recomputeEnabled(parentEnabled) {\n      if (parentEnabled === undefined) {\n        parentEnabled = this._getInheritedAccessibility();\n      }\n\n      var enabledComputed;\n      var enabledStateForChildren;\n\n      if (this.enabled && this.inheritAccessibility && !parentEnabled && this.childActions.length > 0) {\n        // the enabledComputed state here depends on the child actions:\n        // - if there are childActions which have inheritAccessibility=false (recursively): this action must be enabledComputed=true so that these children can be reached\n        // - otherwise this menu is set to enabledComputed=false\n        enabledComputed = this._hasAccessibleChildMenu();\n\n        if (enabledComputed) {\n          // this composite menu is only active because it has children with inheritAccessibility=true\n          // but child-menus should consider the container parent instead, otherwise all children would be enabled (because this composite menu is enabled now)\n          enabledStateForChildren = parentEnabled;\n        } else {\n          enabledStateForChildren = false;\n        }\n      } else {\n        enabledComputed = this._computeEnabled(this.inheritAccessibility, parentEnabled);\n        enabledStateForChildren = enabledComputed;\n      }\n\n      this._updateEnabledComputed(enabledComputed, enabledStateForChildren);\n    }\n    /**\n     * Calculates the inherited enabled state of this menu. This is the enabled state of the next relevant parent.\n     * A relevant parent is either\n     * - the next parent menu with inheritAccessibility=false\n     * - or the container of the menu (the parent of the root menu)\n     *\n     * The enabled state of the container must be used because the parent menu might be a menu which is only enabled because it has children with inheritAccessibility=false.\n     * One exception: if a parent menu itself is inheritAccessibility=false. Then the container is not relevant anymore but this parent is taken instead.\n     */\n\n  }, {\n    key: \"_getInheritedAccessibility\",\n    value: function _getInheritedAccessibility() {\n      var menu = this;\n      var rootMenu = menu;\n\n      while (menu) {\n        if (!menu.inheritAccessibility) {\n          // not inherited. no need to check any more parent widgets\n          return menu.enabled;\n          /* do not use enabledComputed here because the parents have no effect */\n        }\n\n        rootMenu = menu;\n        menu = menu.parentMenu;\n      }\n\n      var container = rootMenu.parent;\n\n      if (container && container.initialized && container.enabledComputed !== undefined) {\n        return container.enabledComputed;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_findRootMenu\",\n    value: function _findRootMenu() {\n      var menu = this;\n      var result;\n\n      while (menu) {\n        result = menu;\n        menu = menu.parentMenu;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_hasAccessibleChildMenu\",\n    value: function _hasAccessibleChildMenu() {\n      var childFound = false;\n      this.visitChildMenus(function (child) {\n        if (!child.inheritAccessibility && child.enabled\n        /* do not use enabledComputed here */\n        && child.visible) {\n          childFound = true;\n          return TreeVisitResult.TERMINATE;\n        }\n\n        return TreeVisitResult.CONTINUE;\n      });\n      return childFound;\n    }\n    /**\n     * cannot use Widget#visitChildren() here because the child actions are not always part of the children collection\n     * e.g. for ellipsis menus which declare childActions as 'PreserveOnPropertyChangeProperties'. this means the childActions are not automatically added to the children list even it is a widget property!\n     */\n\n  }, {\n    key: \"visitChildMenus\",\n    value: function visitChildMenus(visitor) {\n      for (var i = 0; i < this.childActions.length; i++) {\n        var child = this.childActions[i];\n\n        if (child instanceof Menu) {\n          var treeVisitResult = visitor(child);\n\n          if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n            // Visitor wants to abort the visiting\n            return TreeVisitResult.TERMINATE;\n          } else if (treeVisitResult !== TreeVisitResult.SKIP_SUBTREE) {\n            treeVisitResult = child.visitChildMenus(visitor);\n\n            if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n              return TreeVisitResult.TERMINATE;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_hasText\",\n    value: function _hasText() {\n      return strings.hasText(this.text) && this.textVisible;\n    }\n  }, {\n    key: \"_updateIconAndTextStyle\",\n    value: function _updateIconAndTextStyle() {\n      var hasText = this._hasText();\n\n      var hasTextAndIcon = !!(hasText && this.iconId);\n      this.$container.toggleClass('menu-textandicon', hasTextAndIcon);\n      this.$container.toggleClass('menu-icononly', !hasText);\n    }\n  }, {\n    key: \"_closePopup\",\n    value: function _closePopup() {\n      if (this.popup) {\n        this.popup.close();\n      }\n    }\n  }, {\n    key: \"_openPopup\",\n    value: function _openPopup() {\n      if (this.popup) {\n        // already open\n        return;\n      }\n\n      this.popup = this._createPopup();\n      this.popup.open();\n      this.popup.on('remove', function (event) {\n        this.popup = null;\n      }.bind(this)); // Reason for separating remove and close event:\n      // Remove may be called if parent (menubar) gets removed or rebuilt.\n      // In that case, we do not want to change the selected state because after rebuilding the popup should still be open\n      // In every other case the state of the menu needs to be reset if the popup closes\n\n      this.popup.on('close', function (event) {\n        this.setSelected(false);\n      }.bind(this));\n\n      if (this.uiCssClass) {\n        this.popup.$container.addClass(this.uiCssClass);\n      }\n    }\n  }, {\n    key: \"_createPopup\",\n    value: function _createPopup(event) {\n      var options = {\n        parent: this,\n        menu: this,\n        menuFilter: this.menuFilter,\n        ignoreEvent: event,\n        horizontalAlignment: this.popupHorizontalAlignment,\n        verticalAlignment: this.popupVerticalAlignment\n      };\n      return scout.create('MenuBarPopup', options);\n    }\n  }, {\n    key: \"_createActionKeyStroke\",\n    value: function _createActionKeyStroke() {\n      return new MenuKeyStroke(this);\n    }\n  }, {\n    key: \"isToggleAction\",\n    value: function isToggleAction() {\n      return this.childActions.length > 0 || this.toggleAction;\n    }\n  }, {\n    key: \"isButton\",\n    value: function isButton() {\n      return Action.ActionStyle.BUTTON === this.actionStyle;\n    }\n  }, {\n    key: \"addChildActions\",\n    value: function addChildActions(childActions) {\n      var newActions = this.childActions.slice();\n      arrays.pushAll(newActions, arrays.ensure(childActions));\n      this.setChildActions(newActions);\n    }\n  }, {\n    key: \"setChildActions\",\n    value: function setChildActions(childActions) {\n      this.setProperty('childActions', childActions);\n    }\n  }, {\n    key: \"_setChildActions\",\n    value: function _setChildActions(childActions) {\n      // disconnect existing\n      this.childActions.forEach(function (childAction) {\n        childAction.parentMenu = null;\n      });\n\n      this._setProperty('childActions', childActions); // connect new actions\n\n\n      this.childActions.forEach(function (childAction) {\n        childAction.parentMenu = this;\n      }.bind(this));\n\n      if (this.initialized) {\n        this.recomputeEnabled();\n      }\n    }\n    /**\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_setInheritAccessibility\",\n    value: function _setInheritAccessibility(inheritAccessibility) {\n      this._setProperty('inheritAccessibility', inheritAccessibility);\n\n      if (this.initialized) {\n        this._findRootMenu().recomputeEnabled();\n      }\n    }\n    /**\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_setEnabled\",\n    value: function _setEnabled(enabled) {\n      this._setProperty('enabled', enabled);\n\n      if (this.initialized) {\n        this._findRootMenu().recomputeEnabled();\n      }\n    }\n  }, {\n    key: \"_setVisible\",\n    value: function _setVisible(visible) {\n      this._setProperty('visible', visible);\n\n      if (this.initialized) {\n        this._findRootMenu().recomputeEnabled();\n      }\n    }\n  }, {\n    key: \"setSelected\",\n    value: function setSelected(selected) {\n      if (selected === this.selected) {\n        return;\n      }\n\n      _get(_getPrototypeOf(Menu.prototype), \"setSelected\", this).call(this, selected);\n\n      if (!this._doActionTogglesSubMenu() && !this._doActionTogglesPopup()) {\n        return;\n      } // If menu toggles a popup and is in an ellipsis menu which is not selected it needs a special treatment\n\n\n      if (this.overflowMenu && !this.overflowMenu.selected) {\n        this._handleSelectedInEllipsis();\n      }\n    }\n  }, {\n    key: \"_handleSelectedInEllipsis\",\n    value: function _handleSelectedInEllipsis() {\n      // If the selection toggles a popup, open the ellipsis menu as well, otherwise the popup would not be shown\n      if (this.selected) {\n        this.overflowMenu.setSelected(true);\n      }\n    }\n  }, {\n    key: \"setStackable\",\n    value: function setStackable(stackable) {\n      this.setProperty('stackable', stackable);\n    }\n  }, {\n    key: \"setShrinkable\",\n    value: function setShrinkable(shrinkable) {\n      this.setProperty('shrinkable', shrinkable);\n    }\n    /**\n     * For internal usage only.\n     * Used by the MenuBarLayout when a menu is moved to the ellipsis drop down.\n     */\n\n  }, {\n    key: \"_setOverflown\",\n    value: function _setOverflown(overflown) {\n      if (this.overflown === overflown) {\n        return;\n      }\n\n      this._setProperty('overflown', overflown);\n\n      if (this.rendered) {\n        this._renderOverflown();\n      }\n    }\n  }, {\n    key: \"_renderOverflown\",\n    value: function _renderOverflown() {\n      this.$container.toggleClass('overflown', this.overflown);\n\n      this._renderActionStyle();\n    }\n  }, {\n    key: \"setMenuStyle\",\n    value: function setMenuStyle(menuStyle) {\n      this.setProperty('menuStyle', menuStyle);\n    }\n  }, {\n    key: \"_renderMenuStyle\",\n    value: function _renderMenuStyle() {\n      this.$container.toggleClass('default-menu', this.menuStyle === Menu.MenuStyle.DEFAULT);\n    }\n  }, {\n    key: \"setDefaultMenu\",\n    value: function setDefaultMenu(defaultMenu) {\n      this.setProperty('defaultMenu', defaultMenu);\n    }\n  }, {\n    key: \"setMenuFilter\",\n    value: function setMenuFilter(menuFilter) {\n      this.setProperty('menuFilter', menuFilter);\n      this.childActions.forEach(function (child) {\n        child.setMenuFilter(menuFilter);\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(model, options) {\n      var clone = _get(_getPrototypeOf(Menu.prototype), \"clone\", this).call(this, model, options);\n\n      this._deepCloneProperties(clone, 'childActions', options);\n\n      clone._setChildActions(clone.childActions);\n\n      return clone;\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      var event = new Event({\n        source: this\n      });\n      this.trigger('focus', event);\n\n      if (!event.defaultPrevented) {\n        return _get(_getPrototypeOf(Menu.prototype), \"focus\", this).call(this);\n      }\n\n      return false;\n    }\n  }]);\n\n  return Menu;\n}(Action);\n\n_defineProperty(Menu, \"SUBMENU_ICON\", icons.ANGLE_DOWN_BOLD);\n\n_defineProperty(Menu, \"MenuStyle\", {\n  NONE: 0,\n  DEFAULT: 1\n});\n\n_defineProperty(Menu, \"SubMenuVisibility\", {\n  /**\n   * Default: sub-menu icon is only visible when menu has text.\n   */\n  DEFAULT: 'default',\n\n  /**\n   * Text or icon: sub-menu icon is only visible when menu has text or an icon.\n   */\n  TEXT_OR_ICON: 'textOrIcon',\n\n  /**\n   * Always: sub-menu icon is always visible when menu has child-actions.\n   */\n  ALWAYS: 'always'\n});\n\nexport { Menu as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/menu/Menu.js"],"names":["Action","arrays","ContextMenuPopup","Event","HtmlComponent","icons","MenuExecKeyStroke","MenuKeyStroke","objects","scout","strings","tooltips","TreeVisitResult","Menu","childActions","defaultMenu","excludedByFilter","menuTypes","menuStyle","MenuStyle","NONE","overflown","parentMenu","popup","popupHorizontalAlignment","undefined","popupVerticalAlignment","stackable","separator","shrinkable","subMenuVisibility","SubMenuVisibility","DEFAULT","menuFilter","_addCloneProperties","_addWidgetProperties","options","_setChildActions","keyStrokeContext","registerKeyStroke","_renderSeparator","_renderItem","$container","unfocusable","htmlComp","install","session","_renderOverflown","_renderMenuStyle","_renderActionStyle","$submenuIcon","$subMenuBody","$parent","appendDiv","uiCssClass","addClass","mouseEventHandler","_onMouseEvent","bind","on","_renderSubMenuIcon","toggleClass","isButton","_doActionTogglesSubMenu","parent","updateNextToSelected","selected","_renderSubMenuItems","_doActionTogglesPopup","_openPopup","rendered","_removeSubMenuItems","_closePopup","_closeSubMenues","forEach","menu","setSelected","removeSubMenuItems","menus","renderSubMenuItems","closeHandler","event","propertyChangeHandler","propertyName","newValue","off","length","_togglesSubMenu","type","_doubleClickSupport","mousedown","_allowMouseEvent","cancel","doAction","optProperty","$popup","render","visible","_hasText","TEXT_OR_ICON","iconId","ALWAYS","icon","parseIconId","SUBMENU_ICON","appendSpan","text","iconCharacter","invalidateLayoutTree","remove","appendTo","hasText","textVisible","_updateIconAndTextStyle","enabledComputed","parentEnabled","_getInheritedAccessibility","enabledStateForChildren","enabled","inheritAccessibility","_hasAccessibleChildMenu","_computeEnabled","_updateEnabledComputed","rootMenu","container","initialized","result","childFound","visitChildMenus","child","TERMINATE","CONTINUE","visitor","i","treeVisitResult","SKIP_SUBTREE","hasTextAndIcon","close","_createPopup","open","ignoreEvent","horizontalAlignment","verticalAlignment","create","toggleAction","ActionStyle","BUTTON","actionStyle","newActions","slice","pushAll","ensure","setChildActions","setProperty","childAction","_setProperty","recomputeEnabled","_findRootMenu","overflowMenu","_handleSelectedInEllipsis","setMenuFilter","model","clone","_deepCloneProperties","source","trigger","defaultPrevented","ANGLE_DOWN_BOLD"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Action, arrays, ContextMenuPopup, Event, HtmlComponent, icons, MenuExecKeyStroke, MenuKeyStroke, objects, scout, strings, tooltips, TreeVisitResult} from '../index';\n\nexport default class Menu extends Action {\n\n  constructor() {\n    super();\n\n    this.childActions = [];\n    this.defaultMenu = null; // null = determined by the menu bar\n    this.excludedByFilter = false;\n    this.menuTypes = [];\n    this.menuStyle = Menu.MenuStyle.NONE;\n    /**\n     * This property is true when the menu instance was moved into a overflow-menu\n     * when there's not enough space on the screen (see MenuBarLayout.js). When set\n     * to true, button style menus must be displayed as regular menus.\n     */\n    this.overflown = false;\n    /**\n     * This property is set if this is a subMenu\n     */\n    this.parentMenu = null;\n    this.popup = null;\n    this.popupHorizontalAlignment = undefined;\n    this.popupVerticalAlignment = undefined;\n    this.stackable = true;\n    this.separator = false;\n    this.shrinkable = false;\n    this.subMenuVisibility = Menu.SubMenuVisibility.DEFAULT;\n\n    this.menuFilter = null;\n\n    this._addCloneProperties(['defaultMenu', 'menuTypes', 'overflow', 'stackable', 'separator', 'shrinkable', 'parentMenu', 'menuFilter']);\n    this._addWidgetProperties('childActions');\n  }\n\n  static SUBMENU_ICON = icons.ANGLE_DOWN_BOLD;\n\n  /**\n   * Special styles of the menu, calculated by the MenuBar. The default value is MenuStyle.NONE.\n   */\n  static MenuStyle = {\n    NONE: 0,\n    DEFAULT: 1\n  };\n\n  static SubMenuVisibility = {\n    /**\n     * Default: sub-menu icon is only visible when menu has text.\n     */\n    DEFAULT: 'default',\n    /**\n     * Text or icon: sub-menu icon is only visible when menu has text or an icon.\n     */\n    TEXT_OR_ICON: 'textOrIcon',\n    /**\n     * Always: sub-menu icon is always visible when menu has child-actions.\n     */\n    ALWAYS: 'always'\n  };\n\n  _init(options) {\n    super._init(options);\n    this._setChildActions(this.childActions);\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke(new MenuExecKeyStroke(this));\n  }\n\n  _render() {\n    if (this.separator) {\n      this._renderSeparator();\n    } else {\n      this._renderItem();\n    }\n    this.$container.unfocusable();\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderOverflown();\n    this._renderMenuStyle();\n    this._renderActionStyle();\n  }\n\n  _remove() {\n    super._remove();\n    this.$submenuIcon = null;\n    this.$subMenuBody = null;\n  }\n\n  _renderSeparator() {\n    this.$container = this.$parent.appendDiv('menu-separator');\n  }\n\n  _renderItem() {\n    this.$container = this.$parent.appendDiv('menu-item');\n    if (this.uiCssClass) {\n      this.$container.addClass(this.uiCssClass);\n    }\n\n    var mouseEventHandler = this._onMouseEvent.bind(this);\n    this.$container\n      .on('mousedown', mouseEventHandler)\n      .on('contextmenu', mouseEventHandler)\n      .on('click', mouseEventHandler);\n\n    this._renderSubMenuIcon();\n  }\n\n  _renderActionStyle() {\n    this.$container.toggleClass('menu-button', this.isButton() && !this.overflown);\n  }\n\n  _renderSelected() {\n    if (!this._doActionTogglesSubMenu()) {\n      super._renderSelected();\n      // Cannot be done in ContextMenuPopup,\n      // because the property change event is fired before renderSelected is called,\n      // and updateNextToSelected depends on the UI state\n      if (this.parent instanceof ContextMenuPopup) {\n        this.parent.updateNextToSelected();\n      }\n    }\n    if (this.selected) {\n      if (this._doActionTogglesSubMenu()) {\n        this._renderSubMenuItems(this, this.childActions);\n      } else if (this._doActionTogglesPopup()) {\n        this._openPopup();\n      }\n    } else {\n      if (this._doActionTogglesSubMenu() && this.rendered) {\n        this._removeSubMenuItems(this);\n      } else {\n        this._closePopup();\n        this._closeSubMenues();\n      }\n    }\n  }\n\n  _closeSubMenues() {\n    this.childActions.forEach(function(menu) {\n      if (menu._doActionTogglesPopup()) {\n        menu._closeSubMenues();\n        menu.setSelected(false);\n      }\n    });\n  }\n\n  _removeSubMenuItems(parentMenu) {\n    if (this.parent instanceof ContextMenuPopup) {\n      this.parent.removeSubMenuItems(parentMenu, true);\n    } else if (this.parent instanceof Menu) {\n      this.parent._removeSubMenuItems(parentMenu);\n    }\n  }\n\n  _renderSubMenuItems(parentMenu, menus) {\n    if (this.parent instanceof ContextMenuPopup) {\n      this.parent.renderSubMenuItems(parentMenu, menus, true);\n      var closeHandler = function(event) {\n        parentMenu.setSelected(false);\n      };\n      var propertyChangeHandler = function(event) {\n        if (event.propertyName === 'selected' && event.newValue === false) {\n          this.parent.off('close', closeHandler);\n          parentMenu.off('propertyChange', propertyChangeHandler);\n        }\n      }.bind(this);\n      this.parent.on('close', closeHandler);\n      parentMenu.on('propertyChange', propertyChangeHandler);\n    } else if (this.parent instanceof Menu) {\n      this.parent._renderSubMenuItems(parentMenu, menus);\n    }\n  }\n\n  /**\n   * Override this method to control the toggles sub-menu behavior when this menu instance is used as parent.\n   * Some menu sub-classes like the ComboMenu need to show the popup menu instead.\n   * @see: #_doActionTogglesSubMenu\n   */\n  _togglesSubMenu() {\n    return true;\n  }\n\n  _doActionTogglesSubMenu() {\n    if (!this.childActions.length) {\n      return false;\n    }\n    if (this.parent instanceof ContextMenuPopup) {\n      return true;\n    }\n    if (this.parent instanceof Menu) {\n      return this.parent._togglesSubMenu();\n    }\n    return false;\n  }\n\n  _getSubMenuLevel() {\n    if (this.parent instanceof ContextMenuPopup) {\n      return 0;\n    }\n    return super._getSubMenuLevel() + 1;\n  }\n\n  _onMouseEvent(event) {\n    if (event.type === 'mousedown') {\n      this._doubleClickSupport.mousedown(event);\n    }\n    if (!this._allowMouseEvent(event)) {\n      return;\n    }\n\n    // When the action is clicked the user wants to execute the action and not see the tooltip -> cancel the task\n    // If it is already displayed it will stay\n    tooltips.cancel(this.$container);\n\n    // If menu has childActions, a popup should be rendered on click. To create\n    // the impression of a faster UI, open the popup already on 'mousedown', not\n    // on 'click'. All other actions are handled on 'click'.\n    if (event.type === 'mousedown' && this._doActionTogglesPopup()) {\n      this.doAction();\n    } else if ((event.type === 'click' || event.type === 'contextmenu') && !this._doActionTogglesPopup()) {\n      this.doAction();\n    }\n  }\n\n  /**\n   * May be overridden if the criteria to open a popup differs\n   */\n  _doActionTogglesPopup() {\n    return this.childActions.length > 0;\n  }\n\n  /**\n   * Only render child actions if the sub-menu popup is open.\n   */\n  _renderChildActions() {\n    if (objects.optProperty(this.popup, 'rendered')) {\n      var $popup = this.popup.$container;\n      this.childActions.forEach(function(menu) {\n        menu.render($popup);\n      });\n    }\n\n    this._renderSubMenuIcon();\n  }\n\n  _renderSubMenuIcon() {\n    var visible = false;\n\n    // calculate visibility of sub-menu icon\n    if (this.childActions.length > 0) {\n      switch (this.subMenuVisibility) {\n        case Menu.SubMenuVisibility.DEFAULT:\n          visible = this._hasText();\n          break;\n        case Menu.SubMenuVisibility.TEXT_OR_ICON:\n          visible = this._hasText() || this.iconId;\n          break;\n        case Menu.SubMenuVisibility.ALWAYS:\n          visible = true;\n          break;\n      }\n    }\n\n    if (visible) {\n      if (!this.$submenuIcon) {\n        var icon = icons.parseIconId(Menu.SUBMENU_ICON);\n        this.$submenuIcon = this.$container\n          .appendSpan('submenu-icon')\n          .text(icon.iconCharacter);\n        this.invalidateLayoutTree();\n      }\n    } else {\n      if (this.$submenuIcon) {\n        this.$submenuIcon.remove();\n        this.$submenuIcon = null;\n        this.invalidateLayoutTree();\n      }\n    }\n  }\n\n  _renderText(text) {\n    super._renderText(text);\n    // Ensure submenu-icon is the last element in the DOM\n    if (this.$submenuIcon) {\n      this.$submenuIcon.appendTo(this.$container);\n    }\n    this.$container.toggleClass('has-text', strings.hasText(this.text) && this.textVisible);\n    this._updateIconAndTextStyle();\n    this.invalidateLayoutTree();\n  }\n\n  _renderIconId() {\n    super._renderIconId();\n    this.$container.toggleClass('has-icon', !!this.iconId);\n    this._updateIconAndTextStyle();\n    this.invalidateLayoutTree();\n  }\n\n  isTabTarget() {\n    return this.enabledComputed && this.visible && !this.overflown && (this.isButton() || !this.separator);\n  }\n\n  /**\n   * @override Widget.js\n   */\n  recomputeEnabled(parentEnabled) {\n    if (parentEnabled === undefined) {\n      parentEnabled = this._getInheritedAccessibility();\n    }\n\n    var enabledComputed;\n    var enabledStateForChildren;\n    if (this.enabled && this.inheritAccessibility && !parentEnabled && this.childActions.length > 0) {\n      // the enabledComputed state here depends on the child actions:\n      // - if there are childActions which have inheritAccessibility=false (recursively): this action must be enabledComputed=true so that these children can be reached\n      // - otherwise this menu is set to enabledComputed=false\n      enabledComputed = this._hasAccessibleChildMenu();\n      if (enabledComputed) {\n        // this composite menu is only active because it has children with inheritAccessibility=true\n        // but child-menus should consider the container parent instead, otherwise all children would be enabled (because this composite menu is enabled now)\n        enabledStateForChildren = parentEnabled;\n      } else {\n        enabledStateForChildren = false;\n      }\n    } else {\n      enabledComputed = this._computeEnabled(this.inheritAccessibility, parentEnabled);\n      enabledStateForChildren = enabledComputed;\n    }\n\n    this._updateEnabledComputed(enabledComputed, enabledStateForChildren);\n  }\n\n  /**\n   * Calculates the inherited enabled state of this menu. This is the enabled state of the next relevant parent.\n   * A relevant parent is either\n   * - the next parent menu with inheritAccessibility=false\n   * - or the container of the menu (the parent of the root menu)\n   *\n   * The enabled state of the container must be used because the parent menu might be a menu which is only enabled because it has children with inheritAccessibility=false.\n   * One exception: if a parent menu itself is inheritAccessibility=false. Then the container is not relevant anymore but this parent is taken instead.\n   */\n  _getInheritedAccessibility() {\n    var menu = this;\n    var rootMenu = menu;\n    while (menu) {\n      if (!menu.inheritAccessibility) {\n        // not inherited. no need to check any more parent widgets\n        return menu.enabled; /* do not use enabledComputed here because the parents have no effect */\n      }\n      rootMenu = menu;\n      menu = menu.parentMenu;\n    }\n\n    var container = rootMenu.parent;\n    if (container && container.initialized && container.enabledComputed !== undefined) {\n      return container.enabledComputed;\n    }\n    return true;\n  }\n\n  _findRootMenu() {\n    var menu = this;\n    var result;\n    while (menu) {\n      result = menu;\n      menu = menu.parentMenu;\n    }\n    return result;\n  }\n\n  _hasAccessibleChildMenu() {\n    var childFound = false;\n    this.visitChildMenus(function(child) {\n      if (!child.inheritAccessibility && child.enabled /* do not use enabledComputed here */ && child.visible) {\n        childFound = true;\n        return TreeVisitResult.TERMINATE;\n      }\n      return TreeVisitResult.CONTINUE;\n    });\n    return childFound;\n  }\n\n  /**\n   * cannot use Widget#visitChildren() here because the child actions are not always part of the children collection\n   * e.g. for ellipsis menus which declare childActions as 'PreserveOnPropertyChangeProperties'. this means the childActions are not automatically added to the children list even it is a widget property!\n   */\n  visitChildMenus(visitor) {\n    for (var i = 0; i < this.childActions.length; i++) {\n      var child = this.childActions[i];\n      if (child instanceof Menu) {\n        var treeVisitResult = visitor(child);\n        if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n          // Visitor wants to abort the visiting\n          return TreeVisitResult.TERMINATE;\n        } else if (treeVisitResult !== TreeVisitResult.SKIP_SUBTREE) {\n          treeVisitResult = child.visitChildMenus(visitor);\n          if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n            return TreeVisitResult.TERMINATE;\n          }\n        }\n      }\n    }\n  }\n\n  _hasText() {\n    return strings.hasText(this.text) && this.textVisible;\n  }\n\n  _updateIconAndTextStyle() {\n    var hasText = this._hasText();\n    var hasTextAndIcon = !!(hasText && this.iconId);\n    this.$container.toggleClass('menu-textandicon', hasTextAndIcon);\n    this.$container.toggleClass('menu-icononly', !hasText);\n  }\n\n  _closePopup() {\n    if (this.popup) {\n      this.popup.close();\n    }\n  }\n\n  _openPopup() {\n    if (this.popup) {\n      // already open\n      return;\n    }\n    this.popup = this._createPopup();\n    this.popup.open();\n    this.popup.on('remove', function(event) {\n      this.popup = null;\n    }.bind(this));\n    // Reason for separating remove and close event:\n    // Remove may be called if parent (menubar) gets removed or rebuilt.\n    // In that case, we do not want to change the selected state because after rebuilding the popup should still be open\n    // In every other case the state of the menu needs to be reset if the popup closes\n    this.popup.on('close', function(event) {\n      this.setSelected(false);\n    }.bind(this));\n\n    if (this.uiCssClass) {\n      this.popup.$container.addClass(this.uiCssClass);\n    }\n  }\n\n  _createPopup(event) {\n    var options = {\n      parent: this,\n      menu: this,\n      menuFilter: this.menuFilter,\n      ignoreEvent: event,\n      horizontalAlignment: this.popupHorizontalAlignment,\n      verticalAlignment: this.popupVerticalAlignment\n    };\n\n    return scout.create('MenuBarPopup', options);\n  }\n\n  _createActionKeyStroke() {\n    return new MenuKeyStroke(this);\n  }\n\n  isToggleAction() {\n    return this.childActions.length > 0 || this.toggleAction;\n  }\n\n  isButton() {\n    return Action.ActionStyle.BUTTON === this.actionStyle;\n  }\n\n  addChildActions(childActions) {\n    var newActions = this.childActions.slice();\n    arrays.pushAll(newActions, arrays.ensure(childActions));\n    this.setChildActions(newActions);\n  }\n\n  setChildActions(childActions) {\n    this.setProperty('childActions', childActions);\n  }\n\n  _setChildActions(childActions) {\n    // disconnect existing\n    this.childActions.forEach(function(childAction) {\n      childAction.parentMenu = null;\n    });\n\n    this._setProperty('childActions', childActions);\n\n    // connect new actions\n    this.childActions.forEach(function(childAction) {\n      childAction.parentMenu = this;\n    }.bind(this));\n\n    if (this.initialized) {\n      this.recomputeEnabled();\n    }\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _setInheritAccessibility(inheritAccessibility) {\n    this._setProperty('inheritAccessibility', inheritAccessibility);\n    if (this.initialized) {\n      this._findRootMenu().recomputeEnabled();\n    }\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _setEnabled(enabled) {\n    this._setProperty('enabled', enabled);\n    if (this.initialized) {\n      this._findRootMenu().recomputeEnabled();\n    }\n  }\n\n  _setVisible(visible) {\n    this._setProperty('visible', visible);\n    if (this.initialized) {\n      this._findRootMenu().recomputeEnabled();\n    }\n  }\n\n  setSelected(selected) {\n    if (selected === this.selected) {\n      return;\n    }\n    super.setSelected(selected);\n    if (!this._doActionTogglesSubMenu() && !this._doActionTogglesPopup()) {\n      return;\n    }\n    // If menu toggles a popup and is in an ellipsis menu which is not selected it needs a special treatment\n    if (this.overflowMenu && !this.overflowMenu.selected) {\n      this._handleSelectedInEllipsis();\n    }\n  }\n\n  _handleSelectedInEllipsis() {\n    // If the selection toggles a popup, open the ellipsis menu as well, otherwise the popup would not be shown\n    if (this.selected) {\n      this.overflowMenu.setSelected(true);\n    }\n  }\n\n  setStackable(stackable) {\n    this.setProperty('stackable', stackable);\n  }\n\n  setShrinkable(shrinkable) {\n    this.setProperty('shrinkable', shrinkable);\n  }\n\n  /**\n   * For internal usage only.\n   * Used by the MenuBarLayout when a menu is moved to the ellipsis drop down.\n   */\n  _setOverflown(overflown) {\n    if (this.overflown === overflown) {\n      return;\n    }\n    this._setProperty('overflown', overflown);\n    if (this.rendered) {\n      this._renderOverflown();\n    }\n  }\n\n  _renderOverflown() {\n    this.$container.toggleClass('overflown', this.overflown);\n    this._renderActionStyle();\n  }\n\n  setMenuStyle(menuStyle) {\n    this.setProperty('menuStyle', menuStyle);\n  }\n\n  _renderMenuStyle() {\n    this.$container.toggleClass('default-menu', this.menuStyle === Menu.MenuStyle.DEFAULT);\n  }\n\n  setDefaultMenu(defaultMenu) {\n    this.setProperty('defaultMenu', defaultMenu);\n  }\n\n  setMenuFilter(menuFilter) {\n    this.setProperty('menuFilter', menuFilter);\n    this.childActions.forEach(function(child) {\n      child.setMenuFilter(menuFilter);\n    });\n  }\n\n  clone(model, options) {\n    var clone = super.clone(model, options);\n    this._deepCloneProperties(clone, 'childActions', options);\n    clone._setChildActions(clone.childActions);\n    return clone;\n  }\n\n  /**\n   * @override\n   */\n  focus() {\n    var event = new Event({source: this});\n    this.trigger('focus', event);\n    if (!event.defaultPrevented) {\n      return super.focus();\n    }\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}