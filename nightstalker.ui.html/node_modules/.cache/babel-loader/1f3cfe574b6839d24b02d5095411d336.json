{"ast":null,"code":"/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { PromiseCreator } from '../index';\nimport $ from 'jquery';\n/**\n * Use a promise creator to create a promise and wait until each promise has been done before the next\n * promise is created and executed.\n *\n * @param {PromiseCreator} promiseCreator this function\n * @returns {Promise}\n */\n\nexport function oneByOne(promiseCreator) {\n  var deferred = $.Deferred();\n\n  _repeat(promiseCreator);\n\n  return deferred.promise(); // use set timeout to prevent stack overflow\n\n  function onDone() {\n    setTimeout(_repeat.bind(this, promiseCreator));\n  }\n\n  function onFail() {\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n\n  function _repeat(promiseCreator) {\n    if (promiseCreator.hasNext()) {\n      promiseCreator.next().done(onDone).fail(onFail);\n    } else {\n      deferred.resolve.apply(deferred, promiseCreator.results);\n    }\n  }\n}\n/**\n * Use a promise creator to create a group of promises and wait until the whole group has been executed\n * before creating and executing promises for the next group.\n *\n * @param groupSize\n * @param promiseCreator\n * @returns {Promise}\n */\n\nexport function groupwise(groupSize, promiseCreator) {\n  var deferred = $.Deferred();\n\n  _repeat(promiseCreator);\n\n  return deferred.promise(); // use set timeout to prevent stack overflow\n\n  function onDone() {\n    setTimeout(_repeat.bind(this, promiseCreator));\n  }\n\n  function onFail() {\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n\n  function _repeat(promiseCreator) {\n    if (promiseCreator.hasNext()) {\n      var promises = [];\n\n      while (promises.length < groupSize && promiseCreator.hasNext()) {\n        promises.push(promiseCreator.next());\n      }\n\n      $.promiseAll(promises, true).done(onDone).fail(onFail);\n    } else {\n      deferred.resolve.apply(deferred, promiseCreator.results);\n    }\n  }\n}\n/**\n * Use a promise creator to try to keep a fixed size pool of promises of working. As soon as one\n * promise is finished, the next promise will be created and executed (as a long as there are more\n * promises available).\n *\n * @param maxPoolSize defines how many promises should be created and executed at most in parallel.\n * @param promiseCreator\n * @param timeout specifies a timeout to wait for until the next promise will be started.\n * @returns {Promise}\n */\n\nexport function parallel(maxPoolSize, promiseCreator, timeout) {\n  timeout = timeout || 0;\n  var deferred = $.Deferred();\n  var poolSize = 0;\n\n  _startNext(promiseCreator);\n\n  return deferred.promise(); // use set timeout to prevent stack overflow\n\n  function onDone() {\n    poolSize--;\n    setTimeout(_startNext.bind(this, promiseCreator), timeout);\n  }\n\n  function onFail() {\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n\n  function _startNext(promiseCreator) {\n    if (deferred.state() !== 'pending') {\n      // deferred has already been rejected or resolved, do not start anymore promises or call done handler\n      return;\n    }\n\n    while (promiseCreator.hasNext() && poolSize < maxPoolSize) {\n      poolSize++;\n      promiseCreator.next().done(onDone).fail(onFail);\n    }\n\n    if (poolSize === 0) {\n      deferred.resolve.apply(deferred, [promiseCreator.results]);\n    }\n  }\n}\nexport default {\n  groupwise: groupwise,\n  oneByOne: oneByOne,\n  parallel: parallel\n};","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/util/promises.js"],"names":["PromiseCreator","$","oneByOne","promiseCreator","deferred","Deferred","_repeat","promise","onDone","setTimeout","bind","onFail","reject","apply","error","hasNext","next","done","fail","resolve","results","groupwise","groupSize","promises","length","push","promiseAll","parallel","maxPoolSize","timeout","poolSize","_startNext","state"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {PromiseCreator} from '../index';\nimport $ from 'jquery';\n\n/**\n * Use a promise creator to create a promise and wait until each promise has been done before the next\n * promise is created and executed.\n *\n * @param {PromiseCreator} promiseCreator this function\n * @returns {Promise}\n */\nexport function oneByOne(promiseCreator) {\n  var deferred = $.Deferred();\n  _repeat(promiseCreator);\n  return deferred.promise();\n\n  // use set timeout to prevent stack overflow\n  function onDone() {\n    setTimeout(_repeat.bind(this, promiseCreator));\n  }\n\n  function onFail() {\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n\n  function _repeat(promiseCreator) {\n    if (promiseCreator.hasNext()) {\n      promiseCreator.next()\n        .done(onDone)\n        .fail(onFail);\n    } else {\n      deferred.resolve.apply(deferred, promiseCreator.results);\n    }\n  }\n}\n\n/**\n * Use a promise creator to create a group of promises and wait until the whole group has been executed\n * before creating and executing promises for the next group.\n *\n * @param groupSize\n * @param promiseCreator\n * @returns {Promise}\n */\nexport function groupwise(groupSize, promiseCreator) {\n  var deferred = $.Deferred();\n  _repeat(promiseCreator);\n  return deferred.promise();\n\n  // use set timeout to prevent stack overflow\n  function onDone() {\n    setTimeout(_repeat.bind(this, promiseCreator));\n  }\n\n  function onFail() {\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n\n  function _repeat(promiseCreator) {\n    if (promiseCreator.hasNext()) {\n      var promises = [];\n      while (promises.length < groupSize && promiseCreator.hasNext()) {\n        promises.push(promiseCreator.next());\n      }\n      $.promiseAll(promises, true)\n        .done(onDone)\n        .fail(onFail);\n    } else {\n      deferred.resolve.apply(deferred, promiseCreator.results);\n    }\n  }\n}\n\n/**\n * Use a promise creator to try to keep a fixed size pool of promises of working. As soon as one\n * promise is finished, the next promise will be created and executed (as a long as there are more\n * promises available).\n *\n * @param maxPoolSize defines how many promises should be created and executed at most in parallel.\n * @param promiseCreator\n * @param timeout specifies a timeout to wait for until the next promise will be started.\n * @returns {Promise}\n */\nexport function parallel(maxPoolSize, promiseCreator, timeout) {\n  timeout = timeout || 0;\n  var deferred = $.Deferred();\n  var poolSize = 0;\n  _startNext(promiseCreator);\n  return deferred.promise();\n\n  // use set timeout to prevent stack overflow\n  function onDone() {\n    poolSize--;\n    setTimeout(_startNext.bind(this, promiseCreator), timeout);\n  }\n\n  function onFail() {\n    deferred.reject.apply(deferred, promiseCreator.error);\n  }\n\n  function _startNext(promiseCreator) {\n    if (deferred.state() !== 'pending') {\n      // deferred has already been rejected or resolved, do not start anymore promises or call done handler\n      return;\n    }\n    while (promiseCreator.hasNext() && poolSize < maxPoolSize) {\n      poolSize++;\n      promiseCreator.next().done(onDone).fail(onFail);\n    }\n    if (poolSize === 0) {\n      deferred.resolve.apply(deferred, [promiseCreator.results]);\n    }\n  }\n}\n\nexport default {\n  groupwise,\n  oneByOne,\n  parallel\n};\n\n"]},"metadata":{},"sourceType":"module"}