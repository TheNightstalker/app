{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays } from '../index';\n\nvar Range = /*#__PURE__*/function () {\n  function Range(from, to) {\n    _classCallCheck(this, Range);\n\n    this.from = from;\n    this.to = to;\n  }\n\n  _createClass(Range, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return this.from === other.from && this.to === other.to;\n    }\n    /**\n     * Subtracts the given range and returns an array of the remaining ranges.\n     */\n\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      // other is empty\n      if (other.size() === 0) {\n        return [new Range(this.from, this.to)];\n      } // other is greater\n\n\n      if (this.from >= other.from && this.to <= other.to) {\n        return [new Range(0, 0)];\n      } // other is contained completely\n\n\n      if (other.from >= this.from && other.to <= this.to) {\n        var range1 = new Range(this.from, other.from);\n        var range2 = new Range(other.to, this.to);\n\n        if (range1.size() === 0) {\n          return [range2];\n        }\n\n        if (range2.size() === 0) {\n          return [range1];\n        }\n\n        return [range1, range2];\n      } // other overlaps on the bottom\n\n\n      if (other.from > this.from && other.from < this.to) {\n        return [new Range(this.from, other.from)];\n      } // other overlaps on the top\n\n\n      if (this.from > other.from && this.from < other.to) {\n        return [new Range(other.to, this.to)];\n      } // other is outside\n\n\n      return [new Range(this.from, this.to)];\n    }\n    /**\n     * Subtracts every given range and returns an array of the remaining ranges.\n     */\n\n  }, {\n    key: \"subtractAll\",\n    value: function subtractAll(others) {\n      var other = others.shift();\n      var remains = [this];\n      var newRemains = []; // Subtract every other element from the remains of every subtraction\n\n      while (other) {\n        remains.forEach(subtract.bind(other));\n        remains = newRemains;\n        newRemains = [];\n        other = others.shift();\n      } // Remove empty ranges\n\n\n      remains = remains.filter(function (remainingElem) {\n        return remainingElem.size() > 0;\n      }); // If nothing is left add one empty range to be consistent with .subtract()\n\n      if (remains.length === 0) {\n        remains.push(new Range(0, 0));\n      }\n\n      function subtract(remainingElem) {\n        arrays.pushAll(newRemains, remainingElem.subtract(other));\n      }\n\n      return remains;\n    }\n  }, {\n    key: \"shrink\",\n    value: function shrink(other) {\n      // other is empty\n      if (other.size() === 0) {\n        return new Range(this.from, this.to);\n      } // other is greater\n\n\n      if (this.from >= other.from && this.to <= other.to) {\n        return new Range(0, 0);\n      } // other is contained completely\n\n\n      if (other.from >= this.from && other.to <= this.to) {\n        return new Range(this.from, other.to);\n      } // other overlaps on the bottom\n\n\n      if (other.from >= this.from && other.from < this.to) {\n        return new Range(this.from, other.from);\n      } // other overlaps on the top\n\n\n      if (this.from > other.from && this.from < other.to) {\n        return new Range(other.to, this.to);\n      }\n\n      if (other.to < this.from) {\n        return new Range(this.from - other.size() - 1, this.to - other.size() - 1);\n      } // other is outside\n\n\n      return new Range(this.from, this.to);\n    }\n  }, {\n    key: \"union\",\n    value: function union(other) {\n      if (this.to < other.from || other.to < this.from) {\n        var range1 = new Range(this.from, this.to);\n        var range2 = new Range(other.from, other.to);\n\n        if (range1.size() === 0) {\n          return [range2];\n        }\n\n        if (range2.size() === 0) {\n          return [range1];\n        }\n\n        return [range1, range2];\n      }\n\n      return [new Range(Math.min(this.from, other.from), Math.max(this.to, other.to))];\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      if (this.to < other.from || other.to < this.from) {\n        var range1 = new Range(this.from, this.to);\n        var range2 = new Range(other.from, other.to);\n\n        if (range1.size() === 0) {\n          return range2;\n        }\n\n        if (range2.size() === 0) {\n          return range1;\n        }\n\n        throw new Error('Range to add has to border on the existing range. ' + this + ', ' + other);\n      }\n\n      return new Range(Math.min(this.from, other.from), Math.max(this.to, other.to));\n    }\n  }, {\n    key: \"intersect\",\n    value: function intersect(other) {\n      if (this.to <= other.from || other.to <= this.from) {\n        return new Range(0, 0);\n      }\n\n      return new Range(Math.max(this.from, other.from), Math.min(this.to, other.to));\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.to - this.from;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(value) {\n      return this.from <= value && value < this.to;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return 'scout.Range[' + 'from=' + (this.from === null ? 'null' : this.from) + ' to=' + (this.to === null ? 'null' : this.to) + ']';\n    }\n  }]);\n\n  return Range;\n}();\n\nexport { Range as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/util/Range.js"],"names":["arrays","Range","from","to","other","size","range1","range2","others","shift","remains","newRemains","forEach","subtract","bind","filter","remainingElem","length","push","pushAll","Math","min","max","Error","value"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays} from '../index';\n\nexport default class Range {\n\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n\n  equals(other) {\n    return this.from === other.from && this.to === other.to;\n  }\n\n  /**\n   * Subtracts the given range and returns an array of the remaining ranges.\n   */\n  subtract(other) {\n    // other is empty\n    if (other.size() === 0) {\n      return [new Range(this.from, this.to)];\n    }\n    // other is greater\n    if (this.from >= other.from && this.to <= other.to) {\n      return [new Range(0, 0)];\n    }\n    // other is contained completely\n    if (other.from >= this.from && other.to <= this.to) {\n      var range1 = new Range(this.from, other.from);\n      var range2 = new Range(other.to, this.to);\n      if (range1.size() === 0) {\n        return [range2];\n      }\n      if (range2.size() === 0) {\n        return [range1];\n      }\n      return [range1, range2];\n    }\n    // other overlaps on the bottom\n    if (other.from > this.from && other.from < this.to) {\n      return [new Range(this.from, other.from)];\n    }\n    // other overlaps on the top\n    if (this.from > other.from && this.from < other.to) {\n      return [new Range(other.to, this.to)];\n    }\n    // other is outside\n    return [new Range(this.from, this.to)];\n  }\n\n  /**\n   * Subtracts every given range and returns an array of the remaining ranges.\n   */\n  subtractAll(others) {\n    var other = others.shift();\n    var remains = [this];\n    var newRemains = [];\n    // Subtract every other element from the remains of every subtraction\n    while (other) {\n      remains.forEach(subtract.bind(other));\n      remains = newRemains;\n      newRemains = [];\n      other = others.shift();\n    }\n    // Remove empty ranges\n    remains = remains.filter(function(remainingElem) {\n      return remainingElem.size() > 0;\n    });\n    // If nothing is left add one empty range to be consistent with .subtract()\n    if (remains.length === 0) {\n      remains.push(new Range(0, 0));\n    }\n\n    function subtract(remainingElem) {\n      arrays.pushAll(newRemains, remainingElem.subtract(other));\n    }\n\n    return remains;\n  }\n\n  shrink(other) {\n    // other is empty\n    if (other.size() === 0) {\n      return new Range(this.from, this.to);\n    }\n    // other is greater\n    if (this.from >= other.from && this.to <= other.to) {\n      return new Range(0, 0);\n    }\n    // other is contained completely\n    if (other.from >= this.from && other.to <= this.to) {\n      return new Range(this.from, other.to);\n    }\n    // other overlaps on the bottom\n    if (other.from >= this.from && other.from < this.to) {\n      return new Range(this.from, other.from);\n    }\n    // other overlaps on the top\n    if (this.from > other.from && this.from < other.to) {\n      return new Range(other.to, this.to);\n    }\n    if (other.to < this.from) {\n      return new Range(this.from - other.size() - 1, this.to - other.size() - 1);\n    }\n    // other is outside\n    return new Range(this.from, this.to);\n  }\n\n  union(other) {\n    if (this.to < other.from || other.to < this.from) {\n      var range1 = new Range(this.from, this.to);\n      var range2 = new Range(other.from, other.to);\n      if (range1.size() === 0) {\n        return [range2];\n      }\n      if (range2.size() === 0) {\n        return [range1];\n      }\n      return [range1, range2];\n    }\n    return [new Range(Math.min(this.from, other.from), Math.max(this.to, other.to))];\n  }\n\n  add(other) {\n    if (this.to < other.from || other.to < this.from) {\n      var range1 = new Range(this.from, this.to);\n      var range2 = new Range(other.from, other.to);\n      if (range1.size() === 0) {\n        return range2;\n      }\n      if (range2.size() === 0) {\n        return range1;\n      }\n      throw new Error('Range to add has to border on the existing range. ' + this + ', ' + other);\n    }\n    return new Range(Math.min(this.from, other.from), Math.max(this.to, other.to));\n  }\n\n  intersect(other) {\n    if (this.to <= other.from || other.to <= this.from) {\n      return new Range(0, 0);\n    }\n    return new Range(Math.max(this.from, other.from), Math.min(this.to, other.to));\n  }\n\n  size() {\n    return this.to - this.from;\n  }\n\n  contains(value) {\n    return this.from <= value && value < this.to;\n  }\n\n  toString() {\n    return 'scout.Range[' +\n      'from=' + (this.from === null ? 'null' : this.from) +\n      ' to=' + (this.to === null ? 'null' : this.to) + ']';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}