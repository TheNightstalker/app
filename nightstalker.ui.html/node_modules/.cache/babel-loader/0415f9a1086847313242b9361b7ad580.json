{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { comparators, EventSupport, strings, TableMatrix, TableUserFilter } from '../../index';\n\nvar ColumnUserFilter = /*#__PURE__*/function (_TableUserFilter) {\n  _inherits(ColumnUserFilter, _TableUserFilter);\n\n  var _super = _createSuper(ColumnUserFilter);\n\n  function ColumnUserFilter() {\n    var _this;\n\n    _classCallCheck(this, ColumnUserFilter);\n\n    _this = _super.call(this);\n    _this.filterType = ColumnUserFilter.TYPE;\n    _this.events = new EventSupport();\n    /**\n     * This property is used to check early whether or not this filter can produce filter-fields.\n     * Set this property to true in your sub-class, if it creates filter fields.\n     */\n\n    _this.hasFilterFields = false;\n    /**\n     * array of (normalized) key, text composite\n     */\n\n    _this.availableValues = [];\n    /**\n     * array of (normalized) keys\n     */\n\n    _this.selectedValues = [];\n    return _this;\n  }\n\n  _createClass(ColumnUserFilter, [{\n    key: \"axisGroup\",\n    value: function axisGroup() {\n      return TableMatrix.NumberGroup.COUNT;\n    }\n  }, {\n    key: \"calculate\",\n    value: function calculate() {\n      var containsSelectedValue, reorderAxis;\n      this.matrix = new TableMatrix(this.table, this.session);\n      this.matrix.addData(this.column, TableMatrix.NumberGroup.COUNT);\n      this.xAxis = this.matrix.addAxis(this.column, this.axisGroup());\n      var cube = this.matrix.calculate();\n      this.selectedValues.forEach(function (selectedValue) {\n        containsSelectedValue = false;\n\n        if (this._useTextInsteadOfNormValue(selectedValue)) {\n          // selected value was not normalized -> normalize\n          selectedValue = this.xAxis.norm(selectedValue);\n        }\n\n        this.xAxis.some(function (key) {\n          if (key === selectedValue) {\n            containsSelectedValue = true;\n            return true;\n          }\n\n          return false;\n        }, this);\n\n        if (!containsSelectedValue) {\n          this.xAxis.push(selectedValue);\n          reorderAxis = true;\n        }\n      }, this);\n\n      if (reorderAxis) {\n        this.xAxis.reorder();\n      }\n\n      var text, displayKey, cubeValue, iconId;\n      this.availableValues = [];\n      this.xAxis.forEach(function (key) {\n        displayKey = key;\n        text = this.xAxis.format(key);\n        iconId = null;\n\n        if (this._useTextInsteadOfNormValue(key)) {\n          displayKey = text;\n        }\n\n        if (key !== null && this.xAxis.textIsIcon) {\n          // Only display icon if textIsIcon (still display empty text if key is null)\n          iconId = text;\n          text = null;\n        }\n\n        cubeValue = cube.getValue([key]);\n        this.availableValues.push({\n          key: displayKey,\n          text: text,\n          iconId: iconId,\n          htmlEnabled: false,\n          cssClass: null,\n          count: cubeValue ? cubeValue[0] : 0\n        });\n      }, this);\n    }\n    /**\n     * In case of text columns, the normalized key generated by the matrix is not deterministic,\n     * it depends on the table data -> use the text. In the other cases it is possible to use the\n     * normalized key which has the advantage that it is locale independent.\n     */\n\n  }, {\n    key: \"_useTextInsteadOfNormValue\",\n    value: function _useTextInsteadOfNormValue(value) {\n      return false;\n    }\n    /**\n     * @override TableUserFilter.js\n     */\n\n  }, {\n    key: \"createFilterAddedEventData\",\n    value: function createFilterAddedEventData() {\n      var data = _get(_getPrototypeOf(ColumnUserFilter.prototype), \"createFilterAddedEventData\", this).call(this);\n\n      data.columnId = this.column.id;\n      data.selectedValues = this.selectedValues;\n      return data;\n    }\n  }, {\n    key: \"createFilterRemovedEventData\",\n    value: function createFilterRemovedEventData() {\n      var data = _get(_getPrototypeOf(ColumnUserFilter.prototype), \"createFilterRemovedEventData\", this).call(this);\n\n      data.columnId = this.column.id;\n      return data;\n    }\n  }, {\n    key: \"createLabel\",\n    value: function createLabel() {\n      if (this.column.headerHtmlEnabled) {\n        var plainText = strings.plainText(this.column.text);\n        return plainText.replace(/\\n/g, ' ');\n      }\n\n      return this.column.text || '';\n    }\n  }, {\n    key: \"createKey\",\n    value: function createKey() {\n      return this.column.id;\n    }\n  }, {\n    key: \"accept\",\n    value: function accept(row) {\n      if (!this.xAxis) {\n        // Lazy calculation. It is not possible on init, because the table is not rendered yet.\n        this.calculate();\n      }\n\n      var acceptByTable = true,\n          acceptByFields = true,\n          key = this.column.cellValueOrTextForCalculation(row),\n          normKey = this.xAxis.norm(key);\n\n      if (this._useTextInsteadOfNormValue(normKey)) {\n        normKey = this.xAxis.format(normKey);\n      }\n\n      if (this.tableFilterActive()) {\n        acceptByTable = this.selectedValues.indexOf(normKey) > -1;\n      }\n\n      if (this.fieldsFilterActive()) {\n        acceptByFields = this.acceptByFields(key, normKey, row);\n      }\n\n      return acceptByTable && acceptByFields;\n    }\n  }, {\n    key: \"filterActive\",\n    value: function filterActive() {\n      return this.tableFilterActive() || this.fieldsFilterActive();\n    }\n  }, {\n    key: \"tableFilterActive\",\n    value: function tableFilterActive() {\n      return this.selectedValues.length > 0;\n    }\n  }, {\n    key: \"triggerFilterFieldsChanged\",\n    value: function triggerFilterFieldsChanged(event) {\n      this.events.trigger('filterFieldsChanged', event);\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, func) {\n      this.events.on(type, func);\n    }\n  }, {\n    key: \"off\",\n    value: function off(type, func) {\n      this.events.off(type, func);\n    }\n    /**\n     * Returns whether or not the given key is accepted by the filter-fields in their current state.\n     * The default impl. returns true.\n     */\n\n  }, {\n    key: \"acceptByFields\",\n    value: function acceptByFields(key, normKey, row) {\n      return true;\n    }\n    /**\n     * Returns whether or not filter-fields have an effect on the column-filter in their current state.\n     * The default impl. returns false.\n     */\n\n  }, {\n    key: \"fieldsFilterActive\",\n    value: function fieldsFilterActive() {\n      return false;\n    }\n    /**\n     * Adds filter fields for this type of column filter.\n     * The default impl. adds no fields.\n     *\n     * @param groupBox FilterFieldsGroupBox\n     */\n\n  }, {\n    key: \"addFilterFields\",\n    value: function addFilterFields(groupBox) {// NOP\n    }\n    /**\n     * Called after filter group-box has been rendered. Gives the filter impl. a chance to\n     * modify the rendered fields. The default impl. does nothing.\n     */\n\n  }, {\n    key: \"modifyFilterFields\",\n    value: function modifyFilterFields() {// NOP\n    }\n    /**\n     * Returns the title displayed above the filter fields.\n     * The default impl. returns a null value, which means the title is not displayed.\n     */\n\n  }, {\n    key: \"filterFieldsTitle\",\n    value: function filterFieldsTitle() {\n      return null;\n    }\n  }, {\n    key: \"createComparator\",\n    value: function createComparator() {\n      return comparators.NUMERIC;\n    }\n  }]);\n\n  return ColumnUserFilter;\n}(TableUserFilter);\n\n_defineProperty(ColumnUserFilter, \"TYPE\", 'column');\n\nexport { ColumnUserFilter as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/table/userfilter/ColumnUserFilter.js"],"names":["comparators","EventSupport","strings","TableMatrix","TableUserFilter","ColumnUserFilter","filterType","TYPE","events","hasFilterFields","availableValues","selectedValues","NumberGroup","COUNT","containsSelectedValue","reorderAxis","matrix","table","session","addData","column","xAxis","addAxis","axisGroup","cube","calculate","forEach","selectedValue","_useTextInsteadOfNormValue","norm","some","key","push","reorder","text","displayKey","cubeValue","iconId","format","textIsIcon","getValue","htmlEnabled","cssClass","count","value","data","columnId","id","headerHtmlEnabled","plainText","replace","row","acceptByTable","acceptByFields","cellValueOrTextForCalculation","normKey","tableFilterActive","indexOf","fieldsFilterActive","length","event","trigger","type","func","on","off","groupBox","NUMERIC"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {comparators, EventSupport, strings, TableMatrix, TableUserFilter} from '../../index';\n\nexport default class ColumnUserFilter extends TableUserFilter {\n\n  constructor() {\n    super();\n    this.filterType = ColumnUserFilter.TYPE;\n    this.events = new EventSupport();\n\n    /**\n     * This property is used to check early whether or not this filter can produce filter-fields.\n     * Set this property to true in your sub-class, if it creates filter fields.\n     */\n    this.hasFilterFields = false;\n\n    /**\n     * array of (normalized) key, text composite\n     */\n    this.availableValues = [];\n\n    /**\n     * array of (normalized) keys\n     */\n    this.selectedValues = [];\n  }\n\n  static TYPE = 'column';\n\n  axisGroup() {\n    return TableMatrix.NumberGroup.COUNT;\n  }\n\n  calculate() {\n    var containsSelectedValue, reorderAxis;\n\n    this.matrix = new TableMatrix(this.table, this.session);\n    this.matrix.addData(this.column, TableMatrix.NumberGroup.COUNT);\n    this.xAxis = this.matrix.addAxis(this.column, this.axisGroup());\n    var cube = this.matrix.calculate();\n\n    this.selectedValues.forEach(function(selectedValue) {\n      containsSelectedValue = false;\n      if (this._useTextInsteadOfNormValue(selectedValue)) {\n        // selected value was not normalized -> normalize\n        selectedValue = this.xAxis.norm(selectedValue);\n      }\n      this.xAxis.some(function(key) {\n        if (key === selectedValue) {\n          containsSelectedValue = true;\n          return true;\n        }\n        return false;\n      }, this);\n\n      if (!containsSelectedValue) {\n        this.xAxis.push(selectedValue);\n        reorderAxis = true;\n      }\n    }, this);\n\n    if (reorderAxis) {\n      this.xAxis.reorder();\n    }\n\n    var text, displayKey, cubeValue, iconId;\n    this.availableValues = [];\n    this.xAxis.forEach(function(key) {\n      displayKey = key;\n      text = this.xAxis.format(key);\n      iconId = null;\n      if (this._useTextInsteadOfNormValue(key)) {\n        displayKey = text;\n      }\n      if (key !== null && this.xAxis.textIsIcon) {\n        // Only display icon if textIsIcon (still display empty text if key is null)\n        iconId = text;\n        text = null;\n      }\n      cubeValue = cube.getValue([key]);\n      this.availableValues.push({\n        key: displayKey,\n        text: text,\n        iconId: iconId,\n        htmlEnabled: false,\n        cssClass: null,\n        count: cubeValue ? cubeValue[0] : 0\n      });\n    }, this);\n  }\n\n  /**\n   * In case of text columns, the normalized key generated by the matrix is not deterministic,\n   * it depends on the table data -> use the text. In the other cases it is possible to use the\n   * normalized key which has the advantage that it is locale independent.\n   */\n  _useTextInsteadOfNormValue(value) {\n    return false;\n  }\n\n  /**\n   * @override TableUserFilter.js\n   */\n  createFilterAddedEventData() {\n    var data = super.createFilterAddedEventData();\n    data.columnId = this.column.id;\n    data.selectedValues = this.selectedValues;\n    return data;\n  }\n\n  createFilterRemovedEventData() {\n    var data = super.createFilterRemovedEventData();\n    data.columnId = this.column.id;\n    return data;\n  }\n\n  createLabel() {\n    if (this.column.headerHtmlEnabled) {\n      var plainText = strings.plainText(this.column.text);\n      return plainText.replace(/\\n/g, ' ');\n    }\n    return this.column.text || '';\n  }\n\n  createKey() {\n    return this.column.id;\n  }\n\n  accept(row) {\n    if (!this.xAxis) {\n      // Lazy calculation. It is not possible on init, because the table is not rendered yet.\n      this.calculate();\n    }\n    var\n      acceptByTable = true,\n      acceptByFields = true,\n      key = this.column.cellValueOrTextForCalculation(row),\n      normKey = this.xAxis.norm(key);\n\n    if (this._useTextInsteadOfNormValue(normKey)) {\n      normKey = this.xAxis.format(normKey);\n    }\n    if (this.tableFilterActive()) {\n      acceptByTable = this.selectedValues.indexOf(normKey) > -1;\n    }\n    if (this.fieldsFilterActive()) {\n      acceptByFields = this.acceptByFields(key, normKey, row);\n    }\n\n    return acceptByTable && acceptByFields;\n  }\n\n  filterActive() {\n    return this.tableFilterActive() || this.fieldsFilterActive();\n  }\n\n  tableFilterActive() {\n    return this.selectedValues.length > 0;\n  }\n\n  triggerFilterFieldsChanged(event) {\n    this.events.trigger('filterFieldsChanged', event);\n  }\n\n  on(type, func) {\n    this.events.on(type, func);\n  }\n\n  off(type, func) {\n    this.events.off(type, func);\n  }\n\n  /**\n   * Returns whether or not the given key is accepted by the filter-fields in their current state.\n   * The default impl. returns true.\n   */\n  acceptByFields(key, normKey, row) {\n    return true;\n  }\n\n  /**\n   * Returns whether or not filter-fields have an effect on the column-filter in their current state.\n   * The default impl. returns false.\n   */\n  fieldsFilterActive() {\n    return false;\n  }\n\n  /**\n   * Adds filter fields for this type of column filter.\n   * The default impl. adds no fields.\n   *\n   * @param groupBox FilterFieldsGroupBox\n   */\n  addFilterFields(groupBox) {\n    // NOP\n  }\n\n  /**\n   * Called after filter group-box has been rendered. Gives the filter impl. a chance to\n   * modify the rendered fields. The default impl. does nothing.\n   */\n  modifyFilterFields() {\n    // NOP\n  }\n\n  /**\n   * Returns the title displayed above the filter fields.\n   * The default impl. returns a null value, which means the title is not displayed.\n   */\n  filterFieldsTitle() {\n    return null;\n  }\n\n  createComparator() {\n    return comparators.NUMERIC;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}