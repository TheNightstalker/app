{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\n\n/**\n * Definition of a date format pattern.\n *\n * A definition provides the following properties (most of which can be set with the 'options' argument):\n *\n * type:\n *   The \"group\" where the pattern definition belongs to. E.g. \"dd\" and \"d\" belong to the same group \"day\".\n *   This is used during analysis to find other definitions for the same type. Use one of the constants\n *   defined in DateFormatPatternType.\n *\n * terms:\n *   An array consisting of all pattern terms that this particular definition can handle. Multiple\n *   terms with the same meaning may be accepted (e.g. \"yyy\", \"yy\" and \"y\" can be all used for a\n *   2-digit year formatting, but different parsing rules may apply).\n *\n * dateFormat:\n *   Reference to the corresponding dateFormat object.\n *\n * formatFunction:\n *   An optional function that is used to format this particular term.\n *   @param formatContext\n *            See documentation at _createFormatContext().\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            The function may return a string as result. If a string is returned, it is appended\n *            to the formatContext.formattedString automatically. If the formatFunction already did\n *            this, it should return \"undefined\".\n *\n * parseRegExp:\n *   A optional JavaScript RegExp object that is applied to the input string to extract this\n *   definition's term. The expression _must_ use exactly two capturing groups:\n *   [1] = matched part of the input\n *   [2] = remaining input (will be parsed later by other definitions)\n *   Example: /^(\\d{4})(.*)$/\n *\n * applyMatchFunction:\n *   If 'parseRegExp' is set and found a match, and this function is defined, it is called\n *   to apply the matched part to the parseContext.\n *   @param parseContext\n *            See documentation at _createParseContext().\n *   @param match\n *            The first match from the reg exp.\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            No return value.\n *\n * parseFunction:\n *   If parsing is not possible with a regular expression, this function may be defined to execute\n *   more complex parse logic.\n *   @param parseContext\n *            See documentation at _createParseContext().\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            A string with the matched part of the input, or null if it did not match.\n */\nvar DateFormatPatternDefinition = /*#__PURE__*/function () {\n  function DateFormatPatternDefinition(options) {\n    _classCallCheck(this, DateFormatPatternDefinition);\n\n    // NOSONAR\n    options = options || {};\n    this.type = options.type;\n    this.terms = options.terms;\n    this.dateFormat = options.dateFormat;\n    this.formatFunction = options.formatFunction && options.formatFunction.bind(this);\n    this.parseRegExp = options.parseRegExp;\n    this.applyMatchFunction = options.applyMatchFunction && options.applyMatchFunction.bind(this);\n    this.parseFunction = options.parseFunction && options.parseFunction.bind(this);\n  }\n\n  _createClass(DateFormatPatternDefinition, [{\n    key: \"createFormatFunction\",\n    value: function createFormatFunction(acceptedTerm) {\n      return function (formatContext) {\n        if (this.formatFunction) {\n          var result = this.formatFunction(formatContext, acceptedTerm);\n\n          if (result !== undefined) {\n            // convenience\n            formatContext.formattedString += result;\n          }\n        }\n      }.bind(this);\n    }\n  }, {\n    key: \"createParseFunction\",\n    value: function createParseFunction(acceptedTerm) {\n      return function (parseContext) {\n        var m, parsedTerm, match;\n        var success = false;\n\n        if (this.parseRegExp) {\n          // RegEx handling (default)\n          m = this.parseRegExp.exec(parseContext.inputString);\n\n          if (m) {\n            // match found\n            if (this.applyMatchFunction) {\n              this.applyMatchFunction(parseContext, m[1], acceptedTerm);\n            }\n\n            match = m[1]; // update remaining string\n\n            parseContext.inputString = m[2];\n            success = true;\n          }\n        }\n\n        if (!success && this.parseFunction) {\n          // Custom function\n          match = this.parseFunction(parseContext, acceptedTerm);\n\n          if (match !== null) {\n            success = true;\n          }\n        }\n\n        if (success) {\n          // If patternDefinition accepts more than one term, try to choose\n          // the form that matches the length of the match.\n          parsedTerm = this.terms[0];\n\n          if (this.terms.length > 1) {\n            this.terms.some(function (term) {\n              if (term.length === match.length) {\n                parsedTerm = term;\n                return true; // found\n              }\n\n              return false; // look further\n            });\n          }\n\n          parseContext.parsedPattern += parsedTerm;\n        }\n\n        return success;\n      }.bind(this);\n    }\n    /**\n     * @return the accepted term (if is accepted) or null (if it is not accepted)\n     */\n\n  }, {\n    key: \"accept\",\n    value: function accept(term) {\n      if (term) {\n        // Check if one of the terms matches\n        for (var i = 0; i < this.terms.length; i++) {\n          if (term === this.terms[i]) {\n            return this.terms[i];\n          }\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return DateFormatPatternDefinition;\n}();\n\nexport { DateFormatPatternDefinition as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/text/DateFormatPatternDefinition.js"],"names":["DateFormatPatternDefinition","options","type","terms","dateFormat","formatFunction","bind","parseRegExp","applyMatchFunction","parseFunction","acceptedTerm","formatContext","result","undefined","formattedString","parseContext","m","parsedTerm","match","success","exec","inputString","length","some","term","parsedPattern","i"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\n\n/**\n * Definition of a date format pattern.\n *\n * A definition provides the following properties (most of which can be set with the 'options' argument):\n *\n * type:\n *   The \"group\" where the pattern definition belongs to. E.g. \"dd\" and \"d\" belong to the same group \"day\".\n *   This is used during analysis to find other definitions for the same type. Use one of the constants\n *   defined in DateFormatPatternType.\n *\n * terms:\n *   An array consisting of all pattern terms that this particular definition can handle. Multiple\n *   terms with the same meaning may be accepted (e.g. \"yyy\", \"yy\" and \"y\" can be all used for a\n *   2-digit year formatting, but different parsing rules may apply).\n *\n * dateFormat:\n *   Reference to the corresponding dateFormat object.\n *\n * formatFunction:\n *   An optional function that is used to format this particular term.\n *   @param formatContext\n *            See documentation at _createFormatContext().\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            The function may return a string as result. If a string is returned, it is appended\n *            to the formatContext.formattedString automatically. If the formatFunction already did\n *            this, it should return \"undefined\".\n *\n * parseRegExp:\n *   A optional JavaScript RegExp object that is applied to the input string to extract this\n *   definition's term. The expression _must_ use exactly two capturing groups:\n *   [1] = matched part of the input\n *   [2] = remaining input (will be parsed later by other definitions)\n *   Example: /^(\\d{4})(.*)$/\n *\n * applyMatchFunction:\n *   If 'parseRegExp' is set and found a match, and this function is defined, it is called\n *   to apply the matched part to the parseContext.\n *   @param parseContext\n *            See documentation at _createParseContext().\n *   @param match\n *            The first match from the reg exp.\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            No return value.\n *\n * parseFunction:\n *   If parsing is not possible with a regular expression, this function may be defined to execute\n *   more complex parse logic.\n *   @param parseContext\n *            See documentation at _createParseContext().\n *   @param acceptedTerm\n *            The term that was accepted for this definition. This argument is usually only relevant,\n *            if a definition can accept more than one term.\n *   @return\n *            A string with the matched part of the input, or null if it did not match.\n */\nexport default class DateFormatPatternDefinition {\n  constructor(options) { // NOSONAR\n    options = options || {};\n    this.type = options.type;\n    this.terms = options.terms;\n    this.dateFormat = options.dateFormat;\n    this.formatFunction = options.formatFunction && options.formatFunction.bind(this);\n    this.parseRegExp = options.parseRegExp;\n    this.applyMatchFunction = options.applyMatchFunction && options.applyMatchFunction.bind(this);\n    this.parseFunction = options.parseFunction && options.parseFunction.bind(this);\n  }\n\n  createFormatFunction(acceptedTerm) {\n    return function(formatContext) {\n      if (this.formatFunction) {\n        var result = this.formatFunction(formatContext, acceptedTerm);\n        if (result !== undefined) { // convenience\n          formatContext.formattedString += result;\n        }\n      }\n    }.bind(this);\n  }\n\n  createParseFunction(acceptedTerm) {\n    return function(parseContext) {\n      var m, parsedTerm, match;\n\n      var success = false;\n      if (this.parseRegExp) {\n        // RegEx handling (default)\n        m = this.parseRegExp.exec(parseContext.inputString);\n        if (m) { // match found\n          if (this.applyMatchFunction) {\n            this.applyMatchFunction(parseContext, m[1], acceptedTerm);\n          }\n          match = m[1];\n          // update remaining string\n          parseContext.inputString = m[2];\n          success = true;\n        }\n      }\n      if (!success && this.parseFunction) {\n        // Custom function\n        match = this.parseFunction(parseContext, acceptedTerm);\n        if (match !== null) {\n          success = true;\n        }\n      }\n\n      if (success) {\n        // If patternDefinition accepts more than one term, try to choose\n        // the form that matches the length of the match.\n        parsedTerm = this.terms[0];\n        if (this.terms.length > 1) {\n          this.terms.some(function(term) {\n            if (term.length === match.length) {\n              parsedTerm = term;\n              return true; // found\n            }\n            return false; // look further\n          });\n        }\n        parseContext.parsedPattern += parsedTerm;\n      }\n      return success;\n    }.bind(this);\n  }\n\n  /**\n   * @return the accepted term (if is accepted) or null (if it is not accepted)\n   */\n  accept(term) {\n    if (term) {\n      // Check if one of the terms matches\n      for (var i = 0; i < this.terms.length; i++) {\n        if (term === this.terms[i]) {\n          return this.terms[i];\n        }\n      }\n    }\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}