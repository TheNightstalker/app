{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Device, dragAndDrop, InputFieldKeyStrokeContext, keys, mimeTypes, scout, Session, strings, ValueField } from '../../../index';\nimport $ from 'jquery';\n\nvar ClipboardField = /*#__PURE__*/function (_ValueField) {\n  _inherits(ClipboardField, _ValueField);\n\n  var _super = _createSuper(ClipboardField);\n\n  function ClipboardField() {\n    var _this;\n\n    _classCallCheck(this, ClipboardField);\n\n    _this = _super.call(this);\n    _this.dropType = 0;\n    _this.dropMaximumSize = dragAndDrop.DEFAULT_DROP_MAXIMUM_SIZE;\n    _this._fileUploadWaitRetryCountTimeout = 99;\n    _this._fullSelectionLength = 0;\n    return _this;\n  } // Keys that don't alter the content of a text field and are therefore always allowed in the clipboard field\n\n\n  _createClass(ClipboardField, [{\n    key: \"_createKeyStrokeContext\",\n\n    /**\n     * @override Widget.js\n     */\n    value: function _createKeyStrokeContext() {\n      return new InputFieldKeyStrokeContext();\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      // We don't use makeDiv() here intentionally because the DIV created must\n      // not have the 'unselectable' attribute. Otherwise clipboard-field will\n      // not work in IE9.\n      this.addContainer(this.$parent, 'clipboard-field');\n      this.addLabel();\n      this.addField(this.$parent.makeElement('<div>').addClass('input-field'));\n      this.addStatus();\n      this.$field.disableSpellcheck().attr('contenteditable', true).attr('tabindex', '0').on('keydown', this._onKeyDown.bind(this)).on('input', this._onInput.bind(this)).on('paste', this._onPaste.bind(this)).on('copy', this._onCopy.bind(this)).on('cut', this._onCopy.bind(this));\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      _get(_getPrototypeOf(ClipboardField.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderDropType();\n    }\n  }, {\n    key: \"_createDragAndDropHandler\",\n    value: function _createDragAndDropHandler() {\n      return dragAndDrop.handler(this, {\n        supportedScoutTypes: dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n        dropType: function () {\n          return this.dropType;\n        }.bind(this),\n        dropMaximumSize: function () {\n          return this.maximumSize;\n        }.bind(this),\n        allowedTypes: function () {\n          return this.allowedMimeTypes;\n        }.bind(this)\n      });\n    }\n  }, {\n    key: \"_renderDisplayText\",\n    value: function _renderDisplayText() {\n      var displayText = this.displayText;\n      var img;\n      this.$field.children().each(function (idx, elem) {\n        if (!img && elem.nodeName === 'IMG') {\n          img = elem;\n        }\n      });\n\n      if (strings.hasText(displayText)) {\n        this.$field.html(strings.nl2br(displayText, true));\n\n        this._installScrollbars();\n\n        setTimeout(function () {\n          this.$field.selectAllText(); // store length of full selection, in order to determine if the whole text is selected in \"onCopy\"\n\n          var selection = this._getSelection();\n\n          this._fullSelectionLength = selection ? selection.toString().length : 0;\n        }.bind(this));\n      } else {\n        this.$field.empty();\n      } // restore old img for firefox upload mechanism.\n\n\n      if (img) {\n        this.$field.prepend(img);\n      }\n    } // Because a <div> is used as field, jQuery's val() used in ValueField.js is not working here, so\n    // the content of displayText variable is used instead.\n    // (For reading the displayText innerHmtl() _could_ be used on the div-field, but some browsers\n    // would collapse whitespaces which would also collapse multiple tabs when coping some table rows.\n    // So instead of reading the effective displayText from the field, the internal displayText value\n    // will be reused without actual reading. Parsing of pasted content is handled onPaste() and stored\n    // in this.displayText.)\n\n  }, {\n    key: \"_readDisplayText\",\n    value: function _readDisplayText() {\n      return this.displayText;\n    }\n  }, {\n    key: \"_getSelection\",\n    value: function _getSelection() {\n      var selection,\n          myWindow = this.$container.window(true);\n\n      if (myWindow.getSelection) {\n        selection = myWindow.getSelection();\n      } else if (document.getSelection) {\n        selection = document.getSelection();\n      }\n\n      if (!selection || selection.toString().length === 0) {\n        return null;\n      }\n\n      return selection;\n    }\n  }, {\n    key: \"_onKeyDown\",\n    value: function _onKeyDown(event) {\n      if (scout.isOneOf(event.which, ClipboardField.ALWAYS_DESTRUCTIVE_KEYS)) {\n        return false; // never allowed\n      }\n\n      if (event.ctrlKey || event.altKey || event.metaKey || scout.isOneOf(event.which, ClipboardField.NON_DESTRUCTIVE_KEYS)) {\n        return; // allow bubble to other event handlers\n      } // do not allow to enter something manually\n\n\n      return false;\n    }\n  }, {\n    key: \"_onInput\",\n    value: function _onInput(event) {\n      // if the user somehow managed to fire to input something (e.g. \"delete\" menu in FF & IE), just reset the value to the previous content\n      this._renderDisplayText();\n\n      return false;\n    }\n  }, {\n    key: \"_onCopy\",\n    value: function _onCopy(event) {\n      if (Device.get().isIos() && this._onIosCopy(event) === false) {\n        return;\n      }\n\n      var selection,\n          text,\n          dataTransfer,\n          myWindow = this.$container.window(true);\n\n      try {\n        if (event.originalEvent.clipboardData) {\n          dataTransfer = event.originalEvent.clipboardData;\n        } else if (myWindow.clipboardData) {\n          dataTransfer = myWindow.clipboardData;\n        }\n      } catch (e) {\n        // Because windows forbids concurrent access to the clipboard, a possible exception is thrown on 'myWindow.clipboardData'\n        // (see Remarks on https://msdn.microsoft.com/en-us/library/windows/desktop/ms649048(v=vs.85).aspx)\n        // Because of this behavior a failed access will just be logged but not presented to the user.\n        $.log.error('Error while reading \"clipboardData\"', e);\n      }\n\n      if (!dataTransfer) {\n        $.log.error('Unable to access clipboard data.');\n        return false;\n      } // scroll bar must not be in field when copying\n\n\n      this._uninstallScrollbars();\n\n      selection = this._getSelection();\n\n      if (!selection) {\n        return;\n      } // if the length of the selection is equals to the length of the (initial) full selection\n      // use the internal 'displayText' value because some browsers are collapsing white spaces\n      // which lead to problems when coping data form tables with empty cells (\"\\t\\t\").\n\n\n      if (selection.toString().length === this._fullSelectionLength) {\n        text = this.displayText;\n      } else {\n        text = selection.toString();\n      }\n\n      try {\n        // Chrome, Firefox - causes an exception in IE\n        dataTransfer.setData('text/plain', text);\n      } catch (e) {\n        // IE, see https://www.lucidchart.com/techblog/2014/12/02/definitive-guide-copying-pasting-javascript/\n        dataTransfer.setData('Text', text);\n      } // (re)install scroll bars\n\n\n      this._installScrollbars();\n\n      return false;\n    }\n  }, {\n    key: \"_onIosCopy\",\n    value: function _onIosCopy(event) {\n      // Setting custom clipboard data is not possible with iOS due to a WebKit bug.\n      // The default behavior copies rich text. Since it is not expected to copy the style of the clipboard field, temporarily set color and background-color\n      // https://bugs.webkit.org/show_bug.cgi?id=176980\n      var oldStyle = this.$field.attr('style');\n      this.$field.css({\n        'color': '#000',\n        'background-color': 'transparent'\n      });\n      setTimeout(function () {\n        this.$field.attrOrRemove('style', oldStyle);\n      }.bind(this));\n      return false;\n    }\n  }, {\n    key: \"_onPaste\",\n    value: function _onPaste(event) {\n      if (this.readOnly) {\n        // Prevent pasting in \"copy\" mode\n        return false;\n      }\n\n      var startPasteTimestamp = Date.now();\n      var dataTransfer,\n          myWindow = this.$container.window(true);\n      this.$field.selectAllText();\n\n      if (event.originalEvent.clipboardData) {\n        dataTransfer = event.originalEvent.clipboardData;\n      } else if (myWindow.clipboardData) {\n        dataTransfer = myWindow.clipboardData;\n      } else {\n        // unable to obtain data transfer object\n        throw new Error('Unable to access clipboard data.');\n      }\n\n      var filesArgument = [],\n          // options to be uploaded, arguments for this.session.uploadFiles\n      additionalOptions = {},\n          additionalOptionsCompatibilityIndex = 0,\n          // counter for additional options\n      contentCount = 0; // some browsers (e.g. IE) specify text content simply as data of type 'Text', it is not listed in list of types\n\n      var textContent = dataTransfer.getData('Text');\n\n      if (textContent) {\n        if (window.Blob) {\n          filesArgument.push(new Blob([textContent], {\n            type: mimeTypes.TEXT_PLAIN\n          }));\n          contentCount++;\n        } else {\n          // compatibility workaround\n          additionalOptions['textTransferObject' + additionalOptionsCompatibilityIndex++] = textContent;\n          contentCount++;\n        }\n      }\n\n      if (contentCount === 0 && dataTransfer.items) {\n        Array.prototype.forEach.call(dataTransfer.items, function (item) {\n          if (item.type === mimeTypes.TEXT_PLAIN) {\n            item.getAsString(function (str) {\n              filesArgument.push(new Blob([str], {\n                type: mimeTypes.TEXT_PLAIN\n              }));\n              contentCount++;\n            });\n          } else if (scout.isOneOf(item.type, [mimeTypes.IMAGE_PNG, mimeTypes.IMAGE_JPG, mimeTypes.IMAGE_JPEG, mimeTypes.IMAGE_GIF])) {\n            var file = item.getAsFile();\n\n            if (file) {\n              // When pasting an image from the clipboard, Chrome and Firefox create a File object with\n              // a generic name such as \"image.png\" or \"grafik.png\" (hardcoded in Chrome, locale-dependent\n              // in FF). It is therefore not possible to distinguish between a real file and a bitmap\n              // from the clipboard. The following code measures the time between the start of the paste\n              // event and the file's last modified timestamp. If it is \"very small\", the file is likely\n              // a bitmap from the clipboard and not a real file. In that case, add a special \"scoutName\"\n              // attribute to the file object that is then used as a filename in session.uploadFiles().\n              var lastModifiedDiff = startPasteTimestamp - file.lastModified;\n\n              if (lastModifiedDiff < 1000) {\n                file.scoutName = Session.EMPTY_UPLOAD_FILENAME;\n              }\n\n              filesArgument.push(file);\n              contentCount++;\n            }\n          }\n        });\n\n        this._cleanupFiles(filesArgument);\n      }\n\n      var waitForFileReaderEvents = 0;\n\n      if (contentCount === 0 && dataTransfer.files) {\n        Array.prototype.forEach.call(dataTransfer.files, function (item) {\n          var reader = new FileReader(); // register functions for file reader\n\n          reader.onload = function (event) {\n            var f = new Blob([event.target.result], {\n              type: item.type\n            });\n            f.name = item.name;\n            filesArgument.push(f);\n            waitForFileReaderEvents--;\n          };\n\n          reader.onerror = function (event) {\n            waitForFileReaderEvents--;\n            $.log.error('Error while reading file ' + item.name + ' / ' + event.target.error.code);\n          }; // start file reader\n\n\n          waitForFileReaderEvents++;\n          contentCount++;\n          reader.readAsArrayBuffer(item);\n        });\n      } // upload function needs to be called asynchronously to support real files\n\n\n      var uploadFunctionTimeoutCount = 0;\n\n      var uploadFunction = function () {\n        if (waitForFileReaderEvents !== 0 && uploadFunctionTimeoutCount++ !== this._fileUploadWaitRetryCountTimeout) {\n          setTimeout(uploadFunction, 150);\n          return;\n        }\n\n        if (uploadFunctionTimeoutCount >= this._fileUploadWaitRetryCountTimeout) {\n          var boxOptions = {\n            entryPoint: this.$container.entryPoint(),\n            header: this.session.text('ui.ClipboardTimeoutTitle'),\n            body: this.session.text('ui.ClipboardTimeout'),\n            yesButtonText: this.session.text('Ok')\n          };\n          this.session.showFatalMessage(boxOptions);\n          return;\n        } // upload paste event as files\n\n\n        if (filesArgument.length > 0 || Object.keys(additionalOptions).length > 0) {\n          this.session.uploadFiles(this, filesArgument, additionalOptions, this.maximumSize, this.allowedMimeTypes);\n        }\n      }.bind(this); // upload content function, if content can not be read from event\n      // (e.g. \"Allow programmatic clipboard access\" is disabled in IE)\n\n\n      var uploadContentFunction = function () {\n        // store old inner html (will be replaced)\n        this._uninstallScrollbars();\n\n        var oldHtmlContent = this.$field.html();\n        this.$field.html('');\n\n        var restoreOldHtmlContent = function () {\n          this.$field.html(oldHtmlContent);\n\n          this._installScrollbars();\n        }.bind(this);\n\n        setTimeout(function () {\n          var imgElementsFound = false;\n          this.$field.children().each(function (idx, elem) {\n            if (elem.nodeName === 'IMG') {\n              var srcAttr = $(elem).attr('src');\n              var srcDataMatch = /^data:(.*);base64,(.*)/.exec(srcAttr);\n              var mimeType = srcDataMatch && srcDataMatch[1];\n\n              if (scout.isOneOf(mimeType, mimeTypes.IMAGE_PNG, mimeTypes.IMAGE_JPG, mimeTypes.IMAGE_JPEG, mimeTypes.IMAGE_GIF)) {\n                var encData = window.atob(srcDataMatch[2]); // base64 decode\n\n                var byteNumbers = [];\n\n                for (var i = 0; i < encData.length; i++) {\n                  byteNumbers[i] = encData.charCodeAt(i);\n                }\n\n                var byteArray = new Uint8Array(byteNumbers);\n                var f = new Blob([byteArray], {\n                  type: mimeType\n                });\n                f.name = '';\n                filesArgument.push(f);\n                imgElementsFound = true;\n              }\n            }\n          });\n\n          if (imgElementsFound) {\n            restoreOldHtmlContent();\n          } else {\n            // try to read nativly pasted text from field\n            var nativePasteContent = this.$field.text();\n\n            if (strings.hasText(nativePasteContent)) {\n              this.setDisplayText(nativePasteContent);\n              filesArgument.push(new Blob([nativePasteContent], {\n                type: mimeTypes.TEXT_PLAIN\n              }));\n            } else {\n              restoreOldHtmlContent();\n            }\n          }\n\n          uploadFunction();\n        }.bind(this), 0);\n      }.bind(this);\n\n      if (contentCount > 0) {\n        uploadFunction(); // do not trigger any other actions\n\n        return false;\n      }\n\n      uploadContentFunction(); // trigger other actions to catch content\n\n      return true;\n    }\n    /**\n     * Safari creates two files when pasting an image from clipboard, one PNG and one JPEG.\n     * If that happens, remove the JPEG and only keep the PNG.\n     */\n\n  }, {\n    key: \"_cleanupFiles\",\n    value: function _cleanupFiles(files) {\n      if (files.length !== 2) {\n        return;\n      }\n\n      var pngImage;\n      var jpgImage;\n      files.forEach(function (file) {\n        // Check for the scoutName because it will only be set if it is likely a paste from clipboard event\n        if (file.name === 'image.png' && file.scoutName) {\n          pngImage = file;\n        } else if (file.name === 'image.jpeg' && file.scoutName) {\n          jpgImage = file;\n        }\n      });\n\n      if (pngImage && jpgImage) {\n        arrays.remove(files, jpgImage);\n      }\n    }\n  }]);\n\n  return ClipboardField;\n}(ValueField);\n\n_defineProperty(ClipboardField, \"NON_DESTRUCTIVE_KEYS\", [// Default form handling\nkeys.ESC, keys.ENTER, keys.TAB, // Navigate and mark text\nkeys.PAGE_UP, keys.PAGE_DOWN, keys.END, keys.HOME, keys.LEFT, keys.UP, keys.RIGHT, keys.DOWN, // Browser hotkeys (e.g. developer tools)\nkeys.F1, keys.F2, keys.F3, keys.F4, keys.F5, keys.F6, keys.F7, keys.F8, keys.F9, keys.F10, keys.F11, keys.F12]);\n\n_defineProperty(ClipboardField, \"ALWAYS_DESTRUCTIVE_KEYS\", [keys.BACKSPACE, keys.DELETE]);\n\nexport { ClipboardField as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/form/fields/clipboardfield/ClipboardField.js"],"names":["arrays","Device","dragAndDrop","InputFieldKeyStrokeContext","keys","mimeTypes","scout","Session","strings","ValueField","$","ClipboardField","dropType","dropMaximumSize","DEFAULT_DROP_MAXIMUM_SIZE","_fileUploadWaitRetryCountTimeout","_fullSelectionLength","addContainer","$parent","addLabel","addField","makeElement","addClass","addStatus","$field","disableSpellcheck","attr","on","_onKeyDown","bind","_onInput","_onPaste","_onCopy","_renderDropType","handler","supportedScoutTypes","SCOUT_TYPES","FILE_TRANSFER","maximumSize","allowedTypes","allowedMimeTypes","displayText","img","children","each","idx","elem","nodeName","hasText","html","nl2br","_installScrollbars","setTimeout","selectAllText","selection","_getSelection","toString","length","empty","prepend","myWindow","$container","window","getSelection","document","event","isOneOf","which","ALWAYS_DESTRUCTIVE_KEYS","ctrlKey","altKey","metaKey","NON_DESTRUCTIVE_KEYS","_renderDisplayText","get","isIos","_onIosCopy","text","dataTransfer","originalEvent","clipboardData","e","log","error","_uninstallScrollbars","setData","oldStyle","css","attrOrRemove","readOnly","startPasteTimestamp","Date","now","Error","filesArgument","additionalOptions","additionalOptionsCompatibilityIndex","contentCount","textContent","getData","Blob","push","type","TEXT_PLAIN","items","Array","prototype","forEach","call","item","getAsString","str","IMAGE_PNG","IMAGE_JPG","IMAGE_JPEG","IMAGE_GIF","file","getAsFile","lastModifiedDiff","lastModified","scoutName","EMPTY_UPLOAD_FILENAME","_cleanupFiles","waitForFileReaderEvents","files","reader","FileReader","onload","f","target","result","name","onerror","code","readAsArrayBuffer","uploadFunctionTimeoutCount","uploadFunction","boxOptions","entryPoint","header","session","body","yesButtonText","showFatalMessage","Object","uploadFiles","uploadContentFunction","oldHtmlContent","restoreOldHtmlContent","imgElementsFound","srcAttr","srcDataMatch","exec","mimeType","encData","atob","byteNumbers","i","charCodeAt","byteArray","Uint8Array","nativePasteContent","setDisplayText","pngImage","jpgImage","remove","ESC","ENTER","TAB","PAGE_UP","PAGE_DOWN","END","HOME","LEFT","UP","RIGHT","DOWN","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","BACKSPACE","DELETE"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,MAAR,EAAgBC,MAAhB,EAAwBC,WAAxB,EAAqCC,0BAArC,EAAiEC,IAAjE,EAAuEC,SAAvE,EAAkFC,KAAlF,EAAyFC,OAAzF,EAAkGC,OAAlG,EAA2GC,UAA3G,QAA4H,gBAA5H;AACA,OAAOC,CAAP,MAAc,QAAd;;IAEqBC,c;;;;;AAEnB,4BAAc;AAAA;;AAAA;;AACZ;AAEA,UAAKC,QAAL,GAAgB,CAAhB;AACA,UAAKC,eAAL,GAAuBX,WAAW,CAACY,yBAAnC;AACA,UAAKC,gCAAL,GAAwC,EAAxC;AACA,UAAKC,oBAAL,GAA4B,CAA5B;AANY;AAOb,G,CAED;;;;;;AAoCA;AACF;AACA;8CAC4B;AACxB,aAAO,IAAIb,0BAAJ,EAAP;AACD;;;8BAES;AACR;AACA;AACA;AACA,WAAKc,YAAL,CAAkB,KAAKC,OAAvB,EAAgC,iBAAhC;AACA,WAAKC,QAAL;AACA,WAAKC,QAAL,CAAc,KAAKF,OAAL,CAAaG,WAAb,CAAyB,OAAzB,EAAkCC,QAAlC,CAA2C,aAA3C,CAAd;AACA,WAAKC,SAAL;AAEA,WAAKC,MAAL,CACGC,iBADH,GAEGC,IAFH,CAEQ,iBAFR,EAE2B,IAF3B,EAGGA,IAHH,CAGQ,UAHR,EAGoB,GAHpB,EAIGC,EAJH,CAIM,SAJN,EAIiB,KAAKC,UAAL,CAAgBC,IAAhB,CAAqB,IAArB,CAJjB,EAKGF,EALH,CAKM,OALN,EAKe,KAAKG,QAAL,CAAcD,IAAd,CAAmB,IAAnB,CALf,EAMGF,EANH,CAMM,OANN,EAMe,KAAKI,QAAL,CAAcF,IAAd,CAAmB,IAAnB,CANf,EAOGF,EAPH,CAOM,MAPN,EAOc,KAAKK,OAAL,CAAaH,IAAb,CAAkB,IAAlB,CAPd,EAQGF,EARH,CAQM,KARN,EAQa,KAAKK,OAAL,CAAaH,IAAb,CAAkB,IAAlB,CARb;AASD;;;wCAEmB;AAClB;;AACA,WAAKI,eAAL;AACD;;;gDAE2B;AAC1B,aAAO/B,WAAW,CAACgC,OAAZ,CAAoB,IAApB,EAA0B;AAC/BC,QAAAA,mBAAmB,EAAEjC,WAAW,CAACkC,WAAZ,CAAwBC,aADd;AAE/BzB,QAAAA,QAAQ,EAAE,YAAW;AACnB,iBAAO,KAAKA,QAAZ;AACD,SAFS,CAERiB,IAFQ,CAEH,IAFG,CAFqB;AAK/BhB,QAAAA,eAAe,EAAE,YAAW;AAC1B,iBAAO,KAAKyB,WAAZ;AACD,SAFgB,CAEfT,IAFe,CAEV,IAFU,CALc;AAQ/BU,QAAAA,YAAY,EAAE,YAAW;AACvB,iBAAO,KAAKC,gBAAZ;AACD,SAFa,CAEZX,IAFY,CAEP,IAFO;AARiB,OAA1B,CAAP;AAYD;;;yCAEoB;AACnB,UAAIY,WAAW,GAAG,KAAKA,WAAvB;AACA,UAAIC,GAAJ;AACA,WAAKlB,MAAL,CAAYmB,QAAZ,GAAuBC,IAAvB,CAA4B,UAASC,GAAT,EAAcC,IAAd,EAAoB;AAC9C,YAAI,CAACJ,GAAD,IAAQI,IAAI,CAACC,QAAL,KAAkB,KAA9B,EAAqC;AACnCL,UAAAA,GAAG,GAAGI,IAAN;AACD;AACF,OAJD;;AAMA,UAAItC,OAAO,CAACwC,OAAR,CAAgBP,WAAhB,CAAJ,EAAkC;AAChC,aAAKjB,MAAL,CAAYyB,IAAZ,CAAiBzC,OAAO,CAAC0C,KAAR,CAAcT,WAAd,EAA2B,IAA3B,CAAjB;;AACA,aAAKU,kBAAL;;AAEAC,QAAAA,UAAU,CAAC,YAAW;AACpB,eAAK5B,MAAL,CAAY6B,aAAZ,GADoB,CAEpB;;AACA,cAAIC,SAAS,GAAG,KAAKC,aAAL,EAAhB;;AACA,eAAKvC,oBAAL,GAA6BsC,SAAD,GAAcA,SAAS,CAACE,QAAV,GAAqBC,MAAnC,GAA4C,CAAxE;AACD,SALU,CAKT5B,IALS,CAKJ,IALI,CAAD,CAAV;AAMD,OAVD,MAUO;AACL,aAAKL,MAAL,CAAYkC,KAAZ;AACD,OArBkB,CAsBnB;;;AACA,UAAIhB,GAAJ,EAAS;AACP,aAAKlB,MAAL,CAAYmC,OAAZ,CAAoBjB,GAApB;AACD;AACF,K,CAED;AACA;AACA;AACA;AACA;AACA;AACA;;;;uCACmB;AACjB,aAAO,KAAKD,WAAZ;AACD;;;oCAEe;AACd,UAAIa,SAAJ;AAAA,UAAeM,QAAQ,GAAG,KAAKC,UAAL,CAAgBC,MAAhB,CAAuB,IAAvB,CAA1B;;AACA,UAAIF,QAAQ,CAACG,YAAb,EAA2B;AACzBT,QAAAA,SAAS,GAAGM,QAAQ,CAACG,YAAT,EAAZ;AACD,OAFD,MAEO,IAAIC,QAAQ,CAACD,YAAb,EAA2B;AAChCT,QAAAA,SAAS,GAAGU,QAAQ,CAACD,YAAT,EAAZ;AACD;;AACD,UAAI,CAACT,SAAD,IAAcA,SAAS,CAACE,QAAV,GAAqBC,MAArB,KAAgC,CAAlD,EAAqD;AACnD,eAAO,IAAP;AACD;;AACD,aAAOH,SAAP;AACD;;;+BAEUW,K,EAAO;AAChB,UAAI3D,KAAK,CAAC4D,OAAN,CAAcD,KAAK,CAACE,KAApB,EAA2BxD,cAAc,CAACyD,uBAA1C,CAAJ,EAAwE;AACtE,eAAO,KAAP,CADsE,CACxD;AACf;;AACD,UAAIH,KAAK,CAACI,OAAN,IAAiBJ,KAAK,CAACK,MAAvB,IAAiCL,KAAK,CAACM,OAAvC,IAAkDjE,KAAK,CAAC4D,OAAN,CAAcD,KAAK,CAACE,KAApB,EAA2BxD,cAAc,CAAC6D,oBAA1C,CAAtD,EAAuH;AACrH,eADqH,CAC7G;AACT,OANe,CAOhB;;;AACA,aAAO,KAAP;AACD;;;6BAEQP,K,EAAO;AACd;AACA,WAAKQ,kBAAL;;AACA,aAAO,KAAP;AACD;;;4BAEOR,K,EAAO;AACb,UAAIhE,MAAM,CAACyE,GAAP,GAAaC,KAAb,MAAwB,KAAKC,UAAL,CAAgBX,KAAhB,MAA2B,KAAvD,EAA8D;AAC5D;AACD;;AAED,UAAIX,SAAJ;AAAA,UAAeuB,IAAf;AAAA,UAAqBC,YAArB;AAAA,UAAmClB,QAAQ,GAAG,KAAKC,UAAL,CAAgBC,MAAhB,CAAuB,IAAvB,CAA9C;;AACA,UAAI;AACF,YAAIG,KAAK,CAACc,aAAN,CAAoBC,aAAxB,EAAuC;AACrCF,UAAAA,YAAY,GAAGb,KAAK,CAACc,aAAN,CAAoBC,aAAnC;AACD,SAFD,MAEO,IAAIpB,QAAQ,CAACoB,aAAb,EAA4B;AACjCF,UAAAA,YAAY,GAAGlB,QAAQ,CAACoB,aAAxB;AACD;AACF,OAND,CAME,OAAOC,CAAP,EAAU;AACV;AACA;AACA;AACAvE,QAAAA,CAAC,CAACwE,GAAF,CAAMC,KAAN,CAAY,qCAAZ,EAAmDF,CAAnD;AACD;;AACD,UAAI,CAACH,YAAL,EAAmB;AACjBpE,QAAAA,CAAC,CAACwE,GAAF,CAAMC,KAAN,CAAY,kCAAZ;AACA,eAAO,KAAP;AACD,OArBY,CAuBb;;;AACA,WAAKC,oBAAL;;AAEA9B,MAAAA,SAAS,GAAG,KAAKC,aAAL,EAAZ;;AACA,UAAI,CAACD,SAAL,EAAgB;AACd;AACD,OA7BY,CA+Bb;AACA;AACA;;;AACA,UAAIA,SAAS,CAACE,QAAV,GAAqBC,MAArB,KAAgC,KAAKzC,oBAAzC,EAA+D;AAC7D6D,QAAAA,IAAI,GAAG,KAAKpC,WAAZ;AACD,OAFD,MAEO;AACLoC,QAAAA,IAAI,GAAGvB,SAAS,CAACE,QAAV,EAAP;AACD;;AAED,UAAI;AACF;AACAsB,QAAAA,YAAY,CAACO,OAAb,CAAqB,YAArB,EAAmCR,IAAnC;AACD,OAHD,CAGE,OAAOI,CAAP,EAAU;AACV;AACAH,QAAAA,YAAY,CAACO,OAAb,CAAqB,MAArB,EAA6BR,IAA7B;AACD,OA9CY,CAgDb;;;AACA,WAAK1B,kBAAL;;AAEA,aAAO,KAAP;AACD;;;+BAEUc,K,EAAO;AAChB;AACA;AACA;AACA,UAAIqB,QAAQ,GAAG,KAAK9D,MAAL,CAAYE,IAAZ,CAAiB,OAAjB,CAAf;AACA,WAAKF,MAAL,CAAY+D,GAAZ,CAAgB;AACd,iBAAS,MADK;AAEd,4BAAoB;AAFN,OAAhB;AAIAnC,MAAAA,UAAU,CAAC,YAAW;AACpB,aAAK5B,MAAL,CAAYgE,YAAZ,CAAyB,OAAzB,EAAkCF,QAAlC;AACD,OAFU,CAETzD,IAFS,CAEJ,IAFI,CAAD,CAAV;AAGA,aAAO,KAAP;AACD;;;6BAEQoC,K,EAAO;AACd,UAAI,KAAKwB,QAAT,EAAmB;AACjB;AACA,eAAO,KAAP;AACD;;AAED,UAAIC,mBAAmB,GAAGC,IAAI,CAACC,GAAL,EAA1B;AACA,UAAId,YAAJ;AAAA,UAAkBlB,QAAQ,GAAG,KAAKC,UAAL,CAAgBC,MAAhB,CAAuB,IAAvB,CAA7B;AACA,WAAKtC,MAAL,CAAY6B,aAAZ;;AACA,UAAIY,KAAK,CAACc,aAAN,CAAoBC,aAAxB,EAAuC;AACrCF,QAAAA,YAAY,GAAGb,KAAK,CAACc,aAAN,CAAoBC,aAAnC;AACD,OAFD,MAEO,IAAIpB,QAAQ,CAACoB,aAAb,EAA4B;AACjCF,QAAAA,YAAY,GAAGlB,QAAQ,CAACoB,aAAxB;AACD,OAFM,MAEA;AACL;AACA,cAAM,IAAIa,KAAJ,CAAU,kCAAV,CAAN;AACD;;AAED,UAAIC,aAAa,GAAG,EAApB;AAAA,UAAwB;AACtBC,MAAAA,iBAAiB,GAAG,EADtB;AAAA,UAEEC,mCAAmC,GAAG,CAFxC;AAAA,UAE2C;AACzCC,MAAAA,YAAY,GAAG,CAHjB,CAlBc,CAuBd;;AACA,UAAIC,WAAW,GAAGpB,YAAY,CAACqB,OAAb,CAAqB,MAArB,CAAlB;;AACA,UAAID,WAAJ,EAAiB;AACf,YAAIpC,MAAM,CAACsC,IAAX,EAAiB;AACfN,UAAAA,aAAa,CAACO,IAAd,CAAmB,IAAID,IAAJ,CAAS,CAACF,WAAD,CAAT,EAAwB;AACzCI,YAAAA,IAAI,EAAEjG,SAAS,CAACkG;AADyB,WAAxB,CAAnB;AAGAN,UAAAA,YAAY;AACb,SALD,MAKO;AACL;AACAF,UAAAA,iBAAiB,CAAC,uBAAuBC,mCAAmC,EAA3D,CAAjB,GAAkFE,WAAlF;AACAD,UAAAA,YAAY;AACb;AACF;;AAED,UAAIA,YAAY,KAAK,CAAjB,IAAsBnB,YAAY,CAAC0B,KAAvC,EAA8C;AAC5CC,QAAAA,KAAK,CAACC,SAAN,CAAgBC,OAAhB,CAAwBC,IAAxB,CAA6B9B,YAAY,CAAC0B,KAA1C,EAAiD,UAASK,IAAT,EAAe;AAC9D,cAAIA,IAAI,CAACP,IAAL,KAAcjG,SAAS,CAACkG,UAA5B,EAAwC;AACtCM,YAAAA,IAAI,CAACC,WAAL,CAAiB,UAASC,GAAT,EAAc;AAC7BjB,cAAAA,aAAa,CAACO,IAAd,CAAmB,IAAID,IAAJ,CAAS,CAACW,GAAD,CAAT,EAAgB;AACjCT,gBAAAA,IAAI,EAAEjG,SAAS,CAACkG;AADiB,eAAhB,CAAnB;AAGAN,cAAAA,YAAY;AACb,aALD;AAMD,WAPD,MAOO,IAAI3F,KAAK,CAAC4D,OAAN,CAAc2C,IAAI,CAACP,IAAnB,EAAyB,CAACjG,SAAS,CAAC2G,SAAX,EAAsB3G,SAAS,CAAC4G,SAAhC,EAA2C5G,SAAS,CAAC6G,UAArD,EAAiE7G,SAAS,CAAC8G,SAA3E,CAAzB,CAAJ,EAAqH;AAC1H,gBAAIC,IAAI,GAAGP,IAAI,CAACQ,SAAL,EAAX;;AACA,gBAAID,IAAJ,EAAU;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAIE,gBAAgB,GAAG5B,mBAAmB,GAAG0B,IAAI,CAACG,YAAlD;;AACA,kBAAID,gBAAgB,GAAG,IAAvB,EAA6B;AAC3BF,gBAAAA,IAAI,CAACI,SAAL,GAAiBjH,OAAO,CAACkH,qBAAzB;AACD;;AACD3B,cAAAA,aAAa,CAACO,IAAd,CAAmBe,IAAnB;AACAnB,cAAAA,YAAY;AACb;AACF;AACF,SA1BD;;AA2BA,aAAKyB,aAAL,CAAmB5B,aAAnB;AACD;;AAED,UAAI6B,uBAAuB,GAAG,CAA9B;;AACA,UAAI1B,YAAY,KAAK,CAAjB,IAAsBnB,YAAY,CAAC8C,KAAvC,EAA8C;AAC5CnB,QAAAA,KAAK,CAACC,SAAN,CAAgBC,OAAhB,CAAwBC,IAAxB,CAA6B9B,YAAY,CAAC8C,KAA1C,EAAiD,UAASf,IAAT,EAAe;AAC9D,cAAIgB,MAAM,GAAG,IAAIC,UAAJ,EAAb,CAD8D,CAE9D;;AACAD,UAAAA,MAAM,CAACE,MAAP,GAAgB,UAAS9D,KAAT,EAAgB;AAC9B,gBAAI+D,CAAC,GAAG,IAAI5B,IAAJ,CAAS,CAACnC,KAAK,CAACgE,MAAN,CAAaC,MAAd,CAAT,EAAgC;AACtC5B,cAAAA,IAAI,EAAEO,IAAI,CAACP;AAD2B,aAAhC,CAAR;AAGA0B,YAAAA,CAAC,CAACG,IAAF,GAAStB,IAAI,CAACsB,IAAd;AACArC,YAAAA,aAAa,CAACO,IAAd,CAAmB2B,CAAnB;AACAL,YAAAA,uBAAuB;AACxB,WAPD;;AAQAE,UAAAA,MAAM,CAACO,OAAP,GAAiB,UAASnE,KAAT,EAAgB;AAC/B0D,YAAAA,uBAAuB;AACvBjH,YAAAA,CAAC,CAACwE,GAAF,CAAMC,KAAN,CAAY,8BAA8B0B,IAAI,CAACsB,IAAnC,GAA0C,KAA1C,GAAkDlE,KAAK,CAACgE,MAAN,CAAa9C,KAAb,CAAmBkD,IAAjF;AACD,WAHD,CAX8D,CAe9D;;;AACAV,UAAAA,uBAAuB;AACvB1B,UAAAA,YAAY;AACZ4B,UAAAA,MAAM,CAACS,iBAAP,CAAyBzB,IAAzB;AACD,SAnBD;AAoBD,OA3Fa,CA6Fd;;;AACA,UAAI0B,0BAA0B,GAAG,CAAjC;;AACA,UAAIC,cAAc,GAAG,YAAW;AAC9B,YAAIb,uBAAuB,KAAK,CAA5B,IAAiCY,0BAA0B,OAAO,KAAKxH,gCAA3E,EAA6G;AAC3GqC,UAAAA,UAAU,CAACoF,cAAD,EAAiB,GAAjB,CAAV;AACA;AACD;;AAED,YAAID,0BAA0B,IAAI,KAAKxH,gCAAvC,EAAyE;AACvE,cAAI0H,UAAU,GAAG;AACfC,YAAAA,UAAU,EAAE,KAAK7E,UAAL,CAAgB6E,UAAhB,EADG;AAEfC,YAAAA,MAAM,EAAE,KAAKC,OAAL,CAAa/D,IAAb,CAAkB,0BAAlB,CAFO;AAGfgE,YAAAA,IAAI,EAAE,KAAKD,OAAL,CAAa/D,IAAb,CAAkB,qBAAlB,CAHS;AAIfiE,YAAAA,aAAa,EAAE,KAAKF,OAAL,CAAa/D,IAAb,CAAkB,IAAlB;AAJA,WAAjB;AAOA,eAAK+D,OAAL,CAAaG,gBAAb,CAA8BN,UAA9B;AACA;AACD,SAhB6B,CAkB9B;;;AACA,YAAI3C,aAAa,CAACrC,MAAd,GAAuB,CAAvB,IAA4BuF,MAAM,CAAC5I,IAAP,CAAY2F,iBAAZ,EAA+BtC,MAA/B,GAAwC,CAAxE,EAA2E;AACzE,eAAKmF,OAAL,CAAaK,WAAb,CAAyB,IAAzB,EAA+BnD,aAA/B,EAA8CC,iBAA9C,EAAiE,KAAKzD,WAAtE,EAAmF,KAAKE,gBAAxF;AACD;AACF,OAtBoB,CAsBnBX,IAtBmB,CAsBd,IAtBc,CAArB,CA/Fc,CAuHd;AACA;;;AACA,UAAIqH,qBAAqB,GAAG,YAAW;AACrC;AACA,aAAK9D,oBAAL;;AACA,YAAI+D,cAAc,GAAG,KAAK3H,MAAL,CAAYyB,IAAZ,EAArB;AACA,aAAKzB,MAAL,CAAYyB,IAAZ,CAAiB,EAAjB;;AACA,YAAImG,qBAAqB,GAAG,YAAW;AACrC,eAAK5H,MAAL,CAAYyB,IAAZ,CAAiBkG,cAAjB;;AACA,eAAKhG,kBAAL;AACD,SAH2B,CAG1BtB,IAH0B,CAGrB,IAHqB,CAA5B;;AAIAuB,QAAAA,UAAU,CAAC,YAAW;AACpB,cAAIiG,gBAAgB,GAAG,KAAvB;AACA,eAAK7H,MAAL,CAAYmB,QAAZ,GAAuBC,IAAvB,CAA4B,UAASC,GAAT,EAAcC,IAAd,EAAoB;AAC9C,gBAAIA,IAAI,CAACC,QAAL,KAAkB,KAAtB,EAA6B;AAC3B,kBAAIuG,OAAO,GAAG5I,CAAC,CAACoC,IAAD,CAAD,CAAQpB,IAAR,CAAa,KAAb,CAAd;AACA,kBAAI6H,YAAY,GAAG,yBAAyBC,IAAzB,CAA8BF,OAA9B,CAAnB;AACA,kBAAIG,QAAQ,GAAGF,YAAY,IAAIA,YAAY,CAAC,CAAD,CAA3C;;AACA,kBAAIjJ,KAAK,CAAC4D,OAAN,CAAcuF,QAAd,EAAwBpJ,SAAS,CAAC2G,SAAlC,EAA6C3G,SAAS,CAAC4G,SAAvD,EAAkE5G,SAAS,CAAC6G,UAA5E,EAAwF7G,SAAS,CAAC8G,SAAlG,CAAJ,EAAkH;AAChH,oBAAIuC,OAAO,GAAG5F,MAAM,CAAC6F,IAAP,CAAYJ,YAAY,CAAC,CAAD,CAAxB,CAAd,CADgH,CACpE;;AAC5C,oBAAIK,WAAW,GAAG,EAAlB;;AACA,qBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAAO,CAACjG,MAA5B,EAAoCoG,CAAC,EAArC,EAAyC;AACvCD,kBAAAA,WAAW,CAACC,CAAD,CAAX,GAAiBH,OAAO,CAACI,UAAR,CAAmBD,CAAnB,CAAjB;AACD;;AACD,oBAAIE,SAAS,GAAG,IAAIC,UAAJ,CAAeJ,WAAf,CAAhB;AACA,oBAAI5B,CAAC,GAAG,IAAI5B,IAAJ,CAAS,CAAC2D,SAAD,CAAT,EAAsB;AAC5BzD,kBAAAA,IAAI,EAAEmD;AADsB,iBAAtB,CAAR;AAGAzB,gBAAAA,CAAC,CAACG,IAAF,GAAS,EAAT;AACArC,gBAAAA,aAAa,CAACO,IAAd,CAAmB2B,CAAnB;AACAqB,gBAAAA,gBAAgB,GAAG,IAAnB;AACD;AACF;AACF,WApBD;;AAqBA,cAAIA,gBAAJ,EAAsB;AACpBD,YAAAA,qBAAqB;AACtB,WAFD,MAEO;AACL;AACA,gBAAIa,kBAAkB,GAAG,KAAKzI,MAAL,CAAYqD,IAAZ,EAAzB;;AACA,gBAAIrE,OAAO,CAACwC,OAAR,CAAgBiH,kBAAhB,CAAJ,EAAyC;AACvC,mBAAKC,cAAL,CAAoBD,kBAApB;AACAnE,cAAAA,aAAa,CAACO,IAAd,CAAmB,IAAID,IAAJ,CAAS,CAAC6D,kBAAD,CAAT,EAA+B;AAChD3D,gBAAAA,IAAI,EAAEjG,SAAS,CAACkG;AADgC,eAA/B,CAAnB;AAGD,aALD,MAKO;AACL6C,cAAAA,qBAAqB;AACtB;AACF;;AACDZ,UAAAA,cAAc;AACf,SAtCU,CAsCT3G,IAtCS,CAsCJ,IAtCI,CAAD,EAsCI,CAtCJ,CAAV;AAuCD,OAhD2B,CAgD1BA,IAhD0B,CAgDrB,IAhDqB,CAA5B;;AAkDA,UAAIoE,YAAY,GAAG,CAAnB,EAAsB;AACpBuC,QAAAA,cAAc,GADM,CAGpB;;AACA,eAAO,KAAP;AACD;;AACDU,MAAAA,qBAAqB,GAjLP,CAmLd;;AACA,aAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;;;kCACgBtB,K,EAAO;AACnB,UAAIA,KAAK,CAACnE,MAAN,KAAiB,CAArB,EAAwB;AACtB;AACD;;AACD,UAAI0G,QAAJ;AACA,UAAIC,QAAJ;AACAxC,MAAAA,KAAK,CAACjB,OAAN,CAAc,UAASS,IAAT,EAAe;AAC3B;AACA,YAAIA,IAAI,CAACe,IAAL,KAAc,WAAd,IAA6Bf,IAAI,CAACI,SAAtC,EAAiD;AAC/C2C,UAAAA,QAAQ,GAAG/C,IAAX;AACD,SAFD,MAEO,IAAIA,IAAI,CAACe,IAAL,KAAc,YAAd,IAA8Bf,IAAI,CAACI,SAAvC,EAAkD;AACvD4C,UAAAA,QAAQ,GAAGhD,IAAX;AACD;AACF,OAPD;;AAQA,UAAI+C,QAAQ,IAAIC,QAAhB,EAA0B;AACxBpK,QAAAA,MAAM,CAACqK,MAAP,CAAczC,KAAd,EAAqBwC,QAArB;AACD;AACF;;;;EApbyC3J,U;;gBAAvBE,c,0BAYW,CAC5B;AACAP,IAAI,CAACkK,GAFuB,EAG5BlK,IAAI,CAACmK,KAHuB,EAI5BnK,IAAI,CAACoK,GAJuB,EAK5B;AACApK,IAAI,CAACqK,OANuB,EAO5BrK,IAAI,CAACsK,SAPuB,EAQ5BtK,IAAI,CAACuK,GARuB,EAS5BvK,IAAI,CAACwK,IATuB,EAU5BxK,IAAI,CAACyK,IAVuB,EAW5BzK,IAAI,CAAC0K,EAXuB,EAY5B1K,IAAI,CAAC2K,KAZuB,EAa5B3K,IAAI,CAAC4K,IAbuB,EAc5B;AACA5K,IAAI,CAAC6K,EAfuB,EAgB5B7K,IAAI,CAAC8K,EAhBuB,EAiB5B9K,IAAI,CAAC+K,EAjBuB,EAkB5B/K,IAAI,CAACgL,EAlBuB,EAmB5BhL,IAAI,CAACiL,EAnBuB,EAoB5BjL,IAAI,CAACkL,EApBuB,EAqB5BlL,IAAI,CAACmL,EArBuB,EAsB5BnL,IAAI,CAACoL,EAtBuB,EAuB5BpL,IAAI,CAACqL,EAvBuB,EAwB5BrL,IAAI,CAACsL,GAxBuB,EAyB5BtL,IAAI,CAACuL,GAzBuB,EA0B5BvL,IAAI,CAACwL,GA1BuB,C;;gBAZXjL,c,6BA0Cc,CAC/BP,IAAI,CAACyL,SAD0B,EAE/BzL,IAAI,CAAC0L,MAF0B,C;;SA1CdnL,c","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Device, dragAndDrop, InputFieldKeyStrokeContext, keys, mimeTypes, scout, Session, strings, ValueField} from '../../../index';\nimport $ from 'jquery';\n\nexport default class ClipboardField extends ValueField {\n\n  constructor() {\n    super();\n\n    this.dropType = 0;\n    this.dropMaximumSize = dragAndDrop.DEFAULT_DROP_MAXIMUM_SIZE;\n    this._fileUploadWaitRetryCountTimeout = 99;\n    this._fullSelectionLength = 0;\n  }\n\n  // Keys that don't alter the content of a text field and are therefore always allowed in the clipboard field\n  static NON_DESTRUCTIVE_KEYS = [\n    // Default form handling\n    keys.ESC,\n    keys.ENTER,\n    keys.TAB,\n    // Navigate and mark text\n    keys.PAGE_UP,\n    keys.PAGE_DOWN,\n    keys.END,\n    keys.HOME,\n    keys.LEFT,\n    keys.UP,\n    keys.RIGHT,\n    keys.DOWN,\n    // Browser hotkeys (e.g. developer tools)\n    keys.F1,\n    keys.F2,\n    keys.F3,\n    keys.F4,\n    keys.F5,\n    keys.F6,\n    keys.F7,\n    keys.F8,\n    keys.F9,\n    keys.F10,\n    keys.F11,\n    keys.F12\n  ];\n\n  // Keys that always alter the content of a text field, independent from the modifier keys\n  static ALWAYS_DESTRUCTIVE_KEYS = [\n    keys.BACKSPACE,\n    keys.DELETE\n  ];\n\n  /**\n   * @override Widget.js\n   */\n  _createKeyStrokeContext() {\n    return new InputFieldKeyStrokeContext();\n  }\n\n  _render() {\n    // We don't use makeDiv() here intentionally because the DIV created must\n    // not have the 'unselectable' attribute. Otherwise clipboard-field will\n    // not work in IE9.\n    this.addContainer(this.$parent, 'clipboard-field');\n    this.addLabel();\n    this.addField(this.$parent.makeElement('<div>').addClass('input-field'));\n    this.addStatus();\n\n    this.$field\n      .disableSpellcheck()\n      .attr('contenteditable', true)\n      .attr('tabindex', '0')\n      .on('keydown', this._onKeyDown.bind(this))\n      .on('input', this._onInput.bind(this))\n      .on('paste', this._onPaste.bind(this))\n      .on('copy', this._onCopy.bind(this))\n      .on('cut', this._onCopy.bind(this));\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderDropType();\n  }\n\n  _createDragAndDropHandler() {\n    return dragAndDrop.handler(this, {\n      supportedScoutTypes: dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n      dropType: function() {\n        return this.dropType;\n      }.bind(this),\n      dropMaximumSize: function() {\n        return this.maximumSize;\n      }.bind(this),\n      allowedTypes: function() {\n        return this.allowedMimeTypes;\n      }.bind(this)\n    });\n  }\n\n  _renderDisplayText() {\n    var displayText = this.displayText;\n    var img;\n    this.$field.children().each(function(idx, elem) {\n      if (!img && elem.nodeName === 'IMG') {\n        img = elem;\n      }\n    });\n\n    if (strings.hasText(displayText)) {\n      this.$field.html(strings.nl2br(displayText, true));\n      this._installScrollbars();\n\n      setTimeout(function() {\n        this.$field.selectAllText();\n        // store length of full selection, in order to determine if the whole text is selected in \"onCopy\"\n        var selection = this._getSelection();\n        this._fullSelectionLength = (selection) ? selection.toString().length : 0;\n      }.bind(this));\n    } else {\n      this.$field.empty();\n    }\n    // restore old img for firefox upload mechanism.\n    if (img) {\n      this.$field.prepend(img);\n    }\n  }\n\n  // Because a <div> is used as field, jQuery's val() used in ValueField.js is not working here, so\n  // the content of displayText variable is used instead.\n  // (For reading the displayText innerHmtl() _could_ be used on the div-field, but some browsers\n  // would collapse whitespaces which would also collapse multiple tabs when coping some table rows.\n  // So instead of reading the effective displayText from the field, the internal displayText value\n  // will be reused without actual reading. Parsing of pasted content is handled onPaste() and stored\n  // in this.displayText.)\n  _readDisplayText() {\n    return this.displayText;\n  }\n\n  _getSelection() {\n    var selection, myWindow = this.$container.window(true);\n    if (myWindow.getSelection) {\n      selection = myWindow.getSelection();\n    } else if (document.getSelection) {\n      selection = document.getSelection();\n    }\n    if (!selection || selection.toString().length === 0) {\n      return null;\n    }\n    return selection;\n  }\n\n  _onKeyDown(event) {\n    if (scout.isOneOf(event.which, ClipboardField.ALWAYS_DESTRUCTIVE_KEYS)) {\n      return false; // never allowed\n    }\n    if (event.ctrlKey || event.altKey || event.metaKey || scout.isOneOf(event.which, ClipboardField.NON_DESTRUCTIVE_KEYS)) {\n      return; // allow bubble to other event handlers\n    }\n    // do not allow to enter something manually\n    return false;\n  }\n\n  _onInput(event) {\n    // if the user somehow managed to fire to input something (e.g. \"delete\" menu in FF & IE), just reset the value to the previous content\n    this._renderDisplayText();\n    return false;\n  }\n\n  _onCopy(event) {\n    if (Device.get().isIos() && this._onIosCopy(event) === false) {\n      return;\n    }\n\n    var selection, text, dataTransfer, myWindow = this.$container.window(true);\n    try {\n      if (event.originalEvent.clipboardData) {\n        dataTransfer = event.originalEvent.clipboardData;\n      } else if (myWindow.clipboardData) {\n        dataTransfer = myWindow.clipboardData;\n      }\n    } catch (e) {\n      // Because windows forbids concurrent access to the clipboard, a possible exception is thrown on 'myWindow.clipboardData'\n      // (see Remarks on https://msdn.microsoft.com/en-us/library/windows/desktop/ms649048(v=vs.85).aspx)\n      // Because of this behavior a failed access will just be logged but not presented to the user.\n      $.log.error('Error while reading \"clipboardData\"', e);\n    }\n    if (!dataTransfer) {\n      $.log.error('Unable to access clipboard data.');\n      return false;\n    }\n\n    // scroll bar must not be in field when copying\n    this._uninstallScrollbars();\n\n    selection = this._getSelection();\n    if (!selection) {\n      return;\n    }\n\n    // if the length of the selection is equals to the length of the (initial) full selection\n    // use the internal 'displayText' value because some browsers are collapsing white spaces\n    // which lead to problems when coping data form tables with empty cells (\"\\t\\t\").\n    if (selection.toString().length === this._fullSelectionLength) {\n      text = this.displayText;\n    } else {\n      text = selection.toString();\n    }\n\n    try {\n      // Chrome, Firefox - causes an exception in IE\n      dataTransfer.setData('text/plain', text);\n    } catch (e) {\n      // IE, see https://www.lucidchart.com/techblog/2014/12/02/definitive-guide-copying-pasting-javascript/\n      dataTransfer.setData('Text', text);\n    }\n\n    // (re)install scroll bars\n    this._installScrollbars();\n\n    return false;\n  }\n\n  _onIosCopy(event) {\n    // Setting custom clipboard data is not possible with iOS due to a WebKit bug.\n    // The default behavior copies rich text. Since it is not expected to copy the style of the clipboard field, temporarily set color and background-color\n    // https://bugs.webkit.org/show_bug.cgi?id=176980\n    var oldStyle = this.$field.attr('style');\n    this.$field.css({\n      'color': '#000',\n      'background-color': 'transparent'\n    });\n    setTimeout(function() {\n      this.$field.attrOrRemove('style', oldStyle);\n    }.bind(this));\n    return false;\n  }\n\n  _onPaste(event) {\n    if (this.readOnly) {\n      // Prevent pasting in \"copy\" mode\n      return false;\n    }\n\n    var startPasteTimestamp = Date.now();\n    var dataTransfer, myWindow = this.$container.window(true);\n    this.$field.selectAllText();\n    if (event.originalEvent.clipboardData) {\n      dataTransfer = event.originalEvent.clipboardData;\n    } else if (myWindow.clipboardData) {\n      dataTransfer = myWindow.clipboardData;\n    } else {\n      // unable to obtain data transfer object\n      throw new Error('Unable to access clipboard data.');\n    }\n\n    var filesArgument = [], // options to be uploaded, arguments for this.session.uploadFiles\n      additionalOptions = {},\n      additionalOptionsCompatibilityIndex = 0, // counter for additional options\n      contentCount = 0;\n\n    // some browsers (e.g. IE) specify text content simply as data of type 'Text', it is not listed in list of types\n    var textContent = dataTransfer.getData('Text');\n    if (textContent) {\n      if (window.Blob) {\n        filesArgument.push(new Blob([textContent], {\n          type: mimeTypes.TEXT_PLAIN\n        }));\n        contentCount++;\n      } else {\n        // compatibility workaround\n        additionalOptions['textTransferObject' + additionalOptionsCompatibilityIndex++] = textContent;\n        contentCount++;\n      }\n    }\n\n    if (contentCount === 0 && dataTransfer.items) {\n      Array.prototype.forEach.call(dataTransfer.items, function(item) {\n        if (item.type === mimeTypes.TEXT_PLAIN) {\n          item.getAsString(function(str) {\n            filesArgument.push(new Blob([str], {\n              type: mimeTypes.TEXT_PLAIN\n            }));\n            contentCount++;\n          });\n        } else if (scout.isOneOf(item.type, [mimeTypes.IMAGE_PNG, mimeTypes.IMAGE_JPG, mimeTypes.IMAGE_JPEG, mimeTypes.IMAGE_GIF])) {\n          var file = item.getAsFile();\n          if (file) {\n            // When pasting an image from the clipboard, Chrome and Firefox create a File object with\n            // a generic name such as \"image.png\" or \"grafik.png\" (hardcoded in Chrome, locale-dependent\n            // in FF). It is therefore not possible to distinguish between a real file and a bitmap\n            // from the clipboard. The following code measures the time between the start of the paste\n            // event and the file's last modified timestamp. If it is \"very small\", the file is likely\n            // a bitmap from the clipboard and not a real file. In that case, add a special \"scoutName\"\n            // attribute to the file object that is then used as a filename in session.uploadFiles().\n            var lastModifiedDiff = startPasteTimestamp - file.lastModified;\n            if (lastModifiedDiff < 1000) {\n              file.scoutName = Session.EMPTY_UPLOAD_FILENAME;\n            }\n            filesArgument.push(file);\n            contentCount++;\n          }\n        }\n      });\n      this._cleanupFiles(filesArgument);\n    }\n\n    var waitForFileReaderEvents = 0;\n    if (contentCount === 0 && dataTransfer.files) {\n      Array.prototype.forEach.call(dataTransfer.files, function(item) {\n        var reader = new FileReader();\n        // register functions for file reader\n        reader.onload = function(event) {\n          var f = new Blob([event.target.result], {\n            type: item.type\n          });\n          f.name = item.name;\n          filesArgument.push(f);\n          waitForFileReaderEvents--;\n        };\n        reader.onerror = function(event) {\n          waitForFileReaderEvents--;\n          $.log.error('Error while reading file ' + item.name + ' / ' + event.target.error.code);\n        };\n        // start file reader\n        waitForFileReaderEvents++;\n        contentCount++;\n        reader.readAsArrayBuffer(item);\n      });\n    }\n\n    // upload function needs to be called asynchronously to support real files\n    var uploadFunctionTimeoutCount = 0;\n    var uploadFunction = function() {\n      if (waitForFileReaderEvents !== 0 && uploadFunctionTimeoutCount++ !== this._fileUploadWaitRetryCountTimeout) {\n        setTimeout(uploadFunction, 150);\n        return;\n      }\n\n      if (uploadFunctionTimeoutCount >= this._fileUploadWaitRetryCountTimeout) {\n        var boxOptions = {\n          entryPoint: this.$container.entryPoint(),\n          header: this.session.text('ui.ClipboardTimeoutTitle'),\n          body: this.session.text('ui.ClipboardTimeout'),\n          yesButtonText: this.session.text('Ok')\n        };\n\n        this.session.showFatalMessage(boxOptions);\n        return;\n      }\n\n      // upload paste event as files\n      if (filesArgument.length > 0 || Object.keys(additionalOptions).length > 0) {\n        this.session.uploadFiles(this, filesArgument, additionalOptions, this.maximumSize, this.allowedMimeTypes);\n      }\n    }.bind(this);\n\n    // upload content function, if content can not be read from event\n    // (e.g. \"Allow programmatic clipboard access\" is disabled in IE)\n    var uploadContentFunction = function() {\n      // store old inner html (will be replaced)\n      this._uninstallScrollbars();\n      var oldHtmlContent = this.$field.html();\n      this.$field.html('');\n      var restoreOldHtmlContent = function() {\n        this.$field.html(oldHtmlContent);\n        this._installScrollbars();\n      }.bind(this);\n      setTimeout(function() {\n        var imgElementsFound = false;\n        this.$field.children().each(function(idx, elem) {\n          if (elem.nodeName === 'IMG') {\n            var srcAttr = $(elem).attr('src');\n            var srcDataMatch = /^data:(.*);base64,(.*)/.exec(srcAttr);\n            var mimeType = srcDataMatch && srcDataMatch[1];\n            if (scout.isOneOf(mimeType, mimeTypes.IMAGE_PNG, mimeTypes.IMAGE_JPG, mimeTypes.IMAGE_JPEG, mimeTypes.IMAGE_GIF)) {\n              var encData = window.atob(srcDataMatch[2]); // base64 decode\n              var byteNumbers = [];\n              for (var i = 0; i < encData.length; i++) {\n                byteNumbers[i] = encData.charCodeAt(i);\n              }\n              var byteArray = new Uint8Array(byteNumbers);\n              var f = new Blob([byteArray], {\n                type: mimeType\n              });\n              f.name = '';\n              filesArgument.push(f);\n              imgElementsFound = true;\n            }\n          }\n        });\n        if (imgElementsFound) {\n          restoreOldHtmlContent();\n        } else {\n          // try to read nativly pasted text from field\n          var nativePasteContent = this.$field.text();\n          if (strings.hasText(nativePasteContent)) {\n            this.setDisplayText(nativePasteContent);\n            filesArgument.push(new Blob([nativePasteContent], {\n              type: mimeTypes.TEXT_PLAIN\n            }));\n          } else {\n            restoreOldHtmlContent();\n          }\n        }\n        uploadFunction();\n      }.bind(this), 0);\n    }.bind(this);\n\n    if (contentCount > 0) {\n      uploadFunction();\n\n      // do not trigger any other actions\n      return false;\n    }\n    uploadContentFunction();\n\n    // trigger other actions to catch content\n    return true;\n  }\n\n  /**\n   * Safari creates two files when pasting an image from clipboard, one PNG and one JPEG.\n   * If that happens, remove the JPEG and only keep the PNG.\n   */\n  _cleanupFiles(files) {\n    if (files.length !== 2) {\n      return;\n    }\n    var pngImage;\n    var jpgImage;\n    files.forEach(function(file) {\n      // Check for the scoutName because it will only be set if it is likely a paste from clipboard event\n      if (file.name === 'image.png' && file.scoutName) {\n        pngImage = file;\n      } else if (file.name === 'image.jpeg' && file.scoutName) {\n        jpgImage = file;\n      }\n    });\n    if (pngImage && jpgImage) {\n      arrays.remove(files, jpgImage);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}