{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Desktop, DialogLayout, Form, Outline, scout } from '../index';\n/**\n * Controller with functionality to register and render views and dialogs.\n *\n * The forms are put into the list 'views' and 'dialogs' contained in 'displayParent'.\n */\n\nvar FormController = /*#__PURE__*/function () {\n  function FormController(model) {\n    _classCallCheck(this, FormController);\n\n    this.displayParent = model.displayParent;\n    this.session = model.session;\n  }\n  /**\n   * Adds the given view or dialog to this controller and renders it.\n   * position is only used if form is a view. this position determines at which position the tab is placed.\n   * if select view is set the view rendered in _renderView is also selected.\n   */\n\n\n  _createClass(FormController, [{\n    key: \"registerAndRender\",\n    value: function registerAndRender(form, position, selectView) {\n      scout.assertProperty(form, 'displayParent');\n\n      if (form.isPopupWindow()) {\n        this._renderPopupWindow(form);\n      } else if (form.isView()) {\n        this._renderView(form, true, position, selectView);\n      } else {\n        this._renderDialog(form, true);\n      }\n    }\n  }, {\n    key: \"_renderPopupWindow\",\n    value: function _renderPopupWindow(formAdapterId, position) {\n      throw new Error('popup window only supported by DesktopFormController');\n    }\n    /**\n     * Removes the given view or dialog from this controller and DOM. However, the form's adapter is not destroyed. That only happens once the Form is closed.\n     */\n\n  }, {\n    key: \"unregisterAndRemove\",\n    value: function unregisterAndRemove(form) {\n      if (!form) {\n        return;\n      }\n\n      if (form.isPopupWindow()) {\n        this._removePopupWindow(form);\n      } else if (form.isView()) {\n        this._removeView(form);\n      } else {\n        this._removeDialog(form);\n      }\n    }\n  }, {\n    key: \"_removePopupWindow\",\n    value: function _removePopupWindow(form) {\n      throw new Error('popup window only supported by DesktopFormController');\n    }\n    /**\n     * Renders all dialogs and views registered with this controller.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      this._renderViews();\n\n      this._renderDialogs();\n    }\n  }, {\n    key: \"_renderViews\",\n    value: function _renderViews() {\n      this.displayParent.views.forEach(function (view, position) {\n        view.setDisplayParent(this.displayParent);\n\n        this._renderView(view, false, position, false);\n      }.bind(this));\n    }\n  }, {\n    key: \"_renderDialogs\",\n    value: function _renderDialogs() {\n      this.displayParent.dialogs.forEach(function (dialog) {\n        dialog.setDisplayParent(this.displayParent);\n\n        this._renderDialog(dialog, false);\n      }.bind(this));\n    }\n    /**\n     * Removes all dialogs and views registered with this controller.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this.displayParent.dialogs.forEach(function (dialog) {\n        this._removeDialog(dialog, false);\n      }.bind(this));\n      this.displayParent.views.forEach(function (view, position) {\n        this._removeView(view, false);\n      }.bind(this));\n    }\n    /**\n     * Activates the given view or dialog.\n     */\n\n  }, {\n    key: \"activateForm\",\n    value: function activateForm(form) {\n      var displayParent = this.displayParent;\n\n      while (displayParent) {\n        if (displayParent instanceof Outline) {\n          this.session.desktop.setOutline(displayParent);\n          break;\n        }\n\n        displayParent = displayParent.displayParent;\n      }\n\n      if (form.displayHint === Form.DisplayHint.VIEW) {\n        this._activateView(form);\n      } else {\n        this._activateDialog(form);\n      }\n    }\n  }, {\n    key: \"acceptView\",\n    value: function acceptView(view, register, position, selectView) {\n      // Only render view if 'displayParent' is rendered yet; if not, the view will be rendered once 'displayParent' is rendered.\n      return this.displayParent.rendered;\n    }\n  }, {\n    key: \"_renderView\",\n    value: function _renderView(view, register, position, selectView) {\n      if (register) {\n        if (position !== undefined) {\n          arrays.insert(this.displayParent.views, view, position);\n        } else {\n          this.displayParent.views.push(view);\n        }\n      } // Display parent may implement acceptView, if not implemented -> use default\n\n\n      if (this.displayParent.acceptView) {\n        if (!this.displayParent.acceptView(view)) {\n          return;\n        }\n      } else if (!this.acceptView(view)) {\n        return;\n      } // Prevent \"Already rendered\" errors --> TODO [7.0] bsh: Remove this hack! Fix it on model if possible. See #162954.\n\n\n      if (view.rendered) {\n        return false;\n      }\n\n      if (this.session.desktop.displayStyle === Desktop.DisplayStyle.COMPACT && !this.session.desktop.bench) {\n        // Show bench and hide navigation if this is the first view to be shown\n        this.session.desktop.sendOutlineToBack();\n        this.session.desktop.switchToBench();\n      } else if (this.session.desktop.bench.removalPending) {\n        // If a new form should be shown while the bench is being removed because the last form was closed, schedule the rendering to make sure the bench and the new form will be opened right after the bench has been removed\n        setTimeout(this._renderView.bind(this, view, register, position, selectView));\n        return;\n      }\n\n      this.session.desktop.bench.addView(view, selectView);\n    }\n  }, {\n    key: \"acceptDialog\",\n    value: function acceptDialog(dialog) {\n      // Only render dialog if 'displayParent' is rendered yet; if not, the dialog will be rendered once 'displayParent' is rendered.\n      return this.displayParent.rendered;\n    }\n  }, {\n    key: \"_renderDialog\",\n    value: function _renderDialog(dialog, register) {\n      var desktop = this.session.desktop;\n\n      if (register) {\n        this.displayParent.dialogs.push(dialog);\n      } // Display parent may implement acceptDialog, if not implemented -> use default\n\n\n      if (this.displayParent.acceptDialog) {\n        if (!this.displayParent.acceptDialog(dialog)) {\n          return;\n        }\n      } else if (!this.acceptDialog(dialog)) {\n        return;\n      } // Prevent \"Already rendered\" errors --> TODO [7.0] bsh: Remove this hack! Fix it on model if possible. See #162954.\n\n\n      if (dialog.rendered) {\n        return false;\n      }\n\n      dialog.on('remove', function () {\n        var formToActivate = this._findFormToActivateAfterDialogRemove();\n\n        if (formToActivate) {\n          desktop._setFormActivated(formToActivate);\n        } else {\n          desktop._setOutlineActivated();\n        }\n      }.bind(this));\n\n      if (dialog.isPopupWindow()) {\n        this._renderPopupWindow(dialog);\n      } else {\n        // start focus tracking if not already started.\n        dialog.setTrackFocus(true);\n        dialog.render(desktop.$container);\n\n        this._layoutDialog(dialog);\n\n        desktop._setFormActivated(dialog); // Only display the dialog if its 'displayParent' is visible to the user.\n\n\n        if (!this.displayParent.inFront()) {\n          dialog.detach();\n        }\n      }\n    }\n  }, {\n    key: \"_findFormToActivateAfterDialogRemove\",\n    value: function _findFormToActivateAfterDialogRemove() {\n      if (this.displayParent.dialogs.length > 0) {\n        return this.displayParent.dialogs[this.displayParent.dialogs.length - 1];\n      }\n\n      if (this.displayParent instanceof Form && !this.displayParent.detailForm) {\n        // activate display parent, but not if it is the detail form\n        return this.displayParent;\n      }\n\n      var desktop = this.session.desktop;\n\n      if (desktop.bench) {\n        var form = desktop.bench.activeViews()[0];\n\n        if (form instanceof Form && !form.detailForm) {\n          return form;\n        }\n      }\n    }\n  }, {\n    key: \"_removeView\",\n    value: function _removeView(view, unregister) {\n      unregister = scout.nvl(unregister, true);\n\n      if (unregister) {\n        arrays.remove(this.displayParent.views, view);\n      } // in COMPACT case views are already removed.\n\n\n      if (this.session.desktop.bench) {\n        this.session.desktop.bench.removeView(view);\n      }\n    }\n  }, {\n    key: \"_removeDialog\",\n    value: function _removeDialog(dialog, unregister) {\n      unregister = scout.nvl(unregister, true);\n\n      if (unregister) {\n        arrays.remove(this.displayParent.dialogs, dialog);\n      }\n\n      if (dialog.rendered) {\n        dialog.remove();\n      }\n    }\n  }, {\n    key: \"_activateView\",\n    value: function _activateView(view) {\n      var bench = this.session.desktop.bench;\n\n      if (bench) {\n        // Bench may be null (e.g. in mobile mode). This may probably only happen if the form is not really a view, because otherwise the bench would already be open.\n        // Example: form of a FormToolButton has display style set to view but is opened as menu popup rather than in the bench.\n        // So this null check is actually a workaround because a better solution would be to never call this function for fake views, but currently it is not possible to identify them easily.\n        bench.activateView(view);\n      }\n    }\n  }, {\n    key: \"_activateDialog\",\n    value: function _activateDialog(dialog) {\n      // If the display-parent is a view-form --> activate it always.\n      // If it is another dialog --> activate it only if the dialog to activate is modal\n      if (dialog.displayParent instanceof Form && (dialog.displayParent.displayHint === Form.DisplayHint.VIEW || dialog.displayParent.displayHint === Form.DisplayHint.DIALOG && dialog.modal)) {\n        this.activateForm(dialog.displayParent);\n      }\n\n      if (!dialog.rendered) {\n        return;\n      }\n\n      var siblings = dialog.$container.nextAll().toArray(); // Now the approach is to move all eligible siblings that are in the DOM after the given dialog.\n      // It is important not to move the given dialog itself, because this would interfere with the further handling of the\n      // mousedown-DOM-event that triggerd this function.\n\n      var movableSiblings = siblings.filter(function (sibling) {\n        // siblings of a dialog are movable if they meet the following criteria:\n        // - they are forms (sibling forms of a dialog are always dialogs)\n        // - they are either\n        //     - not modal\n        //     - modal\n        //         - and not a descendant of the dialog to activate\n        //         - and their display parent is not the desktop\n        var siblingWidget = scout.widget(sibling);\n        return siblingWidget instanceof Form && (!siblingWidget.modal || !dialog.has(siblingWidget) && siblingWidget.displayParent !== this.session.desktop);\n      }, this); // All descendants of the so far determined movableSiblings are movable as well. (E.g. MessageBox, FileChooser)\n\n      var movableSiblingsDescendants = siblings.filter(function (sibling) {\n        return arrays.find(movableSiblings, function (movableSibling) {\n          var siblingWidget = scout.widget(sibling);\n          return !(siblingWidget instanceof Form) && // all movable forms are already captured by the filter above\n          scout.widget(movableSibling).has(siblingWidget);\n        });\n      });\n      movableSiblings = movableSiblings.concat(movableSiblingsDescendants);\n      this.session.desktop.moveOverlaysBehindAndFocus(movableSiblings, dialog.$container);\n    }\n    /**\n     * Attaches all dialogs to their original DOM parents.\n     * In contrast to 'render', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.\n     *\n     * This method has no effect if already attached.\n     */\n\n  }, {\n    key: \"attachDialogs\",\n    value: function attachDialogs() {\n      this.displayParent.dialogs.forEach(function (dialog) {\n        dialog.attach();\n      }, this);\n    }\n    /**\n     * Detaches all dialogs from their DOM parents. Thereby, modality glassPanes are not detached.\n     * In contrast to 'remove', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.\n     *\n     * This method has no effect if already detached.\n     */\n\n  }, {\n    key: \"detachDialogs\",\n    value: function detachDialogs() {\n      this.displayParent.dialogs.forEach(function (dialog) {\n        dialog.detach();\n      }, this);\n    }\n  }, {\n    key: \"_layoutDialog\",\n    value: function _layoutDialog(dialog) {\n      var cacheBounds, position;\n      dialog.htmlComp.validateLayout();\n      cacheBounds = dialog.readCacheBounds();\n\n      if (cacheBounds) {\n        position = cacheBounds.point();\n      } else {\n        position = DialogLayout.positionContainerInWindow(dialog.$container);\n      }\n\n      dialog.$container.cssPosition(position);\n      dialog.trigger('move', {\n        left: position.x,\n        top: position.y\n      });\n      dialog.updateCacheBounds(); // If not validated anew, focus on single-button forms is not gained.\n      // Maybe, this is the same problem as in BusyIndicator.js\n\n      this.session.focusManager.validateFocus(); // Animate _after_ the layout is valid (otherwise, the position would be wrong, because\n      // HtmlComponent defers the layout when a component is currently being animated)\n\n      dialog.$container.addClassForAnimation('animate-open');\n      dialog.$container.addDeviceClass(); // no animation in IE\n    }\n  }]);\n\n  return FormController;\n}();\n\nexport { FormController as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/form/FormController.js"],"names":["arrays","Desktop","DialogLayout","Form","Outline","scout","FormController","model","displayParent","session","form","position","selectView","assertProperty","isPopupWindow","_renderPopupWindow","isView","_renderView","_renderDialog","formAdapterId","Error","_removePopupWindow","_removeView","_removeDialog","_renderViews","_renderDialogs","views","forEach","view","setDisplayParent","bind","dialogs","dialog","desktop","setOutline","displayHint","DisplayHint","VIEW","_activateView","_activateDialog","register","rendered","undefined","insert","push","acceptView","displayStyle","DisplayStyle","COMPACT","bench","sendOutlineToBack","switchToBench","removalPending","setTimeout","addView","acceptDialog","on","formToActivate","_findFormToActivateAfterDialogRemove","_setFormActivated","_setOutlineActivated","setTrackFocus","render","$container","_layoutDialog","inFront","detach","length","detailForm","activeViews","unregister","nvl","remove","removeView","activateView","DIALOG","modal","activateForm","siblings","nextAll","toArray","movableSiblings","filter","sibling","siblingWidget","widget","has","movableSiblingsDescendants","find","movableSibling","concat","moveOverlaysBehindAndFocus","attach","cacheBounds","htmlComp","validateLayout","readCacheBounds","point","positionContainerInWindow","cssPosition","trigger","left","x","top","y","updateCacheBounds","focusManager","validateFocus","addClassForAnimation","addDeviceClass"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Desktop, DialogLayout, Form, Outline, scout} from '../index';\n\n/**\n * Controller with functionality to register and render views and dialogs.\n *\n * The forms are put into the list 'views' and 'dialogs' contained in 'displayParent'.\n */\nexport default class FormController {\n\n  constructor(model) {\n    this.displayParent = model.displayParent;\n    this.session = model.session;\n  }\n\n  /**\n   * Adds the given view or dialog to this controller and renders it.\n   * position is only used if form is a view. this position determines at which position the tab is placed.\n   * if select view is set the view rendered in _renderView is also selected.\n   */\n  registerAndRender(form, position, selectView) {\n    scout.assertProperty(form, 'displayParent');\n    if (form.isPopupWindow()) {\n      this._renderPopupWindow(form);\n    } else if (form.isView()) {\n      this._renderView(form, true, position, selectView);\n    } else {\n      this._renderDialog(form, true);\n    }\n  }\n\n  _renderPopupWindow(formAdapterId, position) {\n    throw new Error('popup window only supported by DesktopFormController');\n  }\n\n  /**\n   * Removes the given view or dialog from this controller and DOM. However, the form's adapter is not destroyed. That only happens once the Form is closed.\n   */\n  unregisterAndRemove(form) {\n    if (!form) {\n      return;\n    }\n\n    if (form.isPopupWindow()) {\n      this._removePopupWindow(form);\n    } else if (form.isView()) {\n      this._removeView(form);\n    } else {\n      this._removeDialog(form);\n    }\n  }\n\n  _removePopupWindow(form) {\n    throw new Error('popup window only supported by DesktopFormController');\n  }\n\n  /**\n   * Renders all dialogs and views registered with this controller.\n   */\n  render() {\n    this._renderViews();\n\n    this._renderDialogs();\n  }\n\n  _renderViews() {\n    this.displayParent.views.forEach(function(view, position) {\n      view.setDisplayParent(this.displayParent);\n      this._renderView(view, false, position, false);\n    }.bind(this));\n  }\n\n  _renderDialogs() {\n    this.displayParent.dialogs.forEach(function(dialog) {\n      dialog.setDisplayParent(this.displayParent);\n      this._renderDialog(dialog, false);\n    }.bind(this));\n  }\n\n  /**\n   * Removes all dialogs and views registered with this controller.\n   */\n  remove() {\n    this.displayParent.dialogs.forEach(function(dialog) {\n      this._removeDialog(dialog, false);\n    }.bind(this));\n    this.displayParent.views.forEach(function(view, position) {\n      this._removeView(view, false);\n    }.bind(this));\n  }\n\n  /**\n   * Activates the given view or dialog.\n   */\n  activateForm(form) {\n    var displayParent = this.displayParent;\n    while (displayParent) {\n      if (displayParent instanceof Outline) {\n        this.session.desktop.setOutline(displayParent);\n        break;\n      }\n      displayParent = displayParent.displayParent;\n    }\n\n    if (form.displayHint === Form.DisplayHint.VIEW) {\n      this._activateView(form);\n    } else {\n      this._activateDialog(form);\n    }\n  }\n\n  acceptView(view, register, position, selectView) {\n    // Only render view if 'displayParent' is rendered yet; if not, the view will be rendered once 'displayParent' is rendered.\n    return this.displayParent.rendered;\n  }\n\n  _renderView(view, register, position, selectView) {\n    if (register) {\n      if (position !== undefined) {\n        arrays.insert(this.displayParent.views, view, position);\n      } else {\n        this.displayParent.views.push(view);\n      }\n    }\n\n    // Display parent may implement acceptView, if not implemented -> use default\n    if (this.displayParent.acceptView) {\n      if (!this.displayParent.acceptView(view)) {\n        return;\n      }\n    } else if (!this.acceptView(view)) {\n      return;\n    }\n\n    // Prevent \"Already rendered\" errors --> TODO [7.0] bsh: Remove this hack! Fix it on model if possible. See #162954.\n    if (view.rendered) {\n      return false;\n    }\n    if (this.session.desktop.displayStyle === Desktop.DisplayStyle.COMPACT && !this.session.desktop.bench) {\n      // Show bench and hide navigation if this is the first view to be shown\n      this.session.desktop.sendOutlineToBack();\n      this.session.desktop.switchToBench();\n    } else if (this.session.desktop.bench.removalPending) {\n      // If a new form should be shown while the bench is being removed because the last form was closed, schedule the rendering to make sure the bench and the new form will be opened right after the bench has been removed\n      setTimeout(this._renderView.bind(this, view, register, position, selectView));\n      return;\n    }\n    this.session.desktop.bench.addView(view, selectView);\n  }\n\n  acceptDialog(dialog) {\n    // Only render dialog if 'displayParent' is rendered yet; if not, the dialog will be rendered once 'displayParent' is rendered.\n    return this.displayParent.rendered;\n  }\n\n  _renderDialog(dialog, register) {\n    var desktop = this.session.desktop;\n    if (register) {\n      this.displayParent.dialogs.push(dialog);\n    }\n\n    // Display parent may implement acceptDialog, if not implemented -> use default\n    if (this.displayParent.acceptDialog) {\n      if (!this.displayParent.acceptDialog(dialog)) {\n        return;\n      }\n    } else if (!this.acceptDialog(dialog)) {\n      return;\n    }\n\n    // Prevent \"Already rendered\" errors --> TODO [7.0] bsh: Remove this hack! Fix it on model if possible. See #162954.\n    if (dialog.rendered) {\n      return false;\n    }\n\n    dialog.on('remove', function() {\n      var formToActivate = this._findFormToActivateAfterDialogRemove();\n      if (formToActivate) {\n        desktop._setFormActivated(formToActivate);\n      } else {\n        desktop._setOutlineActivated();\n      }\n    }.bind(this));\n\n    if (dialog.isPopupWindow()) {\n      this._renderPopupWindow(dialog);\n    } else {\n      // start focus tracking if not already started.\n      dialog.setTrackFocus(true);\n      dialog.render(desktop.$container);\n      this._layoutDialog(dialog);\n      desktop._setFormActivated(dialog);\n\n      // Only display the dialog if its 'displayParent' is visible to the user.\n      if (!this.displayParent.inFront()) {\n        dialog.detach();\n      }\n    }\n  }\n\n  _findFormToActivateAfterDialogRemove() {\n    if (this.displayParent.dialogs.length > 0) {\n      return this.displayParent.dialogs[this.displayParent.dialogs.length - 1];\n    }\n    if (this.displayParent instanceof Form && !this.displayParent.detailForm) {\n      // activate display parent, but not if it is the detail form\n      return this.displayParent;\n    }\n    var desktop = this.session.desktop;\n    if (desktop.bench) {\n      var form = desktop.bench.activeViews()[0];\n      if (form instanceof Form && !form.detailForm) {\n        return form;\n      }\n    }\n  }\n\n  _removeView(view, unregister) {\n    unregister = scout.nvl(unregister, true);\n    if (unregister) {\n      arrays.remove(this.displayParent.views, view);\n    }\n    // in COMPACT case views are already removed.\n    if (this.session.desktop.bench) {\n      this.session.desktop.bench.removeView(view);\n    }\n  }\n\n  _removeDialog(dialog, unregister) {\n    unregister = scout.nvl(unregister, true);\n    if (unregister) {\n      arrays.remove(this.displayParent.dialogs, dialog);\n    }\n    if (dialog.rendered) {\n      dialog.remove();\n    }\n  }\n\n  _activateView(view) {\n    var bench = this.session.desktop.bench;\n    if (bench) {\n      // Bench may be null (e.g. in mobile mode). This may probably only happen if the form is not really a view, because otherwise the bench would already be open.\n      // Example: form of a FormToolButton has display style set to view but is opened as menu popup rather than in the bench.\n      // So this null check is actually a workaround because a better solution would be to never call this function for fake views, but currently it is not possible to identify them easily.\n      bench.activateView(view);\n    }\n  }\n\n  _activateDialog(dialog) {\n    // If the display-parent is a view-form --> activate it always.\n    // If it is another dialog --> activate it only if the dialog to activate is modal\n    if (dialog.displayParent instanceof Form &&\n      (dialog.displayParent.displayHint === Form.DisplayHint.VIEW ||\n        (dialog.displayParent.displayHint === Form.DisplayHint.DIALOG && dialog.modal))) {\n      this.activateForm(dialog.displayParent);\n    }\n\n    if (!dialog.rendered) {\n      return;\n    }\n\n    var siblings = dialog.$container.nextAll().toArray();\n\n    // Now the approach is to move all eligible siblings that are in the DOM after the given dialog.\n    // It is important not to move the given dialog itself, because this would interfere with the further handling of the\n    // mousedown-DOM-event that triggerd this function.\n    var movableSiblings = siblings.filter(function(sibling) {\n      // siblings of a dialog are movable if they meet the following criteria:\n      // - they are forms (sibling forms of a dialog are always dialogs)\n      // - they are either\n      //     - not modal\n      //     - modal\n      //         - and not a descendant of the dialog to activate\n      //         - and their display parent is not the desktop\n      var siblingWidget = scout.widget(sibling);\n      return siblingWidget instanceof Form &&\n        (!siblingWidget.modal ||\n          (!dialog.has(siblingWidget) && siblingWidget.displayParent !== this.session.desktop));\n    }, this);\n\n    // All descendants of the so far determined movableSiblings are movable as well. (E.g. MessageBox, FileChooser)\n    var movableSiblingsDescendants = siblings.filter(function(sibling) {\n      return arrays.find(movableSiblings, function(movableSibling) {\n        var siblingWidget = scout.widget(sibling);\n        return !(siblingWidget instanceof Form) && // all movable forms are already captured by the filter above\n          scout.widget(movableSibling).has(siblingWidget);\n      });\n    });\n    movableSiblings = movableSiblings.concat(movableSiblingsDescendants);\n\n    this.session.desktop.moveOverlaysBehindAndFocus(movableSiblings, dialog.$container);\n  }\n\n  /**\n   * Attaches all dialogs to their original DOM parents.\n   * In contrast to 'render', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.\n   *\n   * This method has no effect if already attached.\n   */\n  attachDialogs() {\n    this.displayParent.dialogs.forEach(function(dialog) {\n      dialog.attach();\n    }, this);\n  }\n\n  /**\n   * Detaches all dialogs from their DOM parents. Thereby, modality glassPanes are not detached.\n   * In contrast to 'remove', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.\n   *\n   * This method has no effect if already detached.\n   */\n  detachDialogs() {\n    this.displayParent.dialogs.forEach(function(dialog) {\n      dialog.detach();\n    }, this);\n  }\n\n  _layoutDialog(dialog) {\n    var cacheBounds, position;\n    dialog.htmlComp.validateLayout();\n\n    cacheBounds = dialog.readCacheBounds();\n    if (cacheBounds) {\n      position = cacheBounds.point();\n    } else {\n      position = DialogLayout.positionContainerInWindow(dialog.$container);\n    }\n\n    dialog.$container.cssPosition(position);\n    dialog.trigger('move', {\n      left: position.x,\n      top: position.y\n    });\n\n    dialog.updateCacheBounds();\n\n    // If not validated anew, focus on single-button forms is not gained.\n    // Maybe, this is the same problem as in BusyIndicator.js\n    this.session.focusManager.validateFocus();\n\n    // Animate _after_ the layout is valid (otherwise, the position would be wrong, because\n    // HtmlComponent defers the layout when a component is currently being animated)\n    dialog.$container.addClassForAnimation('animate-open');\n    dialog.$container.addDeviceClass(); // no animation in IE\n  }\n}\n"]},"metadata":{},"sourceType":"module"}