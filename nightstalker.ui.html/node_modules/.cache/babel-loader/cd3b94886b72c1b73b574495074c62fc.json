{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, DeferredGlassPaneTarget, Desktop, Device, Event, EventDelegator, EventSupport, filters, focusUtils, Form, graphics, icons, inspector, KeyStrokeContext, LoadingSupport, LogicalGrid, objects, scout, scrollbars, strings, texts, TreeVisitResult, widgets } from '../index';\nimport $ from 'jquery';\n\nvar Widget = /*#__PURE__*/function () {\n  function Widget() {\n    _classCallCheck(this, Widget);\n\n    this.session = null;\n    /**\n     * The owner is responsible that its children are destroyed when the owner is being destroyed.\n     */\n\n    this.owner = null;\n    /**\n     * The parent is typically the same as the owner.\n     * But the widget may be used by another widget (like a popup), in that case the parent will be changed to the popup but the owner stays the same.\n     * This means the popup is now the temporary parent, when the popup is destroyed its widgets are not because the popup is not the owner.\n     * Example: ViewMenuPopup uses the ViewButtons as menu items. These view buttons are owned by the desktop and must therefore not be destroyed\n     * when the popup closes, otherwise they could not be reused the second time the popup opens.\n     */\n\n    this.parent = null;\n    this.children = [];\n    this.initialized = false;\n    /**\n     * The 'rendering' flag is set the true while the _inital_ rendering is performed.\n     * It is used to to something different in a _render* method when the method is\n     * called for the first time.\n     */\n\n    this.rendering = false;\n    this.removing = false;\n    this.removalPending = false;\n    /**\n     * The 'rendered' flag is set the true when initial rendering of the widget is completed.\n     */\n\n    this.rendered = false;\n    this.attached = false;\n    this.destroyed = false;\n    this.destroying = false;\n    this.enabled = true;\n    /**\n     * The computed enabled state. The difference to the 'enabled' property is that this member\n     * also considers the enabled-states of the parent widgets.\n     */\n\n    this.enabledComputed = true;\n    this.inheritAccessibility = true;\n    this.disabledStyle = Widget.DisabledStyle.DEFAULT;\n    this.visible = true;\n    this.focused = false;\n    this.loading = false;\n    this.cssClass = null;\n    this.scrollTop = null;\n    this.scrollLeft = null;\n    this.$container; // If set to true, remove won't remove the element immediately but after the animation has been finished\n    // This expects a css animation which may be triggered by the class 'animate-remove'\n    // If browser does not support css animation, remove will be executed immediately\n\n    this.animateRemoval = false;\n    this.animateRemovalClass = 'animate-remove';\n    this._widgetProperties = [];\n    this._cloneProperties = ['visible', 'enabled', 'inheritAccessibility', 'cssClass'];\n    this.eventDelegators = [];\n    this._preserveOnPropertyChangeProperties = [];\n    this._postRenderActions = [];\n    this._focusInListener = this._onFocusIn.bind(this);\n    this._parentDestroyHandler = this._onParentDestroy.bind(this);\n    this._parentRemovingWhileAnimatingHandler = this._onParentRemovingWhileAnimating.bind(this);\n    this._scrollHandler = this._onScroll.bind(this);\n    this.events = this._createEventSupport();\n    this.events.registerSubTypePredicate('propertyChange', function (event, propertyName) {\n      return event.propertyName === propertyName;\n    });\n    this.loadingSupport = this._createLoadingSupport();\n    this.keyStrokeContext = this._createKeyStrokeContext(); // Widgets using LogicalGridLayout may have a grid to calculate the grid data of the children\n\n    this.logicalGrid; // focus tracking\n\n    this.trackFocus = false;\n    this._$lastFocusedElement = null;\n    this._storedFocusedWidget = null;\n    this._glassPaneContributions = [];\n  }\n  /**\n   * Enum used to define different styles used when the field is disabled.\n   */\n\n\n  _createClass(Widget, [{\n    key: \"init\",\n    value: function init(model) {\n      var staticModel = this._jsonModel();\n\n      if (staticModel) {\n        model = $.extend({}, staticModel, model);\n      }\n\n      model = model || {};\n      model = this._prepareModel(model);\n\n      this._init(model);\n\n      this._initKeyStrokeContext();\n\n      this.recomputeEnabled();\n      this.initialized = true;\n      this.trigger('init');\n    }\n    /**\n     * Default implementation simply returns the unmodified model. A Subclass\n     * may override this method to alter the JSON model before the widgets\n     * are created out of the widgetProperties in the model.\n     */\n\n  }, {\n    key: \"_prepareModel\",\n    value: function _prepareModel(model) {\n      return model;\n    }\n    /**\n     * @param options\n     * - parent (required): The parent widget\n     * - session (optional): If not specified the session of the parent is used\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init(model) {\n      if (!model.parent) {\n        throw new Error('Parent expected: ' + this);\n      }\n\n      this.setOwner(model.owner || model.parent);\n      this.setParent(model.parent);\n      this.session = model.session || this.parent.session;\n\n      if (!this.session) {\n        throw new Error('Session expected: ' + this);\n      }\n\n      this._eachProperty(model, function (propertyName, value, isWidgetProperty) {\n        if (value === undefined) {\n          // Don't set the value if it is undefined, compared to null which is allowed explicitly ($.extend works in the same way)\n          return;\n        }\n\n        if (isWidgetProperty) {\n          value = this._prepareWidgetProperty(propertyName, value);\n        }\n\n        this._initProperty(propertyName, value);\n      }.bind(this));\n\n      this._setCssClass(this.cssClass);\n\n      this._setLogicalGrid(this.logicalGrid);\n\n      this._setEnabled(this.enabled);\n    }\n    /**\n     * This function sets the property value. Override this function when you need special init behavior for certain properties.\n     * For instance you could not simply set the property value, but extend an already existing value.\n     */\n\n  }, {\n    key: \"_initProperty\",\n    value: function _initProperty(propertyName, value) {\n      this[propertyName] = value;\n    }\n    /**\n     * Default implementation simply returns undefined. A Subclass\n     * may override this method to load or extend a JSON model with models.getModel or models.extend.\n     */\n\n  }, {\n    key: \"_jsonModel\",\n    value: function _jsonModel() {}\n    /**\n     * Creates the widgets using the given models, or returns the widgets if the given models already are widgets.\n     * @returns {Widget[]|Widget}an array of created widgets if models was an array. Or the created widget if models is not an array.\n     */\n\n  }, {\n    key: \"_createChildren\",\n    value: function _createChildren(models) {\n      if (!models) {\n        return null;\n      }\n\n      if (!Array.isArray(models)) {\n        return this._createChild(models);\n      }\n\n      var widgets = [];\n      models.forEach(function (model, i) {\n        widgets[i] = this._createChild(model);\n      }, this);\n      return widgets;\n    }\n    /**\n     * Calls {@link scout.create} for the given model, or if model is already a Widget simply returns the widget.\n     *\n     * @param model {Object|Widget}\n     * @returns {Widget}\n     */\n\n  }, {\n    key: \"_createChild\",\n    value: function _createChild(model) {\n      if (model instanceof Widget) {\n        return model;\n      }\n\n      if (typeof model === 'string') {\n        // Special case: If only an ID is supplied, try to (locally) resolve the corresponding widget\n        var existingWidget = this.widget(model);\n\n        if (!existingWidget) {\n          throw new Error('Referenced widget not found: ' + model);\n        }\n\n        return existingWidget;\n      }\n\n      model.parent = this;\n      return scout.create(model);\n    }\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      if (!this.keyStrokeContext) {\n        return;\n      }\n\n      this.keyStrokeContext.$scopeTarget = function () {\n        return this.$container;\n      }.bind(this);\n\n      this.keyStrokeContext.$bindTarget = function () {\n        return this.$container;\n      }.bind(this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.destroyed) {\n        // Already destroyed, do nothing\n        return;\n      }\n\n      this.destroying = true;\n\n      if (this.rendered && (this.animateRemoval || this._isRemovalPrevented())) {\n        // Do not destroy yet if the removal happens animated\n        // Also don't destroy if the removal is pending to keep the parent / child link until removal finishes\n        this.one('remove', function () {\n          this.destroy();\n        }.bind(this));\n        this.remove();\n        return;\n      } // Destroy children in reverse order\n\n\n      this._destroyChildren(this.children.slice().reverse());\n\n      this.remove();\n\n      this._destroy(); // Disconnect from owner and parent\n\n\n      this.owner._removeChild(this);\n\n      this.owner = null;\n\n      this.parent._removeChild(this);\n\n      this.parent.off('destroy', this._parentDestroyHandler);\n      this.parent = null;\n      this.destroying = false;\n      this.destroyed = true;\n      this.trigger('destroy');\n    }\n    /**\n     * Override this function to do clean-up (like removing listeners) when the widget is destroyed.\n     * The default impl. does nothing.\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {// NOP\n    }\n    /**\n     * @param widgets may be an object or array of objects\n     */\n\n  }, {\n    key: \"_destroyChildren\",\n    value: function _destroyChildren(widgets) {\n      if (!widgets) {\n        return;\n      }\n\n      widgets = arrays.ensure(widgets);\n      widgets.forEach(function (widget, i) {\n        this._destroyChild(widget);\n      }, this);\n    }\n  }, {\n    key: \"_destroyChild\",\n    value: function _destroyChild(child) {\n      if (child.owner !== this) {\n        return;\n      }\n\n      child.destroy();\n    }\n    /**\n     * @param [$parent] The jQuery element which is used as $parent when rendering this widget.\n     * It will be put onto the widget and is therefore accessible as this.$parent in the _render method.\n     * If not specified, the $container of the parent is used.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render($parent) {\n      $.log.isTraceEnabled() && $.log.trace('Rendering widget: ' + this);\n\n      if (!this.initialized) {\n        throw new Error('Not initialized: ' + this);\n      }\n\n      if (this.rendered) {\n        throw new Error('Already rendered: ' + this);\n      }\n\n      if (this.destroyed) {\n        throw new Error('Widget is destroyed: ' + this);\n      }\n\n      this.rendering = true;\n      this.$parent = $parent || this.parent.$container;\n\n      this._render();\n\n      this._renderProperties();\n\n      this._renderInspectorInfo();\n\n      this._linkWithDOM();\n\n      this.session.keyStrokeManager.installKeyStrokeContext(this.keyStrokeContext);\n      this.rendering = false;\n      this.rendered = true;\n      this.attached = true;\n      this.trigger('render');\n      this.restoreFocus();\n\n      this._postRender();\n    }\n    /**\n     * This method creates the UI through DOM manipulation. At this point we should not apply model\n     * properties on the UI, since sub-classes may need to contribute to the DOM first. You must not\n     * apply model values to the UI here, since this is done in the _renderProperties method later.\n     * The default impl. does nothing.\n     */\n\n  }, {\n    key: \"_render\",\n    value: function _render() {// NOP\n    }\n    /**\n     * This method calls the UI setter methods after the _render method has been executed.\n     * Here values of the model are applied to the DOM / UI.\n     */\n\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      this._renderTrackFocus();\n\n      this._renderEnabled();\n\n      this._renderVisible();\n\n      this._renderFocused();\n\n      this._renderCssClass();\n\n      this._renderLoading();\n\n      this._renderScrollTop();\n\n      this._renderScrollLeft();\n    }\n    /**\n     * Method invoked once rendering completed and 'rendered' flag is set to 'true'.<p>\n     * By default executes every action of this._postRenderActions\n     */\n\n  }, {\n    key: \"_postRender\",\n    value: function _postRender() {\n      var actions = this._postRenderActions;\n      this._postRenderActions = [];\n      actions.forEach(function (action) {\n        action();\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (!this.rendered || this._isRemovalPrevented()) {\n        return;\n      }\n\n      if (this.animateRemoval) {\n        this._removeAnimated();\n      } else {\n        this._removeInternal();\n      }\n    }\n    /**\n     * Will be called by {@link #remove()}. If true is returned, the widget won't be removed.<p>\n     * By default it just delegates to {@link #_isRemovalPending}. May be overridden to customize it.\n     */\n\n  }, {\n    key: \"_isRemovalPrevented\",\n    value: function _isRemovalPrevented() {\n      return this._isRemovalPending();\n    }\n    /**\n     * Returns true if the removal of this or an ancestor widget is pending. Checking the ancestor is omitted if the parent is being removed.\n     * This may be used to prevent a removal if an ancestor will be removed (e.g by an animation)\n     */\n\n  }, {\n    key: \"_isRemovalPending\",\n    value: function _isRemovalPending() {\n      if (this.removalPending) {\n        return true;\n      }\n\n      var parent = this.parent;\n\n      if (!parent || parent.removing || parent.rendering) {\n        // If parent is being removed or rendered, no need to check the ancestors because removing / rendering is already in progress\n        return false;\n      }\n\n      while (parent) {\n        if (parent.removalPending) {\n          return true;\n        }\n\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_removeInternal\",\n    value: function _removeInternal() {\n      if (!this.rendered) {\n        return;\n      }\n\n      $.log.isTraceEnabled() && $.log.trace('Removing widget: ' + this);\n      this.removing = true;\n      this.removalPending = false;\n      this.trigger('removing'); // transform last focused element into a scout widget\n\n      if (this.$container) {\n        this.$container.off('focusin', this._focusInListener);\n      }\n\n      if (this._$lastFocusedElement) {\n        this._storedFocusedWidget = scout.widget(this._$lastFocusedElement);\n        this._$lastFocusedElement = null;\n      } // remove children in reverse order.\n\n\n      this.children.slice().reverse().forEach(function (child) {\n        // Only remove the child if this widget is the current parent (if that is not the case this widget is the owner)\n        if (child.parent === this) {\n          child.remove();\n        }\n      }, this);\n\n      if (!this.rendered) {\n        // The widget may have been removed already by one of the above remove() calls (e.g. by a remove listener)\n        // -> don't try to do it again, it might fail\n        return;\n      }\n\n      this._cleanup();\n\n      this._remove();\n\n      this.$parent = null;\n      this.rendered = false;\n      this.attached = false;\n      this.removing = false;\n      this.trigger('remove');\n    }\n    /**\n     * Adds class 'animate-remove' to container which can be used to trigger the animation.\n     * After the animation is executed, the element gets removed using this._removeInternal.\n     */\n\n  }, {\n    key: \"_removeAnimated\",\n    value: function _removeAnimated() {\n      if (!Device.get().supportsCssAnimation() || !this.$container || this.$container.isDisplayNone()) {\n        // Cannot remove animated, remove regularly\n        this._removeInternal();\n\n        return;\n      } // Destroy open popups first, they are not animated\n\n\n      this.session.desktop.destroyPopupsFor(this);\n      this.removalPending = true; // Don't execute immediately to make sure nothing interferes with the animation (e.g. layouting) which could make it laggy\n\n      setTimeout(function () {\n        // check if the container has been removed in the meantime\n        if (!this.rendered) {\n          return;\n        }\n\n        if (!this.animateRemovalClass) {\n          throw new Error('Missing animate removal class. Cannot remove animated.');\n        }\n\n        if (!this.$container.isVisible() || !this.$container.isEveryParentVisible()) {\n          // If element is not visible, animationEnd would never fire -> remove it immediately\n          this._removeInternal();\n\n          return;\n        }\n\n        this.$container.addClass(this.animateRemovalClass);\n        this.$container.oneAnimationEnd(function () {\n          this._removeInternal();\n        }.bind(this));\n      }.bind(this)); // If the parent is being removed while the animation is running, the animationEnd event will never fire\n      // -> Make sure remove is called nevertheless. Important: remove it before the parent is removed to maintain the regular remove order\n\n      this.parent.one('removing', this._parentRemovingWhileAnimatingHandler);\n    }\n  }, {\n    key: \"_onParentRemovingWhileAnimating\",\n    value: function _onParentRemovingWhileAnimating() {\n      this._removeInternal();\n    }\n  }, {\n    key: \"_renderInspectorInfo\",\n    value: function _renderInspectorInfo() {\n      if (!this.session.inspector) {\n        return;\n      }\n\n      inspector.applyInfo(this);\n    }\n    /**\n     * Links $container with the widget.\n     */\n\n  }, {\n    key: \"_linkWithDOM\",\n    value: function _linkWithDOM() {\n      if (this.$container) {\n        this.$container.data('widget', this);\n      }\n    }\n    /**\n     * Called right before _remove is called.\n     * Default calls LayoutValidator.cleanupInvalidComponents to make sure that child components are removed from the invalid components list.\n     * Also uninstalls key stroke context, loading support and scrollbars.\n     */\n\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      this.parent.off('removing', this._parentRemovingWhileAnimatingHandler);\n      this.session.keyStrokeManager.uninstallKeyStrokeContext(this.keyStrokeContext);\n\n      if (this.loadingSupport) {\n        this.loadingSupport.remove();\n      }\n\n      this._uninstallScrollbars();\n\n      if (this.$container) {\n        this.session.layoutValidator.cleanupInvalidComponents(this.$container);\n      }\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      if (this.$container) {\n        this.$container.remove();\n        this.$container = null;\n      }\n    }\n  }, {\n    key: \"setOwner\",\n    value: function setOwner(owner) {\n      scout.assertParameter('owner', owner);\n\n      if (owner === this.owner) {\n        return;\n      }\n\n      if (this.owner) {\n        // Remove from old owner\n        this.owner._removeChild(this);\n      }\n\n      this.owner = owner;\n\n      this.owner._addChild(this);\n    }\n  }, {\n    key: \"setParent\",\n    value: function setParent(parent) {\n      scout.assertParameter('parent', parent);\n\n      if (parent === this.parent) {\n        return;\n      }\n\n      if (this.rendered && !parent.rendered) {\n        $.log.isInfoEnabled() && $.log.info('rendered child ' + this + ' is added to not rendered parent ' + parent + '. Removing child.', new Error('origin'));\n        this.remove();\n      }\n\n      if (this.parent) {\n        // Don't link to new parent yet if removal is still pending.\n        // After the animation the parent will remove its children.\n        // If they are already linked to a new parent, removing the children is not possible anymore.\n        // This may lead to an \"Already rendered\" exception if the new parent wants to render its children.\n        if (this.parent._isRemovalPending()) {\n          this.parent.one('remove', function () {\n            this.setParent(parent);\n          }.bind(this));\n          return;\n        }\n\n        this.parent.off('destroy', this._parentDestroyHandler);\n        this.parent.off('removing', this._parentRemovingWhileAnimatingHandler);\n\n        if (this.parent !== this.owner) {\n          // Remove from old parent if getting relinked\n          // If the old parent is still the owner, don't remove it because owner stays responsible for destroying it\n          this.parent._removeChild(this);\n        }\n      }\n\n      var oldParent = this.parent;\n      this.parent = parent;\n\n      this.parent._addChild(this);\n\n      this.trigger('hierarchyChange', {\n        oldParent: oldParent,\n        parent: parent\n      });\n\n      if (this.initialized) {\n        this.recomputeEnabled(this.parent.enabledComputed);\n      }\n\n      this.parent.one('destroy', this._parentDestroyHandler);\n    }\n  }, {\n    key: \"_addChild\",\n    value: function _addChild(child) {\n      $.log.isTraceEnabled() && $.log.trace('addChild(' + child + ') to ' + this);\n      arrays.pushSet(this.children, child);\n    }\n  }, {\n    key: \"_removeChild\",\n    value: function _removeChild(child) {\n      $.log.isTraceEnabled() && $.log.trace('removeChild(' + child + ') from ' + this);\n      arrays.remove(this.children, child);\n    }\n    /**\n     * @returns {Widget[]} a list of all ancestors\n     */\n\n  }, {\n    key: \"ancestors\",\n    value: function ancestors() {\n      var ancestors = [];\n      var parent = this.parent;\n\n      while (parent) {\n        ancestors.push(parent);\n        parent = parent.parent;\n      }\n\n      return ancestors;\n    }\n    /**\n     * @returns {boolean} true if the given widget is the same as this or a descendant\n     */\n\n  }, {\n    key: \"isOrHas\",\n    value: function isOrHas(widget) {\n      if (widget === this) {\n        return true;\n      }\n\n      return this.has(widget);\n    }\n    /**\n     * @returns {boolean} true if the given widget is a descendant\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(widget) {\n      while (widget) {\n        if (widget.parent === this) {\n          return true;\n        }\n\n        widget = widget.parent;\n      }\n\n      return false;\n    }\n    /**\n     * @returns {Form} the form the widget belongs to (returns the first parent which is a {@link Form}.\n     */\n\n  }, {\n    key: \"getForm\",\n    value: function getForm() {\n      return Form.findForm(this);\n    }\n    /**\n     * @returns {Form} the first form which is not an inner form of a wrapped form field\n     */\n\n  }, {\n    key: \"findNonWrappedForm\",\n    value: function findNonWrappedForm() {\n      return Form.findNonWrappedForm(this);\n    }\n    /**\n     * @returns {Desktop} the desktop linked to the current session.\n     * If desktop is still initializing it might not be available yet, in that case it searches the parent hierarchy for it.\n     */\n\n  }, {\n    key: \"findDesktop\",\n    value: function findDesktop() {\n      if (this.session.desktop) {\n        return this.session.desktop;\n      }\n\n      return this.findParent(function (parent) {\n        return parent instanceof Desktop;\n      });\n    }\n    /**\n     * Changes the enabled property of this form field to the given value.\n     *\n     * @param {boolean} enabled\n     *          Required. The new enabled value\n     * @param {boolean} [updateParents]\n     *          (optional) If true, the enabled property of all parent form fields are\n     *          updated to same value as well. Default is false.\n     * @param {boolean} [updateChildren]\n     *          (optional) If true the enabled property of all child form fields (recursive)\n     *          are updated to same value as well. Default is false.\n     */\n\n  }, {\n    key: \"setEnabled\",\n    value: function setEnabled(enabled, updateParents, updateChildren) {\n      this.setProperty('enabled', enabled);\n\n      if (enabled && updateParents && this.parent) {\n        this.parent.setEnabled(true, true, false);\n      }\n\n      if (updateChildren) {\n        this.visitChildren(function (field) {\n          field.setEnabled(enabled);\n        });\n      }\n    }\n  }, {\n    key: \"_setEnabled\",\n    value: function _setEnabled(enabled) {\n      this._setProperty('enabled', enabled);\n\n      if (this.initialized) {\n        this.recomputeEnabled();\n      }\n    }\n  }, {\n    key: \"recomputeEnabled\",\n    value: function recomputeEnabled(parentEnabled) {\n      if (parentEnabled === undefined) {\n        parentEnabled = true;\n\n        if (this.parent && this.parent.initialized && this.parent.enabledComputed !== undefined) {\n          parentEnabled = this.parent.enabledComputed;\n        }\n      }\n\n      var enabledComputed = this._computeEnabled(this.inheritAccessibility, parentEnabled);\n\n      this._updateEnabledComputed(enabledComputed);\n    }\n  }, {\n    key: \"_updateEnabledComputed\",\n    value: function _updateEnabledComputed(enabledComputed, enabledComputedForChildren) {\n      if (this.enabledComputed === enabledComputed && enabledComputedForChildren === undefined) {\n        // no change for this instance. there is no need to propagate to children\n        // exception: the enabledComputed for the children differs from the one for me. In this case the propagation is necessary.\n        return;\n      }\n\n      this.setProperty('enabledComputed', enabledComputed); // Manually call _renderEnabled(), because _renderEnabledComputed() does not exist\n\n      if (this.rendered) {\n        this._renderEnabled();\n      }\n\n      var computedStateForChildren = scout.nvl(enabledComputedForChildren, enabledComputed);\n      this.children.forEach(function (child) {\n        if (child.inheritAccessibility) {\n          child.recomputeEnabled(computedStateForChildren);\n        }\n      });\n    }\n  }, {\n    key: \"_computeEnabled\",\n    value: function _computeEnabled(inheritAccessibility, parentEnabled) {\n      return this.enabled && (inheritAccessibility ? parentEnabled : true);\n    }\n  }, {\n    key: \"_renderEnabled\",\n    value: function _renderEnabled() {\n      if (!this.$container) {\n        return;\n      }\n\n      this.$container.setEnabled(this.enabledComputed);\n\n      this._renderDisabledStyle();\n    }\n  }, {\n    key: \"setInheritAccessibility\",\n    value: function setInheritAccessibility(inheritAccessibility) {\n      this.setProperty('inheritAccessibility', inheritAccessibility);\n    }\n  }, {\n    key: \"_setInheritAccessibility\",\n    value: function _setInheritAccessibility(inheritAccessibility) {\n      this._setProperty('inheritAccessibility', inheritAccessibility);\n\n      if (this.initialized) {\n        this.recomputeEnabled();\n      }\n    }\n  }, {\n    key: \"setDisabledStyle\",\n    value: function setDisabledStyle(disabledStyle) {\n      this.setProperty('disabledStyle', disabledStyle);\n      this.children.forEach(function (child) {\n        child.setDisabledStyle(disabledStyle);\n      });\n    }\n  }, {\n    key: \"_renderDisabledStyle\",\n    value: function _renderDisabledStyle() {\n      this._renderDisabledStyleInternal(this.$container);\n    }\n    /**\n     * This function is used by subclasses to render the read-only class for a given $field.\n     * Some fields like DateField have two input fields and thus cannot use the this.$field property.\n     */\n\n  }, {\n    key: \"_renderDisabledStyleInternal\",\n    value: function _renderDisabledStyleInternal($element) {\n      if (!$element) {\n        return;\n      }\n\n      if (this.enabledComputed) {\n        $element.removeClass('read-only');\n      } else {\n        $element.toggleClass('read-only', this.disabledStyle === Widget.DisabledStyle.READ_ONLY);\n      }\n    }\n    /**\n     * @param {boolean} visible true, to make the widget visible, false to hide it\n     */\n\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      this.setProperty('visible', visible);\n    }\n    /**\n     * @returns {boolean} whether the widget is visible or not. May depend on other conditions than the visible property only\n     */\n\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return this.visible;\n    }\n  }, {\n    key: \"_renderVisible\",\n    value: function _renderVisible() {\n      if (!this.$container) {\n        return;\n      }\n\n      this.$container.setVisible(this.isVisible());\n      this.invalidateParentLogicalGrid();\n    }\n    /**\n     * @returns {boolean} true if every parent within the hierarchy is visible.\n     */\n\n  }, {\n    key: \"isEveryParentVisible\",\n    value: function isEveryParentVisible() {\n      var parent = this.parent;\n\n      while (parent) {\n        if (!parent.isVisible()) {\n          return false;\n        }\n\n        parent = parent.parent;\n      }\n\n      return true;\n    }\n    /**\n     * This function does not set the focus to the field. It toggles the 'focused' class on the field container if present.\n     * Objects using widget as prototype must call this function onBlur and onFocus to ensure the class gets toggled.\n     *\n     *  Use Widget.focus to set the focus to the widget.\n     */\n\n  }, {\n    key: \"setFocused\",\n    value: function setFocused(focused) {\n      this.setProperty('focused', focused);\n    }\n  }, {\n    key: \"_renderFocused\",\n    value: function _renderFocused() {\n      if (this.$container) {\n        this.$container.toggleClass('focused', this.focused);\n      }\n    }\n  }, {\n    key: \"_setCssClass\",\n    value: function _setCssClass(cssClass) {\n      if (this.rendered) {\n        this._removeCssClass();\n      }\n\n      this._setProperty('cssClass', cssClass);\n    }\n  }, {\n    key: \"_removeCssClass\",\n    value: function _removeCssClass() {\n      if (!this.$container) {\n        return;\n      }\n\n      this.$container.removeClass(this.cssClass);\n    }\n  }, {\n    key: \"_renderCssClass\",\n    value: function _renderCssClass() {\n      if (!this.$container) {\n        return;\n      }\n\n      this.$container.addClass(this.cssClass);\n    }\n  }, {\n    key: \"setCssClass\",\n    value: function setCssClass(cssClass) {\n      this.setProperty('cssClass', cssClass);\n    }\n  }, {\n    key: \"addCssClass\",\n    value: function addCssClass(cssClass) {\n      var cssClasses = this.cssClassAsArray();\n      var cssClassesToAdd = Widget.cssClassAsArray(cssClass);\n      cssClassesToAdd.forEach(function (newCssClass) {\n        if (cssClasses.indexOf(newCssClass) >= 0) {\n          return;\n        }\n\n        cssClasses.push(newCssClass);\n      }, this);\n      this.setProperty('cssClass', arrays.format(cssClasses, ' '));\n    }\n  }, {\n    key: \"removeCssClass\",\n    value: function removeCssClass(cssClass) {\n      var cssClasses = this.cssClassAsArray();\n      var cssClassesToRemove = Widget.cssClassAsArray(cssClass);\n\n      if (arrays.removeAll(cssClasses, cssClassesToRemove)) {\n        this.setProperty('cssClass', arrays.format(cssClasses, ' '));\n      }\n    }\n  }, {\n    key: \"toggleCssClass\",\n    value: function toggleCssClass(cssClass, condition) {\n      if (condition) {\n        this.addCssClass(cssClass);\n      } else {\n        this.removeCssClass(cssClass);\n      }\n    }\n  }, {\n    key: \"cssClassAsArray\",\n    value: function cssClassAsArray() {\n      return Widget.cssClassAsArray(this.cssClass);\n    }\n    /**\n     * Creates nothing by default. If a widget needs loading support, override this method and return a loading support.\n     * @returns {LoadingSupport}\n     */\n\n  }, {\n    key: \"_createLoadingSupport\",\n    value: function _createLoadingSupport() {\n      return null;\n    }\n  }, {\n    key: \"setLoading\",\n    value: function setLoading(loading) {\n      this.setProperty('loading', loading);\n    }\n  }, {\n    key: \"isLoading\",\n    value: function isLoading() {\n      return this.loading;\n    }\n  }, {\n    key: \"_renderLoading\",\n    value: function _renderLoading() {\n      if (!this.loadingSupport) {\n        return;\n      }\n\n      this.loadingSupport.renderLoading();\n    } // --- Layouting / HtmlComponent methods ---\n\n  }, {\n    key: \"pack\",\n    value: function pack() {\n      if (!this.rendered || this.removing) {\n        return;\n      }\n\n      if (!this.htmlComp) {\n        throw new Error('Function expects a htmlComp property');\n      }\n\n      this.htmlComp.pack();\n    }\n  }, {\n    key: \"invalidateLayout\",\n    value: function invalidateLayout() {\n      if (!this.rendered || this.removing) {\n        return;\n      }\n\n      if (!this.htmlComp) {\n        throw new Error('Function expects a htmlComp property');\n      }\n\n      this.htmlComp.invalidateLayout();\n    }\n  }, {\n    key: \"validateLayout\",\n    value: function validateLayout() {\n      if (!this.rendered || this.removing) {\n        return;\n      }\n\n      if (!this.htmlComp) {\n        throw new Error('Function expects a htmlComp property');\n      }\n\n      this.htmlComp.validateLayout();\n    }\n  }, {\n    key: \"revalidateLayout\",\n    value: function revalidateLayout() {\n      if (!this.rendered || this.removing) {\n        return;\n      }\n\n      if (!this.htmlComp) {\n        throw new Error('Function expects a htmlComp property');\n      }\n\n      this.htmlComp.revalidateLayout();\n    }\n    /**\n     * @param [invalidateParents] optional, default is true\n     */\n\n  }, {\n    key: \"invalidateLayoutTree\",\n    value: function invalidateLayoutTree(invalidateParents) {\n      if (!this.rendered || this.removing) {\n        return;\n      }\n\n      if (!this.htmlComp) {\n        throw new Error('Function expects a htmlComp property');\n      }\n\n      this.htmlComp.invalidateLayoutTree(invalidateParents);\n    }\n  }, {\n    key: \"validateLayoutTree\",\n    value: function validateLayoutTree() {\n      if (!this.rendered || this.removing) {\n        return;\n      }\n\n      if (!this.htmlComp) {\n        throw new Error('Function expects a htmlComp property');\n      }\n\n      this.htmlComp.validateLayoutTree();\n    }\n  }, {\n    key: \"revalidateLayoutTree\",\n    value: function revalidateLayoutTree(invalidateParents) {\n      if (!this.rendered || this.removing) {\n        return;\n      }\n\n      if (!this.htmlComp) {\n        throw new Error('Function expects a htmlComp property');\n      }\n\n      this.htmlComp.revalidateLayoutTree(invalidateParents);\n    }\n    /**\n     * The layout data contains hints for the layout of the parent container to layout this individual child widget inside the container.<br>\n     * Note: this is not the same as the LayoutConfig. The LayoutConfig contains constraints for the layout itself and is therefore set on the parent container directly.\n     * <p>\n     * Example: The parent container uses a LogicalGridLayout to layout its children. Every child has a LogicalGridLayoutData to tell the layout how this specific child should be layouted.\n     * The parent may have a LogicalGridLayoutConfig to specify constraints which affect either only the container or every child in the container.\n     */\n\n  }, {\n    key: \"setLayoutData\",\n    value: function setLayoutData(layoutData) {\n      if (!this.rendered) {\n        return;\n      }\n\n      if (!this.htmlComp) {\n        throw new Error('Function expects a htmlComp property');\n      }\n\n      this.htmlComp.layoutData = layoutData;\n    }\n    /**\n     * If the widget uses a logical grid layout, the grid may be validated using this method.\n     * <p>\n     * If the grid is not dirty, nothing happens.\n     */\n\n  }, {\n    key: \"validateLogicalGrid\",\n    value: function validateLogicalGrid() {\n      if (this.logicalGrid) {\n        this.logicalGrid.validate(this);\n      }\n    }\n    /**\n     * Marks the logical grid as dirty.<br>\n     * Does nothing, if there is no logical grid.\n     * @param {boolean} [invalidateLayout] true, to invalidate the layout afterwards, false if not. Default is true.\n     */\n\n  }, {\n    key: \"invalidateLogicalGrid\",\n    value: function invalidateLogicalGrid(invalidateLayout) {\n      if (!this.initialized) {\n        return;\n      }\n\n      if (!this.logicalGrid) {\n        return;\n      }\n\n      this.logicalGrid.setDirty(true);\n\n      if (scout.nvl(invalidateLayout, true)) {\n        this.invalidateLayoutTree();\n      }\n    }\n    /**\n     * Invalidates the logical grid of the parent widget. Typically done when the visibility of the widget changes.\n     * @param {boolean} [invalidateLayout] true, to invalidate the layout of the parent of this.htmlComp, false if not. Default is true.\n     */\n\n  }, {\n    key: \"invalidateParentLogicalGrid\",\n    value: function invalidateParentLogicalGrid(invalidateLayout) {\n      this.parent.invalidateLogicalGrid(false);\n\n      if (!this.rendered || !this.htmlComp) {\n        return;\n      }\n\n      if (scout.nvl(invalidateLayout, true)) {\n        var htmlCompParent = this.htmlComp.getParent();\n\n        if (htmlCompParent) {\n          htmlCompParent.invalidateLayoutTree();\n        }\n      }\n    }\n  }, {\n    key: \"revalidateLogicalGrid\",\n    value: function revalidateLogicalGrid(invalidateLayout) {\n      this.invalidateLogicalGrid(invalidateLayout);\n      this.validateLogicalGrid();\n    }\n  }, {\n    key: \"setLogicalGrid\",\n    value: function setLogicalGrid(logicalGrid) {\n      this.setProperty('logicalGrid', logicalGrid);\n    }\n    /**\n     * @param logicalGrid an instance of {@link LogicalGrid} or a string representing the object type of a logical grid.\n     */\n\n  }, {\n    key: \"_setLogicalGrid\",\n    value: function _setLogicalGrid(logicalGrid) {\n      if (typeof logicalGrid === 'string') {\n        logicalGrid = scout.create(logicalGrid);\n      }\n\n      this._setProperty('logicalGrid', logicalGrid);\n\n      this.invalidateLogicalGrid();\n    } // --- Event handling methods ---\n\n  }, {\n    key: \"_createEventSupport\",\n    value: function _createEventSupport() {\n      return new EventSupport();\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(type, event) {\n      event = event || {};\n      event.source = this;\n      this.events.trigger(type, event);\n    }\n  }, {\n    key: \"one\",\n    value: function one(type, func) {\n      this.events.one(type, func);\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, func) {\n      return this.events.on(type, func);\n    }\n  }, {\n    key: \"off\",\n    value: function off(type, func) {\n      this.events.off(type, func);\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener(listener) {\n      this.events.addListener(listener);\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(listener) {\n      this.events.removeListener(listener);\n    }\n    /**\n     * Adds an event handler using {@link #one()} and returns a promise.\n     * The promise is resolved as soon as the event is triggered.\n     */\n\n  }, {\n    key: \"when\",\n    value: function when(type) {\n      return this.events.when(type);\n    }\n    /**\n     * @returns {$} the entry-point for this Widget or its parent. If the widget is part of the main-window it returns this.session.$entryPoint,\n     * for popup-window this function will return the body of the document in the popup window.\n     */\n\n  }, {\n    key: \"entryPoint\",\n    value: function entryPoint() {\n      var $element = scout.nvl(this.$container, this.parent.$container);\n\n      if (!$element || !$element.length) {\n        throw new Error('Cannot resolve entryPoint, $element.length is 0 or undefined');\n      }\n\n      return $element.entryPoint();\n    }\n  }, {\n    key: \"window\",\n    value: function window(domElement) {\n      var $el = this.$container || this.$parent;\n      return $el ? $el.window(domElement) : domElement ? null : $(null);\n    }\n  }, {\n    key: \"document\",\n    value: function document(domElement) {\n      var $el = this.$container || this.$parent;\n      return $el ? $el.document(domElement) : domElement ? null : $(null);\n    }\n    /**\n     * This method attaches the detached $container to the DOM.\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach() {\n      if (this.attached || !this.rendered) {\n        return;\n      }\n\n      this._attach();\n\n      this._installFocusContext();\n\n      this.restoreFocus();\n      this.attached = true;\n\n      this._postAttach();\n\n      this._onAttach();\n\n      this._triggerChildrenOnAttach(this);\n    }\n    /**\n     * Override this method to do something when Widget is attached again. Typically\n     * you will append this.$container to this.$parent.\n     *\n     * @param the event.target property is used to decide if a Widget must attach\n     *   its $container. When the parent of the Widget already attaches, the Widget\n     *   itself must _not_ attach its own $container. That's why we should only\n     *   attach when event.target is === this.\n     */\n\n  }, {\n    key: \"_attach\",\n    value: function _attach() {// NOP\n    }\n    /**\n     * Override this method to do something after this widget is attached.\n     * This function is not called on any child of the attached widget.\n     */\n\n  }, {\n    key: \"_postAttach\",\n    value: function _postAttach() {// NOP\n    }\n  }, {\n    key: \"_triggerChildrenOnAttach\",\n    value: function _triggerChildrenOnAttach(parent) {\n      this.children.forEach(function (child) {\n        child._onAttach();\n\n        child._triggerChildrenOnAttach(parent);\n      });\n    }\n    /**\n     * Override this method to do something after this widget or any parent of it is attached.\n     * This function is called whether or not the widget is rendered.\n     */\n\n  }, {\n    key: \"_onAttach\",\n    value: function _onAttach() {\n      if (this.rendered) {\n        this._renderOnAttach();\n      }\n    }\n    /**\n     * Override this method to do something after this widget or any parent of it is attached.\n     * This function is only called when this widget is rendered.\n     */\n\n  }, {\n    key: \"_renderOnAttach\",\n    value: function _renderOnAttach() {\n      this._renderScrollTop();\n\n      this._renderScrollLeft();\n    }\n    /**\n     * This method calls detach() on all child-widgets. It is used to store some data\n     * before a DOM element is detached and propagate the detach \"event\" to all child-\n     * widgets, because when a DOM element is detached - child elements are not notified\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this.rendering) {\n        // Defer the execution of detach. If it was detached while rendering the attached flag would be wrong.\n        this._postRenderActions.push(this.detach.bind(this));\n      }\n\n      if (!this.attached || !this.rendered || this._isRemovalPending()) {\n        return;\n      }\n\n      this._beforeDetach();\n\n      this._onDetach();\n\n      this._triggerChildrenOnDetach(this);\n\n      this._detach();\n\n      this.attached = false;\n    }\n    /**\n     * This function is called before a widget gets detached. The function is only called on the detached widget and NOT on\n     * any of its children.\n     */\n\n  }, {\n    key: \"_beforeDetach\",\n    value: function _beforeDetach(parent) {\n      if (!this.$container) {\n        return;\n      }\n\n      var activeElement = this.$container.document(true).activeElement;\n      var isFocused = this.$container.isOrHas(activeElement);\n      var focusManager = this.session.focusManager;\n\n      if (focusManager.isFocusContextInstalled(this.$container)) {\n        this._uninstallFocusContext();\n      } else if (isFocused) {\n        // exclude the container or any of its child elements to gain focus\n        focusManager.validateFocus(filters.outsideFilter(this.$container));\n      }\n    }\n  }, {\n    key: \"_triggerChildrenOnDetach\",\n    value: function _triggerChildrenOnDetach() {\n      this.children.forEach(function (child) {\n        child._onDetach();\n\n        child._triggerChildrenOnDetach(parent);\n      });\n    }\n    /**\n     * This function is called before a widget or any of its parent getting detached.\n     * This function is thought to be overridden.\n     */\n\n  }, {\n    key: \"_onDetach\",\n    value: function _onDetach() {\n      if (this.rendered) {\n        this._renderOnDetach();\n      }\n    }\n  }, {\n    key: \"_renderOnDetach\",\n    value: function _renderOnDetach() {// NOP\n    }\n    /**\n     * Override this method to do something when Widget is detached. Typically you\n     * will call this.$container.detach(). The default\n     * implementation sets this.attached to false.\n     */\n\n  }, {\n    key: \"_detach\",\n    value: function _detach() {}\n  }, {\n    key: \"_uninstallFocusContext\",\n    value: function _uninstallFocusContext() {// NOP\n    }\n  }, {\n    key: \"_installFocusContext\",\n    value: function _installFocusContext() {// NOP\n    }\n    /**\n     * Does nothing by default. If a widget needs keystroke support override this method and return a keystroke context, e.g. the default KeyStrokeContext.\n     * @returns {KeyStrokeContext}\n     */\n\n  }, {\n    key: \"_createKeyStrokeContext\",\n    value: function _createKeyStrokeContext() {\n      return null;\n    }\n  }, {\n    key: \"updateKeyStrokes\",\n    value: function updateKeyStrokes(newKeyStrokes, oldKeyStrokes) {\n      this.unregisterKeyStrokes(oldKeyStrokes);\n      this.registerKeyStrokes(newKeyStrokes);\n    }\n  }, {\n    key: \"registerKeyStrokes\",\n    value: function registerKeyStrokes(keyStrokes) {\n      this.keyStrokeContext.registerKeyStrokes(keyStrokes);\n    }\n  }, {\n    key: \"unregisterKeyStrokes\",\n    value: function unregisterKeyStrokes(keyStrokes) {\n      this.keyStrokeContext.unregisterKeyStrokes(keyStrokes);\n    }\n    /**\n     * Triggers a property change for a single property. The event is only triggered when\n     * old and new value are the same.\n     */\n\n  }, {\n    key: \"triggerPropertyChange\",\n    value: function triggerPropertyChange(propertyName, oldValue, newValue) {\n      scout.assertParameter('propertyName', propertyName);\n      var event = new Event({\n        propertyName: propertyName,\n        oldValue: oldValue,\n        newValue: newValue\n      });\n      this.trigger('propertyChange', event);\n      return event;\n    }\n    /**\n     * Sets the value of the property 'propertyName' to 'newValue' and then fires a propertyChange event for that property.\n     */\n\n  }, {\n    key: \"_setProperty\",\n    value: function _setProperty(propertyName, newValue) {\n      scout.assertParameter('propertyName', propertyName);\n      var oldValue = this[propertyName];\n\n      if (objects.equals(oldValue, newValue)) {\n        return;\n      }\n\n      this[propertyName] = newValue;\n      var event = this.triggerPropertyChange(propertyName, oldValue, newValue);\n\n      if (event.defaultPrevented) {\n        // Revert to old value if property change should be prevented\n        this[propertyName] = oldValue;\n      }\n    }\n    /**\n     * Sets a new value for a specific property. If the new value is the same value as the old one, nothing is performed.\n     * Otherwise the following phases are executed:\n     * <p>\n     * 1. Preparation: If the property is a widget property, several actions are performed in _prepareWidgetProperty().\n     * 2. DOM removal: If the property is a widget property and the widget is rendered, the changed widget(s) are removed unless the property should not be preserved (see _preserveOnPropertyChangeProperties).\n     *    If there is a custom remove function (e.g. _removeXY where XY is the property name), it will be called instead of removing the widgets directly.\n     * 3. Model update: If there is a custom set function (e.g. _setXY where XY is the property name), it will be called. Otherwise the default set function _setProperty is called.\n     * 4. DOM rendering: If the widget is rendered and there is a custom render function (e.g. _renderXY where XY is the property name), it will be called. Otherwise nothing happens.\n     */\n\n  }, {\n    key: \"setProperty\",\n    value: function setProperty(propertyName, value) {\n      if (objects.equals(this[propertyName], value)) {\n        return;\n      }\n\n      value = this._prepareProperty(propertyName, value);\n\n      if (this.rendered) {\n        this._callRemoveProperty(propertyName);\n      }\n\n      this._callSetProperty(propertyName, value);\n\n      if (this.rendered) {\n        this._callRenderProperty(propertyName);\n      }\n    }\n  }, {\n    key: \"_prepareProperty\",\n    value: function _prepareProperty(propertyName, value) {\n      if (!this.isWidgetProperty(propertyName)) {\n        return value;\n      }\n\n      return this._prepareWidgetProperty(propertyName, value);\n    }\n  }, {\n    key: \"_prepareWidgetProperty\",\n    value: function _prepareWidgetProperty(propertyName, widgets) {\n      // Create new child widget(s)\n      widgets = this._createChildren(widgets);\n      var oldWidgets = this[propertyName];\n\n      if (oldWidgets && Array.isArray(widgets)) {\n        // If new value is an array, old value has to be one as well\n        // Only destroy those which are not in the new array\n        oldWidgets = arrays.diff(oldWidgets, widgets);\n      }\n\n      if (!this.isPreserveOnPropertyChangeProperty(propertyName)) {\n        // Destroy old child widget(s)\n        this._destroyChildren(oldWidgets); // Link to new parent\n\n\n        this.link(widgets);\n      }\n\n      return widgets;\n    }\n    /**\n     * Does nothing if the property is not a widget property.<p>\n     * If it is a widget property, it removes the existing widgets. Render has to be implemented by the widget itself.\n     */\n\n  }, {\n    key: \"_callRemoveProperty\",\n    value: function _callRemoveProperty(propertyName) {\n      if (!this.isWidgetProperty(propertyName)) {\n        return;\n      }\n\n      if (this.isPreserveOnPropertyChangeProperty(propertyName)) {\n        return;\n      }\n\n      var widgets = this[propertyName];\n\n      if (!widgets) {\n        return;\n      }\n\n      var removeFuncName = '_remove' + strings.toUpperCaseFirstLetter(propertyName);\n\n      if (this[removeFuncName]) {\n        this[removeFuncName]();\n      } else {\n        this._internalRemoveWidgets(widgets);\n      }\n    }\n    /**\n     * Removes the given widgets\n     */\n\n  }, {\n    key: \"_internalRemoveWidgets\",\n    value: function _internalRemoveWidgets(widgets) {\n      widgets = arrays.ensure(widgets);\n      widgets.forEach(function (widget) {\n        widget.remove();\n      });\n    }\n  }, {\n    key: \"_callSetProperty\",\n    value: function _callSetProperty(propertyName, value) {\n      var setFuncName = '_set' + strings.toUpperCaseFirstLetter(propertyName);\n\n      if (this[setFuncName]) {\n        this[setFuncName](value);\n      } else {\n        this._setProperty(propertyName, value);\n      }\n    }\n  }, {\n    key: \"_callRenderProperty\",\n    value: function _callRenderProperty(propertyName) {\n      var renderFuncName = '_render' + strings.toUpperCaseFirstLetter(propertyName);\n\n      if (!this[renderFuncName]) {\n        return;\n      }\n\n      this[renderFuncName]();\n    }\n    /**\n     * Sets this widget as parent of the given widget(s).\n     *\n     * @param widgets may be a widget or array of widgets\n     */\n\n  }, {\n    key: \"link\",\n    value: function link(widgets) {\n      if (!widgets) {\n        return;\n      }\n\n      widgets = arrays.ensure(widgets);\n      widgets.forEach(function (child, i) {\n        child.setParent(this);\n      }, this);\n    }\n    /**\n     * Method required for widgets which are supposed to be directly covered by a glasspane.<p>\n     *\n     * Returns the DOM elements to paint a glassPanes over, once a modal Form, message-box or file-chooser is shown with this widget as its 'displayParent'.<br>\n     * If the widget is not rendered yet, a scout.DeferredGlassPaneTarget is returned.<br>\n     * In both cases the method _glassPaneTargets is called which may be overridden by the actual widget.\n     */\n\n  }, {\n    key: \"glassPaneTargets\",\n    value: function glassPaneTargets(element) {\n      var resolveGlassPanes = function (element) {\n        // contributions\n        var targets = arrays.flatMap(this._glassPaneContributions, function (cont) {\n          var $elements = cont(element);\n\n          if ($elements) {\n            return arrays.ensure($elements);\n          }\n\n          return [];\n        });\n        return targets.concat(this._glassPaneTargets(element));\n      }.bind(this);\n\n      if (this.rendered) {\n        return resolveGlassPanes(element);\n      }\n\n      return DeferredGlassPaneTarget.createFor(this, resolveGlassPanes.bind(this, element));\n    }\n  }, {\n    key: \"_glassPaneTargets\",\n    value: function _glassPaneTargets(element) {\n      // since popups are rendered outside the DOM of the widget parent-child hierarchy, get glassPaneTargets of popups belonging to this widget separately.\n      return [this.$container].concat(this.session.desktop.getPopupsFor(this).reduce(function (acc, popup) {\n        return acc.concat(popup.glassPaneTargets());\n      }, []));\n    }\n  }, {\n    key: \"addGlassPaneContribution\",\n    value: function addGlassPaneContribution(contribution) {\n      this._glassPaneContributions.push(contribution);\n\n      this.trigger('glassPaneContributionAdded', {\n        contribution: contribution\n      });\n    }\n    /**\n     * @param [contribution] a function which returns glass pane targets (jQuery elements)\n     */\n\n  }, {\n    key: \"removeGlassPaneContribution\",\n    value: function removeGlassPaneContribution(contribution) {\n      arrays.remove(this._glassPaneContributions, contribution);\n      this.trigger('glassPaneContributionRemoved', {\n        contribution: contribution\n      });\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var attrs = '';\n      attrs += 'id=' + this.id;\n      attrs += ' objectType=' + this.objectType;\n      attrs += ' rendered=' + this.rendered;\n\n      if (this.$container) {\n        attrs += ' $container=' + graphics.debugOutput(this.$container);\n      }\n\n      return 'Widget[' + attrs.trim() + ']';\n    }\n    /**\n     * Returns the ancestors as string delimited by '\\n'.\n     * @param [count] the number of ancestors to be processed. Default is -1 which means all.\n     */\n\n  }, {\n    key: \"ancestorsToString\",\n    value: function ancestorsToString(count) {\n      var str = '',\n          ancestors = this.ancestors();\n      count = scout.nvl(count, -1);\n      ancestors.some(function (ancestor, i) {\n        if (count > -1 && i >= count) {\n          return true;\n        }\n\n        if (i > 0 && i < ancestors.length - 1) {\n          str += '\\n';\n        }\n\n        str += ancestor.toString();\n        return false;\n      });\n      return str;\n    }\n  }, {\n    key: \"resolveTextKeys\",\n    value: function resolveTextKeys(properties) {\n      properties.forEach(function (property) {\n        texts.resolveTextProperty(this, property);\n      }, this);\n    }\n  }, {\n    key: \"resolveIconIds\",\n    value: function resolveIconIds(properties) {\n      properties.forEach(function (property) {\n        icons.resolveIconProperty(this, property);\n      }, this);\n    }\n  }, {\n    key: \"resolveConsts\",\n    value: function resolveConsts(configs) {\n      configs.forEach(function (config) {\n        objects.resolveConstProperty(this, config);\n      }, this);\n    }\n    /**\n     * A so called widget property is a property with a widget as value incl. automatic resolution of that widget.\n     * This means the property not only accepts the actual widget, but also a widget model or a widget reference (id)\n     * and then either creates a new widget based on the model or resolves the id and uses the referenced widget as value.\n     * Furthermore it will take care of its lifecycle which means, the widget will automatically be removed and destroyed (as long as the parent is also the owner).\n     * <p>\n     * If only the resolve operations without the lifecycle actions should be performed, you need to add the property to the list _preserveOnPropertyChangeProperties as well.\n     */\n\n  }, {\n    key: \"_addWidgetProperties\",\n    value: function _addWidgetProperties(properties) {\n      this._addProperties('_widgetProperties', properties);\n    }\n  }, {\n    key: \"isWidgetProperty\",\n    value: function isWidgetProperty(propertyName) {\n      return this._widgetProperties.indexOf(propertyName) > -1;\n    }\n  }, {\n    key: \"_addCloneProperties\",\n    value: function _addCloneProperties(properties) {\n      this._addProperties('_cloneProperties', properties);\n    }\n  }, {\n    key: \"isCloneProperty\",\n    value: function isCloneProperty(propertyName) {\n      return this._cloneProperties.indexOf(propertyName) > -1;\n    }\n    /**\n     * Properties in this list won't be affected by the automatic lifecycle actions performed for regular widget properties.\n     * This means, the widget won't be removed, destroyed and also not linked, which means the parent stays the same.\n     * But the resolve operations are still applied, as for regular widget properties.\n     * <p>\n     * The typical use case for such properties is referencing another widget without taking care of that widget.\n     */\n\n  }, {\n    key: \"_addPreserveOnPropertyChangeProperties\",\n    value: function _addPreserveOnPropertyChangeProperties(properties) {\n      this._addProperties('_preserveOnPropertyChangeProperties', properties);\n    }\n  }, {\n    key: \"isPreserveOnPropertyChangeProperty\",\n    value: function isPreserveOnPropertyChangeProperty(propertyName) {\n      return this._preserveOnPropertyChangeProperties.indexOf(propertyName) > -1;\n    }\n  }, {\n    key: \"_addProperties\",\n    value: function _addProperties(propertyName, properties) {\n      properties = arrays.ensure(properties);\n      properties.forEach(function (property) {\n        if (this[propertyName].indexOf(property) > -1) {\n          throw new Error(propertyName + ' already contains the property ' + property);\n        }\n\n        this[propertyName].push(property);\n      }, this);\n    }\n  }, {\n    key: \"_eachProperty\",\n    value: function _eachProperty(model, func) {\n      var propertyName, value, i; // Loop through primitive properties\n\n      for (propertyName in model) {\n        if (this._widgetProperties.indexOf(propertyName) > -1) {\n          continue; // will be handled below\n        }\n\n        value = model[propertyName];\n        func(propertyName, value);\n      } // Loop through adapter properties (any order will do).\n\n\n      for (i = 0; i < this._widgetProperties.length; i++) {\n        propertyName = this._widgetProperties[i];\n        value = model[propertyName];\n\n        if (value === undefined) {\n          continue;\n        }\n\n        func(propertyName, value, true);\n      }\n    }\n  }, {\n    key: \"_removeWidgetProperties\",\n    value: function _removeWidgetProperties(properties) {\n      if (Array.isArray(properties)) {\n        arrays.removeAll(this._widgetProperties, properties);\n      } else {\n        arrays.remove(this._widgetProperties, properties);\n      }\n    }\n    /**\n     * Clones the widget and mirrors the events, see this.clone() and this.mirror() for details.\n     */\n\n  }, {\n    key: \"cloneAndMirror\",\n    value: function cloneAndMirror(model) {\n      return this.clone(model, {\n        delegateAllPropertiesToClone: true\n      });\n    }\n    /**\n     * @returns {Widget} the original widget from which this one was cloned. If it is not a clone, itself is returned.\n     */\n\n  }, {\n    key: \"original\",\n    value: function original() {\n      var original = this;\n\n      while (original.cloneOf) {\n        original = original.cloneOf;\n      }\n\n      return original;\n    }\n    /**\n     * Clones the widget and returns the clone. Only the properties defined in this._cloneProperties are copied to the clone.\n     * The parameter model has to contain at least the property 'parent'.\n     *\n     * OPTION                          DEFAULT VALUE   DESCRIPTION\n     * --------------------------------------------------------------------------------------------------------\n     * delegatePropertiesToClone       []              An array of all properties to be delegated from the original\n     *                                                 to the to the clone when changed on the original widget.\n     *\n     * delegatePropertiesToOriginal    []              An array of all properties to be delegated from the clone\n     *                                                 to the original when changed on the clone widget.\n     *\n     * excludePropertiesToOriginal     []              An array of all properties to be excluded from delegating\n     *                                                 from the clone to the original in any cases.\n     *\n     * delegateEventsToOriginal        []              An array of all events to be delegated from the clone to\n     *                                                 the original when fired on the clone widget.\n     *\n     * delegateAllPropertiesToClone    false           True to delegate all property changes from the original to\n     *                                                 the clone.\n     *\n     * delegateAllPropertiesToOriginal false           True to delegate all property changes from the clone to\n     *                                                 the original.\n     *\n     * @param model The model used to create the clone is a combination of the clone properties and this model.\n     * Therefore this model may be used to override the cloned properties or to add additional properties.\n     * @param options Options used for the clone widgets. See above.\n     *\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone(model, options) {\n      var clone, cloneModel;\n      model = model || {};\n      options = options || {};\n      cloneModel = objects.extractProperties(this, model, this._cloneProperties);\n      clone = scout.create(this.objectType, cloneModel);\n      clone.cloneOf = this;\n\n      this._mirror(clone, options);\n\n      if (this.logicalGrid) {\n        // Create a new logical grid to make sure it does not influence the original widget\n        // This also creates the correct grid config for the specific widget\n        clone.setLogicalGrid(this.logicalGrid.objectType);\n      } else {\n        // Remove the grid if the original does not have one either\n        clone.setLogicalGrid(null);\n      }\n\n      return clone;\n    }\n  }, {\n    key: \"_deepCloneProperties\",\n    value: function _deepCloneProperties(clone, properties, options) {\n      if (!properties) {\n        return clone;\n      }\n\n      properties = arrays.ensure(properties);\n      properties.forEach(function (property) {\n        var propertyValue = this[property],\n            clonedProperty = null;\n\n        if (propertyValue === undefined) {\n          throw new Error('Property \\'' + property + '\\' is undefined. Deep copy not possible.');\n        }\n\n        if (this._widgetProperties.indexOf(property) > -1) {\n          if (Array.isArray(propertyValue)) {\n            clonedProperty = propertyValue.map(function (val) {\n              return val.clone({\n                parent: clone\n              }, options);\n            });\n          } else {\n            clonedProperty = propertyValue.clone({\n              parent: clone\n            }, options);\n          }\n        } else if (Array.isArray(propertyValue)) {\n          clonedProperty = propertyValue.map(function (val) {\n            return val;\n          });\n        } else {\n          clonedProperty = propertyValue;\n        }\n\n        clone[property] = clonedProperty;\n      }.bind(this));\n    }\n    /**\n     * Delegates every property change event from the original widget to this cloned widget by calling the appropriate setter.\n     * If no target is set it works only if this widget is a clone.\n     */\n\n  }, {\n    key: \"mirror\",\n    value: function mirror(options, target) {\n      target = target || this.cloneOf;\n\n      if (!target) {\n        throw new Error('No target for mirroring.');\n      }\n\n      this._mirror(target, options);\n    }\n  }, {\n    key: \"_mirror\",\n    value: function _mirror(clone, options) {\n      var eventDelegator = arrays.find(this.eventDelegators, function (eventDelegator) {\n        return eventDelegator.clone === clone;\n      });\n\n      if (eventDelegator) {\n        throw new Error('_mirror can only be called on not mirrored widgets. call unmirror first.');\n      }\n\n      options = options || {};\n      eventDelegator = {\n        clone: clone,\n        originalToClone: EventDelegator.create(this, clone, {\n          delegateProperties: options.delegatePropertiesToClone,\n          delegateAllProperties: options.delegateAllPropertiesToClone\n        }),\n        cloneToOriginal: EventDelegator.create(clone, this, {\n          delegateProperties: options.delegatePropertiesToOriginal,\n          delegateAllProperties: options.delegateAllPropertiesToOriginal,\n          excludeProperties: options.excludePropertiesToOriginal,\n          delegateEvents: options.delegateEventsToOriginal\n        })\n      };\n      this.eventDelegators.push(eventDelegator);\n      clone.one('destroy', function () {\n        this._unmirror(clone);\n      }.bind(this));\n    }\n  }, {\n    key: \"unmirror\",\n    value: function unmirror(target) {\n      target = target || this.cloneOf;\n\n      if (!target) {\n        throw new Error('No target for unmirroring.');\n      }\n\n      this._unmirror(target);\n    }\n  }, {\n    key: \"_unmirror\",\n    value: function _unmirror(target) {\n      var eventDelegatorIndex = arrays.findIndex(this.eventDelegators, function (eventDelegator) {\n        return eventDelegator.clone === target;\n      }),\n          eventDelegator = eventDelegatorIndex > -1 ? this.eventDelegators.splice(eventDelegatorIndex, 1)[0] : null;\n\n      if (!eventDelegator) {\n        return;\n      }\n\n      if (eventDelegator.originalToClone) {\n        eventDelegator.originalToClone.destroy();\n      }\n\n      if (eventDelegator.cloneToOriginal) {\n        eventDelegator.cloneToOriginal.destroy();\n      }\n    }\n  }, {\n    key: \"_onParentDestroy\",\n    value: function _onParentDestroy(event) {\n      if (this.destroyed) {\n        return;\n      } // If the parent is destroyed but the widget not make sure it gets a new parent\n      // This ensures the old one may be properly garbage collected\n\n\n      this.setParent(this.owner);\n    }\n  }, {\n    key: \"callSetter\",\n    value: function callSetter(propertyName, value) {\n      var setterFuncName = 'set' + strings.toUpperCaseFirstLetter(propertyName);\n\n      if (this[setterFuncName]) {\n        this[setterFuncName](value);\n      } else {\n        this.setProperty(propertyName, value);\n      }\n    }\n    /**\n     * Traverses the object-tree (children) of this widget and searches for a widget with the given ID.\n     * Returns the widget with the requested ID or null if no widget has been found.\n     *\n     * @param widgetId\n     * @returns {Widget} the found widget for the given id\n     */\n\n  }, {\n    key: \"widget\",\n    value: function widget(widgetId) {\n      if (predicate(this)) {\n        return this;\n      }\n\n      return this.findChild(predicate);\n\n      function predicate(widget) {\n        if (widget.id === widgetId) {\n          return widget;\n        }\n      }\n    }\n    /**\n     * Similar to widget(), but uses \"breadth-first\" strategy, i.e. it checks all children of the\n     * same depth (level) before it advances to the next level. If multiple widgets with the same\n     * ID exist, the one with the smallest distance to this widget is returned.\n     *\n     * Example:\n     *\n     *    Widget ['MyWidget']                     #1\n     *    +- GroupBox ['LeftBox']                 #2\n     *       +- StringField ['NameField']         #3\n     *       +- StringField ['CityField']         #4\n     *       +- GroupBox ['InnerBox']             #5\n     *          +- GroupBox ['LeftBox']           #6\n     *             +- DateField ['StartDate']     #7\n     *          +- GroupBox ['RightBox']          #8\n     *             +- DateField ['EndDate']       #9\n     *    +- GroupBox ['RightBox']                #10\n     *       +- StringField ['NameField']         #11\n     *       +- DateField ['StartDate']           #12\n     *\n     *   CALL:                                    RESULT:\n     *   ---------------------------------------------------------------------------------------------\n     *   this.widget('RightBox')                  #8               (might not be the expected result)\n     *   this.nearestWidget('RightBox')           #10\n     *\n     *   this.widget('NameField')                 #3\n     *   this.nearestWidget('NameField')          null             (because no direct child has the requested id)\n     *   this.nearestWidget('NameField', true)    #3               (because #3 and #11 have the same distance)\n     *\n     *   this.widget('StartDate')                 #7\n     *   this.nearestWidget('StartDate', true)    #12              (#12 has smaller distance than #7)\n     *\n     * @param {string} widgetId\n     *          The ID of the widget to find.\n     * @param {boolean} deep\n     *          If false, only this widget and the next level are checked. This is the default.\n     *          If true, the entire tree is traversed.\n     * @return {Widget} the first found widget, or null if no widget was found.\n     */\n\n  }, {\n    key: \"nearestWidget\",\n    value: function nearestWidget(widgetId, deep) {\n      if (this.id === widgetId) {\n        return this;\n      }\n\n      var widgets = this.children.slice(); // list of widgets to check\n\n      while (widgets.length) {\n        var widget = widgets.shift();\n\n        if (widget.id === widgetId) {\n          return widget; // found\n        }\n\n        if (deep) {\n          for (var i = 0; i < widget.children.length; i++) {\n            var child = widget.children[i];\n\n            if (child.parent === widget) {\n              // same check as in visitChildren()\n              widgets.push(child);\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * @returns {Widget} the first parent for which the given function returns true.\n     */\n\n  }, {\n    key: \"findParent\",\n    value: function findParent(predicate) {\n      var parent = this.parent;\n\n      while (parent) {\n        if (predicate(parent)) {\n          return parent;\n        }\n\n        parent = parent.parent;\n      }\n\n      return parent;\n    }\n    /**\n     * @returns {Widget} the first child for which the given function returns true.\n     */\n\n  }, {\n    key: \"findChild\",\n    value: function findChild(predicate) {\n      var foundChild = null;\n      this.visitChildren(function (child) {\n        if (predicate(child)) {\n          foundChild = child;\n          return true;\n        }\n      });\n      return foundChild;\n    }\n  }, {\n    key: \"setTrackFocus\",\n    value: function setTrackFocus(trackFocus) {\n      this.setProperty('trackFocus', trackFocus);\n    }\n  }, {\n    key: \"_renderTrackFocus\",\n    value: function _renderTrackFocus() {\n      if (!this.$container) {\n        return;\n      }\n\n      if (this.trackFocus) {\n        this.$container.on('focusin', this._focusInListener);\n      } else {\n        this.$container.off('focusin', this._focusInListener);\n      }\n    }\n  }, {\n    key: \"restoreFocus\",\n    value: function restoreFocus() {\n      if (this._$lastFocusedElement) {\n        this.session.focusManager.requestFocus(this._$lastFocusedElement);\n      } else if (this._storedFocusedWidget) {\n        this._storedFocusedWidget.focus();\n\n        this._storedFocusedWidget = null;\n      }\n    }\n    /**\n     * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.\n     */\n\n  }, {\n    key: \"_onFocusIn\",\n    value: function _onFocusIn(event) {\n      // do not track focus events during rendering to avoid initial focus to be restored.\n      if (this.rendering) {\n        return;\n      }\n\n      var $target = $(event.target);\n\n      if (this.$container.has($target)) {\n        this._$lastFocusedElement = $target;\n      }\n    }\n    /**\n     * Tries to set the focus on the widget.\n     * <p>\n     * By default the focus is set on the container but this may vary from widget to widget.\n     * @returns {boolean} true if the element could be focused, false if not\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (!this.rendered) {\n        this.session.layoutValidator.schedulePostValidateFunction(this.focus.bind(this));\n        return false;\n      }\n\n      return this.session.focusManager.requestFocus(this.getFocusableElement());\n    }\n    /**\n     * Calls {@link focus()} and prevents the default behavior of the event if the focusing was successful.\n     */\n\n  }, {\n    key: \"focusAndPreventDefault\",\n    value: function focusAndPreventDefault(event) {\n      if (this.focus()) {\n        // Preventing blur is bad for touch devices because it prevents that the keyboard can close.\n        // In that case focus() will return false because focus manager is disabled.\n        event.preventDefault();\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @returns whether the widget is the currently active element\n     */\n\n  }, {\n    key: \"isFocused\",\n    value: function isFocused() {\n      return this.rendered && focusUtils.isActiveElement(this.getFocusableElement());\n    }\n    /**\n     * @return {boolean} true if the element is focusable, false if not.\n     */\n\n  }, {\n    key: \"isFocusable\",\n    value: function isFocusable() {\n      if (!this.rendered || !this.visible) {\n        return false;\n      }\n\n      var elem = this.getFocusableElement();\n\n      if (elem) {\n        return $.ensure(elem).is(':focusable');\n      }\n\n      return false;\n    }\n    /**\n     * This method returns the HtmlElement to be used when {@link #focus()} is called.\n     * It can be overridden, in case the widget needs to return something other than this.$container[0].\n     */\n\n  }, {\n    key: \"getFocusableElement\",\n    value: function getFocusableElement() {\n      if (this.rendered && this.$container) {\n        return this.$container[0];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_installScrollbars\",\n    value: function _installScrollbars(options) {\n      var $scrollable = this.get$Scrollable();\n\n      if (!$scrollable) {\n        throw new Error('Scrollable is not defined, cannot install scrollbars');\n      }\n\n      if ($scrollable.data('scrollable')) {\n        // already installed\n        return;\n      }\n\n      options = options || {};\n      var defaults = {\n        parent: this\n      };\n      options = $.extend({}, defaults, options);\n      scrollbars.install($scrollable, options);\n      $scrollable.on('scroll', this._scrollHandler);\n    }\n  }, {\n    key: \"_uninstallScrollbars\",\n    value: function _uninstallScrollbars() {\n      var $scrollable = this.get$Scrollable();\n\n      if (!$scrollable || !$scrollable.data('scrollable')) {\n        return;\n      }\n\n      scrollbars.uninstall($scrollable, this.session);\n      $scrollable.off('scroll', this._scrollHandler);\n\n      if (!this.removing) {\n        // If scrollbars are removed on the fly and not because the widget is removing, reset scroll positions to initial state\n        // Only reset if position is 0 to preserve the position (uninstalling does not reset the position of the scrollable either)\n        if ($scrollable[0].scrollTop === 0) {\n          this.scrollTop = null;\n        }\n\n        if ($scrollable[0].scrollLeft === 0) {\n          this.scrollLeft = null;\n        }\n      }\n    }\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll() {\n      var $scrollable = this.get$Scrollable();\n      this.scrollTop = $scrollable[0].scrollTop;\n      this.scrollLeft = $scrollable[0].scrollLeft;\n    }\n  }, {\n    key: \"setScrollTop\",\n    value: function setScrollTop(scrollTop) {\n      if (this.getDelegateScrollable()) {\n        this.getDelegateScrollable().setScrollTop(scrollTop);\n        return;\n      }\n\n      if (this.scrollTop === scrollTop) {\n        return;\n      }\n\n      this.scrollTop = scrollTop;\n\n      if (this.rendered) {\n        this._renderScrollTop();\n      }\n    }\n  }, {\n    key: \"_renderScrollTop\",\n    value: function _renderScrollTop() {\n      var $scrollable = this.get$Scrollable();\n\n      if (!$scrollable || this.scrollTop === null) {\n        // Don't do anything for non scrollable elements. Also, reading $scrollable[0].scrollTop must not be done while rendering because it would provoke a reflow\n        return;\n      }\n\n      if (this.rendering || this.htmlComp && !this.htmlComp.layouted && !this.htmlComp.layouting) {\n        // If the widget is not layouted yet (which is always true while rendering), the scroll position cannot be updated -> do it after the layout\n        // If scroll top is set while layouting, layout obviously wants to set it -> do it\n        this.session.layoutValidator.schedulePostValidateFunction(this._renderScrollTop.bind(this));\n        return;\n      }\n\n      scrollbars.scrollTop($scrollable, this.scrollTop);\n    }\n  }, {\n    key: \"setScrollLeft\",\n    value: function setScrollLeft(scrollLeft) {\n      if (this.getDelegateScrollable()) {\n        this.getDelegateScrollable().setScrollLeft(scrollLeft);\n        return;\n      }\n\n      if (this.scrollLeft === scrollLeft) {\n        return;\n      }\n\n      this.scrollLeft = scrollLeft;\n\n      if (this.rendered) {\n        this._renderScrollLeft();\n      }\n    }\n  }, {\n    key: \"_renderScrollLeft\",\n    value: function _renderScrollLeft() {\n      var $scrollable = this.get$Scrollable();\n\n      if (!$scrollable || this.scrollLeft === null) {\n        // Don't do anything for non scrollable elements. Also, reading $scrollable[0].scrollLeft must not be done while rendering because it would provoke a reflow\n        return;\n      }\n\n      if (this.rendering || this.htmlComp && !this.htmlComp.layouted && !this.htmlComp.layouting) {\n        // If the widget is not layouted yet (which is always true while rendering), the scroll position cannot be updated -> do it after the layout\n        // If scroll left is set while layouting, layout obviously wants to set it -> do it\n        this.session.layoutValidator.schedulePostValidateFunction(this._renderScrollLeft.bind(this));\n        return;\n      }\n\n      scrollbars.scrollLeft($scrollable, this.scrollLeft);\n    }\n    /**\n     * Returns the jQuery element which is supposed to be scrollable. This element will be used by the scroll functions like {@link #_installScrollbars}, {@link #setScrollTop}, {@link #setScrollLeft}, {@link #scrollToBottom} etc..\n     * The element won't be used unless {@link #_installScrollbars} is called.\n     * If the widget is mainly a wrapper for a scrollable widget and does not have a scrollable element by itself, you can use @{link #getDelegateScrollable} instead.\n     * @return {$}\n     */\n\n  }, {\n    key: \"get$Scrollable\",\n    value: function get$Scrollable() {\n      return this.$container;\n    }\n    /**\n     * If the widget is mainly a wrapper for another widget, it is often the case that the other widget is scrollable and not the wrapper.\n     * In that case implement this method and return the other widget so that the calls to the scroll functions can be delegated.\n     * @return {Widget}\n     */\n\n  }, {\n    key: \"getDelegateScrollable\",\n    value: function getDelegateScrollable() {\n      return null;\n    }\n  }, {\n    key: \"scrollToTop\",\n    value: function scrollToTop() {\n      if (this.getDelegateScrollable()) {\n        this.getDelegateScrollable().scrollToTop();\n        return;\n      }\n\n      var $scrollable = this.get$Scrollable();\n\n      if (!$scrollable) {\n        return;\n      }\n\n      if (!this.rendered) {\n        this.session.layoutValidator.schedulePostValidateFunction(this.scrollToTop.bind(this));\n        return;\n      }\n\n      scrollbars.scrollTop($scrollable, 0);\n    }\n  }, {\n    key: \"scrollToBottom\",\n    value: function scrollToBottom() {\n      if (this.getDelegateScrollable()) {\n        this.getDelegateScrollable().scrollToBottom();\n        return;\n      }\n\n      var $scrollable = this.get$Scrollable();\n\n      if (!$scrollable) {\n        return;\n      }\n\n      if (!this.rendered) {\n        this.session.layoutValidator.schedulePostValidateFunction(this.scrollToBottom.bind(this));\n        return;\n      }\n\n      scrollbars.scrollToBottom($scrollable);\n    }\n    /**\n     * Brings the widget into view by scrolling the first scrollable parent.\n     */\n\n  }, {\n    key: \"reveal\",\n    value: function reveal(options) {\n      if (!this.rendered) {\n        return;\n      }\n\n      var $scrollParent = this.$container.scrollParent();\n\n      if ($scrollParent.length === 0) {\n        // No scrollable parent found -> scrolling is not possible\n        return;\n      }\n\n      scrollbars.scrollTo($scrollParent, this.$container, options);\n    }\n    /**\n     * Visits every child of this widget in pre-order (top-down).<br>\n     * This widget itself is not visited! Only child widgets are visited recursively.\n     * <p>\n     * The children with a different parent are excluded.<br>\n     * This makes sure the child is not visited twice if the owner and the parent are not the same\n     * (in that case the widget would be in the children list of the owner and of the parent).\n     * <p>\n     * In order to abort visiting, the visitor can return true.\n     * @returns {boolean} true if the visitor aborted the visiting, false if the visiting completed without aborting\n     */\n\n  }, {\n    key: \"visitChildren\",\n    value: function visitChildren(visitor) {\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n\n        if (child.parent === this) {\n          var treeVisitResult = visitor(child);\n\n          if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n            // Visitor wants to abort the visiting\n            return TreeVisitResult.TERMINATE;\n          } else if (treeVisitResult !== TreeVisitResult.SKIP_SUBTREE) {\n            treeVisitResult = child.visitChildren(visitor);\n\n            if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n              return TreeVisitResult.TERMINATE;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * @returns {boolean} Whether or not the widget is rendered (or rendering) and the DOM $container isAttached()\n     */\n\n  }, {\n    key: \"isAttachedAndRendered\",\n    value: function isAttachedAndRendered() {\n      return (this.rendered || this.rendering) && this.$container.isAttached();\n    }\n    /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n    /**\n     * @deprecated use {@link widgets.get}\n     */\n\n  }], [{\n    key: \"getWidgetFor\",\n    value: function getWidgetFor($elem) {\n      return widgets.get($elem);\n    }\n  }, {\n    key: \"cssClassAsArray\",\n    value: function cssClassAsArray(cssClass) {\n      var cssClasses = [],\n          cssClassesStr = cssClass || '';\n      cssClassesStr = cssClassesStr.trim();\n\n      if (cssClassesStr.length > 0) {\n        cssClasses = cssClassesStr.split(' ');\n      }\n\n      return cssClasses;\n    }\n  }]);\n\n  return Widget;\n}();\n\n_defineProperty(Widget, \"DisabledStyle\", {\n  DEFAULT: 0,\n  READ_ONLY: 1\n});\n\nexport { Widget as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/widget/Widget.js"],"names":["arrays","DeferredGlassPaneTarget","Desktop","Device","Event","EventDelegator","EventSupport","filters","focusUtils","Form","graphics","icons","inspector","KeyStrokeContext","LoadingSupport","LogicalGrid","objects","scout","scrollbars","strings","texts","TreeVisitResult","widgets","$","Widget","session","owner","parent","children","initialized","rendering","removing","removalPending","rendered","attached","destroyed","destroying","enabled","enabledComputed","inheritAccessibility","disabledStyle","DisabledStyle","DEFAULT","visible","focused","loading","cssClass","scrollTop","scrollLeft","$container","animateRemoval","animateRemovalClass","_widgetProperties","_cloneProperties","eventDelegators","_preserveOnPropertyChangeProperties","_postRenderActions","_focusInListener","_onFocusIn","bind","_parentDestroyHandler","_onParentDestroy","_parentRemovingWhileAnimatingHandler","_onParentRemovingWhileAnimating","_scrollHandler","_onScroll","events","_createEventSupport","registerSubTypePredicate","event","propertyName","loadingSupport","_createLoadingSupport","keyStrokeContext","_createKeyStrokeContext","logicalGrid","trackFocus","_$lastFocusedElement","_storedFocusedWidget","_glassPaneContributions","model","staticModel","_jsonModel","extend","_prepareModel","_init","_initKeyStrokeContext","recomputeEnabled","trigger","Error","setOwner","setParent","_eachProperty","value","isWidgetProperty","undefined","_prepareWidgetProperty","_initProperty","_setCssClass","_setLogicalGrid","_setEnabled","models","Array","isArray","_createChild","forEach","i","existingWidget","widget","create","$scopeTarget","$bindTarget","_isRemovalPrevented","one","destroy","remove","_destroyChildren","slice","reverse","_destroy","_removeChild","off","ensure","_destroyChild","child","$parent","log","isTraceEnabled","trace","_render","_renderProperties","_renderInspectorInfo","_linkWithDOM","keyStrokeManager","installKeyStrokeContext","restoreFocus","_postRender","_renderTrackFocus","_renderEnabled","_renderVisible","_renderFocused","_renderCssClass","_renderLoading","_renderScrollTop","_renderScrollLeft","actions","action","_removeAnimated","_removeInternal","_isRemovalPending","_cleanup","_remove","get","supportsCssAnimation","isDisplayNone","desktop","destroyPopupsFor","setTimeout","isVisible","isEveryParentVisible","addClass","oneAnimationEnd","applyInfo","data","uninstallKeyStrokeContext","_uninstallScrollbars","layoutValidator","cleanupInvalidComponents","assertParameter","_addChild","isInfoEnabled","info","oldParent","pushSet","ancestors","push","has","findForm","findNonWrappedForm","findParent","updateParents","updateChildren","setProperty","setEnabled","visitChildren","field","_setProperty","parentEnabled","_computeEnabled","_updateEnabledComputed","enabledComputedForChildren","computedStateForChildren","nvl","_renderDisabledStyle","setDisabledStyle","_renderDisabledStyleInternal","$element","removeClass","toggleClass","READ_ONLY","setVisible","invalidateParentLogicalGrid","_removeCssClass","cssClasses","cssClassAsArray","cssClassesToAdd","newCssClass","indexOf","format","cssClassesToRemove","removeAll","condition","addCssClass","removeCssClass","renderLoading","htmlComp","pack","invalidateLayout","validateLayout","revalidateLayout","invalidateParents","invalidateLayoutTree","validateLayoutTree","revalidateLayoutTree","layoutData","validate","setDirty","invalidateLogicalGrid","htmlCompParent","getParent","validateLogicalGrid","type","source","func","on","listener","addListener","removeListener","when","length","entryPoint","domElement","$el","window","document","_attach","_installFocusContext","_postAttach","_onAttach","_triggerChildrenOnAttach","_renderOnAttach","detach","_beforeDetach","_onDetach","_triggerChildrenOnDetach","_detach","activeElement","isFocused","isOrHas","focusManager","isFocusContextInstalled","_uninstallFocusContext","validateFocus","outsideFilter","_renderOnDetach","newKeyStrokes","oldKeyStrokes","unregisterKeyStrokes","registerKeyStrokes","keyStrokes","oldValue","newValue","equals","triggerPropertyChange","defaultPrevented","_prepareProperty","_callRemoveProperty","_callSetProperty","_callRenderProperty","_createChildren","oldWidgets","diff","isPreserveOnPropertyChangeProperty","link","removeFuncName","toUpperCaseFirstLetter","_internalRemoveWidgets","setFuncName","renderFuncName","element","resolveGlassPanes","targets","flatMap","cont","$elements","concat","_glassPaneTargets","createFor","getPopupsFor","reduce","acc","popup","glassPaneTargets","contribution","attrs","id","objectType","debugOutput","trim","count","str","some","ancestor","toString","properties","property","resolveTextProperty","resolveIconProperty","configs","config","resolveConstProperty","_addProperties","clone","delegateAllPropertiesToClone","original","cloneOf","options","cloneModel","extractProperties","_mirror","setLogicalGrid","propertyValue","clonedProperty","map","val","target","eventDelegator","find","originalToClone","delegateProperties","delegatePropertiesToClone","delegateAllProperties","cloneToOriginal","delegatePropertiesToOriginal","delegateAllPropertiesToOriginal","excludeProperties","excludePropertiesToOriginal","delegateEvents","delegateEventsToOriginal","_unmirror","eventDelegatorIndex","findIndex","splice","setterFuncName","widgetId","predicate","findChild","deep","shift","foundChild","requestFocus","focus","$target","schedulePostValidateFunction","getFocusableElement","preventDefault","isActiveElement","elem","is","$scrollable","get$Scrollable","defaults","install","uninstall","getDelegateScrollable","setScrollTop","layouted","layouting","setScrollLeft","scrollToTop","scrollToBottom","$scrollParent","scrollParent","scrollTo","visitor","treeVisitResult","TERMINATE","SKIP_SUBTREE","isAttached","$elem","cssClassesStr","split"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  arrays,\n  DeferredGlassPaneTarget,\n  Desktop,\n  Device,\n  Event,\n  EventDelegator,\n  EventSupport,\n  filters,\n  focusUtils,\n  Form,\n  graphics,\n  icons,\n  inspector,\n  KeyStrokeContext,\n  LoadingSupport,\n  LogicalGrid,\n  objects,\n  scout,\n  scrollbars,\n  strings,\n  texts,\n  TreeVisitResult,\n  widgets\n} from '../index';\nimport $ from 'jquery';\n\nexport default class Widget {\n  constructor() {\n    this.session = null;\n\n    /**\n     * The owner is responsible that its children are destroyed when the owner is being destroyed.\n     */\n    this.owner = null;\n    /**\n     * The parent is typically the same as the owner.\n     * But the widget may be used by another widget (like a popup), in that case the parent will be changed to the popup but the owner stays the same.\n     * This means the popup is now the temporary parent, when the popup is destroyed its widgets are not because the popup is not the owner.\n     * Example: ViewMenuPopup uses the ViewButtons as menu items. These view buttons are owned by the desktop and must therefore not be destroyed\n     * when the popup closes, otherwise they could not be reused the second time the popup opens.\n     */\n    this.parent = null;\n    this.children = [];\n    this.initialized = false;\n\n    /**\n     * The 'rendering' flag is set the true while the _inital_ rendering is performed.\n     * It is used to to something different in a _render* method when the method is\n     * called for the first time.\n     */\n    this.rendering = false;\n    this.removing = false;\n    this.removalPending = false;\n\n    /**\n     * The 'rendered' flag is set the true when initial rendering of the widget is completed.\n     */\n    this.rendered = false;\n    this.attached = false;\n    this.destroyed = false;\n    this.destroying = false;\n\n    this.enabled = true;\n    /**\n     * The computed enabled state. The difference to the 'enabled' property is that this member\n     * also considers the enabled-states of the parent widgets.\n     */\n    this.enabledComputed = true;\n    this.inheritAccessibility = true;\n    this.disabledStyle = Widget.DisabledStyle.DEFAULT;\n    this.visible = true;\n    this.focused = false;\n    this.loading = false;\n    this.cssClass = null;\n    this.scrollTop = null;\n    this.scrollLeft = null;\n\n    this.$container;\n\n    // If set to true, remove won't remove the element immediately but after the animation has been finished\n    // This expects a css animation which may be triggered by the class 'animate-remove'\n    // If browser does not support css animation, remove will be executed immediately\n    this.animateRemoval = false;\n    this.animateRemovalClass = 'animate-remove';\n\n    this._widgetProperties = [];\n    this._cloneProperties = ['visible', 'enabled', 'inheritAccessibility', 'cssClass'];\n    this.eventDelegators = [];\n    this._preserveOnPropertyChangeProperties = [];\n    this._postRenderActions = [];\n    this._focusInListener = this._onFocusIn.bind(this);\n    this._parentDestroyHandler = this._onParentDestroy.bind(this);\n    this._parentRemovingWhileAnimatingHandler = this._onParentRemovingWhileAnimating.bind(this);\n    this._scrollHandler = this._onScroll.bind(this);\n    this.events = this._createEventSupport();\n    this.events.registerSubTypePredicate('propertyChange', function(event, propertyName) {\n      return event.propertyName === propertyName;\n    });\n    this.loadingSupport = this._createLoadingSupport();\n    this.keyStrokeContext = this._createKeyStrokeContext();\n    // Widgets using LogicalGridLayout may have a grid to calculate the grid data of the children\n    this.logicalGrid;\n\n    // focus tracking\n    this.trackFocus = false;\n    this._$lastFocusedElement = null;\n    this._storedFocusedWidget = null;\n\n    this._glassPaneContributions = [];\n  }\n\n  /**\n   * Enum used to define different styles used when the field is disabled.\n   */\n  static DisabledStyle = {\n    DEFAULT: 0,\n    READ_ONLY: 1\n  };\n\n  init(model) {\n    var staticModel = this._jsonModel();\n    if (staticModel) {\n      model = $.extend({}, staticModel, model);\n    }\n    model = model || {};\n    model = this._prepareModel(model);\n    this._init(model);\n    this._initKeyStrokeContext();\n    this.recomputeEnabled();\n    this.initialized = true;\n    this.trigger('init');\n  }\n\n  /**\n   * Default implementation simply returns the unmodified model. A Subclass\n   * may override this method to alter the JSON model before the widgets\n   * are created out of the widgetProperties in the model.\n   */\n  _prepareModel(model) {\n    return model;\n  }\n\n  /**\n   * @param options\n   * - parent (required): The parent widget\n   * - session (optional): If not specified the session of the parent is used\n   */\n  _init(model) {\n    if (!model.parent) {\n      throw new Error('Parent expected: ' + this);\n    }\n    this.setOwner(model.owner || model.parent);\n    this.setParent(model.parent);\n\n    this.session = model.session || this.parent.session;\n    if (!this.session) {\n      throw new Error('Session expected: ' + this);\n    }\n\n    this._eachProperty(model, function(propertyName, value, isWidgetProperty) {\n      if (value === undefined) {\n        // Don't set the value if it is undefined, compared to null which is allowed explicitly ($.extend works in the same way)\n        return;\n      }\n      if (isWidgetProperty) {\n        value = this._prepareWidgetProperty(propertyName, value);\n      }\n      this._initProperty(propertyName, value);\n    }.bind(this));\n\n    this._setCssClass(this.cssClass);\n    this._setLogicalGrid(this.logicalGrid);\n    this._setEnabled(this.enabled);\n  }\n\n  /**\n   * This function sets the property value. Override this function when you need special init behavior for certain properties.\n   * For instance you could not simply set the property value, but extend an already existing value.\n   */\n  _initProperty(propertyName, value) {\n    this[propertyName] = value;\n  }\n\n  /**\n   * Default implementation simply returns undefined. A Subclass\n   * may override this method to load or extend a JSON model with models.getModel or models.extend.\n   */\n  _jsonModel() {\n  }\n\n  /**\n   * Creates the widgets using the given models, or returns the widgets if the given models already are widgets.\n   * @returns {Widget[]|Widget}an array of created widgets if models was an array. Or the created widget if models is not an array.\n   */\n  _createChildren(models) {\n    if (!models) {\n      return null;\n    }\n\n    if (!Array.isArray(models)) {\n      return this._createChild(models);\n    }\n\n    var widgets = [];\n    models.forEach(function(model, i) {\n      widgets[i] = this._createChild(model);\n    }, this);\n    return widgets;\n  }\n\n  /**\n   * Calls {@link scout.create} for the given model, or if model is already a Widget simply returns the widget.\n   *\n   * @param model {Object|Widget}\n   * @returns {Widget}\n   */\n  _createChild(model) {\n    if (model instanceof Widget) {\n      return model;\n    }\n    if (typeof model === 'string') {\n      // Special case: If only an ID is supplied, try to (locally) resolve the corresponding widget\n      var existingWidget = this.widget(model);\n      if (!existingWidget) {\n        throw new Error('Referenced widget not found: ' + model);\n      }\n      return existingWidget;\n    }\n    model.parent = this;\n    return scout.create(model);\n  }\n\n  _initKeyStrokeContext() {\n    if (!this.keyStrokeContext) {\n      return;\n    }\n    this.keyStrokeContext.$scopeTarget = function() {\n      return this.$container;\n    }.bind(this);\n    this.keyStrokeContext.$bindTarget = function() {\n      return this.$container;\n    }.bind(this);\n  }\n\n  destroy() {\n    if (this.destroyed) {\n      // Already destroyed, do nothing\n      return;\n    }\n    this.destroying = true;\n    if (this.rendered && (this.animateRemoval || this._isRemovalPrevented())) {\n      // Do not destroy yet if the removal happens animated\n      // Also don't destroy if the removal is pending to keep the parent / child link until removal finishes\n      this.one('remove', function() {\n        this.destroy();\n      }.bind(this));\n      this.remove();\n      return;\n    }\n\n    // Destroy children in reverse order\n    this._destroyChildren(this.children.slice().reverse());\n    this.remove();\n    this._destroy();\n\n    // Disconnect from owner and parent\n    this.owner._removeChild(this);\n    this.owner = null;\n    this.parent._removeChild(this);\n    this.parent.off('destroy', this._parentDestroyHandler);\n    this.parent = null;\n\n    this.destroying = false;\n    this.destroyed = true;\n    this.trigger('destroy');\n  }\n\n  /**\n   * Override this function to do clean-up (like removing listeners) when the widget is destroyed.\n   * The default impl. does nothing.\n   */\n  _destroy() {\n    // NOP\n  }\n\n  /**\n   * @param widgets may be an object or array of objects\n   */\n  _destroyChildren(widgets) {\n    if (!widgets) {\n      return;\n    }\n\n    widgets = arrays.ensure(widgets);\n    widgets.forEach(function(widget, i) {\n      this._destroyChild(widget);\n    }, this);\n  }\n\n  _destroyChild(child) {\n    if (child.owner !== this) {\n      return;\n    }\n    child.destroy();\n  }\n\n  /**\n   * @param [$parent] The jQuery element which is used as $parent when rendering this widget.\n   * It will be put onto the widget and is therefore accessible as this.$parent in the _render method.\n   * If not specified, the $container of the parent is used.\n   */\n  render($parent) {\n    $.log.isTraceEnabled() && $.log.trace('Rendering widget: ' + this);\n    if (!this.initialized) {\n      throw new Error('Not initialized: ' + this);\n    }\n    if (this.rendered) {\n      throw new Error('Already rendered: ' + this);\n    }\n    if (this.destroyed) {\n      throw new Error('Widget is destroyed: ' + this);\n    }\n    this.rendering = true;\n    this.$parent = $parent || this.parent.$container;\n    this._render();\n    this._renderProperties();\n    this._renderInspectorInfo();\n    this._linkWithDOM();\n    this.session.keyStrokeManager.installKeyStrokeContext(this.keyStrokeContext);\n    this.rendering = false;\n    this.rendered = true;\n    this.attached = true;\n    this.trigger('render');\n    this.restoreFocus();\n    this._postRender();\n  }\n\n  /**\n   * This method creates the UI through DOM manipulation. At this point we should not apply model\n   * properties on the UI, since sub-classes may need to contribute to the DOM first. You must not\n   * apply model values to the UI here, since this is done in the _renderProperties method later.\n   * The default impl. does nothing.\n   */\n  _render() {\n    // NOP\n  }\n\n  /**\n   * This method calls the UI setter methods after the _render method has been executed.\n   * Here values of the model are applied to the DOM / UI.\n   */\n  _renderProperties() {\n    this._renderTrackFocus();\n    this._renderEnabled();\n    this._renderVisible();\n    this._renderFocused();\n    this._renderCssClass();\n    this._renderLoading();\n    this._renderScrollTop();\n    this._renderScrollLeft();\n  }\n\n  /**\n   * Method invoked once rendering completed and 'rendered' flag is set to 'true'.<p>\n   * By default executes every action of this._postRenderActions\n   */\n  _postRender() {\n    var actions = this._postRenderActions;\n    this._postRenderActions = [];\n    actions.forEach(function(action) {\n      action();\n    });\n  }\n\n  remove() {\n    if (!this.rendered || this._isRemovalPrevented()) {\n      return;\n    }\n    if (this.animateRemoval) {\n      this._removeAnimated();\n    } else {\n      this._removeInternal();\n    }\n  }\n\n  /**\n   * Will be called by {@link #remove()}. If true is returned, the widget won't be removed.<p>\n   * By default it just delegates to {@link #_isRemovalPending}. May be overridden to customize it.\n   */\n  _isRemovalPrevented() {\n    return this._isRemovalPending();\n  }\n\n  /**\n   * Returns true if the removal of this or an ancestor widget is pending. Checking the ancestor is omitted if the parent is being removed.\n   * This may be used to prevent a removal if an ancestor will be removed (e.g by an animation)\n   */\n  _isRemovalPending() {\n    if (this.removalPending) {\n      return true;\n    }\n    var parent = this.parent;\n    if (!parent || parent.removing || parent.rendering) {\n      // If parent is being removed or rendered, no need to check the ancestors because removing / rendering is already in progress\n      return false;\n    }\n    while (parent) {\n      if (parent.removalPending) {\n        return true;\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n\n  _removeInternal() {\n    if (!this.rendered) {\n      return;\n    }\n\n    $.log.isTraceEnabled() && $.log.trace('Removing widget: ' + this);\n    this.removing = true;\n    this.removalPending = false;\n    this.trigger('removing');\n    // transform last focused element into a scout widget\n    if (this.$container) {\n      this.$container.off('focusin', this._focusInListener);\n    }\n    if (this._$lastFocusedElement) {\n      this._storedFocusedWidget = scout.widget(this._$lastFocusedElement);\n      this._$lastFocusedElement = null;\n    }\n    // remove children in reverse order.\n    this.children.slice().reverse()\n      .forEach(function(child) {\n        // Only remove the child if this widget is the current parent (if that is not the case this widget is the owner)\n        if (child.parent === this) {\n          child.remove();\n        }\n      }, this);\n\n    if (!this.rendered) {\n      // The widget may have been removed already by one of the above remove() calls (e.g. by a remove listener)\n      // -> don't try to do it again, it might fail\n      return;\n    }\n    this._cleanup();\n    this._remove();\n    this.$parent = null;\n    this.rendered = false;\n    this.attached = false;\n    this.removing = false;\n    this.trigger('remove');\n  }\n\n  /**\n   * Adds class 'animate-remove' to container which can be used to trigger the animation.\n   * After the animation is executed, the element gets removed using this._removeInternal.\n   */\n  _removeAnimated() {\n    if (!Device.get().supportsCssAnimation() || !this.$container || this.$container.isDisplayNone()) {\n      // Cannot remove animated, remove regularly\n      this._removeInternal();\n      return;\n    }\n\n    // Destroy open popups first, they are not animated\n    this.session.desktop.destroyPopupsFor(this);\n\n    this.removalPending = true;\n    // Don't execute immediately to make sure nothing interferes with the animation (e.g. layouting) which could make it laggy\n    setTimeout(function() {\n      // check if the container has been removed in the meantime\n      if (!this.rendered) {\n        return;\n      }\n      if (!this.animateRemovalClass) {\n        throw new Error('Missing animate removal class. Cannot remove animated.');\n      }\n      if (!this.$container.isVisible() || !this.$container.isEveryParentVisible()) {\n        // If element is not visible, animationEnd would never fire -> remove it immediately\n        this._removeInternal();\n        return;\n      }\n      this.$container.addClass(this.animateRemovalClass);\n      this.$container.oneAnimationEnd(function() {\n        this._removeInternal();\n      }.bind(this));\n    }.bind(this));\n\n    // If the parent is being removed while the animation is running, the animationEnd event will never fire\n    // -> Make sure remove is called nevertheless. Important: remove it before the parent is removed to maintain the regular remove order\n    this.parent.one('removing', this._parentRemovingWhileAnimatingHandler);\n  }\n\n  _onParentRemovingWhileAnimating() {\n    this._removeInternal();\n  }\n\n  _renderInspectorInfo() {\n    if (!this.session.inspector) {\n      return;\n    }\n    inspector.applyInfo(this);\n  }\n\n  /**\n   * Links $container with the widget.\n   */\n  _linkWithDOM() {\n    if (this.$container) {\n      this.$container.data('widget', this);\n    }\n  }\n\n  /**\n   * Called right before _remove is called.\n   * Default calls LayoutValidator.cleanupInvalidComponents to make sure that child components are removed from the invalid components list.\n   * Also uninstalls key stroke context, loading support and scrollbars.\n   */\n  _cleanup() {\n    this.parent.off('removing', this._parentRemovingWhileAnimatingHandler);\n    this.session.keyStrokeManager.uninstallKeyStrokeContext(this.keyStrokeContext);\n    if (this.loadingSupport) {\n      this.loadingSupport.remove();\n    }\n    this._uninstallScrollbars();\n    if (this.$container) {\n      this.session.layoutValidator.cleanupInvalidComponents(this.$container);\n    }\n  }\n\n  _remove() {\n    if (this.$container) {\n      this.$container.remove();\n      this.$container = null;\n    }\n  }\n\n  setOwner(owner) {\n    scout.assertParameter('owner', owner);\n    if (owner === this.owner) {\n      return;\n    }\n\n    if (this.owner) {\n      // Remove from old owner\n      this.owner._removeChild(this);\n    }\n    this.owner = owner;\n    this.owner._addChild(this);\n  }\n\n  setParent(parent) {\n    scout.assertParameter('parent', parent);\n    if (parent === this.parent) {\n      return;\n    }\n    if (this.rendered && !parent.rendered) {\n      $.log.isInfoEnabled() && $.log.info('rendered child ' + this + ' is added to not rendered parent ' + parent + '. Removing child.', new Error('origin'));\n      this.remove();\n    }\n\n    if (this.parent) {\n      // Don't link to new parent yet if removal is still pending.\n      // After the animation the parent will remove its children.\n      // If they are already linked to a new parent, removing the children is not possible anymore.\n      // This may lead to an \"Already rendered\" exception if the new parent wants to render its children.\n      if (this.parent._isRemovalPending()) {\n        this.parent.one('remove', function() {\n          this.setParent(parent);\n        }.bind(this));\n        return;\n      }\n\n      this.parent.off('destroy', this._parentDestroyHandler);\n      this.parent.off('removing', this._parentRemovingWhileAnimatingHandler);\n\n      if (this.parent !== this.owner) {\n        // Remove from old parent if getting relinked\n        // If the old parent is still the owner, don't remove it because owner stays responsible for destroying it\n        this.parent._removeChild(this);\n      }\n    }\n    var oldParent = this.parent;\n    this.parent = parent;\n    this.parent._addChild(this);\n    this.trigger('hierarchyChange', {\n      oldParent: oldParent,\n      parent: parent\n    });\n    if (this.initialized) {\n      this.recomputeEnabled(this.parent.enabledComputed);\n    }\n    this.parent.one('destroy', this._parentDestroyHandler);\n  }\n\n  _addChild(child) {\n    $.log.isTraceEnabled() && $.log.trace('addChild(' + child + ') to ' + this);\n    arrays.pushSet(this.children, child);\n  }\n\n  _removeChild(child) {\n    $.log.isTraceEnabled() && $.log.trace('removeChild(' + child + ') from ' + this);\n    arrays.remove(this.children, child);\n  }\n\n  /**\n   * @returns {Widget[]} a list of all ancestors\n   */\n  ancestors() {\n    var ancestors = [];\n    var parent = this.parent;\n    while (parent) {\n      ancestors.push(parent);\n      parent = parent.parent;\n    }\n    return ancestors;\n  }\n\n  /**\n   * @returns {boolean} true if the given widget is the same as this or a descendant\n   */\n  isOrHas(widget) {\n    if (widget === this) {\n      return true;\n    }\n    return this.has(widget);\n  }\n\n  /**\n   * @returns {boolean} true if the given widget is a descendant\n   */\n  has(widget) {\n    while (widget) {\n      if (widget.parent === this) {\n        return true;\n      }\n      widget = widget.parent;\n    }\n\n    return false;\n  }\n\n  /**\n   * @returns {Form} the form the widget belongs to (returns the first parent which is a {@link Form}.\n   */\n  getForm() {\n    return Form.findForm(this);\n  }\n\n  /**\n   * @returns {Form} the first form which is not an inner form of a wrapped form field\n   */\n  findNonWrappedForm() {\n    return Form.findNonWrappedForm(this);\n  }\n\n  /**\n   * @returns {Desktop} the desktop linked to the current session.\n   * If desktop is still initializing it might not be available yet, in that case it searches the parent hierarchy for it.\n   */\n  findDesktop() {\n    if (this.session.desktop) {\n      return this.session.desktop;\n    }\n    return this.findParent(function(parent) {\n      return parent instanceof Desktop;\n    });\n  }\n\n  /**\n   * Changes the enabled property of this form field to the given value.\n   *\n   * @param {boolean} enabled\n   *          Required. The new enabled value\n   * @param {boolean} [updateParents]\n   *          (optional) If true, the enabled property of all parent form fields are\n   *          updated to same value as well. Default is false.\n   * @param {boolean} [updateChildren]\n   *          (optional) If true the enabled property of all child form fields (recursive)\n   *          are updated to same value as well. Default is false.\n   */\n  setEnabled(enabled, updateParents, updateChildren) {\n    this.setProperty('enabled', enabled);\n\n    if (enabled && updateParents && this.parent) {\n      this.parent.setEnabled(true, true, false);\n    }\n\n    if (updateChildren) {\n      this.visitChildren(function(field) {\n        field.setEnabled(enabled);\n      });\n    }\n  }\n\n  _setEnabled(enabled) {\n    this._setProperty('enabled', enabled);\n    if (this.initialized) {\n      this.recomputeEnabled();\n    }\n  }\n\n  recomputeEnabled(parentEnabled) {\n    if (parentEnabled === undefined) {\n      parentEnabled = true;\n      if (this.parent && this.parent.initialized && this.parent.enabledComputed !== undefined) {\n        parentEnabled = this.parent.enabledComputed;\n      }\n    }\n\n    var enabledComputed = this._computeEnabled(this.inheritAccessibility, parentEnabled);\n    this._updateEnabledComputed(enabledComputed);\n  }\n\n  _updateEnabledComputed(enabledComputed, enabledComputedForChildren) {\n    if (this.enabledComputed === enabledComputed && enabledComputedForChildren === undefined) {\n      // no change for this instance. there is no need to propagate to children\n      // exception: the enabledComputed for the children differs from the one for me. In this case the propagation is necessary.\n      return;\n    }\n\n    this.setProperty('enabledComputed', enabledComputed);\n\n    // Manually call _renderEnabled(), because _renderEnabledComputed() does not exist\n    if (this.rendered) {\n      this._renderEnabled();\n    }\n\n    var computedStateForChildren = scout.nvl(enabledComputedForChildren, enabledComputed);\n    this.children.forEach(function(child) {\n      if (child.inheritAccessibility) {\n        child.recomputeEnabled(computedStateForChildren);\n      }\n    });\n  }\n\n  _computeEnabled(inheritAccessibility, parentEnabled) {\n    return this.enabled && (inheritAccessibility ? parentEnabled : true);\n  }\n\n  _renderEnabled() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.setEnabled(this.enabledComputed);\n    this._renderDisabledStyle();\n  }\n\n  setInheritAccessibility(inheritAccessibility) {\n    this.setProperty('inheritAccessibility', inheritAccessibility);\n  }\n\n  _setInheritAccessibility(inheritAccessibility) {\n    this._setProperty('inheritAccessibility', inheritAccessibility);\n    if (this.initialized) {\n      this.recomputeEnabled();\n    }\n  }\n\n  setDisabledStyle(disabledStyle) {\n    this.setProperty('disabledStyle', disabledStyle);\n\n    this.children.forEach(function(child) {\n      child.setDisabledStyle(disabledStyle);\n    });\n  }\n\n  _renderDisabledStyle() {\n    this._renderDisabledStyleInternal(this.$container);\n  }\n\n  /**\n   * This function is used by subclasses to render the read-only class for a given $field.\n   * Some fields like DateField have two input fields and thus cannot use the this.$field property.\n   */\n  _renderDisabledStyleInternal($element) {\n    if (!$element) {\n      return;\n    }\n    if (this.enabledComputed) {\n      $element.removeClass('read-only');\n    } else {\n      $element.toggleClass('read-only', this.disabledStyle === Widget.DisabledStyle.READ_ONLY);\n    }\n  }\n\n  /**\n   * @param {boolean} visible true, to make the widget visible, false to hide it\n   */\n  setVisible(visible) {\n    this.setProperty('visible', visible);\n  }\n\n  /**\n   * @returns {boolean} whether the widget is visible or not. May depend on other conditions than the visible property only\n   */\n  isVisible() {\n    return this.visible;\n  }\n\n  _renderVisible() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.setVisible(this.isVisible());\n    this.invalidateParentLogicalGrid();\n  }\n\n  /**\n   * @returns {boolean} true if every parent within the hierarchy is visible.\n   */\n  isEveryParentVisible() {\n    var parent = this.parent;\n    while (parent) {\n      if (!parent.isVisible()) {\n        return false;\n      }\n      parent = parent.parent;\n    }\n\n    return true;\n  }\n\n  /**\n   * This function does not set the focus to the field. It toggles the 'focused' class on the field container if present.\n   * Objects using widget as prototype must call this function onBlur and onFocus to ensure the class gets toggled.\n   *\n   *  Use Widget.focus to set the focus to the widget.\n   */\n  setFocused(focused) {\n    this.setProperty('focused', focused);\n  }\n\n  _renderFocused() {\n    if (this.$container) {\n      this.$container.toggleClass('focused', this.focused);\n    }\n  }\n\n  _setCssClass(cssClass) {\n    if (this.rendered) {\n      this._removeCssClass();\n    }\n    this._setProperty('cssClass', cssClass);\n  }\n\n  _removeCssClass() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.removeClass(this.cssClass);\n  }\n\n  _renderCssClass() {\n    if (!this.$container) {\n      return;\n    }\n    this.$container.addClass(this.cssClass);\n  }\n\n  setCssClass(cssClass) {\n    this.setProperty('cssClass', cssClass);\n  }\n\n  addCssClass(cssClass) {\n    var cssClasses = this.cssClassAsArray();\n    var cssClassesToAdd = Widget.cssClassAsArray(cssClass);\n    cssClassesToAdd.forEach(function(newCssClass) {\n      if (cssClasses.indexOf(newCssClass) >= 0) {\n        return;\n      }\n      cssClasses.push(newCssClass);\n    }, this);\n    this.setProperty('cssClass', arrays.format(cssClasses, ' '));\n  }\n\n  removeCssClass(cssClass) {\n    var cssClasses = this.cssClassAsArray();\n    var cssClassesToRemove = Widget.cssClassAsArray(cssClass);\n    if (arrays.removeAll(cssClasses, cssClassesToRemove)) {\n      this.setProperty('cssClass', arrays.format(cssClasses, ' '));\n    }\n  }\n\n  toggleCssClass(cssClass, condition) {\n    if (condition) {\n      this.addCssClass(cssClass);\n    } else {\n      this.removeCssClass(cssClass);\n    }\n  }\n\n  cssClassAsArray() {\n    return Widget.cssClassAsArray(this.cssClass);\n  }\n\n  /**\n   * Creates nothing by default. If a widget needs loading support, override this method and return a loading support.\n   * @returns {LoadingSupport}\n   */\n  _createLoadingSupport() {\n    return null;\n  }\n\n  setLoading(loading) {\n    this.setProperty('loading', loading);\n  }\n\n  isLoading() {\n    return this.loading;\n  }\n\n  _renderLoading() {\n    if (!this.loadingSupport) {\n      return;\n    }\n    this.loadingSupport.renderLoading();\n  }\n\n  // --- Layouting / HtmlComponent methods ---\n\n  pack() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.pack();\n  }\n\n  invalidateLayout() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.invalidateLayout();\n  }\n\n  validateLayout() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.validateLayout();\n  }\n\n  revalidateLayout() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.revalidateLayout();\n  }\n\n  /**\n   * @param [invalidateParents] optional, default is true\n   */\n  invalidateLayoutTree(invalidateParents) {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.invalidateLayoutTree(invalidateParents);\n  }\n\n  validateLayoutTree() {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.validateLayoutTree();\n  }\n\n  revalidateLayoutTree(invalidateParents) {\n    if (!this.rendered || this.removing) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.revalidateLayoutTree(invalidateParents);\n  }\n\n  /**\n   * The layout data contains hints for the layout of the parent container to layout this individual child widget inside the container.<br>\n   * Note: this is not the same as the LayoutConfig. The LayoutConfig contains constraints for the layout itself and is therefore set on the parent container directly.\n   * <p>\n   * Example: The parent container uses a LogicalGridLayout to layout its children. Every child has a LogicalGridLayoutData to tell the layout how this specific child should be layouted.\n   * The parent may have a LogicalGridLayoutConfig to specify constraints which affect either only the container or every child in the container.\n   */\n  setLayoutData(layoutData) {\n    if (!this.rendered) {\n      return;\n    }\n    if (!this.htmlComp) {\n      throw new Error('Function expects a htmlComp property');\n    }\n    this.htmlComp.layoutData = layoutData;\n  }\n\n  /**\n   * If the widget uses a logical grid layout, the grid may be validated using this method.\n   * <p>\n   * If the grid is not dirty, nothing happens.\n   */\n  validateLogicalGrid() {\n    if (this.logicalGrid) {\n      this.logicalGrid.validate(this);\n    }\n  }\n\n  /**\n   * Marks the logical grid as dirty.<br>\n   * Does nothing, if there is no logical grid.\n   * @param {boolean} [invalidateLayout] true, to invalidate the layout afterwards, false if not. Default is true.\n   */\n  invalidateLogicalGrid(invalidateLayout) {\n    if (!this.initialized) {\n      return;\n    }\n    if (!this.logicalGrid) {\n      return;\n    }\n    this.logicalGrid.setDirty(true);\n    if (scout.nvl(invalidateLayout, true)) {\n      this.invalidateLayoutTree();\n    }\n  }\n\n  /**\n   * Invalidates the logical grid of the parent widget. Typically done when the visibility of the widget changes.\n   * @param {boolean} [invalidateLayout] true, to invalidate the layout of the parent of this.htmlComp, false if not. Default is true.\n   */\n  invalidateParentLogicalGrid(invalidateLayout) {\n    this.parent.invalidateLogicalGrid(false);\n    if (!this.rendered || !this.htmlComp) {\n      return;\n    }\n    if (scout.nvl(invalidateLayout, true)) {\n      var htmlCompParent = this.htmlComp.getParent();\n      if (htmlCompParent) {\n        htmlCompParent.invalidateLayoutTree();\n      }\n    }\n  }\n\n  revalidateLogicalGrid(invalidateLayout) {\n    this.invalidateLogicalGrid(invalidateLayout);\n    this.validateLogicalGrid();\n  }\n\n  setLogicalGrid(logicalGrid) {\n    this.setProperty('logicalGrid', logicalGrid);\n  }\n\n  /**\n   * @param logicalGrid an instance of {@link LogicalGrid} or a string representing the object type of a logical grid.\n   */\n  _setLogicalGrid(logicalGrid) {\n    if (typeof logicalGrid === 'string') {\n      logicalGrid = scout.create(logicalGrid);\n    }\n    this._setProperty('logicalGrid', logicalGrid);\n    this.invalidateLogicalGrid();\n  }\n\n  // --- Event handling methods ---\n  _createEventSupport() {\n    return new EventSupport();\n  }\n\n  trigger(type, event) {\n    event = event || {};\n    event.source = this;\n    this.events.trigger(type, event);\n  }\n\n  one(type, func) {\n    this.events.one(type, func);\n  }\n\n  on(type, func) {\n    return this.events.on(type, func);\n  }\n\n  off(type, func) {\n    this.events.off(type, func);\n  }\n\n  addListener(listener) {\n    this.events.addListener(listener);\n  }\n\n  removeListener(listener) {\n    this.events.removeListener(listener);\n  }\n\n  /**\n   * Adds an event handler using {@link #one()} and returns a promise.\n   * The promise is resolved as soon as the event is triggered.\n   */\n  when(type) {\n    return this.events.when(type);\n  }\n\n  /**\n   * @returns {$} the entry-point for this Widget or its parent. If the widget is part of the main-window it returns this.session.$entryPoint,\n   * for popup-window this function will return the body of the document in the popup window.\n   */\n  entryPoint() {\n    var $element = scout.nvl(this.$container, this.parent.$container);\n    if (!$element || !$element.length) {\n      throw new Error('Cannot resolve entryPoint, $element.length is 0 or undefined');\n    }\n    return $element.entryPoint();\n  }\n\n  window(domElement) {\n    var $el = this.$container || this.$parent;\n    return $el ? $el.window(domElement) : domElement ? null : $(null);\n  }\n\n  document(domElement) {\n    var $el = this.$container || this.$parent;\n    return $el ? $el.document(domElement) : domElement ? null : $(null);\n  }\n\n  /**\n   * This method attaches the detached $container to the DOM.\n   */\n  attach() {\n    if (this.attached || !this.rendered) {\n      return;\n    }\n    this._attach();\n    this._installFocusContext();\n    this.restoreFocus();\n    this.attached = true;\n    this._postAttach();\n    this._onAttach();\n    this._triggerChildrenOnAttach(this);\n  }\n\n  /**\n   * Override this method to do something when Widget is attached again. Typically\n   * you will append this.$container to this.$parent.\n   *\n   * @param the event.target property is used to decide if a Widget must attach\n   *   its $container. When the parent of the Widget already attaches, the Widget\n   *   itself must _not_ attach its own $container. That's why we should only\n   *   attach when event.target is === this.\n   */\n  _attach() {\n    // NOP\n  }\n\n  /**\n   * Override this method to do something after this widget is attached.\n   * This function is not called on any child of the attached widget.\n   */\n  _postAttach() {\n    // NOP\n  }\n\n  _triggerChildrenOnAttach(parent) {\n    this.children.forEach(function(child) {\n      child._onAttach();\n      child._triggerChildrenOnAttach(parent);\n    });\n  }\n\n  /**\n   * Override this method to do something after this widget or any parent of it is attached.\n   * This function is called whether or not the widget is rendered.\n   */\n  _onAttach() {\n    if (this.rendered) {\n      this._renderOnAttach();\n    }\n  }\n\n  /**\n   * Override this method to do something after this widget or any parent of it is attached.\n   * This function is only called when this widget is rendered.\n   */\n  _renderOnAttach() {\n    this._renderScrollTop();\n    this._renderScrollLeft();\n  }\n\n  /**\n   * This method calls detach() on all child-widgets. It is used to store some data\n   * before a DOM element is detached and propagate the detach \"event\" to all child-\n   * widgets, because when a DOM element is detached - child elements are not notified\n   */\n  detach() {\n    if (this.rendering) {\n      // Defer the execution of detach. If it was detached while rendering the attached flag would be wrong.\n      this._postRenderActions.push(this.detach.bind(this));\n    }\n    if (!this.attached || !this.rendered || this._isRemovalPending()) {\n      return;\n    }\n\n    this._beforeDetach();\n    this._onDetach();\n    this._triggerChildrenOnDetach(this);\n    this._detach();\n    this.attached = false;\n  }\n\n  /**\n   * This function is called before a widget gets detached. The function is only called on the detached widget and NOT on\n   * any of its children.\n   */\n  _beforeDetach(parent) {\n    if (!this.$container) {\n      return;\n    }\n\n    var activeElement = this.$container.document(true).activeElement;\n    var isFocused = this.$container.isOrHas(activeElement);\n    var focusManager = this.session.focusManager;\n\n    if (focusManager.isFocusContextInstalled(this.$container)) {\n      this._uninstallFocusContext();\n    } else if (isFocused) {\n      // exclude the container or any of its child elements to gain focus\n      focusManager.validateFocus(filters.outsideFilter(this.$container));\n    }\n  }\n\n  _triggerChildrenOnDetach() {\n    this.children.forEach(function(child) {\n      child._onDetach();\n      child._triggerChildrenOnDetach(parent);\n    });\n  }\n\n  /**\n   * This function is called before a widget or any of its parent getting detached.\n   * This function is thought to be overridden.\n   */\n  _onDetach() {\n    if (this.rendered) {\n      this._renderOnDetach();\n    }\n  }\n\n  _renderOnDetach() {\n    // NOP\n  }\n\n  /**\n   * Override this method to do something when Widget is detached. Typically you\n   * will call this.$container.detach(). The default\n   * implementation sets this.attached to false.\n   */\n  _detach() {\n  }\n\n  _uninstallFocusContext() {\n    // NOP\n  }\n\n  _installFocusContext() {\n    // NOP\n  }\n\n  /**\n   * Does nothing by default. If a widget needs keystroke support override this method and return a keystroke context, e.g. the default KeyStrokeContext.\n   * @returns {KeyStrokeContext}\n   */\n  _createKeyStrokeContext() {\n    return null;\n  }\n\n  updateKeyStrokes(newKeyStrokes, oldKeyStrokes) {\n    this.unregisterKeyStrokes(oldKeyStrokes);\n    this.registerKeyStrokes(newKeyStrokes);\n  }\n\n  registerKeyStrokes(keyStrokes) {\n    this.keyStrokeContext.registerKeyStrokes(keyStrokes);\n  }\n\n  unregisterKeyStrokes(keyStrokes) {\n    this.keyStrokeContext.unregisterKeyStrokes(keyStrokes);\n  }\n\n  /**\n   * Triggers a property change for a single property. The event is only triggered when\n   * old and new value are the same.\n   */\n  triggerPropertyChange(propertyName, oldValue, newValue) {\n    scout.assertParameter('propertyName', propertyName);\n    var event = new Event({\n      propertyName: propertyName,\n      oldValue: oldValue,\n      newValue: newValue\n    });\n    this.trigger('propertyChange', event);\n    return event;\n  }\n\n  /**\n   * Sets the value of the property 'propertyName' to 'newValue' and then fires a propertyChange event for that property.\n   */\n  _setProperty(propertyName, newValue) {\n    scout.assertParameter('propertyName', propertyName);\n    var oldValue = this[propertyName];\n    if (objects.equals(oldValue, newValue)) {\n      return;\n    }\n    this[propertyName] = newValue;\n    var event = this.triggerPropertyChange(propertyName, oldValue, newValue);\n    if (event.defaultPrevented) {\n      // Revert to old value if property change should be prevented\n      this[propertyName] = oldValue;\n    }\n  }\n\n  /**\n   * Sets a new value for a specific property. If the new value is the same value as the old one, nothing is performed.\n   * Otherwise the following phases are executed:\n   * <p>\n   * 1. Preparation: If the property is a widget property, several actions are performed in _prepareWidgetProperty().\n   * 2. DOM removal: If the property is a widget property and the widget is rendered, the changed widget(s) are removed unless the property should not be preserved (see _preserveOnPropertyChangeProperties).\n   *    If there is a custom remove function (e.g. _removeXY where XY is the property name), it will be called instead of removing the widgets directly.\n   * 3. Model update: If there is a custom set function (e.g. _setXY where XY is the property name), it will be called. Otherwise the default set function _setProperty is called.\n   * 4. DOM rendering: If the widget is rendered and there is a custom render function (e.g. _renderXY where XY is the property name), it will be called. Otherwise nothing happens.\n   */\n  setProperty(propertyName, value) {\n    if (objects.equals(this[propertyName], value)) {\n      return;\n    }\n\n    value = this._prepareProperty(propertyName, value);\n    if (this.rendered) {\n      this._callRemoveProperty(propertyName);\n    }\n    this._callSetProperty(propertyName, value);\n    if (this.rendered) {\n      this._callRenderProperty(propertyName);\n    }\n  }\n\n  _prepareProperty(propertyName, value) {\n    if (!this.isWidgetProperty(propertyName)) {\n      return value;\n    }\n    return this._prepareWidgetProperty(propertyName, value);\n  }\n\n  _prepareWidgetProperty(propertyName, widgets) {\n    // Create new child widget(s)\n    widgets = this._createChildren(widgets);\n\n    var oldWidgets = this[propertyName];\n    if (oldWidgets && Array.isArray(widgets)) {\n      // If new value is an array, old value has to be one as well\n      // Only destroy those which are not in the new array\n      oldWidgets = arrays.diff(oldWidgets, widgets);\n    }\n\n    if (!this.isPreserveOnPropertyChangeProperty(propertyName)) {\n      // Destroy old child widget(s)\n      this._destroyChildren(oldWidgets);\n\n      // Link to new parent\n      this.link(widgets);\n    }\n\n    return widgets;\n  }\n\n  /**\n   * Does nothing if the property is not a widget property.<p>\n   * If it is a widget property, it removes the existing widgets. Render has to be implemented by the widget itself.\n   */\n  _callRemoveProperty(propertyName) {\n    if (!this.isWidgetProperty(propertyName)) {\n      return;\n    }\n    if (this.isPreserveOnPropertyChangeProperty(propertyName)) {\n      return;\n    }\n    var widgets = this[propertyName];\n    if (!widgets) {\n      return;\n    }\n    var removeFuncName = '_remove' + strings.toUpperCaseFirstLetter(propertyName);\n    if (this[removeFuncName]) {\n      this[removeFuncName]();\n    } else {\n      this._internalRemoveWidgets(widgets);\n    }\n  }\n\n  /**\n   * Removes the given widgets\n   */\n  _internalRemoveWidgets(widgets) {\n    widgets = arrays.ensure(widgets);\n    widgets.forEach(function(widget) {\n      widget.remove();\n    });\n  }\n\n  _callSetProperty(propertyName, value) {\n    var setFuncName = '_set' + strings.toUpperCaseFirstLetter(propertyName);\n    if (this[setFuncName]) {\n      this[setFuncName](value);\n    } else {\n      this._setProperty(propertyName, value);\n    }\n  }\n\n  _callRenderProperty(propertyName) {\n    var renderFuncName = '_render' + strings.toUpperCaseFirstLetter(propertyName);\n    if (!this[renderFuncName]) {\n      return;\n    }\n    this[renderFuncName]();\n  }\n\n  /**\n   * Sets this widget as parent of the given widget(s).\n   *\n   * @param widgets may be a widget or array of widgets\n   */\n  link(widgets) {\n    if (!widgets) {\n      return;\n    }\n\n    widgets = arrays.ensure(widgets);\n    widgets.forEach(function(child, i) {\n      child.setParent(this);\n    }, this);\n  }\n\n  /**\n   * Method required for widgets which are supposed to be directly covered by a glasspane.<p>\n   *\n   * Returns the DOM elements to paint a glassPanes over, once a modal Form, message-box or file-chooser is shown with this widget as its 'displayParent'.<br>\n   * If the widget is not rendered yet, a scout.DeferredGlassPaneTarget is returned.<br>\n   * In both cases the method _glassPaneTargets is called which may be overridden by the actual widget.\n   */\n  glassPaneTargets(element) {\n    var resolveGlassPanes = function(element) {\n      // contributions\n      var targets = arrays.flatMap(this._glassPaneContributions, function(cont) {\n        var $elements = cont(element);\n        if ($elements) {\n          return arrays.ensure($elements);\n        }\n        return [];\n      });\n      return targets.concat(this._glassPaneTargets(element));\n    }.bind(this);\n    if (this.rendered) {\n      return resolveGlassPanes(element);\n    }\n\n    return DeferredGlassPaneTarget.createFor(this, resolveGlassPanes.bind(this, element));\n  }\n\n  _glassPaneTargets(element) {\n    // since popups are rendered outside the DOM of the widget parent-child hierarchy, get glassPaneTargets of popups belonging to this widget separately.\n    return [this.$container].concat(\n      this.session.desktop.getPopupsFor(this)\n        .reduce(function(acc, popup) {\n          return acc.concat(popup.glassPaneTargets());\n        }, []));\n  }\n\n  addGlassPaneContribution(contribution) {\n    this._glassPaneContributions.push(contribution);\n    this.trigger('glassPaneContributionAdded', {\n      contribution: contribution\n    });\n  }\n\n  /**\n   * @param [contribution] a function which returns glass pane targets (jQuery elements)\n   */\n  removeGlassPaneContribution(contribution) {\n    arrays.remove(this._glassPaneContributions, contribution);\n    this.trigger('glassPaneContributionRemoved', {\n      contribution: contribution\n    });\n  }\n\n  toString() {\n    var attrs = '';\n    attrs += 'id=' + this.id;\n    attrs += ' objectType=' + this.objectType;\n    attrs += ' rendered=' + this.rendered;\n    if (this.$container) {\n      attrs += ' $container=' + graphics.debugOutput(this.$container);\n    }\n    return 'Widget[' + attrs.trim() + ']';\n  }\n\n  /**\n   * Returns the ancestors as string delimited by '\\n'.\n   * @param [count] the number of ancestors to be processed. Default is -1 which means all.\n   */\n  ancestorsToString(count) {\n    var str = '',\n      ancestors = this.ancestors();\n\n    count = scout.nvl(count, -1);\n    ancestors.some(function(ancestor, i) {\n      if (count > -1 && i >= count) {\n        return true;\n      }\n      if (i > 0 && i < ancestors.length - 1) {\n        str += '\\n';\n      }\n      str += ancestor.toString();\n      return false;\n    });\n    return str;\n  }\n\n  resolveTextKeys(properties) {\n    properties.forEach(function(property) {\n      texts.resolveTextProperty(this, property);\n    }, this);\n  }\n\n  resolveIconIds(properties) {\n    properties.forEach(function(property) {\n      icons.resolveIconProperty(this, property);\n    }, this);\n  }\n\n  resolveConsts(configs) {\n    configs.forEach(function(config) {\n      objects.resolveConstProperty(this, config);\n    }, this);\n  }\n\n  /**\n   * A so called widget property is a property with a widget as value incl. automatic resolution of that widget.\n   * This means the property not only accepts the actual widget, but also a widget model or a widget reference (id)\n   * and then either creates a new widget based on the model or resolves the id and uses the referenced widget as value.\n   * Furthermore it will take care of its lifecycle which means, the widget will automatically be removed and destroyed (as long as the parent is also the owner).\n   * <p>\n   * If only the resolve operations without the lifecycle actions should be performed, you need to add the property to the list _preserveOnPropertyChangeProperties as well.\n   */\n  _addWidgetProperties(properties) {\n    this._addProperties('_widgetProperties', properties);\n  }\n\n  isWidgetProperty(propertyName) {\n    return this._widgetProperties.indexOf(propertyName) > -1;\n  }\n\n  _addCloneProperties(properties) {\n    this._addProperties('_cloneProperties', properties);\n  }\n\n  isCloneProperty(propertyName) {\n    return this._cloneProperties.indexOf(propertyName) > -1;\n  }\n\n  /**\n   * Properties in this list won't be affected by the automatic lifecycle actions performed for regular widget properties.\n   * This means, the widget won't be removed, destroyed and also not linked, which means the parent stays the same.\n   * But the resolve operations are still applied, as for regular widget properties.\n   * <p>\n   * The typical use case for such properties is referencing another widget without taking care of that widget.\n   */\n  _addPreserveOnPropertyChangeProperties(properties) {\n    this._addProperties('_preserveOnPropertyChangeProperties', properties);\n  }\n\n  isPreserveOnPropertyChangeProperty(propertyName) {\n    return this._preserveOnPropertyChangeProperties.indexOf(propertyName) > -1;\n  }\n\n  _addProperties(propertyName, properties) {\n    properties = arrays.ensure(properties);\n    properties.forEach(function(property) {\n      if (this[propertyName].indexOf(property) > -1) {\n        throw new Error(propertyName + ' already contains the property ' + property);\n      }\n      this[propertyName].push(property);\n    }, this);\n  }\n\n  _eachProperty(model, func) {\n    var propertyName, value, i;\n\n    // Loop through primitive properties\n    for (propertyName in model) {\n      if (this._widgetProperties.indexOf(propertyName) > -1) {\n        continue; // will be handled below\n      }\n      value = model[propertyName];\n      func(propertyName, value);\n    }\n\n    // Loop through adapter properties (any order will do).\n    for (i = 0; i < this._widgetProperties.length; i++) {\n      propertyName = this._widgetProperties[i];\n      value = model[propertyName];\n      if (value === undefined) {\n        continue;\n      }\n\n      func(propertyName, value, true);\n    }\n  }\n\n  _removeWidgetProperties(properties) {\n    if (Array.isArray(properties)) {\n      arrays.removeAll(this._widgetProperties, properties);\n    } else {\n      arrays.remove(this._widgetProperties, properties);\n    }\n  }\n\n  /**\n   * Clones the widget and mirrors the events, see this.clone() and this.mirror() for details.\n   */\n  cloneAndMirror(model) {\n    return this.clone(model, {\n      delegateAllPropertiesToClone: true\n    });\n  }\n\n  /**\n   * @returns {Widget} the original widget from which this one was cloned. If it is not a clone, itself is returned.\n   */\n  original() {\n    var original = this;\n    while (original.cloneOf) {\n      original = original.cloneOf;\n    }\n    return original;\n  }\n\n  /**\n   * Clones the widget and returns the clone. Only the properties defined in this._cloneProperties are copied to the clone.\n   * The parameter model has to contain at least the property 'parent'.\n   *\n   * OPTION                          DEFAULT VALUE   DESCRIPTION\n   * --------------------------------------------------------------------------------------------------------\n   * delegatePropertiesToClone       []              An array of all properties to be delegated from the original\n   *                                                 to the to the clone when changed on the original widget.\n   *\n   * delegatePropertiesToOriginal    []              An array of all properties to be delegated from the clone\n   *                                                 to the original when changed on the clone widget.\n   *\n   * excludePropertiesToOriginal     []              An array of all properties to be excluded from delegating\n   *                                                 from the clone to the original in any cases.\n   *\n   * delegateEventsToOriginal        []              An array of all events to be delegated from the clone to\n   *                                                 the original when fired on the clone widget.\n   *\n   * delegateAllPropertiesToClone    false           True to delegate all property changes from the original to\n   *                                                 the clone.\n   *\n   * delegateAllPropertiesToOriginal false           True to delegate all property changes from the clone to\n   *                                                 the original.\n   *\n   * @param model The model used to create the clone is a combination of the clone properties and this model.\n   * Therefore this model may be used to override the cloned properties or to add additional properties.\n   * @param options Options used for the clone widgets. See above.\n   *\n   */\n  clone(model, options) {\n    var clone, cloneModel;\n    model = model || {};\n    options = options || {};\n\n    cloneModel = objects.extractProperties(this, model, this._cloneProperties);\n    clone = scout.create(this.objectType, cloneModel);\n    clone.cloneOf = this;\n    this._mirror(clone, options);\n\n    if (this.logicalGrid) {\n      // Create a new logical grid to make sure it does not influence the original widget\n      // This also creates the correct grid config for the specific widget\n      clone.setLogicalGrid(this.logicalGrid.objectType);\n    } else {\n      // Remove the grid if the original does not have one either\n      clone.setLogicalGrid(null);\n    }\n\n    return clone;\n  }\n\n  _deepCloneProperties(clone, properties, options) {\n    if (!properties) {\n      return clone;\n    }\n    properties = arrays.ensure(properties);\n    properties.forEach(function(property) {\n      var propertyValue = this[property],\n        clonedProperty = null;\n      if (propertyValue === undefined) {\n        throw new Error('Property \\'' + property + '\\' is undefined. Deep copy not possible.');\n      }\n      if (this._widgetProperties.indexOf(property) > -1) {\n        if (Array.isArray(propertyValue)) {\n          clonedProperty = propertyValue.map(function(val) {\n            return val.clone({\n              parent: clone\n            }, options);\n          });\n        } else {\n          clonedProperty = propertyValue.clone({\n            parent: clone\n          }, options);\n        }\n      } else if (Array.isArray(propertyValue)) {\n        clonedProperty = propertyValue.map(function(val) {\n          return val;\n        });\n      } else {\n        clonedProperty = propertyValue;\n      }\n      clone[property] = clonedProperty;\n    }.bind(this));\n  }\n\n  /**\n   * Delegates every property change event from the original widget to this cloned widget by calling the appropriate setter.\n   * If no target is set it works only if this widget is a clone.\n   */\n  mirror(options, target) {\n    target = target || this.cloneOf;\n    if (!target) {\n      throw new Error('No target for mirroring.');\n    }\n    this._mirror(target, options);\n  }\n\n  _mirror(clone, options) {\n    var eventDelegator = arrays.find(this.eventDelegators, function(eventDelegator) {\n      return eventDelegator.clone === clone;\n    });\n    if (eventDelegator) {\n      throw new Error('_mirror can only be called on not mirrored widgets. call unmirror first.');\n    }\n    options = options || {};\n    eventDelegator = {\n      clone: clone,\n      originalToClone: EventDelegator.create(this, clone, {\n        delegateProperties: options.delegatePropertiesToClone,\n        delegateAllProperties: options.delegateAllPropertiesToClone\n      }),\n      cloneToOriginal: EventDelegator.create(clone, this, {\n        delegateProperties: options.delegatePropertiesToOriginal,\n        delegateAllProperties: options.delegateAllPropertiesToOriginal,\n        excludeProperties: options.excludePropertiesToOriginal,\n        delegateEvents: options.delegateEventsToOriginal\n      })\n    };\n    this.eventDelegators.push(eventDelegator);\n    clone.one('destroy', function() {\n      this._unmirror(clone);\n    }.bind(this));\n  }\n\n  unmirror(target) {\n    target = target || this.cloneOf;\n    if (!target) {\n      throw new Error('No target for unmirroring.');\n    }\n    this._unmirror(target);\n  }\n\n  _unmirror(target) {\n    var eventDelegatorIndex = arrays.findIndex(this.eventDelegators, function(eventDelegator) {\n        return eventDelegator.clone === target;\n      }),\n      eventDelegator = eventDelegatorIndex > -1 ? this.eventDelegators.splice(eventDelegatorIndex, 1)[0] : null;\n    if (!eventDelegator) {\n      return;\n    }\n    if (eventDelegator.originalToClone) {\n      eventDelegator.originalToClone.destroy();\n    }\n    if (eventDelegator.cloneToOriginal) {\n      eventDelegator.cloneToOriginal.destroy();\n    }\n  }\n\n  _onParentDestroy(event) {\n    if (this.destroyed) {\n      return;\n    }\n    // If the parent is destroyed but the widget not make sure it gets a new parent\n    // This ensures the old one may be properly garbage collected\n    this.setParent(this.owner);\n  }\n\n  callSetter(propertyName, value) {\n    var setterFuncName = 'set' + strings.toUpperCaseFirstLetter(propertyName);\n    if (this[setterFuncName]) {\n      this[setterFuncName](value);\n    } else {\n      this.setProperty(propertyName, value);\n    }\n  }\n\n  /**\n   * Traverses the object-tree (children) of this widget and searches for a widget with the given ID.\n   * Returns the widget with the requested ID or null if no widget has been found.\n   *\n   * @param widgetId\n   * @returns {Widget} the found widget for the given id\n   */\n  widget(widgetId) {\n    if (predicate(this)) {\n      return this;\n    }\n    return this.findChild(predicate);\n\n    function predicate(widget) {\n      if (widget.id === widgetId) {\n        return widget;\n      }\n    }\n  }\n\n  /**\n   * Similar to widget(), but uses \"breadth-first\" strategy, i.e. it checks all children of the\n   * same depth (level) before it advances to the next level. If multiple widgets with the same\n   * ID exist, the one with the smallest distance to this widget is returned.\n   *\n   * Example:\n   *\n   *    Widget ['MyWidget']                     #1\n   *    +- GroupBox ['LeftBox']                 #2\n   *       +- StringField ['NameField']         #3\n   *       +- StringField ['CityField']         #4\n   *       +- GroupBox ['InnerBox']             #5\n   *          +- GroupBox ['LeftBox']           #6\n   *             +- DateField ['StartDate']     #7\n   *          +- GroupBox ['RightBox']          #8\n   *             +- DateField ['EndDate']       #9\n   *    +- GroupBox ['RightBox']                #10\n   *       +- StringField ['NameField']         #11\n   *       +- DateField ['StartDate']           #12\n   *\n   *   CALL:                                    RESULT:\n   *   ---------------------------------------------------------------------------------------------\n   *   this.widget('RightBox')                  #8               (might not be the expected result)\n   *   this.nearestWidget('RightBox')           #10\n   *\n   *   this.widget('NameField')                 #3\n   *   this.nearestWidget('NameField')          null             (because no direct child has the requested id)\n   *   this.nearestWidget('NameField', true)    #3               (because #3 and #11 have the same distance)\n   *\n   *   this.widget('StartDate')                 #7\n   *   this.nearestWidget('StartDate', true)    #12              (#12 has smaller distance than #7)\n   *\n   * @param {string} widgetId\n   *          The ID of the widget to find.\n   * @param {boolean} deep\n   *          If false, only this widget and the next level are checked. This is the default.\n   *          If true, the entire tree is traversed.\n   * @return {Widget} the first found widget, or null if no widget was found.\n   */\n  nearestWidget(widgetId, deep) {\n    if (this.id === widgetId) {\n      return this;\n    }\n    var widgets = this.children.slice(); // list of widgets to check\n    while (widgets.length) {\n      var widget = widgets.shift();\n      if (widget.id === widgetId) {\n        return widget; // found\n      }\n      if (deep) {\n        for (var i = 0; i < widget.children.length; i++) {\n          var child = widget.children[i];\n          if (child.parent === widget) { // same check as in visitChildren()\n            widgets.push(child);\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @returns {Widget} the first parent for which the given function returns true.\n   */\n  findParent(predicate) {\n    var parent = this.parent;\n    while (parent) {\n      if (predicate(parent)) {\n        return parent;\n      }\n      parent = parent.parent;\n    }\n    return parent;\n  }\n\n  /**\n   * @returns {Widget} the first child for which the given function returns true.\n   */\n  findChild(predicate) {\n    var foundChild = null;\n    this.visitChildren(function(child) {\n      if (predicate(child)) {\n        foundChild = child;\n        return true;\n      }\n    });\n    return foundChild;\n  }\n\n  setTrackFocus(trackFocus) {\n    this.setProperty('trackFocus', trackFocus);\n  }\n\n  _renderTrackFocus() {\n    if (!this.$container) {\n      return;\n    }\n    if (this.trackFocus) {\n      this.$container.on('focusin', this._focusInListener);\n    } else {\n      this.$container.off('focusin', this._focusInListener);\n    }\n  }\n\n  restoreFocus() {\n    if (this._$lastFocusedElement) {\n      this.session.focusManager.requestFocus(this._$lastFocusedElement);\n    } else if (this._storedFocusedWidget) {\n      this._storedFocusedWidget.focus();\n      this._storedFocusedWidget = null;\n    }\n  }\n\n  /**\n   * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.\n   */\n  _onFocusIn(event) {\n    // do not track focus events during rendering to avoid initial focus to be restored.\n    if (this.rendering) {\n      return;\n    }\n    var $target = $(event.target);\n    if (this.$container.has($target)) {\n      this._$lastFocusedElement = $target;\n    }\n  }\n\n  /**\n   * Tries to set the focus on the widget.\n   * <p>\n   * By default the focus is set on the container but this may vary from widget to widget.\n   * @returns {boolean} true if the element could be focused, false if not\n   */\n  focus() {\n    if (!this.rendered) {\n      this.session.layoutValidator.schedulePostValidateFunction(this.focus.bind(this));\n      return false;\n    }\n\n    return this.session.focusManager.requestFocus(this.getFocusableElement());\n  }\n\n  /**\n   * Calls {@link focus()} and prevents the default behavior of the event if the focusing was successful.\n   */\n  focusAndPreventDefault(event) {\n    if (this.focus()) {\n      // Preventing blur is bad for touch devices because it prevents that the keyboard can close.\n      // In that case focus() will return false because focus manager is disabled.\n      event.preventDefault();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns whether the widget is the currently active element\n   */\n  isFocused() {\n    return this.rendered && focusUtils.isActiveElement(this.getFocusableElement());\n  }\n\n  /**\n   * @return {boolean} true if the element is focusable, false if not.\n   */\n  isFocusable() {\n    if (!this.rendered || !this.visible) {\n      return false;\n    }\n    var elem = this.getFocusableElement();\n    if (elem) {\n      return $.ensure(elem).is(':focusable');\n    }\n    return false;\n  }\n\n  /**\n   * This method returns the HtmlElement to be used when {@link #focus()} is called.\n   * It can be overridden, in case the widget needs to return something other than this.$container[0].\n   */\n  getFocusableElement() {\n    if (this.rendered && this.$container) {\n      return this.$container[0];\n    }\n    return null;\n  }\n\n  _installScrollbars(options) {\n    var $scrollable = this.get$Scrollable();\n    if (!$scrollable) {\n      throw new Error('Scrollable is not defined, cannot install scrollbars');\n    }\n    if ($scrollable.data('scrollable')) {\n      // already installed\n      return;\n    }\n    options = options || {};\n    var defaults = {\n      parent: this\n    };\n    options = $.extend({}, defaults, options);\n    scrollbars.install($scrollable, options);\n    $scrollable.on('scroll', this._scrollHandler);\n  }\n\n  _uninstallScrollbars() {\n    var $scrollable = this.get$Scrollable();\n    if (!$scrollable || !$scrollable.data('scrollable')) {\n      return;\n    }\n    scrollbars.uninstall($scrollable, this.session);\n    $scrollable.off('scroll', this._scrollHandler);\n    if (!this.removing) {\n      // If scrollbars are removed on the fly and not because the widget is removing, reset scroll positions to initial state\n      // Only reset if position is 0 to preserve the position (uninstalling does not reset the position of the scrollable either)\n      if ($scrollable[0].scrollTop === 0) {\n        this.scrollTop = null;\n      }\n      if ($scrollable[0].scrollLeft === 0) {\n        this.scrollLeft = null;\n      }\n    }\n  }\n\n  _onScroll() {\n    var $scrollable = this.get$Scrollable();\n    this.scrollTop = $scrollable[0].scrollTop;\n    this.scrollLeft = $scrollable[0].scrollLeft;\n  }\n\n  setScrollTop(scrollTop) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().setScrollTop(scrollTop);\n      return;\n    }\n    if (this.scrollTop === scrollTop) {\n      return;\n    }\n    this.scrollTop = scrollTop;\n    if (this.rendered) {\n      this._renderScrollTop();\n    }\n  }\n\n  _renderScrollTop() {\n    var $scrollable = this.get$Scrollable();\n    if (!$scrollable || this.scrollTop === null) {\n      // Don't do anything for non scrollable elements. Also, reading $scrollable[0].scrollTop must not be done while rendering because it would provoke a reflow\n      return;\n    }\n    if (this.rendering || this.htmlComp && !this.htmlComp.layouted && !this.htmlComp.layouting) {\n      // If the widget is not layouted yet (which is always true while rendering), the scroll position cannot be updated -> do it after the layout\n      // If scroll top is set while layouting, layout obviously wants to set it -> do it\n      this.session.layoutValidator.schedulePostValidateFunction(this._renderScrollTop.bind(this));\n      return;\n    }\n    scrollbars.scrollTop($scrollable, this.scrollTop);\n  }\n\n  setScrollLeft(scrollLeft) {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().setScrollLeft(scrollLeft);\n      return;\n    }\n    if (this.scrollLeft === scrollLeft) {\n      return;\n    }\n    this.scrollLeft = scrollLeft;\n    if (this.rendered) {\n      this._renderScrollLeft();\n    }\n  }\n\n  _renderScrollLeft() {\n    var $scrollable = this.get$Scrollable();\n    if (!$scrollable || this.scrollLeft === null) {\n      // Don't do anything for non scrollable elements. Also, reading $scrollable[0].scrollLeft must not be done while rendering because it would provoke a reflow\n      return;\n    }\n    if (this.rendering || this.htmlComp && !this.htmlComp.layouted && !this.htmlComp.layouting) {\n      // If the widget is not layouted yet (which is always true while rendering), the scroll position cannot be updated -> do it after the layout\n      // If scroll left is set while layouting, layout obviously wants to set it -> do it\n      this.session.layoutValidator.schedulePostValidateFunction(this._renderScrollLeft.bind(this));\n      return;\n    }\n    scrollbars.scrollLeft($scrollable, this.scrollLeft);\n  }\n\n  /**\n   * Returns the jQuery element which is supposed to be scrollable. This element will be used by the scroll functions like {@link #_installScrollbars}, {@link #setScrollTop}, {@link #setScrollLeft}, {@link #scrollToBottom} etc..\n   * The element won't be used unless {@link #_installScrollbars} is called.\n   * If the widget is mainly a wrapper for a scrollable widget and does not have a scrollable element by itself, you can use @{link #getDelegateScrollable} instead.\n   * @return {$}\n   */\n  get$Scrollable() {\n    return this.$container;\n  }\n\n  /**\n   * If the widget is mainly a wrapper for another widget, it is often the case that the other widget is scrollable and not the wrapper.\n   * In that case implement this method and return the other widget so that the calls to the scroll functions can be delegated.\n   * @return {Widget}\n   */\n  getDelegateScrollable() {\n    return null;\n  }\n\n  scrollToTop() {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().scrollToTop();\n      return;\n    }\n    var $scrollable = this.get$Scrollable();\n    if (!$scrollable) {\n      return;\n    }\n    if (!this.rendered) {\n      this.session.layoutValidator.schedulePostValidateFunction(this.scrollToTop.bind(this));\n      return;\n    }\n    scrollbars.scrollTop($scrollable, 0);\n  }\n\n  scrollToBottom() {\n    if (this.getDelegateScrollable()) {\n      this.getDelegateScrollable().scrollToBottom();\n      return;\n    }\n    var $scrollable = this.get$Scrollable();\n    if (!$scrollable) {\n      return;\n    }\n    if (!this.rendered) {\n      this.session.layoutValidator.schedulePostValidateFunction(this.scrollToBottom.bind(this));\n      return;\n    }\n    scrollbars.scrollToBottom($scrollable);\n  }\n\n  /**\n   * Brings the widget into view by scrolling the first scrollable parent.\n   */\n  reveal(options) {\n    if (!this.rendered) {\n      return;\n    }\n    var $scrollParent = this.$container.scrollParent();\n    if ($scrollParent.length === 0) {\n      // No scrollable parent found -> scrolling is not possible\n      return;\n    }\n    scrollbars.scrollTo($scrollParent, this.$container, options);\n  }\n\n  /**\n   * Visits every child of this widget in pre-order (top-down).<br>\n   * This widget itself is not visited! Only child widgets are visited recursively.\n   * <p>\n   * The children with a different parent are excluded.<br>\n   * This makes sure the child is not visited twice if the owner and the parent are not the same\n   * (in that case the widget would be in the children list of the owner and of the parent).\n   * <p>\n   * In order to abort visiting, the visitor can return true.\n   * @returns {boolean} true if the visitor aborted the visiting, false if the visiting completed without aborting\n   */\n  visitChildren(visitor) {\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      if (child.parent === this) {\n        var treeVisitResult = visitor(child);\n        if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n          // Visitor wants to abort the visiting\n          return TreeVisitResult.TERMINATE;\n        } else if (treeVisitResult !== TreeVisitResult.SKIP_SUBTREE) {\n          treeVisitResult = child.visitChildren(visitor);\n          if (treeVisitResult === true || treeVisitResult === TreeVisitResult.TERMINATE) {\n            return TreeVisitResult.TERMINATE;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns {boolean} Whether or not the widget is rendered (or rendering) and the DOM $container isAttached()\n   */\n  isAttachedAndRendered() {\n    return (this.rendered || this.rendering) && this.$container.isAttached();\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * @deprecated use {@link widgets.get}\n   */\n  static getWidgetFor($elem) {\n    return widgets.get($elem);\n  }\n\n  static cssClassAsArray(cssClass) {\n    var cssClasses = [],\n      cssClassesStr = cssClass || '';\n\n    cssClassesStr = cssClassesStr.trim();\n    if (cssClassesStr.length > 0) {\n      cssClasses = cssClassesStr.split(' ');\n    }\n    return cssClasses;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}