{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { objects, arrays, QueryBy, scout } from '../index';\nimport $ from 'jquery';\n/**\n * Base class for lookup calls. A concrete implementation of LookupCall.js which uses resources over a network\n * must deal with I/O errors and set, in case of an error, the 'exception' property on the returned lookup result.\n * The lookup call must _always_ return a result, otherwise the SmartField cannot work properly.\n */\n\nvar LookupCall = /*#__PURE__*/function () {\n  function LookupCall() {\n    _classCallCheck(this, LookupCall);\n\n    this.session = null;\n    this.hierarchical = false;\n    this.loadIncremental = false;\n    this.batch = false; // indicates if the lookup call implements 'getByKeys' and therefore supports 'textsByKeys'\n\n    this.queryBy = null;\n    this.searchText = null; // used on QueryBy.TEXT\n\n    this.key = null; // used on QueryBy.KEY\n\n    this.keys = null; // used on QueryBy.KEYS\n\n    this.parentKey = null; // used on QueryBy.REC\n\n    this.active = null;\n  }\n\n  _createClass(LookupCall, [{\n    key: \"init\",\n    value: function init(model) {\n      scout.assertParameter('session', model.session);\n\n      this._init(model);\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(model) {\n      $.extend(this, model);\n    }\n  }, {\n    key: \"setLoadIncremental\",\n    value: function setLoadIncremental(loadIncremental) {\n      this.loadIncremental = loadIncremental;\n    }\n  }, {\n    key: \"setHierarchical\",\n    value: function setHierarchical(hierarchical) {\n      this.hierarchical = hierarchical;\n    }\n  }, {\n    key: \"setBatch\",\n    value: function setBatch(batch) {\n      this.batch = batch;\n    }\n    /**\n     * This method may be called directly on any LookupCall. For the key lookup an internal clone is created automatically.\n     *\n     * You should not override this function. Instead override <code>_textByKey</code>.\n     *\n     * @returns {Promise} which returns a text of the lookup row resolved by #getByKey\n     */\n\n  }, {\n    key: \"textByKey\",\n    value: function textByKey(key) {\n      if (objects.isNullOrUndefined(key)) {\n        return $.resolvedPromise('');\n      }\n\n      return this._textByKey(key);\n    }\n    /**\n     * Override this function to provide your own textByKey implementation.\n     *\n     * @returns {Promise} which returns a text of the lookup row resolved by #getByKey\n     */\n\n  }, {\n    key: \"_textByKey\",\n    value: function _textByKey(key) {\n      return this.cloneForKey(key).execute().then(function (result) {\n        var lookupRow = LookupCall.firstLookupRow(result);\n        return lookupRow ? lookupRow.text : '';\n      });\n    }\n    /**\n     * This method may be called directly on any LookupCall. For the keys lookup an internal clone is created automatically.\n     *\n     * You should not override this function. Instead override <code>_textsByKeys</code>.\n     *\n     * @returns {Promise} which returns an object that maps every key to the text of the resolved lookup row\n     */\n\n  }, {\n    key: \"textsByKeys\",\n    value: function textsByKeys(keys) {\n      if (arrays.empty(keys)) {\n        return $.resolvedPromise({});\n      }\n\n      return this._textsByKeys(keys);\n    }\n    /**\n     * Override this function to provide your own textsByKeys implementation.\n     *\n     * @returns {Promise} which returns an object that maps every key to the text of the lookup row\n     */\n\n  }, {\n    key: \"_textsByKeys\",\n    value: function _textsByKeys(keys) {\n      return this.cloneForKeys(keys).execute().then(function (result) {\n        if (!result || !objects.isArray(result.lookupRows)) {\n          return {};\n        }\n\n        var textMap = {};\n        result.lookupRows.forEach(function (row) {\n          textMap[row.key] = row.text;\n        });\n        return textMap;\n      });\n    }\n    /**\n     * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForAll().execute()</code> or <code>.clone().getAll()</code>.\n     *\n     * You should not override this function. Instead override <code>_getAll</code>.\n     *\n     * @return {Promise} resolves to a result object with an array of {LookupRow}s\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      this.queryBy = QueryBy.ALL;\n      return this._getAll();\n    }\n    /**\n     * Override this method to implement.\n     */\n\n  }, {\n    key: \"_getAll\",\n    value: function _getAll() {\n      throw new Error('getAll() not implemented');\n    }\n    /**\n     * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForText(text).execute()</code> or <code>.clone().getByText(text)</code>.\n     *\n     * You should not override this function. Instead override <code>_getByText</code>.\n     *\n     * @return {Promise} resolves to a result object with an array of {LookupRow}s\n     */\n\n  }, {\n    key: \"getByText\",\n    value: function getByText(text) {\n      this.queryBy = QueryBy.TEXT;\n      this.searchText = text;\n      return this._getByText(text);\n    }\n    /**\n     * Override this method to implement.\n     */\n\n  }, {\n    key: \"_getByText\",\n    value: function _getByText(text) {\n      throw new Error('getByText() not implemented');\n    }\n    /**\n     * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForKey(key).execute()</code> or <code>.clone().getByKey(parentKey)</code>.\n     *\n     * You should not override this function. Instead override <code>_getByKey</code>.\n     *\n     * @return {Promise} resolves to a result object with a single {LookupRow}\n     */\n\n  }, {\n    key: \"getByKey\",\n    value: function getByKey(key) {\n      this.queryBy = QueryBy.KEY;\n      this.key = key;\n      return this._getByKey(key);\n    }\n    /**\n     * Override this method to implement.\n     */\n\n  }, {\n    key: \"_getByKey\",\n    value: function _getByKey(key) {\n      throw new Error('getByKey() not implemented');\n    }\n    /**\n     * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForKeys(keys).execute()</code> or <code>.clone().getByKeys(keys)</code>.\n     *\n     * You should not override this function. Instead override <code>_getByKeys</code>.\n     *\n     * @return {Promise} resolves to a result object with an array of {scout.LookupRow}s\n     */\n\n  }, {\n    key: \"getByKeys\",\n    value: function getByKeys(keys) {\n      this.queryBy = QueryBy.KEYS;\n      this.keys = keys;\n      return this._getByKeys(keys);\n    }\n    /**\n     * Override this method to implement.\n     */\n\n  }, {\n    key: \"_getByKeys\",\n    value: function _getByKeys(keys) {\n      throw new Error('getByKeys() not implemented');\n    }\n    /**\n     * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForRec(parentKey).execute()</code> or <code>.clone().getByRec(parentKey)</code>.\n     *\n     * You should not override this function. Instead override <code>_getByRec</code>.\n     *\n     * Returns a result with lookup rows for the given parent key. This is used for incremental lookups.\n     *\n     * @return {Promise} resolves to a result object with an array of {LookupRow}s\n     * @param {object} parentKey references the parent key\n     */\n\n  }, {\n    key: \"getByRec\",\n    value: function getByRec(parentKey) {\n      this.queryBy = QueryBy.REC;\n      this.parentKey = parentKey;\n      return this._getByRec(parentKey);\n    }\n    /**\n     * Override this method to implement.\n     */\n\n  }, {\n    key: \"_getByRec\",\n    value: function _getByRec(rec) {\n      throw new Error('getByRec() not implemented');\n    }\n    /**\n     * Executes this LookupCall. For this method to work this LookupCall must be a clone created with one of the following methods:\n     * <code>cloneForAll()</code>, <code>cloneForText(text)</code>, <code>cloneForKey(key)</code>, <code>cloneForRec(parentKey)</code>\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      if (QueryBy.KEY === this.queryBy) {\n        return this._getByKey(this.key);\n      }\n\n      if (QueryBy.ALL === this.queryBy) {\n        return this._getAll();\n      }\n\n      if (QueryBy.KEYS === this.queryBy) {\n        return this._getByKeys(this.keys);\n      }\n\n      if (QueryBy.TEXT === this.queryBy) {\n        return this._getByText(this.searchText);\n      }\n\n      if (QueryBy.REC === this.queryBy) {\n        return this._getByRec(this.parentKey);\n      }\n\n      throw new Error('cannot execute a non-clone LookupCall. Use one of the cloneFor*-methods before executing.');\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(properties) {\n      // Warning: This is _not_ a deep clone! (Because otherwise the entire session would be duplicated.)\n      // Non-primitive properties must _only_ be added to the resulting clone during the 'prepareLookupCall' event!\n      return scout.cloneShallow(this, properties, true);\n    }\n  }, {\n    key: \"cloneForAll\",\n    value: function cloneForAll() {\n      return this.clone({\n        queryBy: QueryBy.ALL\n      });\n    }\n  }, {\n    key: \"cloneForText\",\n    value: function cloneForText(text) {\n      return this.clone({\n        queryBy: QueryBy.TEXT,\n        searchText: text\n      });\n    }\n  }, {\n    key: \"cloneForKey\",\n    value: function cloneForKey(key) {\n      return this.clone({\n        queryBy: QueryBy.KEY,\n        key: key\n      });\n    }\n  }, {\n    key: \"cloneForKeys\",\n    value: function cloneForKeys(keys) {\n      return this.clone({\n        queryBy: QueryBy.KEYS,\n        keys: keys\n      });\n    }\n  }, {\n    key: \"cloneForRec\",\n    value: function cloneForRec(parentKey) {\n      return this.clone({\n        queryBy: QueryBy.REC,\n        parentKey: parentKey\n      });\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {// NOP. Implement in subclasses if necessary.\n    } // ---- static helpers ----\n\n  }], [{\n    key: \"ensure\",\n    value: function ensure(lookupCall, session) {\n      if (lookupCall instanceof LookupCall) {// NOP - required to distinct instance from plain object (=model)\n      } else if (objects.isPlainObject(lookupCall)) {\n        lookupCall.session = session;\n        lookupCall = scout.create(lookupCall);\n      } else if (typeof lookupCall === 'string') {\n        lookupCall = scout.create(lookupCall, {\n          session: session\n        });\n      }\n\n      return lookupCall;\n    }\n  }, {\n    key: \"firstLookupRow\",\n    value: function firstLookupRow(result) {\n      if (!result) {\n        return null;\n      }\n\n      if (!objects.isArray(result.lookupRows)) {\n        return null;\n      }\n\n      if (result.lookupRows.length === 0) {\n        return null;\n      }\n\n      return result.lookupRows[0];\n    }\n  }]);\n\n  return LookupCall;\n}();\n\nexport { LookupCall as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/lookup/LookupCall.js"],"names":["objects","arrays","QueryBy","scout","$","LookupCall","session","hierarchical","loadIncremental","batch","queryBy","searchText","key","keys","parentKey","active","model","assertParameter","_init","extend","isNullOrUndefined","resolvedPromise","_textByKey","cloneForKey","execute","then","result","lookupRow","firstLookupRow","text","empty","_textsByKeys","cloneForKeys","isArray","lookupRows","textMap","forEach","row","ALL","_getAll","Error","TEXT","_getByText","KEY","_getByKey","KEYS","_getByKeys","REC","_getByRec","rec","properties","cloneShallow","clone","lookupCall","isPlainObject","create","length"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {objects, arrays, QueryBy, scout} from '../index';\nimport $ from 'jquery';\n\n/**\n * Base class for lookup calls. A concrete implementation of LookupCall.js which uses resources over a network\n * must deal with I/O errors and set, in case of an error, the 'exception' property on the returned lookup result.\n * The lookup call must _always_ return a result, otherwise the SmartField cannot work properly.\n */\nexport default class LookupCall {\n  constructor() {\n    this.session = null;\n    this.hierarchical = false;\n    this.loadIncremental = false;\n    this.batch = false; // indicates if the lookup call implements 'getByKeys' and therefore supports 'textsByKeys'\n\n    this.queryBy = null;\n    this.searchText = null; // used on QueryBy.TEXT\n    this.key = null; // used on QueryBy.KEY\n    this.keys = null; // used on QueryBy.KEYS\n    this.parentKey = null; // used on QueryBy.REC\n    this.active = null;\n  }\n\n  init(model) {\n    scout.assertParameter('session', model.session);\n    this._init(model);\n  }\n\n  _init(model) {\n    $.extend(this, model);\n  }\n\n  setLoadIncremental(loadIncremental) {\n    this.loadIncremental = loadIncremental;\n  }\n\n  setHierarchical(hierarchical) {\n    this.hierarchical = hierarchical;\n  }\n\n  setBatch(batch) {\n    this.batch = batch;\n  }\n\n  /**\n   * This method may be called directly on any LookupCall. For the key lookup an internal clone is created automatically.\n   *\n   * You should not override this function. Instead override <code>_textByKey</code>.\n   *\n   * @returns {Promise} which returns a text of the lookup row resolved by #getByKey\n   */\n  textByKey(key) {\n    if (objects.isNullOrUndefined(key)) {\n      return $.resolvedPromise('');\n    }\n    return this._textByKey(key);\n  }\n\n  /**\n   * Override this function to provide your own textByKey implementation.\n   *\n   * @returns {Promise} which returns a text of the lookup row resolved by #getByKey\n   */\n  _textByKey(key) {\n    return this\n      .cloneForKey(key)\n      .execute()\n      .then(function(result) {\n        var lookupRow = LookupCall.firstLookupRow(result);\n        return lookupRow ? lookupRow.text : '';\n      });\n  }\n\n  /**\n   * This method may be called directly on any LookupCall. For the keys lookup an internal clone is created automatically.\n   *\n   * You should not override this function. Instead override <code>_textsByKeys</code>.\n   *\n   * @returns {Promise} which returns an object that maps every key to the text of the resolved lookup row\n   */\n  textsByKeys(keys) {\n    if (arrays.empty(keys)) {\n      return $.resolvedPromise({});\n    }\n    return this._textsByKeys(keys);\n  }\n\n  /**\n   * Override this function to provide your own textsByKeys implementation.\n   *\n   * @returns {Promise} which returns an object that maps every key to the text of the lookup row\n   */\n  _textsByKeys(keys) {\n    return this\n      .cloneForKeys(keys)\n      .execute()\n      .then(function(result) {\n        if (!result || !objects.isArray(result.lookupRows)) {\n          return {};\n        }\n\n        var textMap = {};\n        result.lookupRows.forEach(function(row) {\n          textMap[row.key] = row.text;\n        });\n\n        return textMap;\n      });\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForAll().execute()</code> or <code>.clone().getAll()</code>.\n   *\n   * You should not override this function. Instead override <code>_getAll</code>.\n   *\n   * @return {Promise} resolves to a result object with an array of {LookupRow}s\n   */\n  getAll() {\n    this.queryBy = QueryBy.ALL;\n    return this._getAll();\n  }\n\n  /**\n   * Override this method to implement.\n   */\n  _getAll() {\n    throw new Error('getAll() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForText(text).execute()</code> or <code>.clone().getByText(text)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByText</code>.\n   *\n   * @return {Promise} resolves to a result object with an array of {LookupRow}s\n   */\n  getByText(text) {\n    this.queryBy = QueryBy.TEXT;\n    this.searchText = text;\n    return this._getByText(text);\n  }\n\n  /**\n   * Override this method to implement.\n   */\n  _getByText(text) {\n    throw new Error('getByText() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForKey(key).execute()</code> or <code>.clone().getByKey(parentKey)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByKey</code>.\n   *\n   * @return {Promise} resolves to a result object with a single {LookupRow}\n   */\n  getByKey(key) {\n    this.queryBy = QueryBy.KEY;\n    this.key = key;\n    return this._getByKey(key);\n  }\n\n  /**\n   * Override this method to implement.\n   */\n  _getByKey(key) {\n    throw new Error('getByKey() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForKeys(keys).execute()</code> or <code>.clone().getByKeys(keys)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByKeys</code>.\n   *\n   * @return {Promise} resolves to a result object with an array of {scout.LookupRow}s\n   */\n  getByKeys(keys) {\n    this.queryBy = QueryBy.KEYS;\n    this.keys = keys;\n    return this._getByKeys(keys);\n  }\n\n  /**\n   * Override this method to implement.\n   */\n  _getByKeys(keys) {\n    throw new Error('getByKeys() not implemented');\n  }\n\n  /**\n   * Only call this function if this LookupCall is not used again. Otherwise use <code>.cloneForRec(parentKey).execute()</code> or <code>.clone().getByRec(parentKey)</code>.\n   *\n   * You should not override this function. Instead override <code>_getByRec</code>.\n   *\n   * Returns a result with lookup rows for the given parent key. This is used for incremental lookups.\n   *\n   * @return {Promise} resolves to a result object with an array of {LookupRow}s\n   * @param {object} parentKey references the parent key\n   */\n  getByRec(parentKey) {\n    this.queryBy = QueryBy.REC;\n    this.parentKey = parentKey;\n    return this._getByRec(parentKey);\n  }\n\n  /**\n   * Override this method to implement.\n   */\n  _getByRec(rec) {\n    throw new Error('getByRec() not implemented');\n  }\n\n  /**\n   * Executes this LookupCall. For this method to work this LookupCall must be a clone created with one of the following methods:\n   * <code>cloneForAll()</code>, <code>cloneForText(text)</code>, <code>cloneForKey(key)</code>, <code>cloneForRec(parentKey)</code>\n   */\n  execute() {\n    if (QueryBy.KEY === this.queryBy) {\n      return this._getByKey(this.key);\n    }\n    if (QueryBy.ALL === this.queryBy) {\n      return this._getAll();\n    }\n    if (QueryBy.KEYS === this.queryBy) {\n      return this._getByKeys(this.keys);\n    }\n    if (QueryBy.TEXT === this.queryBy) {\n      return this._getByText(this.searchText);\n    }\n    if (QueryBy.REC === this.queryBy) {\n      return this._getByRec(this.parentKey);\n    }\n    throw new Error('cannot execute a non-clone LookupCall. Use one of the cloneFor*-methods before executing.');\n  }\n\n  clone(properties) {\n    // Warning: This is _not_ a deep clone! (Because otherwise the entire session would be duplicated.)\n    // Non-primitive properties must _only_ be added to the resulting clone during the 'prepareLookupCall' event!\n    return scout.cloneShallow(this, properties, true);\n  }\n\n  cloneForAll() {\n    return this.clone({\n      queryBy: QueryBy.ALL\n    });\n  }\n\n  cloneForText(text) {\n    return this.clone({\n      queryBy: QueryBy.TEXT,\n      searchText: text\n    });\n  }\n\n  cloneForKey(key) {\n    return this.clone({\n      queryBy: QueryBy.KEY,\n      key: key\n    });\n  }\n\n  cloneForKeys(keys) {\n    return this.clone({\n      queryBy: QueryBy.KEYS,\n      keys: keys\n    });\n  }\n\n  cloneForRec(parentKey) {\n    return this.clone({\n      queryBy: QueryBy.REC,\n      parentKey: parentKey\n    });\n  }\n\n  abort() {\n    // NOP. Implement in subclasses if necessary.\n  }\n\n  // ---- static helpers ----\n\n  static ensure(lookupCall, session) {\n    if (lookupCall instanceof LookupCall) {\n      // NOP - required to distinct instance from plain object (=model)\n    } else if (objects.isPlainObject(lookupCall)) {\n      lookupCall.session = session;\n      lookupCall = scout.create(lookupCall);\n    } else if (typeof lookupCall === 'string') {\n      lookupCall = scout.create(lookupCall, {\n        session: session\n      });\n    }\n    return lookupCall;\n  }\n\n  static firstLookupRow(result) {\n    if (!result) {\n      return null;\n    }\n    if (!objects.isArray(result.lookupRows)) {\n      return null;\n    }\n    if (result.lookupRows.length === 0) {\n      return null;\n    }\n    return result.lookupRows[0];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}