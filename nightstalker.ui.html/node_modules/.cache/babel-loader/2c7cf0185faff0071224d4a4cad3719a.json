{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, ContextMenuKeyStroke, DoubleClickSupport, graphics, HtmlComponent, KeyStrokeContext, LoadingSupport, LogicalGridData, MenuDestinations, menus as menus_1, numbers, objects, PlaceholderTile, Range, scout, TileGridGridConfig, TileGridLayout, TileGridLayoutConfig, TileGridSelectAllKeyStroke, TileGridSelectDownKeyStroke, TileGridSelectFirstKeyStroke, TileGridSelectionHandler, TileGridSelectLastKeyStroke, TileGridSelectLeftKeyStroke, TileGridSelectRightKeyStroke, TileGridSelectUpKeyStroke, VirtualScrolling, Widget } from '../index';\nimport $ from 'jquery';\n/**\n * Only select top-level tile elements. Do not select elements with a 'tile' class deeper in the tree.\n * This prevents errors when a developer accidentally adds an element that has the 'tile' class. #262146\n * @type {string}\n */\n\nvar TILE_SELECTOR = '> .tile';\n\nvar TileGrid = /*#__PURE__*/function (_Widget) {\n  _inherits(TileGrid, _Widget);\n\n  var _super = _createSuper(TileGrid);\n\n  function TileGrid() {\n    var _this;\n\n    _classCallCheck(this, TileGrid);\n\n    _this = _super.call(this);\n    _this.animateTileRemoval = true;\n    _this.animateTileInsertion = true;\n    _this.comparator = null;\n    _this._doubleClickSupport = new DoubleClickSupport();\n    _this.empty = false;\n    _this.filters = [];\n    _this.filteredTiles = [];\n    _this.filteredTilesDirty = true;\n    _this.focusedTile = null; // GridColumnCount will be modified by the layout, prefGridColumnCount remains unchanged\n\n    _this.gridColumnCount = 4;\n    _this.prefGridColumnCount = _this.gridColumnCount;\n    _this.logicalGrid = scout.create('scout.HorizontalGrid');\n    _this.layoutConfig = null;\n    _this.menus = [];\n    _this.multiSelect = true;\n    _this.renderAnimationEnabled = false;\n    _this.selectable = false;\n    _this.selectedTiles = [];\n    _this.selectionHandler = new TileGridSelectionHandler(_assertThisInitialized(_this));\n    _this.scrollable = true;\n    _this.scrolling = false;\n    _this.scrollTopDirty = false;\n    _this.startupAnimationDone = false;\n    _this.startupAnimationEnabled = false;\n    _this.tiles = [];\n    _this.tileRemovalPendingCount = 0;\n    _this.viewRangeSize = 0;\n    _this.viewRangeRendered = new Range(0, 0);\n    _this.virtual = false;\n    _this.virtualScrolling = null;\n    _this.withPlaceholders = false;\n    _this._filterMenusHandler = _this._filterMenus.bind(_assertThisInitialized(_this));\n    _this._renderViewPortAfterAttach = false;\n    _this._scrollParentScrollHandler = _this._onScrollParentScroll.bind(_assertThisInitialized(_this));\n\n    _this._addWidgetProperties(['tiles', 'selectedTiles', 'menus']);\n\n    _this._addPreserveOnPropertyChangeProperties(['selectedTiles']);\n\n    _this.$fillBefore = null;\n    _this.$fillAfter = null;\n    return _this;\n  }\n\n  _createClass(TileGrid, [{\n    key: \"_init\",\n    value: function _init(model) {\n      _get(_getPrototypeOf(TileGrid.prototype), \"_init\", this).call(this, model);\n\n      this._setGridColumnCount(this.gridColumnCount);\n\n      this._setLayoutConfig(this.layoutConfig);\n\n      this._initVirtualScrolling();\n\n      this._initTiles();\n\n      this._applyFilters(this.tiles);\n\n      this._updateFilteredTiles();\n\n      this._setMenus(this.menus);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_createKeyStrokeContext\",\n    value: function _createKeyStrokeContext() {\n      return new KeyStrokeContext();\n    }\n  }, {\n    key: \"_initVirtualScrolling\",\n    value: function _initVirtualScrolling() {\n      this.virtualScrolling = this._createVirtualScrolling();\n    }\n  }, {\n    key: \"_createVirtualScrolling\",\n    value: function _createVirtualScrolling() {\n      return new VirtualScrolling({\n        widget: this,\n        enabled: this.virtual,\n        viewRangeSize: this.viewRangeSize,\n        rowHeight: this._heightForRow.bind(this),\n        rowCount: this.rowCount.bind(this),\n        _renderViewRange: this._renderViewRange.bind(this)\n      });\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_createLoadingSupport\",\n    value: function _createLoadingSupport() {\n      return new LoadingSupport({\n        widget: this\n      });\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      _get(_getPrototypeOf(TileGrid.prototype), \"_initKeyStrokeContext\", this).call(this);\n\n      this.keyStrokeContext.registerKeyStroke([new TileGridSelectAllKeyStroke(this), new TileGridSelectLeftKeyStroke(this), new TileGridSelectRightKeyStroke(this), new TileGridSelectDownKeyStroke(this), new TileGridSelectUpKeyStroke(this), new TileGridSelectFirstKeyStroke(this), new TileGridSelectLastKeyStroke(this), new ContextMenuKeyStroke(this, this.showContextMenu, this)]);\n    }\n  }, {\n    key: \"_initTiles\",\n    value: function _initTiles() {\n      this.tiles.forEach(function (tile) {\n        this._initTile(tile);\n      }, this);\n    }\n  }, {\n    key: \"_initTile\",\n    value: function _initTile(tile) {\n      tile.setSelectable(this.selectable);\n      tile.setSelected(this.selectedTiles.indexOf(tile) >= 0); // Set proper state in case tile was used in another grid\n\n      tile.setParent(this);\n      tile.setFilterAccepted(true);\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      this.$container = this.$parent.appendDiv('tile-grid');\n      this.htmlComp = HtmlComponent.install(this.$container, this.session);\n      this.htmlComp.setLayout(this._createLayout());\n      this.$container.on('mousedown', TILE_SELECTOR, this._onTileMouseDown.bind(this)).on('click', TILE_SELECTOR, this._onTileClick.bind(this)).on('dblclick', TILE_SELECTOR, this._onTileDoubleClick.bind(this));\n    }\n  }, {\n    key: \"_createLayout\",\n    value: function _createLayout() {\n      return new TileGridLayout(this, this.layoutConfig);\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      _get(_getPrototypeOf(TileGrid.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderLayoutConfig();\n\n      this._renderScrollable();\n\n      this._renderVirtual();\n\n      this._renderSelectable();\n\n      this._renderEmpty();\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      this.$fillBefore = null;\n      this.$fillAfter = null;\n      this.viewRangeRendered = new Range(0, 0);\n\n      this._updateVirtualScrollable();\n\n      _get(_getPrototypeOf(TileGrid.prototype), \"_remove\", this).call(this);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_renderOnAttach\",\n    value: function _renderOnAttach() {\n      _get(_getPrototypeOf(TileGrid.prototype), \"_renderOnAttach\", this).call(this);\n\n      if (this._renderViewPortAfterAttach) {\n        this._renderViewPort();\n\n        this._renderViewPortAfterAttach = false;\n      }\n    }\n  }, {\n    key: \"_renderEnabled\",\n    value: function _renderEnabled() {\n      _get(_getPrototypeOf(TileGrid.prototype), \"_renderEnabled\", this).call(this);\n\n      this._updateTabbable();\n    }\n  }, {\n    key: \"_updateTabbable\",\n    value: function _updateTabbable() {\n      this.$container.setTabbable(this.enabled && this.selectable);\n    }\n  }, {\n    key: \"insertTile\",\n    value: function insertTile(tile) {\n      this.insertTiles([tile]);\n    }\n  }, {\n    key: \"insertTiles\",\n    value: function insertTiles(tilesToInsert, appendPlaceholders) {\n      tilesToInsert = arrays.ensure(tilesToInsert);\n\n      if (tilesToInsert.length === 0) {\n        return;\n      }\n\n      this.setTiles(this.tiles.concat(tilesToInsert), appendPlaceholders);\n    }\n  }, {\n    key: \"deleteTile\",\n    value: function deleteTile(tile) {\n      this.deleteTiles([tile]);\n    }\n  }, {\n    key: \"deleteTiles\",\n    value: function deleteTiles(tilesToDelete, appendPlaceholders) {\n      tilesToDelete = arrays.ensure(tilesToDelete);\n\n      if (tilesToDelete.length === 0) {\n        return;\n      }\n\n      var tiles = this.tiles.slice();\n      arrays.removeAll(tiles, tilesToDelete);\n      this.setTiles(tiles, appendPlaceholders);\n    }\n  }, {\n    key: \"deleteAllTiles\",\n    value: function deleteAllTiles() {\n      this.setTiles([]);\n    }\n  }, {\n    key: \"setTiles\",\n    value: function setTiles(tiles, appendPlaceholders) {\n      tiles = arrays.ensure(tiles);\n\n      if (objects.equals(this.tiles, tiles)) {\n        return;\n      } // Ensure given tiles are real tiles (of type Tile)\n\n\n      tiles = this._createChildren(tiles);\n\n      if (this.withPlaceholders && scout.nvl(appendPlaceholders, true)) {\n        // Remove placeholders from new tiles, they will be added later\n        this._deletePlaceholders(tiles);\n      } // Only insert those which are not already there\n\n\n      var tilesToInsert = arrays.diff(tiles, this.tiles);\n\n      this._insertTiles(tilesToInsert); // Append the existing placeholders, otherwise they would be unnecessarily deleted if a tile is deleted\n\n\n      if (this.withPlaceholders && scout.nvl(appendPlaceholders, true)) {\n        var placeholders = this.placeholders(); // But only add as much placeholders as needed: If a new tile is added, it should replace the placeholder underneath.\n        // If this were not done the placeholders would move animated when a new tile is inserted rather than just staying where they are\n\n        placeholders = placeholders.slice(Math.min(this._filterTiles(tilesToInsert).length, placeholders.length), placeholders.length);\n        arrays.pushAll(tiles, placeholders);\n      } // Only delete those which are not in the new array\n\n\n      var tilesToDelete = arrays.diff(this.tiles, tiles);\n\n      this._deleteTiles(tilesToDelete);\n\n      this._sort(tiles);\n\n      this.filteredTilesDirty = this.filteredTilesDirty || tilesToDelete.length > 0 || tilesToInsert.length > 0 || !arrays.equals(this.tiles, tiles); // last check necessary if sorting changed\n\n      var currentTiles = this.tiles;\n\n      this._setProperty('tiles', tiles);\n\n      this._updateFilteredTiles();\n\n      if (this.rendered) {\n        this._renderTileDelta();\n\n        this._renderTileOrder(currentTiles);\n\n        this._renderInsertTiles(tilesToInsert);\n      }\n    }\n  }, {\n    key: \"_insertTiles\",\n    value: function _insertTiles(tiles) {\n      if (tiles.length === 0) {\n        return;\n      }\n\n      tiles.forEach(function (tile) {\n        this._insertTile(tile);\n      }, this);\n    }\n  }, {\n    key: \"_insertTile\",\n    value: function _insertTile(tile) {\n      this._initTile(tile);\n\n      this._applyFilters([tile]);\n\n      if (!this.virtual && this.rendered) {\n        this._renderTile(tile);\n      }\n    }\n  }, {\n    key: \"_renderTile\",\n    value: function _renderTile(tile) {\n      if (tile.removalPending) {\n        // If tile is being removed by the filter and the filter cleared so that the tile should be rendered again while the animation is still running,\n        // we need to wait for the remove animation, otherwise an already rendered exception occurs\n        tile.one('remove', function () {\n          if (tile.rendered) {\n            // Might be already rendered again by renderTileDelta because filter was changed again\n            return;\n          }\n\n          this._renderTile(tile);\n\n          this._renderTileVisibleForFilter(tile);\n\n          if (this.tileRemovalPendingCount === 0) {\n            this.invalidateLayoutTree();\n          }\n        }.bind(this));\n        return;\n      }\n\n      tile.render();\n      tile.setLayoutData(new LogicalGridData(tile));\n      tile.$container.addClass('newly-rendered');\n    }\n  }, {\n    key: \"_renderInsertTiles\",\n    value: function _renderInsertTiles(tiles) {\n      tiles.forEach(function (tile) {\n        if (!tile.rendered) {\n          return;\n        }\n\n        tile.$container.addClass('invisible'); // Wait until the layout animation is done before animating the insert operation.\n        // Also make them invisible to not cover existing tiles while they are moving or changing size.\n        // Also do it for tiles which don't have an insert animation (e.g. placeholders), due to the same reason.\n\n        this.one('layoutAnimationDone', function () {\n          if (tile.rendered) {\n            tile.$container.removeClass('invisible');\n\n            if (this._animateTileInsertion(tile)) {\n              tile.$container.addClassForAnimation('animate-insert');\n            }\n          }\n        }.bind(this));\n      }, this);\n\n      if (!this.htmlComp.layouting) {\n        // no need to invalidate when tile placeholders are added or removed while layouting\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_removeAllTiles\",\n    value: function _removeAllTiles() {\n      this.tiles.forEach(function (tile) {\n        tile.remove();\n      });\n      this.viewRangeRendered = new Range(0, 0);\n    }\n  }, {\n    key: \"_renderAllTiles\",\n    value: function _renderAllTiles() {\n      this.tiles.forEach(function (tile) {\n        this._renderTile(tile);\n      }, this);\n    }\n  }, {\n    key: \"_deleteTiles\",\n    value: function _deleteTiles(tiles) {\n      if (tiles.length === 0) {\n        return;\n      }\n\n      tiles.forEach(function (tile) {\n        this._deleteTile(tile);\n      }, this);\n      this.deselectTiles(tiles);\n\n      if (this.rendered && !this.htmlComp.layouting) {\n        // no need to invalidate when tile placeholders are added or removed while layouting\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_deleteTile\",\n    value: function _deleteTile(tile) {\n      if (this._animateTileRemoval(tile)) {\n        // Animate tile removal, but not while layouting when tile placeholders are added or removed\n        tile.animateRemoval = true;\n      } // Destroy only if it is the owner, if tile belongs to another widget, just remove it\n\n\n      if (tile.owner === this) {\n        tile.destroy();\n      } else if (this.rendered) {\n        tile.remove();\n      }\n\n      this._onAnimatedTileRemove(tile);\n\n      tile.animateRemoval = false;\n\n      if (tile === this.focusedTile) {\n        this.setFocusedTile(null);\n      }\n    }\n  }, {\n    key: \"_animateTileRemoval\",\n    value: function _animateTileRemoval(tile) {\n      return this.animateTileRemoval && !(tile instanceof PlaceholderTile);\n    }\n  }, {\n    key: \"_animateTileInsertion\",\n    value: function _animateTileInsertion(tile) {\n      return this.animateTileInsertion && !(tile instanceof PlaceholderTile);\n    }\n  }, {\n    key: \"_onAnimatedTileRemove\",\n    value: function _onAnimatedTileRemove(tile) {\n      if (!tile.rendered || !tile.animateRemoval) {\n        return;\n      }\n\n      this.tileRemovalPendingCount++;\n      tile.one('remove', function () {\n        this.tileRemovalPendingCount--;\n\n        if (this.rendered && this.tileRemovalPendingCount === 0 && !this.htmlComp.layouting) {\n          this.invalidateLayoutTree();\n        }\n      }.bind(this));\n    }\n  }, {\n    key: \"setComparator\",\n    value: function setComparator(comparator) {\n      if (this.comparator === comparator) {\n        return;\n      }\n\n      this.comparator = comparator;\n    }\n  }, {\n    key: \"sort\",\n    value: function sort() {\n      var tiles = this.tiles.slice();\n\n      this._sort(tiles);\n\n      if (arrays.equals(this.tiles, tiles)) {\n        // Check is needed anyway to determine whether filteredTilesDirty needs to be set, so we can use it here as well to early return if nothing changed\n        return;\n      }\n\n      var currentTiles = this.tiles;\n\n      this._setProperty('tiles', tiles); // Sort list of filtered tiles as well\n\n\n      this.filteredTilesDirty = true;\n\n      this._updateFilteredTiles();\n\n      if (this.rendered) {\n        this._renderTileDelta();\n\n        this._renderTileOrder(currentTiles);\n\n        this.validateLayoutTree(); // prevent flickering in virtual mode\n      }\n    }\n  }, {\n    key: \"_sort\",\n    value: function _sort(tiles) {\n      if (this.comparator === null) {\n        return;\n      }\n\n      var placeholders = [];\n\n      if (this.withPlaceholders) {\n        // Don't reorder placeholders -> remove them first, then sort and add them afterwards again\n        placeholders = this._deletePlaceholders(tiles);\n      }\n\n      tiles.sort(this.comparator);\n      arrays.pushAll(tiles, placeholders);\n    }\n  }, {\n    key: \"invalidateLayoutTree\",\n    value: function invalidateLayoutTree(invalidateParents) {\n      if (this.tileRemovalPendingCount > 0) {\n        // Do not invalidate while tile removal is still pending\n        return;\n      }\n\n      _get(_getPrototypeOf(TileGrid.prototype), \"invalidateLayoutTree\", this).call(this, invalidateParents);\n    }\n  }, {\n    key: \"setGridColumnCount\",\n    value: function setGridColumnCount(gridColumnCount) {\n      this.setProperty('gridColumnCount', gridColumnCount);\n    }\n  }, {\n    key: \"_setGridColumnCount\",\n    value: function _setGridColumnCount(gridColumnCount) {\n      this._setProperty('gridColumnCount', gridColumnCount);\n\n      this.prefGridColumnCount = gridColumnCount;\n      this.invalidateLogicalGrid();\n    }\n  }, {\n    key: \"setLayoutConfig\",\n    value: function setLayoutConfig(layoutConfig) {\n      this.setProperty('layoutConfig', layoutConfig);\n    }\n  }, {\n    key: \"_setLayoutConfig\",\n    value: function _setLayoutConfig(layoutConfig) {\n      if (!layoutConfig) {\n        layoutConfig = new TileGridLayoutConfig();\n      }\n\n      this._setProperty('layoutConfig', TileGridLayoutConfig.ensure(layoutConfig));\n    }\n  }, {\n    key: \"_renderLayoutConfig\",\n    value: function _renderLayoutConfig() {\n      var oldMinWidth = this.htmlComp.layout.minWidth;\n      this.layoutConfig.applyToLayout(this.htmlComp.layout);\n\n      if (this.virtualScrolling) {\n        this.virtualScrolling.setMinRowHeight(this._minRowHeight());\n        this.setViewRangeSize(this.virtualScrolling.viewRangeSize, false);\n      }\n\n      if (oldMinWidth !== this.htmlComp.layout.minWidth) {\n        this._renderScrollable();\n      }\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_setMenus\",\n    value: function _setMenus(menus, oldMenus) {\n      this.updateKeyStrokes(menus, oldMenus);\n\n      this._setProperty('menus', menus);\n    }\n  }, {\n    key: \"_filterMenus\",\n    value: function _filterMenus(menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {\n      return menus_1.filterAccordingToSelection('TileGrid', this.selectedTiles.length, menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes);\n    }\n  }, {\n    key: \"showContextMenu\",\n    value: function showContextMenu(options) {\n      this.session.onRequestsDone(this._showContextMenu.bind(this, options));\n    }\n    /**\n     * @param options may contain pageX, pageY, menuItems and menuFilter.\n     * If these properties are not provided they are determined automatically.\n     */\n\n  }, {\n    key: \"_showContextMenu\",\n    value: function _showContextMenu(options) {\n      options = options || {};\n\n      if (!this.rendered || !this.attached) {\n        // check needed because function is called asynchronously\n        return;\n      }\n\n      if (this.selectedTiles.length === 0) {\n        return;\n      }\n\n      var menuItems = options.menuItems || this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true, false);\n\n      if (menuItems.length === 0) {\n        return;\n      }\n\n      var pageX = scout.nvl(options.pageX, null);\n      var pageY = scout.nvl(options.pageY, null);\n\n      if (pageX === null || pageY === null) {\n        var offset;\n        var $scrollable = this.$container.scrollParent();\n\n        if ($scrollable.length === 0) {\n          $scrollable = this.$container;\n        }\n\n        var scrollableBounds = graphics.offsetBounds($scrollable);\n        var focusedTile = this.focusedTile || arrays.last(this.selectedTiles);\n\n        if (this.isTileInView(focusedTile)) {\n          // Place the context menu on the focused tile if possible\n          offset = focusedTile.$container.offset();\n        } else {\n          // If focused tile is not in view place the popup in the top left corner of the tile grid\n          offset = this.$container.offset();\n        }\n\n        pageX = offset.left + 10;\n        pageY = offset.top + 10; // Ensure popup is always in view. Add +-1 to make sure it won't be made invisible by Popup._isInView even if bounds are fractional\n\n        pageX = Math.min(Math.max(pageX, scrollableBounds.x + 1), scrollableBounds.right() - 1);\n        pageY = Math.min(Math.max(pageY, scrollableBounds.y + 1), scrollableBounds.bottom() - 1);\n      } // Prevent firing of 'onClose'-handler during contextMenu.open()\n      // (Can lead to null-access when adding a new handler to this.contextMenu)\n\n\n      if (this.contextMenu) {\n        this.contextMenu.close();\n      }\n\n      this.contextMenu = scout.create('ContextMenuPopup', {\n        parent: this,\n        menuItems: menuItems,\n        location: {\n          x: pageX,\n          y: pageY\n        },\n        $anchor: this.$container,\n        menuFilter: options.menuFilter || this._filterMenusHandler\n      });\n      this.contextMenu.open();\n    }\n  }, {\n    key: \"setScrollable\",\n    value: function setScrollable(scrollable) {\n      this.setProperty('scrollable', scrollable);\n    }\n  }, {\n    key: \"_renderScrollable\",\n    value: function _renderScrollable() {\n      this._uninstallScrollbars(); // horizontal (x-axis) scrollbar is only installed when minWidth is > 0\n\n\n      if (this.scrollable) {\n        this._installScrollbars({\n          axis: this.layoutConfig.minWidth > 0 ? 'both' : 'y'\n        });\n      } else if (this.layoutConfig.minWidth > 0) {\n        this._installScrollbars({\n          axis: 'x'\n        });\n      }\n\n      this.$container.toggleClass('scrollable', this.scrollable);\n\n      this._updateVirtualScrollable();\n\n      this.invalidateLayoutTree();\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll() {\n      var scrollTop = this.$container[0].scrollTop;\n      var scrollLeft = this.$container[0].scrollLeft;\n\n      if (this.scrollTop !== scrollTop && this.virtual) {\n        this.scrolling = true;\n        this.revalidateLayout();\n        this.scrolling = false;\n      }\n\n      this.scrollTop = scrollTop;\n      this.scrollLeft = scrollLeft;\n    }\n  }, {\n    key: \"_onScrollParentScroll\",\n    value: function _onScrollParentScroll(event) {\n      this.scrolling = true;\n      this.revalidateLayoutTree(false);\n      this.scrolling = false;\n    }\n  }, {\n    key: \"setWithPlaceholders\",\n    value: function setWithPlaceholders(withPlaceholders) {\n      this.setProperty('withPlaceholders', withPlaceholders);\n    }\n  }, {\n    key: \"_renderWithPlaceholders\",\n    value: function _renderWithPlaceholders() {\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"fillUpWithPlaceholders\",\n    value: function fillUpWithPlaceholders() {\n      if (!this.withPlaceholders) {\n        this._deleteAllPlaceholders();\n\n        return;\n      }\n\n      this._deleteObsoletePlaceholders();\n\n      this._insertMissingPlaceholders();\n    }\n  }, {\n    key: \"tilesWithoutPlaceholders\",\n    value: function tilesWithoutPlaceholders() {\n      if (!this.withPlaceholders) {\n        return this.tiles;\n      }\n\n      return this.tiles.filter(function (tile) {\n        return !(tile instanceof PlaceholderTile);\n      });\n    }\n  }, {\n    key: \"_createPlaceholders\",\n    value: function _createPlaceholders() {\n      var numPlaceholders,\n          lastX,\n          columnCount = this.gridColumnCount,\n          tiles = this.filteredTiles,\n          placeholders = [];\n\n      if (tiles.length > 0) {\n        lastX = tiles[tiles.length - 1].gridData.x;\n      } else {\n        // If there are no tiles, create one row with placeholders\n        lastX = -1;\n      }\n\n      if (lastX === columnCount - 1) {\n        // If last tile is the last element in the row, don't create placeholders\n        return [];\n      } // Otherwise create placeholders for every missing tile in the last row\n\n\n      numPlaceholders = columnCount - 1 - lastX;\n\n      for (var i = 0; i < numPlaceholders; i++) {\n        placeholders.push(this._createPlaceholder());\n      }\n\n      return placeholders;\n    }\n  }, {\n    key: \"_createPlaceholder\",\n    value: function _createPlaceholder() {\n      return scout.create('PlaceholderTile', {\n        parent: this\n      });\n    }\n  }, {\n    key: \"_deleteObsoletePlaceholders\",\n    value: function _deleteObsoletePlaceholders() {\n      var obsoletePlaceholders = [],\n          obsolete = false;\n      var placeholders = this.placeholders();\n      placeholders.forEach(function (placeholder) {\n        // Remove all placeholder in the row if there is one at x=0 (don't do it if there are only placeholders)\n        if (placeholder.gridData.x === 0 && this.filteredTiles[0] !== placeholder) {\n          obsolete = true;\n        }\n\n        if (obsolete) {\n          obsoletePlaceholders.push(placeholder);\n        }\n      }, this);\n      this.deleteTiles(obsoletePlaceholders, false);\n    }\n  }, {\n    key: \"_deleteAllPlaceholders\",\n    value: function _deleteAllPlaceholders() {\n      this.deleteTiles(this.placeholders(), false);\n    }\n  }, {\n    key: \"placeholders\",\n    value: function placeholders() {\n      var i,\n          placeholders = [];\n\n      for (i = this.tiles.length - 1; i >= 0; i--) {\n        if (!(this.tiles[i] instanceof PlaceholderTile)) {\n          // Placeholders are always at the end -> we may stop as soon as no more placeholders are found\n          break;\n        }\n\n        arrays.insert(placeholders, this.tiles[i], 0);\n      }\n\n      return placeholders;\n    }\n  }, {\n    key: \"_insertMissingPlaceholders\",\n    value: function _insertMissingPlaceholders() {\n      var placeholders = this._createPlaceholders();\n\n      this.insertTiles(placeholders, false);\n    }\n  }, {\n    key: \"_deletePlaceholders\",\n    value: function _deletePlaceholders(tiles) {\n      var i;\n      var deletedPlaceholders = [];\n\n      for (i = tiles.length - 1; i >= 0; i--) {\n        if (tiles[i] instanceof PlaceholderTile) {\n          deletedPlaceholders.push(tiles[i]);\n          arrays.remove(tiles, tiles[i]);\n        }\n      }\n\n      return deletedPlaceholders.reverse();\n    }\n  }, {\n    key: \"_replacePlaceholders\",\n    value: function _replacePlaceholders(tiles, tilesToInsert) {\n      // Find index of the first tile which is not a placeholder (placeholders are always added at the end, so it is faster if search is done backwards)\n      var index = arrays.findIndexFromReverse(tiles, tiles.length - 1, function (tile) {\n        return !(tile instanceof PlaceholderTile);\n      });\n      var numPlaceholders = tiles.length - 1 - index;\n\n      for (var i = 1; i <= numPlaceholders; i++) {\n        var tile = tiles[index + i];\n\n        if (tilesToInsert[i - 1] && !(tilesToInsert[i - 1] instanceof PlaceholderTile)) {\n          arrays.remove(tiles, tile);\n        }\n      }\n    }\n  }, {\n    key: \"validateLogicalGrid\",\n    value: function validateLogicalGrid() {\n      if (!this.logicalGrid.dirty) {\n        return;\n      }\n\n      this.logicalGrid.validate(this);\n      this.fillUpWithPlaceholders();\n      this.logicalGrid.setDirty(true);\n      this.logicalGrid.validate(this);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_setLogicalGrid\",\n    value: function _setLogicalGrid(logicalGrid) {\n      _get(_getPrototypeOf(TileGrid.prototype), \"_setLogicalGrid\", this).call(this, logicalGrid);\n\n      if (this.logicalGrid) {\n        this.logicalGrid.setGridConfig(new TileGridGridConfig());\n      }\n    }\n  }, {\n    key: \"setFocusedTile\",\n    value: function setFocusedTile(tile) {\n      if (this.focusedTile === tile) {\n        return;\n      }\n\n      this.focusedTile = tile;\n\n      if (!this.rendered || !tile || this.isFocused()) {\n        return;\n      }\n\n      var $scrollables = this.$container.scrollParents();\n\n      if ($scrollables.length === 0) {\n        return;\n      }\n\n      var oldScrollTopArr = $scrollables.map(function (i, $elem) {\n        return $elem.scrollTop();\n      }).toArray(); // Make sure the tile grid has the focus when focusing a tile\n\n      if (this.focus()) {\n        // Restore old scroll to prevent scrolling by the browser due to the focus() call\n        oldScrollTopArr.forEach(function (val, idx) {\n          $scrollables[idx].scrollTop(val);\n        }, this);\n      }\n    }\n  }, {\n    key: \"setSelectable\",\n    value: function setSelectable(selectable) {\n      this.setProperty('selectable', selectable);\n\n      if (!selectable) {\n        this.deselectAllTiles();\n      }\n\n      this.tiles.forEach(function (tile) {\n        tile.setSelectable(selectable);\n      });\n    }\n  }, {\n    key: \"_renderSelectable\",\n    value: function _renderSelectable() {\n      this.$container.toggleClass('selectable', this.selectable);\n\n      this._updateTabbable();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"setMultiSelect\",\n    value: function setMultiSelect(multiSelect) {\n      this.setProperty('multiSelect', multiSelect);\n    }\n    /**\n     * Selects the given tiles and deselects the previously selected ones.\n     */\n\n  }, {\n    key: \"selectTiles\",\n    value: function selectTiles(tiles) {\n      tiles = arrays.ensure(tiles); // Ensure given tiles are real tiles (of type Tile)\n\n      tiles = this._createChildren(tiles);\n      tiles = this._filterTiles(tiles); // Selecting invisible tiles is not allowed\n      // Ensure no tiles will be selected if selectable is disabled\n\n      if (!this.selectable) {\n        tiles = [];\n      } // Ensure only one tile is selected if multiSelect is disabled\n\n\n      if (!this.multiSelect && tiles.length > 1) {\n        tiles = [tiles[0]];\n      }\n\n      if (arrays.equals(this.selectedTiles, tiles)) {\n        // Do nothing if new selection is same as old one\n        return;\n      } // Deselect the tiles which are not part of the new selection\n\n\n      var tilesToUnselect = this.selectedTiles;\n      arrays.removeAll(tilesToUnselect, tiles);\n      tilesToUnselect.forEach(function (tile) {\n        tile.setSelected(false);\n\n        if (tile === this.focusedTile) {\n          this.setFocusedTile(null);\n        }\n      }, this); // Select the tiles\n\n      tiles.forEach(function (tile) {\n        tile.setSelected(true);\n      }, this);\n      this.setProperty('selectedTiles', tiles.slice());\n    }\n  }, {\n    key: \"selectTile\",\n    value: function selectTile(tile) {\n      this.selectTiles([tile]);\n    }\n    /**\n     * Selects all tiles. As for every selection operation: only filtered tiles are considered.\n     */\n\n  }, {\n    key: \"selectAllTiles\",\n    value: function selectAllTiles() {\n      this.selectTiles(this.filteredTiles);\n    }\n  }, {\n    key: \"deselectTiles\",\n    value: function deselectTiles(tiles) {\n      tiles = arrays.ensure(tiles);\n      var selectedTiles = this.selectedTiles.slice();\n\n      if (arrays.removeAll(selectedTiles, tiles)) {\n        this.selectTiles(selectedTiles);\n      }\n    }\n  }, {\n    key: \"deselectTile\",\n    value: function deselectTile(tile) {\n      this.deselectTiles([tile]);\n    }\n  }, {\n    key: \"deselectAllTiles\",\n    value: function deselectAllTiles() {\n      this.selectTiles([]);\n    }\n  }, {\n    key: \"toggleSelection\",\n    value: function toggleSelection() {\n      if (this.selectedTiles.length === this.filteredTiles.length) {\n        this.deselectAllTiles();\n      } else {\n        this.selectAllTiles();\n      }\n    }\n  }, {\n    key: \"addTilesToSelection\",\n    value: function addTilesToSelection(tiles) {\n      tiles = arrays.ensure(tiles);\n      this.selectTiles(this.selectedTiles.concat(tiles));\n    }\n  }, {\n    key: \"addTileToSelection\",\n    value: function addTileToSelection(tile) {\n      this.addTilesToSelection([tile]);\n    }\n    /**\n     * @returns {boolean} true if the tile is completely or partially visible in the first scrollable parent.\n     */\n\n  }, {\n    key: \"isTileInView\",\n    value: function isTileInView(tile) {\n      var $scrollable = this.$container.scrollParent();\n\n      if ($scrollable.length === 0) {\n        $scrollable = this.$container;\n      }\n\n      if (!tile || !tile.$container || !$scrollable) {\n        return false;\n      }\n\n      return graphics.offsetBounds(tile.$container).intersects(graphics.offsetBounds($scrollable));\n    }\n  }, {\n    key: \"_onTileMouseDown\",\n    value: function _onTileMouseDown(event) {\n      this._doubleClickSupport.mousedown(event);\n\n      this._selectTileOnMouseDown(event);\n\n      if (event.which === 3) {\n        this.showContextMenu({\n          pageX: event.pageX,\n          pageY: event.pageY\n        });\n        return false;\n      }\n    }\n  }, {\n    key: \"_onTileClick\",\n    value: function _onTileClick(event) {\n      var $tile = $(event.currentTarget);\n      var tile = $tile.data('widget');\n\n      if (tile instanceof PlaceholderTile) {\n        return;\n      }\n\n      if (this._doubleClickSupport.doubleClicked()) {\n        // Don't execute on double click events\n        return;\n      }\n\n      var mouseButton = event.which;\n\n      this._triggerTileClick(tile, mouseButton);\n    }\n  }, {\n    key: \"_triggerTileClick\",\n    value: function _triggerTileClick(tile, mouseButton) {\n      var event = {\n        tile: tile,\n        mouseButton: mouseButton\n      };\n      this.trigger('tileClick', event);\n    }\n  }, {\n    key: \"_onTileDoubleClick\",\n    value: function _onTileDoubleClick(event) {\n      var $tile = $(event.currentTarget);\n      var tile = $tile.data('widget');\n\n      if (tile instanceof PlaceholderTile) {\n        return;\n      }\n\n      this.doTileAction(tile);\n    }\n  }, {\n    key: \"doTileAction\",\n    value: function doTileAction(tile) {\n      if (!tile) {\n        return;\n      }\n\n      this._triggerTileAction(tile);\n    }\n  }, {\n    key: \"_triggerTileAction\",\n    value: function _triggerTileAction(tile) {\n      this.trigger('tileAction', {\n        tile: tile\n      });\n    }\n  }, {\n    key: \"setSelectionHandler\",\n    value: function setSelectionHandler(selectionHandler) {\n      this.selectionHandler = selectionHandler;\n    }\n  }, {\n    key: \"_selectTileOnMouseDown\",\n    value: function _selectTileOnMouseDown(event) {\n      this.selectionHandler.selectTileOnMouseDown(event);\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(tile, options) {\n      this.ensureTileRendered(tile); // If tile was not rendered it is not yet positioned correctly -> make sure layout is valid before trying to scroll\n      // Layout must not render the viewport because scroll position is not correct yet -> just make sure tiles are at the correct position\n\n      this.scrolling = true;\n      this.scrollTopDirty = true;\n      this.validateLayoutTree();\n      this.scrolling = false;\n      tile.reveal(options);\n      this.scrollTopDirty = false;\n    }\n  }, {\n    key: \"revealSelection\",\n    value: function revealSelection() {\n      if (!this.rendered) {\n        // Execute delayed because tileGrid may be not layouted yet\n        this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n        return;\n      }\n\n      if (this.selectedTiles.length > 0) {\n        this.scrollTo(this.selectedTiles[0]);\n      }\n    }\n  }, {\n    key: \"addFilter\",\n    value: function addFilter(filter) {\n      this.addFilters([filter]);\n    }\n  }, {\n    key: \"addFilters\",\n    value: function addFilters(filtersToAdd) {\n      filtersToAdd = arrays.ensure(filtersToAdd);\n      var filters = this.filters.slice();\n      filtersToAdd.forEach(function (filter) {\n        if (filters.indexOf(filter) >= 0) {\n          return;\n        }\n\n        filters.push(filter);\n      });\n\n      if (filters.length === this.filters.length) {\n        return;\n      }\n\n      this.setFilters(filters);\n    }\n  }, {\n    key: \"removeFilter\",\n    value: function removeFilter(filter) {\n      this.removeFilters([filter]);\n    }\n  }, {\n    key: \"removeFilters\",\n    value: function removeFilters(filtersToRemove) {\n      filtersToRemove = arrays.ensure(filtersToRemove);\n      var filters = this.filters.slice();\n\n      if (!arrays.removeAll(filters, filtersToRemove)) {\n        return;\n      }\n\n      this.setFilters(filters);\n    }\n  }, {\n    key: \"setFilters\",\n    value: function setFilters(filters) {\n      this.setProperty('filters', filters.slice());\n    }\n  }, {\n    key: \"filter\",\n    value: function filter() {\n      var currentTiles = this.tiles; // Full reset is set to true to loop through every tile and make sure tile.filterAccepted is correctly set\n\n      var filterResult = this._applyFilters(this.tiles, true);\n\n      this._updateFilteredTiles();\n\n      if (this.rendered) {\n        // Not all tiles may be rendered yet (e.g. if filter is active before grid is rendered and removed after grid is rendered)\n        // But updating the view range is necessary anyway (fillers, scrollbars, viewRangeRendered etc.)\n        this._renderTileDelta(filterResult);\n\n        this._renderTileOrder(currentTiles);\n      }\n    }\n  }, {\n    key: \"_applyFilters\",\n    value: function _applyFilters(tiles, fullReset) {\n      if (this.filters.length === 0 && !scout.nvl(fullReset, false)) {\n        return;\n      }\n\n      var newlyShownTiles = [];\n      var newlyHiddenTiles = [];\n      var changed = false;\n      tiles.forEach(function (tile) {\n        if (this._applyFiltersForTile(tile)) {\n          changed = true;\n\n          if (tile.filterAccepted) {\n            newlyShownTiles.push(tile);\n          } else {\n            newlyHiddenTiles.push(tile);\n\n            if (tile === this.focusedTile) {\n              this.setFocusedTile(null);\n            }\n          }\n        }\n      }, this);\n\n      if (changed) {\n        this.filteredTilesDirty = true;\n      } // Non visible tiles must be deselected\n\n\n      this.deselectTiles(newlyHiddenTiles);\n      return {\n        newlyHiddenTiles: newlyHiddenTiles,\n        newlyShownTiles: newlyShownTiles\n      };\n    }\n  }, {\n    key: \"_updateFilteredTiles\",\n    value: function _updateFilteredTiles() {\n      var tiles = this.tiles;\n\n      if (this.filters.length > 0) {\n        tiles = this._filterTiles();\n      }\n\n      if (this.filteredTilesDirty) {\n        this.setProperty('filteredTiles', tiles);\n        this.invalidateLogicalGrid(false);\n        this.filteredTilesDirty = false;\n      }\n\n      this._updateEmpty();\n    }\n  }, {\n    key: \"_updateEmpty\",\n    value: function _updateEmpty() {\n      this.setEmpty(this.filteredTiles.length === 0);\n    }\n  }, {\n    key: \"setEmpty\",\n    value: function setEmpty(empty) {\n      this.setProperty('empty', empty);\n    }\n  }, {\n    key: \"_renderEmpty\",\n    value: function _renderEmpty() {\n      this.$container.toggleClass('empty', this.empty);\n      this.invalidateLayoutTree();\n    }\n    /**\n     * @returns {Boolean} true if tile state has changed, false if not\n     */\n\n  }, {\n    key: \"_applyFiltersForTile\",\n    value: function _applyFiltersForTile(tile) {\n      if (this._tileAcceptedByFilters(tile)) {\n        if (!tile.filterAccepted) {\n          tile.setFilterAccepted(true);\n          return true;\n        }\n      } else if (tile.filterAccepted) {\n        tile.setFilterAccepted(false);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_tileAcceptedByFilters\",\n    value: function _tileAcceptedByFilters(tile) {\n      return !this.filters.some(function (filter) {\n        // return true if an element was found which is not accepted by the filter to break the some() loop\n        if (tile instanceof PlaceholderTile) {\n          return false;\n        }\n\n        return !filter.accept(tile);\n      });\n    }\n    /**\n     * @returns {Tile[]} the tiles which are accepted by the filter and therefore visible.\n     */\n\n  }, {\n    key: \"_filterTiles\",\n    value: function _filterTiles(tiles) {\n      tiles = scout.nvl(tiles, this.tiles);\n\n      if (this.filters.length === 0) {\n        return tiles.slice();\n      }\n\n      return tiles.filter(function (tile) {\n        return tile.filterAccepted;\n      });\n    }\n  }, {\n    key: \"findTileIndexAt\",\n    value: function findTileIndexAt(x, y, startIndex, reverse) {\n      startIndex = scout.nvl(startIndex, 0);\n      return arrays.findIndexFrom(this.filteredTiles, startIndex, function (tile, i) {\n        return tile.gridData.x === x && tile.gridData.y === y;\n      }, reverse);\n    }\n    /**\n     * If the max range is used, the live list of filtered tiles is returned, because every tile has to be in the range.\n     */\n\n  }, {\n    key: \"findTilesInRange\",\n    value: function findTilesInRange(viewRange, filter) {\n      if (viewRange.equals(this.virtualScrolling.maxViewRange())) {\n        // Directly return all tiles if max view range\n        return this.filteredTiles;\n      }\n\n      var tiles = [];\n\n      for (var row = viewRange.from; row < viewRange.to; row++) {\n        this.eachTileInRow(row, function (tile) {\n          // jshint ignore:line\n          if (!filter || filter(tile)) {\n            tiles.push(tile);\n          }\n        });\n      }\n\n      return tiles;\n    }\n  }, {\n    key: \"findTilesInRow\",\n    value: function findTilesInRow(row) {\n      var tiles = [];\n      this.eachTileInRow(row, function (tile) {\n        tiles.push(tile);\n      });\n      return tiles;\n    }\n    /**\n     * Executes the given function for each tile in a row.\n     */\n\n  }, {\n    key: \"eachTileInRow\",\n    value: function eachTileInRow(row, func) {\n      var startIndex = row * this.gridColumnCount;\n      var tiles = [];\n\n      for (var i = startIndex; i < startIndex + this.gridColumnCount; i++) {\n        if (this.filteredTiles[i]) {\n          func(this.filteredTiles[i], i);\n        }\n      }\n\n      return tiles;\n    }\n  }, {\n    key: \"setVirtual\",\n    value: function setVirtual(virtual) {\n      this.setProperty('virtual', virtual);\n    }\n  }, {\n    key: \"_setVirtual\",\n    value: function _setVirtual(virtual) {\n      this._setProperty('virtual', virtual);\n\n      this.virtualScrolling.setEnabled(this.virtual);\n    }\n  }, {\n    key: \"_renderVirtual\",\n    value: function _renderVirtual() {\n      this._updateVirtualScrollable();\n\n      if (!this.rendering) {\n        // No need to do it while rendering, will be done by the layout. But needs to be done if virtual changes on the fly\n        this.setViewRangeSize(this.calculateViewRangeSize(), false);\n      }\n\n      if (this.rendered) {\n        // When virtual toggles, remove all tiles and render them anew (to have the correct tiles rendered in the new mode)\n        this._removeAllTiles();\n\n        if (this.virtual) {\n          // RenderViewPort may do nothing if all tiles are already in the view port, but fillers may not be created yet\n          this._renderFiller();\n        }\n      }\n\n      if (!this.virtual) {\n        // Render all tiles (on toggle and initially) (_renderViewRange is not used in non virtual mode because filtered tiles need to be rendered as well)\n        this._renderAllTiles();\n      }\n\n      this._renderViewPort();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_updateVirtualScrollable\",\n    value: function _updateVirtualScrollable() {\n      var $scrollable = this.virtualScrolling.$scrollable;\n\n      if ($scrollable) {\n        $scrollable.off('scroll', this._scrollParentScrollHandler);\n      }\n\n      if (!this.virtual || this.removing) {\n        this.virtualScrolling.set$Scrollable(null);\n        return;\n      }\n\n      if (this.scrollable) {\n        this.virtualScrolling.set$Scrollable(this.$container);\n      } else {\n        this.virtualScrolling.set$Scrollable(this.$container.scrollParent());\n        this.virtualScrolling.$scrollable.on('scroll', this._scrollParentScrollHandler);\n      }\n    }\n  }, {\n    key: \"calculateViewRangeSize\",\n    value: function calculateViewRangeSize() {\n      return this.virtualScrolling.calculateViewRangeSize();\n    }\n  }, {\n    key: \"setViewRangeSize\",\n    value: function setViewRangeSize(viewRangeSize, updateViewPort) {\n      if (this.viewRangeSize === viewRangeSize) {\n        return;\n      }\n\n      this._setProperty('viewRangeSize', viewRangeSize);\n\n      this.virtualScrolling.setViewRangeSize(viewRangeSize, updateViewPort);\n    }\n  }, {\n    key: \"_heightForRow\",\n    value: function _heightForRow(row) {\n      var height = 0;\n      height = this.htmlComp.layout.rowHeight;\n\n      if (row !== this.rowCount() - 1) {\n        // Add row gap unless it is the last row\n        height += this.htmlComp.layout.vgap;\n      }\n\n      if (!numbers.isNumber(height)) {\n        throw new Error('Calculated height is not a number: ' + height);\n      }\n\n      return height;\n    }\n    /**\n     * Used for virtual scrolling to calculate the view range size.\n     * @returns {number} the configured rowHeight + vgap / 2. Reason: the gaps are only between rows, the first and last row therefore only have 1 gap.\n     */\n\n  }, {\n    key: \"_minRowHeight\",\n    value: function _minRowHeight() {\n      return this.htmlComp.layout.rowHeight + this.htmlComp.layout.vgap / 2;\n    }\n  }, {\n    key: \"rowCount\",\n    value: function rowCount(gridColumnCount) {\n      gridColumnCount = scout.nvl(gridColumnCount, this.gridColumnCount);\n      return Math.ceil(this.filteredTiles.length / gridColumnCount);\n    }\n    /**\n     * Calculates and renders the rows which should be visible in the current viewport based on scroll top.\n     */\n\n  }, {\n    key: \"_renderViewPort\",\n    value: function _renderViewPort() {\n      if (!this.isAttachedAndRendered()) {\n        // if grid is not attached the correct viewPort can not be evaluated. Mark for render after attach.\n        this._renderViewPortAfterAttach = true;\n        return;\n      }\n\n      if (!this.virtual) {\n        return;\n      }\n\n      this.virtualScrolling._renderViewPort();\n    }\n    /**\n     * Renders the rows visible in the viewport and removes the other rows\n     */\n\n  }, {\n    key: \"_renderViewRange\",\n    value: function _renderViewRange(viewRange) {\n      if (viewRange.equals(this.viewRangeRendered)) {\n        if (viewRange.size() === 0) {\n          // Iif view range is empty initially viewRangeRendered will be empty as well -> make sure fillers are rendered correctly (used for pref size)\n          this._renderFiller();\n        } // Range already rendered -> do nothing\n\n\n        return;\n      }\n\n      var rangesToRemove = this.viewRangeRendered.subtract(viewRange).filter(function (range) {\n        return range.size() > 0;\n      });\n      rangesToRemove.forEach(function (range) {\n        this._removeTilesInRange(range);\n      }.bind(this));\n      var rangesToRender = viewRange.subtract(this.viewRangeRendered).filter(function (range) {\n        return range.size() > 0;\n      });\n      rangesToRender.forEach(function (range) {\n        this._renderTilesInRange(range);\n      }.bind(this));\n\n      this._renderFiller();\n    }\n  }, {\n    key: \"_renderTilesInRange\",\n    value: function _renderTilesInRange(range) {\n      var numRowsRendered = 0;\n      var tilesRendered = 0;\n      var tiles = this.filteredTiles;\n\n      if (tiles.length === 0) {\n        return;\n      }\n\n      var maxRange = this.virtualScrolling.maxViewRange();\n      range = maxRange.intersect(range);\n      var newRange = this.viewRangeRendered.union(range);\n\n      if (newRange.length === 2) {\n        throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n      }\n\n      this.viewRangeRendered = newRange[0];\n\n      for (var row = range.from; row < range.to; row++) {\n        this.eachTileInRow(row, renderTile.bind(this));\n        numRowsRendered++;\n      }\n\n      if ($.log.isTraceEnabled()) {\n        $.log.trace(numRowsRendered + ' new rows rendered from ' + range);\n        $.log.trace(this._rowsRenderedInfo());\n      }\n\n      function renderTile(tile) {\n        if (tile.rendered) {\n          return;\n        }\n\n        this._renderTile(tile);\n\n        tilesRendered++;\n      }\n    }\n    /**\n     * @returns {Tile[]} the newly rendered tiles\n     */\n\n  }, {\n    key: \"_renderTileDelta\",\n    value: function _renderTileDelta(filterResult) {\n      if (!this.virtual) {\n        return [];\n      }\n\n      var prevTiles = this.renderedTiles();\n      var newViewRange = this.virtualScrolling.calculateCurrentViewRange();\n      var newTiles = this.findTilesInRange(newViewRange);\n      var tilesToRemove = arrays.diff(prevTiles, newTiles);\n      var tilesToRender = arrays.diff(newTiles, prevTiles);\n\n      if (filterResult) {\n        filterResult.newlyHiddenTiles.forEach(function (tile) {\n          if (tile.rendered) {\n            this._removeTileByFilter(tile);\n          }\n        }, this);\n      } // tilesToRemove contains newlyHiddenTiles as well but remove() does nothing if it is already removing\n\n\n      tilesToRemove.forEach(function (tile) {\n        tile.remove();\n      });\n      tilesToRender.forEach(function (tile) {\n        this._renderTile(tile);\n      }, this);\n\n      if (filterResult) {\n        // Suppress because Tile.js would invalidate which leads to poor performance if grid is used in a Group.js and group is being expanded while tiles are shown\n        // invalidating will be done afterwards anyway so no need to do it for each tile\n        this.htmlComp.suppressInvalidate = true;\n        filterResult.newlyShownTiles.forEach(function (tile) {\n          if (tile.rendered) {\n            this._renderTileVisibleForFilter(tile);\n          }\n        }, this);\n        this.htmlComp.suppressInvalidate = false;\n      }\n\n      this.viewRangeRendered = newViewRange;\n\n      this._renderFiller();\n\n      if (!this.htmlComp.layouting) {\n        // If a tile is inserted while a group of the tile accordion is being expanded,\n        // invalidating may create a loop because the group resizes the body which triggers the TileGridLayout and eventually calls this function again -> Don't invalidate while layouting\n        this.invalidateLayoutTree();\n      }\n\n      return tilesToRender;\n    }\n  }, {\n    key: \"_removeTileByFilter\",\n    value: function _removeTileByFilter(tile) {\n      // In virtual mode, filtered tiles are not rendered. In normal mode, the filter animation is triggerd by _renderVisible of the tile.\n      // Since the tile is removed immediately, the invisible animation would not start, so we use the remove animation instead.\n      // But because the delete animation is a different one to the filter animation, the removeClass needs to be swapped\n      // Remove class first to make sure animation won't be finished before the animationend listener is attached in Widget._removeAnimated (which may happen because a setTimeout is used there)\n      tile.$container.removeClass('animate-invisible');\n      tile.animateRemoval = true;\n      tile.animateRemovalClass = 'animate-invisible';\n      tile.remove();\n\n      this._onAnimatedTileRemove(tile);\n\n      tile.animateRemoval = false; // Remove animation is started by a set timeout -> use set timeout as well to come after\n\n      setTimeout(function () {\n        // Reset to default\n        tile.animateRemovalClass = 'animate-remove';\n      });\n    }\n  }, {\n    key: \"_renderTileVisibleForFilter\",\n    value: function _renderTileVisibleForFilter(tile) {\n      if (!tile.filterAccepted || tile.$container.hasClass('animate-visible')) {\n        return;\n      }\n\n      if (tile.removalPending) {\n        return;\n      } // Start filter animation (at the time setFilterAccepted was set the tile was not rendered)\n\n\n      tile.$container.setVisible(false);\n\n      tile._renderVisible();\n    }\n  }, {\n    key: \"_renderTileOrder\",\n    value: function _renderTileOrder(prevTiles) {\n      // Loop through the tiles and move every html element to the end of the container\n      // Only move if the order is different to the old order\n      // This is actually only necessary to make debugging easier, since the tiles are positioned absolutely it would work without it\n      var different = false;\n      this.tiles.forEach(function (tile, i) {\n        if (prevTiles[i] !== tile || different) {\n          // Start ordering as soon as the order of the arrays starts to differ\n          if (this.virtual && !tile.rendered) {\n            // In non virtual mode, every tile is rendered, even the filtered one. So if a tile is not rendered ignore it in virtual, but fail in non virtual\n            return;\n          }\n\n          different = true;\n          tile.$container.appendTo(this.$container);\n        }\n      }, this);\n\n      if (different && !this.virtual) {\n        // In virtual mode this is done by _renderTileDelta()\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_rowsRenderedInfo\",\n    value: function _rowsRenderedInfo() {\n      var numRenderedTiles = this.$container.children('.tile').length;\n      var renderedRowsRange = '(' + this.viewRangeRendered + ')';\n      return numRenderedTiles + ' tiles rendered in range ' + renderedRowsRange;\n    }\n  }, {\n    key: \"_removeTilesInRange\",\n    value: function _removeTilesInRange(range) {\n      var numRowsRemoved = 0;\n      var newRange = this.viewRangeRendered.subtract(range);\n\n      if (newRange.length === 2) {\n        throw new Error('Can only remove rows at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n      }\n\n      this.viewRangeRendered = newRange[0];\n\n      for (var i = range.from; i < range.to; i++) {\n        this._removeTilesInRow(i);\n\n        numRowsRemoved++;\n      }\n\n      if ($.log.isTraceEnabled()) {\n        $.log.trace(numRowsRemoved + ' rows removed from ' + range + '.');\n        $.log.trace(this._rowsRenderedInfo());\n      }\n    }\n  }, {\n    key: \"_removeTilesInRow\",\n    value: function _removeTilesInRow(row) {\n      var tiles = this.findTilesInRow(row);\n      tiles.forEach(function (tile) {\n        tile.remove();\n      });\n    }\n  }, {\n    key: \"rowHasRenderedTiles\",\n    value: function rowHasRenderedTiles(row) {\n      var tilesInRow = this.findTilesInRow(row);\n      return tilesInRow.some(function (tile) {\n        return tile.rendered && !tile.removing;\n      });\n    }\n  }, {\n    key: \"ensureTileRendered\",\n    value: function ensureTileRendered(tile) {\n      if (!tile.rendered) {\n        var rowIndex = tile.gridData.y;\n\n        this.virtualScrolling._renderViewRangeForRowIndex(rowIndex);\n\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_renderFiller\",\n    value: function _renderFiller() {\n      if (!this.$fillBefore) {\n        this.$fillBefore = this.$container.prependDiv('filler');\n      }\n\n      var fillBeforeHeight = this._calculateFillerHeight(new Range(0, this.viewRangeRendered.from));\n\n      this.$fillBefore.cssHeight(fillBeforeHeight);\n      this.$fillBefore.css('width', '100%');\n      $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeHeight);\n\n      if (!this.$fillAfter) {\n        this.$fillAfter = this.$container.appendDiv('filler');\n      } // Make sure filler is always at the end\n\n\n      this.$fillAfter.appendTo(this.$container);\n\n      var renderedTilesHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.from, this.viewRangeRendered.to));\n\n      this.$fillAfter.cssTop(fillBeforeHeight + renderedTilesHeight);\n\n      var fillAfterHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.to, this.rowCount()));\n\n      this.$fillAfter.cssHeight(fillAfterHeight);\n      this.$fillAfter.css('width', '100%');\n      $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterHeight);\n    }\n  }, {\n    key: \"_calculateFillerHeight\",\n    value: function _calculateFillerHeight(range) {\n      var totalHeight = 0;\n\n      for (var i = range.from; i < range.to; i++) {\n        totalHeight += this._heightForRow(i);\n      }\n\n      return totalHeight;\n    }\n    /**\n     * If virtual is false, the live list of filtered tiles is returned, because every tile has to be rendered. If virtual is true, the rendered tiles are collected and returned.\n     */\n\n  }, {\n    key: \"renderedTiles\",\n    value: function renderedTiles() {\n      if (!this.rendered) {\n        return [];\n      }\n\n      if (!this.virtual) {\n        return this.filteredTiles;\n      }\n\n      var tiles = [];\n      this.$container.children('.tile').each(function (i, elem) {\n        var tile = scout.widget(elem);\n\n        if (!tile.removalPending) {\n          // Don't return the tiles which are being removed\n          // Otherwise delta could be wrong if called while removing. Example: filter is added and removed right after while the tiles are still being removed -> RenderTileDelta has to render the tiles being removed\n          tiles.push(tile);\n        }\n      });\n      return tiles;\n    }\n  }]);\n\n  return TileGrid;\n}(Widget);\n\nexport { TileGrid as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/tile/TileGrid.js"],"names":["arrays","ContextMenuKeyStroke","DoubleClickSupport","graphics","HtmlComponent","KeyStrokeContext","LoadingSupport","LogicalGridData","MenuDestinations","menus","menus_1","numbers","objects","PlaceholderTile","Range","scout","TileGridGridConfig","TileGridLayout","TileGridLayoutConfig","TileGridSelectAllKeyStroke","TileGridSelectDownKeyStroke","TileGridSelectFirstKeyStroke","TileGridSelectionHandler","TileGridSelectLastKeyStroke","TileGridSelectLeftKeyStroke","TileGridSelectRightKeyStroke","TileGridSelectUpKeyStroke","VirtualScrolling","Widget","$","TILE_SELECTOR","TileGrid","animateTileRemoval","animateTileInsertion","comparator","_doubleClickSupport","empty","filters","filteredTiles","filteredTilesDirty","focusedTile","gridColumnCount","prefGridColumnCount","logicalGrid","create","layoutConfig","multiSelect","renderAnimationEnabled","selectable","selectedTiles","selectionHandler","scrollable","scrolling","scrollTopDirty","startupAnimationDone","startupAnimationEnabled","tiles","tileRemovalPendingCount","viewRangeSize","viewRangeRendered","virtual","virtualScrolling","withPlaceholders","_filterMenusHandler","_filterMenus","bind","_renderViewPortAfterAttach","_scrollParentScrollHandler","_onScrollParentScroll","_addWidgetProperties","_addPreserveOnPropertyChangeProperties","$fillBefore","$fillAfter","model","_setGridColumnCount","_setLayoutConfig","_initVirtualScrolling","_initTiles","_applyFilters","_updateFilteredTiles","_setMenus","_createVirtualScrolling","widget","enabled","rowHeight","_heightForRow","rowCount","_renderViewRange","keyStrokeContext","registerKeyStroke","showContextMenu","forEach","tile","_initTile","setSelectable","setSelected","indexOf","setParent","setFilterAccepted","$container","$parent","appendDiv","htmlComp","install","session","setLayout","_createLayout","on","_onTileMouseDown","_onTileClick","_onTileDoubleClick","_renderLayoutConfig","_renderScrollable","_renderVirtual","_renderSelectable","_renderEmpty","_updateVirtualScrollable","_renderViewPort","_updateTabbable","setTabbable","insertTiles","tilesToInsert","appendPlaceholders","ensure","length","setTiles","concat","deleteTiles","tilesToDelete","slice","removeAll","equals","_createChildren","nvl","_deletePlaceholders","diff","_insertTiles","placeholders","Math","min","_filterTiles","pushAll","_deleteTiles","_sort","currentTiles","_setProperty","rendered","_renderTileDelta","_renderTileOrder","_renderInsertTiles","_insertTile","_renderTile","removalPending","one","_renderTileVisibleForFilter","invalidateLayoutTree","render","setLayoutData","addClass","removeClass","_animateTileInsertion","addClassForAnimation","layouting","remove","_deleteTile","deselectTiles","_animateTileRemoval","animateRemoval","owner","destroy","_onAnimatedTileRemove","setFocusedTile","validateLayoutTree","sort","invalidateParents","setProperty","invalidateLogicalGrid","oldMinWidth","layout","minWidth","applyToLayout","setMinRowHeight","_minRowHeight","setViewRangeSize","oldMenus","updateKeyStrokes","destination","onlyVisible","enableDisableKeyStroke","notAllowedTypes","filterAccordingToSelection","options","onRequestsDone","_showContextMenu","attached","menuItems","CONTEXT_MENU","pageX","pageY","offset","$scrollable","scrollParent","scrollableBounds","offsetBounds","last","isTileInView","left","top","max","x","right","y","bottom","contextMenu","close","parent","location","$anchor","menuFilter","open","_uninstallScrollbars","_installScrollbars","axis","toggleClass","scrollTop","scrollLeft","revalidateLayout","event","revalidateLayoutTree","_deleteAllPlaceholders","_deleteObsoletePlaceholders","_insertMissingPlaceholders","filter","numPlaceholders","lastX","columnCount","gridData","i","push","_createPlaceholder","obsoletePlaceholders","obsolete","placeholder","insert","_createPlaceholders","deletedPlaceholders","reverse","index","findIndexFromReverse","dirty","validate","fillUpWithPlaceholders","setDirty","setGridConfig","isFocused","$scrollables","scrollParents","oldScrollTopArr","map","$elem","toArray","focus","val","idx","deselectAllTiles","tilesToUnselect","selectTiles","selectAllTiles","addTilesToSelection","intersects","mousedown","_selectTileOnMouseDown","which","$tile","currentTarget","data","doubleClicked","mouseButton","_triggerTileClick","trigger","doTileAction","_triggerTileAction","selectTileOnMouseDown","ensureTileRendered","reveal","layoutValidator","schedulePostValidateFunction","revealSelection","scrollTo","addFilters","filtersToAdd","setFilters","removeFilters","filtersToRemove","filterResult","fullReset","newlyShownTiles","newlyHiddenTiles","changed","_applyFiltersForTile","filterAccepted","_updateEmpty","setEmpty","_tileAcceptedByFilters","some","accept","startIndex","findIndexFrom","viewRange","maxViewRange","row","from","to","eachTileInRow","func","setEnabled","rendering","calculateViewRangeSize","_removeAllTiles","_renderFiller","_renderAllTiles","off","removing","set$Scrollable","updateViewPort","height","vgap","isNumber","Error","ceil","isAttachedAndRendered","size","rangesToRemove","subtract","range","_removeTilesInRange","rangesToRender","_renderTilesInRange","numRowsRendered","tilesRendered","maxRange","intersect","newRange","union","renderTile","log","isTraceEnabled","trace","_rowsRenderedInfo","prevTiles","renderedTiles","newViewRange","calculateCurrentViewRange","newTiles","findTilesInRange","tilesToRemove","tilesToRender","_removeTileByFilter","suppressInvalidate","animateRemovalClass","setTimeout","hasClass","setVisible","_renderVisible","different","appendTo","numRenderedTiles","children","renderedRowsRange","numRowsRemoved","_removeTilesInRow","findTilesInRow","tilesInRow","rowIndex","_renderViewRangeForRowIndex","prependDiv","fillBeforeHeight","_calculateFillerHeight","cssHeight","css","renderedTilesHeight","cssTop","fillAfterHeight","totalHeight","each","elem"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  arrays,\n  ContextMenuKeyStroke,\n  DoubleClickSupport,\n  graphics,\n  HtmlComponent,\n  KeyStrokeContext,\n  LoadingSupport,\n  LogicalGridData,\n  MenuDestinations,\n  menus as menus_1,\n  numbers,\n  objects,\n  PlaceholderTile,\n  Range,\n  scout,\n  TileGridGridConfig,\n  TileGridLayout,\n  TileGridLayoutConfig,\n  TileGridSelectAllKeyStroke,\n  TileGridSelectDownKeyStroke,\n  TileGridSelectFirstKeyStroke,\n  TileGridSelectionHandler,\n  TileGridSelectLastKeyStroke,\n  TileGridSelectLeftKeyStroke,\n  TileGridSelectRightKeyStroke,\n  TileGridSelectUpKeyStroke,\n  VirtualScrolling,\n  Widget\n} from '../index';\nimport $ from 'jquery';\n\n/**\n * Only select top-level tile elements. Do not select elements with a 'tile' class deeper in the tree.\n * This prevents errors when a developer accidentally adds an element that has the 'tile' class. #262146\n * @type {string}\n */\nconst TILE_SELECTOR = '> .tile';\n\nexport default class TileGrid extends Widget {\n  constructor() {\n    super();\n    this.animateTileRemoval = true;\n    this.animateTileInsertion = true;\n    this.comparator = null;\n    this._doubleClickSupport = new DoubleClickSupport();\n    this.empty = false;\n    this.filters = [];\n    this.filteredTiles = [];\n    this.filteredTilesDirty = true;\n    this.focusedTile = null;\n    // GridColumnCount will be modified by the layout, prefGridColumnCount remains unchanged\n    this.gridColumnCount = 4;\n    this.prefGridColumnCount = this.gridColumnCount;\n    this.logicalGrid = scout.create('scout.HorizontalGrid');\n    this.layoutConfig = null;\n    this.menus = [];\n    this.multiSelect = true;\n    this.renderAnimationEnabled = false;\n    this.selectable = false;\n    this.selectedTiles = [];\n    this.selectionHandler = new TileGridSelectionHandler(this);\n    this.scrollable = true;\n    this.scrolling = false;\n    this.scrollTopDirty = false;\n    this.startupAnimationDone = false;\n    this.startupAnimationEnabled = false;\n    this.tiles = [];\n    this.tileRemovalPendingCount = 0;\n    this.viewRangeSize = 0;\n    this.viewRangeRendered = new Range(0, 0);\n    this.virtual = false;\n    this.virtualScrolling = null;\n    this.withPlaceholders = false;\n    this._filterMenusHandler = this._filterMenus.bind(this);\n    this._renderViewPortAfterAttach = false;\n    this._scrollParentScrollHandler = this._onScrollParentScroll.bind(this);\n    this._addWidgetProperties(['tiles', 'selectedTiles', 'menus']);\n    this._addPreserveOnPropertyChangeProperties(['selectedTiles']);\n\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n  }\n\n  _init(model) {\n    super._init(model);\n    this._setGridColumnCount(this.gridColumnCount);\n    this._setLayoutConfig(this.layoutConfig);\n    this._initVirtualScrolling();\n    this._initTiles();\n    this._applyFilters(this.tiles);\n    this._updateFilteredTiles();\n    this._setMenus(this.menus);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  _initVirtualScrolling() {\n    this.virtualScrolling = this._createVirtualScrolling();\n  }\n\n  _createVirtualScrolling() {\n    return new VirtualScrolling({\n      widget: this,\n      enabled: this.virtual,\n      viewRangeSize: this.viewRangeSize,\n      rowHeight: this._heightForRow.bind(this),\n      rowCount: this.rowCount.bind(this),\n      _renderViewRange: this._renderViewRange.bind(this)\n    });\n  }\n\n  /**\n   * @override\n   */\n  _createLoadingSupport() {\n    return new LoadingSupport({\n      widget: this\n    });\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke([\n      new TileGridSelectAllKeyStroke(this),\n      new TileGridSelectLeftKeyStroke(this),\n      new TileGridSelectRightKeyStroke(this),\n      new TileGridSelectDownKeyStroke(this),\n      new TileGridSelectUpKeyStroke(this),\n      new TileGridSelectFirstKeyStroke(this),\n      new TileGridSelectLastKeyStroke(this),\n      new ContextMenuKeyStroke(this, this.showContextMenu, this)\n    ]);\n  }\n\n  _initTiles() {\n    this.tiles.forEach(function(tile) {\n      this._initTile(tile);\n    }, this);\n  }\n\n  _initTile(tile) {\n    tile.setSelectable(this.selectable);\n    tile.setSelected(this.selectedTiles.indexOf(tile) >= 0);\n\n    // Set proper state in case tile was used in another grid\n    tile.setParent(this);\n    tile.setFilterAccepted(true);\n  }\n\n  _render() {\n    this.$container = this.$parent.appendDiv('tile-grid');\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(this._createLayout());\n    this.$container\n      .on('mousedown', TILE_SELECTOR, this._onTileMouseDown.bind(this))\n      .on('click', TILE_SELECTOR, this._onTileClick.bind(this))\n      .on('dblclick', TILE_SELECTOR, this._onTileDoubleClick.bind(this));\n  }\n\n  _createLayout() {\n    return new TileGridLayout(this, this.layoutConfig);\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderLayoutConfig();\n    this._renderScrollable();\n    this._renderVirtual();\n    this._renderSelectable();\n    this._renderEmpty();\n  }\n\n  _remove() {\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n    this.viewRangeRendered = new Range(0, 0);\n    this._updateVirtualScrollable();\n    super._remove();\n  }\n\n  /**\n   * @override\n   */\n  _renderOnAttach() {\n    super._renderOnAttach();\n    if (this._renderViewPortAfterAttach) {\n      this._renderViewPort();\n      this._renderViewPortAfterAttach = false;\n    }\n  }\n\n  _renderEnabled() {\n    super._renderEnabled();\n\n    this._updateTabbable();\n  }\n\n  _updateTabbable() {\n    this.$container.setTabbable(this.enabled && this.selectable);\n  }\n\n  insertTile(tile) {\n    this.insertTiles([tile]);\n  }\n\n  insertTiles(tilesToInsert, appendPlaceholders) {\n    tilesToInsert = arrays.ensure(tilesToInsert);\n    if (tilesToInsert.length === 0) {\n      return;\n    }\n    this.setTiles(this.tiles.concat(tilesToInsert), appendPlaceholders);\n  }\n\n  deleteTile(tile) {\n    this.deleteTiles([tile]);\n  }\n\n  deleteTiles(tilesToDelete, appendPlaceholders) {\n    tilesToDelete = arrays.ensure(tilesToDelete);\n    if (tilesToDelete.length === 0) {\n      return;\n    }\n    var tiles = this.tiles.slice();\n    arrays.removeAll(tiles, tilesToDelete);\n    this.setTiles(tiles, appendPlaceholders);\n  }\n\n  deleteAllTiles() {\n    this.setTiles([]);\n  }\n\n  setTiles(tiles, appendPlaceholders) {\n    tiles = arrays.ensure(tiles);\n    if (objects.equals(this.tiles, tiles)) {\n      return;\n    }\n\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n\n    if (this.withPlaceholders && scout.nvl(appendPlaceholders, true)) {\n      // Remove placeholders from new tiles, they will be added later\n      this._deletePlaceholders(tiles);\n    }\n\n    // Only insert those which are not already there\n    var tilesToInsert = arrays.diff(tiles, this.tiles);\n    this._insertTiles(tilesToInsert);\n\n    // Append the existing placeholders, otherwise they would be unnecessarily deleted if a tile is deleted\n    if (this.withPlaceholders && scout.nvl(appendPlaceholders, true)) {\n      var placeholders = this.placeholders();\n      // But only add as much placeholders as needed: If a new tile is added, it should replace the placeholder underneath.\n      // If this were not done the placeholders would move animated when a new tile is inserted rather than just staying where they are\n      placeholders = placeholders.slice(Math.min(this._filterTiles(tilesToInsert).length, placeholders.length), placeholders.length);\n      arrays.pushAll(tiles, placeholders);\n    }\n\n    // Only delete those which are not in the new array\n    var tilesToDelete = arrays.diff(this.tiles, tiles);\n    this._deleteTiles(tilesToDelete);\n\n    this._sort(tiles);\n    this.filteredTilesDirty = this.filteredTilesDirty || tilesToDelete.length > 0 || tilesToInsert.length > 0 || !arrays.equals(this.tiles, tiles); // last check necessary if sorting changed\n    var currentTiles = this.tiles;\n    this._setProperty('tiles', tiles);\n    this._updateFilteredTiles();\n\n    if (this.rendered) {\n      this._renderTileDelta();\n      this._renderTileOrder(currentTiles);\n      this._renderInsertTiles(tilesToInsert);\n    }\n  }\n\n  _insertTiles(tiles) {\n    if (tiles.length === 0) {\n      return;\n    }\n\n    tiles.forEach(function(tile) {\n      this._insertTile(tile);\n    }, this);\n  }\n\n  _insertTile(tile) {\n    this._initTile(tile);\n    this._applyFilters([tile]);\n    if (!this.virtual && this.rendered) {\n      this._renderTile(tile);\n    }\n  }\n\n  _renderTile(tile) {\n    if (tile.removalPending) {\n      // If tile is being removed by the filter and the filter cleared so that the tile should be rendered again while the animation is still running,\n      // we need to wait for the remove animation, otherwise an already rendered exception occurs\n      tile.one('remove', function() {\n        if (tile.rendered) {\n          // Might be already rendered again by renderTileDelta because filter was changed again\n          return;\n        }\n        this._renderTile(tile);\n        this._renderTileVisibleForFilter(tile);\n        if (this.tileRemovalPendingCount === 0) {\n          this.invalidateLayoutTree();\n        }\n      }.bind(this));\n      return;\n    }\n    tile.render();\n    tile.setLayoutData(new LogicalGridData(tile));\n    tile.$container.addClass('newly-rendered');\n  }\n\n  _renderInsertTiles(tiles) {\n    tiles.forEach(function(tile) {\n      if (!tile.rendered) {\n        return;\n      }\n      tile.$container.addClass('invisible');\n      // Wait until the layout animation is done before animating the insert operation.\n      // Also make them invisible to not cover existing tiles while they are moving or changing size.\n      // Also do it for tiles which don't have an insert animation (e.g. placeholders), due to the same reason.\n      this.one('layoutAnimationDone', function() {\n        if (tile.rendered) {\n          tile.$container.removeClass('invisible');\n          if (this._animateTileInsertion(tile)) {\n            tile.$container.addClassForAnimation('animate-insert');\n          }\n        }\n      }.bind(this));\n    }, this);\n\n    if (!this.htmlComp.layouting) {\n      // no need to invalidate when tile placeholders are added or removed while layouting\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _removeAllTiles() {\n    this.tiles.forEach(function(tile) {\n      tile.remove();\n    });\n    this.viewRangeRendered = new Range(0, 0);\n  }\n\n  _renderAllTiles() {\n    this.tiles.forEach(function(tile) {\n      this._renderTile(tile);\n    }, this);\n  }\n\n  _deleteTiles(tiles) {\n    if (tiles.length === 0) {\n      return;\n    }\n\n    tiles.forEach(function(tile) {\n      this._deleteTile(tile);\n    }, this);\n    this.deselectTiles(tiles);\n\n    if (this.rendered && !this.htmlComp.layouting) {\n      // no need to invalidate when tile placeholders are added or removed while layouting\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _deleteTile(tile) {\n    if (this._animateTileRemoval(tile)) {\n      // Animate tile removal, but not while layouting when tile placeholders are added or removed\n      tile.animateRemoval = true;\n    }\n    // Destroy only if it is the owner, if tile belongs to another widget, just remove it\n    if (tile.owner === this) {\n      tile.destroy();\n    } else if (this.rendered) {\n      tile.remove();\n    }\n    this._onAnimatedTileRemove(tile);\n    tile.animateRemoval = false;\n    if (tile === this.focusedTile) {\n      this.setFocusedTile(null);\n    }\n  }\n\n  _animateTileRemoval(tile) {\n    return this.animateTileRemoval && !(tile instanceof PlaceholderTile);\n  }\n\n  _animateTileInsertion(tile) {\n    return this.animateTileInsertion && !(tile instanceof PlaceholderTile);\n  }\n\n  _onAnimatedTileRemove(tile) {\n    if (!tile.rendered || !tile.animateRemoval) {\n      return;\n    }\n    this.tileRemovalPendingCount++;\n    tile.one('remove', function() {\n      this.tileRemovalPendingCount--;\n      if (this.rendered && this.tileRemovalPendingCount === 0 && !this.htmlComp.layouting) {\n        this.invalidateLayoutTree();\n      }\n    }.bind(this));\n  }\n\n  setComparator(comparator) {\n    if (this.comparator === comparator) {\n      return;\n    }\n    this.comparator = comparator;\n  }\n\n  sort() {\n    var tiles = this.tiles.slice();\n    this._sort(tiles);\n    if (arrays.equals(this.tiles, tiles)) {\n      // Check is needed anyway to determine whether filteredTilesDirty needs to be set, so we can use it here as well to early return if nothing changed\n      return;\n    }\n    var currentTiles = this.tiles;\n    this._setProperty('tiles', tiles);\n\n    // Sort list of filtered tiles as well\n    this.filteredTilesDirty = true;\n    this._updateFilteredTiles();\n\n    if (this.rendered) {\n      this._renderTileDelta();\n      this._renderTileOrder(currentTiles);\n      this.validateLayoutTree(); // prevent flickering in virtual mode\n    }\n  }\n\n  _sort(tiles) {\n    if (this.comparator === null) {\n      return;\n    }\n\n    var placeholders = [];\n    if (this.withPlaceholders) {\n      // Don't reorder placeholders -> remove them first, then sort and add them afterwards again\n      placeholders = this._deletePlaceholders(tiles);\n    }\n    tiles.sort(this.comparator);\n    arrays.pushAll(tiles, placeholders);\n  }\n\n  invalidateLayoutTree(invalidateParents) {\n    if (this.tileRemovalPendingCount > 0) {\n      // Do not invalidate while tile removal is still pending\n      return;\n    }\n    super.invalidateLayoutTree(invalidateParents);\n  }\n\n  setGridColumnCount(gridColumnCount) {\n    this.setProperty('gridColumnCount', gridColumnCount);\n  }\n\n  _setGridColumnCount(gridColumnCount) {\n    this._setProperty('gridColumnCount', gridColumnCount);\n    this.prefGridColumnCount = gridColumnCount;\n    this.invalidateLogicalGrid();\n  }\n\n  setLayoutConfig(layoutConfig) {\n    this.setProperty('layoutConfig', layoutConfig);\n  }\n\n  _setLayoutConfig(layoutConfig) {\n    if (!layoutConfig) {\n      layoutConfig = new TileGridLayoutConfig();\n    }\n    this._setProperty('layoutConfig', TileGridLayoutConfig.ensure(layoutConfig));\n  }\n\n  _renderLayoutConfig() {\n    var oldMinWidth = this.htmlComp.layout.minWidth;\n    this.layoutConfig.applyToLayout(this.htmlComp.layout);\n    if (this.virtualScrolling) {\n      this.virtualScrolling.setMinRowHeight(this._minRowHeight());\n      this.setViewRangeSize(this.virtualScrolling.viewRangeSize, false);\n    }\n    if (oldMinWidth !== this.htmlComp.layout.minWidth) {\n      this._renderScrollable();\n    }\n    this.invalidateLayoutTree();\n  }\n\n  _setMenus(menus, oldMenus) {\n    this.updateKeyStrokes(menus, oldMenus);\n    this._setProperty('menus', menus);\n  }\n\n  _filterMenus(menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {\n    return menus_1.filterAccordingToSelection('TileGrid', this.selectedTiles.length, menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes);\n  }\n\n  showContextMenu(options) {\n    this.session.onRequestsDone(this._showContextMenu.bind(this, options));\n  }\n\n  /**\n   * @param options may contain pageX, pageY, menuItems and menuFilter.\n   * If these properties are not provided they are determined automatically.\n   */\n  _showContextMenu(options) {\n    options = options || {};\n    if (!this.rendered || !this.attached) { // check needed because function is called asynchronously\n      return;\n    }\n    if (this.selectedTiles.length === 0) {\n      return;\n    }\n    var menuItems = options.menuItems || this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true, false);\n    if (menuItems.length === 0) {\n      return;\n    }\n    var pageX = scout.nvl(options.pageX, null);\n    var pageY = scout.nvl(options.pageY, null);\n    if (pageX === null || pageY === null) {\n      var offset;\n      var $scrollable = this.$container.scrollParent();\n      if ($scrollable.length === 0) {\n        $scrollable = this.$container;\n      }\n      var scrollableBounds = graphics.offsetBounds($scrollable);\n      var focusedTile = this.focusedTile || arrays.last(this.selectedTiles);\n      if (this.isTileInView(focusedTile)) {\n        // Place the context menu on the focused tile if possible\n        offset = focusedTile.$container.offset();\n      } else {\n        // If focused tile is not in view place the popup in the top left corner of the tile grid\n        offset = this.$container.offset();\n      }\n      pageX = offset.left + 10;\n      pageY = offset.top + 10;\n      // Ensure popup is always in view. Add +-1 to make sure it won't be made invisible by Popup._isInView even if bounds are fractional\n      pageX = Math.min(Math.max(pageX, scrollableBounds.x + 1), scrollableBounds.right() - 1);\n      pageY = Math.min(Math.max(pageY, scrollableBounds.y + 1), scrollableBounds.bottom() - 1);\n    }\n    // Prevent firing of 'onClose'-handler during contextMenu.open()\n    // (Can lead to null-access when adding a new handler to this.contextMenu)\n    if (this.contextMenu) {\n      this.contextMenu.close();\n    }\n    this.contextMenu = scout.create('ContextMenuPopup', {\n      parent: this,\n      menuItems: menuItems,\n      location: {\n        x: pageX,\n        y: pageY\n      },\n      $anchor: this.$container,\n      menuFilter: options.menuFilter || this._filterMenusHandler\n    });\n    this.contextMenu.open();\n  }\n\n  setScrollable(scrollable) {\n    this.setProperty('scrollable', scrollable);\n  }\n\n  _renderScrollable() {\n    this._uninstallScrollbars();\n\n    // horizontal (x-axis) scrollbar is only installed when minWidth is > 0\n    if (this.scrollable) {\n      this._installScrollbars({\n        axis: this.layoutConfig.minWidth > 0 ? 'both' : 'y'\n      });\n    } else if (this.layoutConfig.minWidth > 0) {\n      this._installScrollbars({\n        axis: 'x'\n      });\n    }\n    this.$container.toggleClass('scrollable', this.scrollable);\n    this._updateVirtualScrollable();\n    this.invalidateLayoutTree();\n  }\n\n  /**\n   * @override\n   */\n  _onScroll() {\n    var scrollTop = this.$container[0].scrollTop;\n    var scrollLeft = this.$container[0].scrollLeft;\n    if (this.scrollTop !== scrollTop && this.virtual) {\n      this.scrolling = true;\n      this.revalidateLayout();\n      this.scrolling = false;\n    }\n    this.scrollTop = scrollTop;\n    this.scrollLeft = scrollLeft;\n  }\n\n  _onScrollParentScroll(event) {\n    this.scrolling = true;\n    this.revalidateLayoutTree(false);\n    this.scrolling = false;\n  }\n\n  setWithPlaceholders(withPlaceholders) {\n    this.setProperty('withPlaceholders', withPlaceholders);\n  }\n\n  _renderWithPlaceholders() {\n    this.invalidateLayoutTree();\n  }\n\n  fillUpWithPlaceholders() {\n    if (!this.withPlaceholders) {\n      this._deleteAllPlaceholders();\n      return;\n    }\n    this._deleteObsoletePlaceholders();\n    this._insertMissingPlaceholders();\n  }\n\n  tilesWithoutPlaceholders() {\n    if (!this.withPlaceholders) {\n      return this.tiles;\n    }\n    return this.tiles.filter(function(tile) {\n      return !(tile instanceof PlaceholderTile);\n    });\n  }\n\n  _createPlaceholders() {\n    var numPlaceholders, lastX,\n      columnCount = this.gridColumnCount,\n      tiles = this.filteredTiles,\n      placeholders = [];\n\n    if (tiles.length > 0) {\n      lastX = tiles[tiles.length - 1].gridData.x;\n    } else {\n      // If there are no tiles, create one row with placeholders\n      lastX = -1;\n    }\n\n    if (lastX === columnCount - 1) {\n      // If last tile is the last element in the row, don't create placeholders\n      return [];\n    }\n\n    // Otherwise create placeholders for every missing tile in the last row\n    numPlaceholders = columnCount - 1 - lastX;\n    for (var i = 0; i < numPlaceholders; i++) {\n      placeholders.push(this._createPlaceholder());\n    }\n    return placeholders;\n  }\n\n  _createPlaceholder() {\n    return scout.create('PlaceholderTile', {\n      parent: this\n    });\n  }\n\n  _deleteObsoletePlaceholders() {\n    var obsoletePlaceholders = [],\n      obsolete = false;\n\n    var placeholders = this.placeholders();\n    placeholders.forEach(function(placeholder) {\n      // Remove all placeholder in the row if there is one at x=0 (don't do it if there are only placeholders)\n      if (placeholder.gridData.x === 0 && this.filteredTiles[0] !== placeholder) {\n        obsolete = true;\n      }\n      if (obsolete) {\n        obsoletePlaceholders.push(placeholder);\n      }\n    }, this);\n\n    this.deleteTiles(obsoletePlaceholders, false);\n  }\n\n  _deleteAllPlaceholders() {\n    this.deleteTiles(this.placeholders(), false);\n  }\n\n  placeholders() {\n    var i, placeholders = [];\n    for (i = this.tiles.length - 1; i >= 0; i--) {\n      if (!(this.tiles[i] instanceof PlaceholderTile)) {\n        // Placeholders are always at the end -> we may stop as soon as no more placeholders are found\n        break;\n      }\n      arrays.insert(placeholders, this.tiles[i], 0);\n    }\n    return placeholders;\n  }\n\n  _insertMissingPlaceholders() {\n    var placeholders = this._createPlaceholders();\n    this.insertTiles(placeholders, false);\n  }\n\n  _deletePlaceholders(tiles) {\n    var i;\n    var deletedPlaceholders = [];\n    for (i = tiles.length - 1; i >= 0; i--) {\n      if (tiles[i] instanceof PlaceholderTile) {\n        deletedPlaceholders.push(tiles[i]);\n        arrays.remove(tiles, tiles[i]);\n      }\n    }\n    return deletedPlaceholders.reverse();\n  }\n\n  _replacePlaceholders(tiles, tilesToInsert) {\n    // Find index of the first tile which is not a placeholder (placeholders are always added at the end, so it is faster if search is done backwards)\n    var index = arrays.findIndexFromReverse(tiles, tiles.length - 1, function(tile) {\n      return !(tile instanceof PlaceholderTile);\n    });\n\n    var numPlaceholders = tiles.length - 1 - index;\n    for (var i = 1; i <= numPlaceholders; i++) {\n      var tile = tiles[index + i];\n      if (tilesToInsert[i - 1] && !(tilesToInsert[i - 1] instanceof PlaceholderTile)) {\n        arrays.remove(tiles, tile);\n      }\n    }\n  }\n\n  validateLogicalGrid() {\n    if (!this.logicalGrid.dirty) {\n      return;\n    }\n    this.logicalGrid.validate(this);\n    this.fillUpWithPlaceholders();\n    this.logicalGrid.setDirty(true);\n    this.logicalGrid.validate(this);\n  }\n\n  /**\n   * @override\n   */\n  _setLogicalGrid(logicalGrid) {\n    super._setLogicalGrid(logicalGrid);\n    if (this.logicalGrid) {\n      this.logicalGrid.setGridConfig(new TileGridGridConfig());\n    }\n  }\n\n  setFocusedTile(tile) {\n    if (this.focusedTile === tile) {\n      return;\n    }\n    this.focusedTile = tile;\n    if (!this.rendered || !tile || this.isFocused()) {\n      return;\n    }\n    var $scrollables = this.$container.scrollParents();\n    if ($scrollables.length === 0) {\n      return;\n    }\n    var oldScrollTopArr = $scrollables.map(function(i, $elem) {\n      return $elem.scrollTop();\n    }).toArray();\n    // Make sure the tile grid has the focus when focusing a tile\n    if (this.focus()) {\n      // Restore old scroll to prevent scrolling by the browser due to the focus() call\n      oldScrollTopArr.forEach(function(val, idx) {\n        $scrollables[idx].scrollTop(val);\n      }, this);\n    }\n  }\n\n  setSelectable(selectable) {\n    this.setProperty('selectable', selectable);\n    if (!selectable) {\n      this.deselectAllTiles();\n    }\n    this.tiles.forEach(function(tile) {\n      tile.setSelectable(selectable);\n    });\n  }\n\n  _renderSelectable() {\n    this.$container.toggleClass('selectable', this.selectable);\n    this._updateTabbable();\n    this.invalidateLayoutTree();\n  }\n\n  setMultiSelect(multiSelect) {\n    this.setProperty('multiSelect', multiSelect);\n  }\n\n  /**\n   * Selects the given tiles and deselects the previously selected ones.\n   */\n  selectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    // Ensure given tiles are real tiles (of type Tile)\n    tiles = this._createChildren(tiles);\n    tiles = this._filterTiles(tiles); // Selecting invisible tiles is not allowed\n\n    // Ensure no tiles will be selected if selectable is disabled\n    if (!this.selectable) {\n      tiles = [];\n    }\n\n    // Ensure only one tile is selected if multiSelect is disabled\n    if (!this.multiSelect && tiles.length > 1) {\n      tiles = [tiles[0]];\n    }\n\n    if (arrays.equals(this.selectedTiles, tiles)) {\n      // Do nothing if new selection is same as old one\n      return;\n    }\n\n    // Deselect the tiles which are not part of the new selection\n    var tilesToUnselect = this.selectedTiles;\n    arrays.removeAll(tilesToUnselect, tiles);\n    tilesToUnselect.forEach(function(tile) {\n      tile.setSelected(false);\n      if (tile === this.focusedTile) {\n        this.setFocusedTile(null);\n      }\n    }, this);\n\n    // Select the tiles\n    tiles.forEach(function(tile) {\n      tile.setSelected(true);\n    }, this);\n\n    this.setProperty('selectedTiles', tiles.slice());\n  }\n\n  selectTile(tile) {\n    this.selectTiles([tile]);\n  }\n\n  /**\n   * Selects all tiles. As for every selection operation: only filtered tiles are considered.\n   */\n  selectAllTiles() {\n    this.selectTiles(this.filteredTiles);\n  }\n\n  deselectTiles(tiles) {\n    tiles = arrays.ensure(tiles);\n    var selectedTiles = this.selectedTiles.slice();\n    if (arrays.removeAll(selectedTiles, tiles)) {\n      this.selectTiles(selectedTiles);\n    }\n  }\n\n  deselectTile(tile) {\n    this.deselectTiles([tile]);\n  }\n\n  deselectAllTiles() {\n    this.selectTiles([]);\n  }\n\n  toggleSelection() {\n    if (this.selectedTiles.length === this.filteredTiles.length) {\n      this.deselectAllTiles();\n    } else {\n      this.selectAllTiles();\n    }\n  }\n\n  addTilesToSelection(tiles) {\n    tiles = arrays.ensure(tiles);\n    this.selectTiles(this.selectedTiles.concat(tiles));\n  }\n\n  addTileToSelection(tile) {\n    this.addTilesToSelection([tile]);\n  }\n\n  /**\n   * @returns {boolean} true if the tile is completely or partially visible in the first scrollable parent.\n   */\n  isTileInView(tile) {\n    var $scrollable = this.$container.scrollParent();\n    if ($scrollable.length === 0) {\n      $scrollable = this.$container;\n    }\n    if (!tile || !tile.$container || !$scrollable) {\n      return false;\n    }\n    return graphics.offsetBounds(tile.$container).intersects(graphics.offsetBounds($scrollable));\n  }\n\n  _onTileMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    this._selectTileOnMouseDown(event);\n\n    if (event.which === 3) {\n      this.showContextMenu({\n        pageX: event.pageX,\n        pageY: event.pageY\n      });\n      return false;\n    }\n  }\n\n  _onTileClick(event) {\n    var $tile = $(event.currentTarget);\n    var tile = $tile.data('widget');\n    if (tile instanceof PlaceholderTile) {\n      return;\n    }\n\n    if (this._doubleClickSupport.doubleClicked()) {\n      // Don't execute on double click events\n      return;\n    }\n\n    var mouseButton = event.which;\n    this._triggerTileClick(tile, mouseButton);\n  }\n\n  _triggerTileClick(tile, mouseButton) {\n    var event = {\n      tile: tile,\n      mouseButton: mouseButton\n    };\n    this.trigger('tileClick', event);\n  }\n\n  _onTileDoubleClick(event) {\n    var $tile = $(event.currentTarget);\n    var tile = $tile.data('widget');\n    if (tile instanceof PlaceholderTile) {\n      return;\n    }\n    this.doTileAction(tile);\n  }\n\n  doTileAction(tile) {\n    if (!tile) {\n      return;\n    }\n    this._triggerTileAction(tile);\n  }\n\n  _triggerTileAction(tile) {\n    this.trigger('tileAction', {\n      tile: tile\n    });\n  }\n\n  setSelectionHandler(selectionHandler) {\n    this.selectionHandler = selectionHandler;\n  }\n\n  _selectTileOnMouseDown(event) {\n    this.selectionHandler.selectTileOnMouseDown(event);\n  }\n\n  scrollTo(tile, options) {\n    this.ensureTileRendered(tile);\n    // If tile was not rendered it is not yet positioned correctly -> make sure layout is valid before trying to scroll\n    // Layout must not render the viewport because scroll position is not correct yet -> just make sure tiles are at the correct position\n    this.scrolling = true;\n    this.scrollTopDirty = true;\n    this.validateLayoutTree();\n    this.scrolling = false;\n    tile.reveal(options);\n    this.scrollTopDirty = false;\n  }\n\n  revealSelection() {\n    if (!this.rendered) {\n      // Execute delayed because tileGrid may be not layouted yet\n      this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n      return;\n    }\n\n    if (this.selectedTiles.length > 0) {\n      this.scrollTo(this.selectedTiles[0]);\n    }\n  }\n\n  addFilter(filter) {\n    this.addFilters([filter]);\n  }\n\n  addFilters(filtersToAdd) {\n    filtersToAdd = arrays.ensure(filtersToAdd);\n    var filters = this.filters.slice();\n    filtersToAdd.forEach(function(filter) {\n      if (filters.indexOf(filter) >= 0) {\n        return;\n      }\n      filters.push(filter);\n    });\n    if (filters.length === this.filters.length) {\n      return;\n    }\n    this.setFilters(filters);\n  }\n\n  removeFilter(filter) {\n    this.removeFilters([filter]);\n  }\n\n  removeFilters(filtersToRemove) {\n    filtersToRemove = arrays.ensure(filtersToRemove);\n    var filters = this.filters.slice();\n    if (!arrays.removeAll(filters, filtersToRemove)) {\n      return;\n    }\n    this.setFilters(filters);\n  }\n\n  setFilters(filters) {\n    this.setProperty('filters', filters.slice());\n  }\n\n  filter() {\n    var currentTiles = this.tiles;\n    // Full reset is set to true to loop through every tile and make sure tile.filterAccepted is correctly set\n    var filterResult = this._applyFilters(this.tiles, true);\n    this._updateFilteredTiles();\n    if (this.rendered) {\n      // Not all tiles may be rendered yet (e.g. if filter is active before grid is rendered and removed after grid is rendered)\n      // But updating the view range is necessary anyway (fillers, scrollbars, viewRangeRendered etc.)\n      this._renderTileDelta(filterResult);\n      this._renderTileOrder(currentTiles);\n    }\n  }\n\n  _applyFilters(tiles, fullReset) {\n    if (this.filters.length === 0 && !scout.nvl(fullReset, false)) {\n      return;\n    }\n    var newlyShownTiles = [];\n    var newlyHiddenTiles = [];\n    var changed = false;\n    tiles.forEach(function(tile) {\n      if (this._applyFiltersForTile(tile)) {\n        changed = true;\n        if (tile.filterAccepted) {\n          newlyShownTiles.push(tile);\n        } else {\n          newlyHiddenTiles.push(tile);\n          if (tile === this.focusedTile) {\n            this.setFocusedTile(null);\n          }\n        }\n      }\n    }, this);\n\n    if (changed) {\n      this.filteredTilesDirty = true;\n    }\n\n    // Non visible tiles must be deselected\n    this.deselectTiles(newlyHiddenTiles);\n    return {\n      newlyHiddenTiles: newlyHiddenTiles,\n      newlyShownTiles: newlyShownTiles\n    };\n  }\n\n  _updateFilteredTiles() {\n    var tiles = this.tiles;\n    if (this.filters.length > 0) {\n      tiles = this._filterTiles();\n    }\n    if (this.filteredTilesDirty) {\n      this.setProperty('filteredTiles', tiles);\n      this.invalidateLogicalGrid(false);\n      this.filteredTilesDirty = false;\n    }\n    this._updateEmpty();\n  }\n\n  _updateEmpty() {\n    this.setEmpty(this.filteredTiles.length === 0);\n  }\n\n  setEmpty(empty) {\n    this.setProperty('empty', empty);\n  }\n\n  _renderEmpty() {\n    this.$container.toggleClass('empty', this.empty);\n    this.invalidateLayoutTree();\n  }\n\n  /**\n   * @returns {Boolean} true if tile state has changed, false if not\n   */\n  _applyFiltersForTile(tile) {\n    if (this._tileAcceptedByFilters(tile)) {\n      if (!tile.filterAccepted) {\n        tile.setFilterAccepted(true);\n        return true;\n      }\n    } else if (tile.filterAccepted) {\n      tile.setFilterAccepted(false);\n      return true;\n    }\n    return false;\n  }\n\n  _tileAcceptedByFilters(tile) {\n    return !this.filters.some(function(filter) {\n      // return true if an element was found which is not accepted by the filter to break the some() loop\n      if (tile instanceof PlaceholderTile) {\n        return false;\n      }\n      return !filter.accept(tile);\n    });\n  }\n\n  /**\n   * @returns {Tile[]} the tiles which are accepted by the filter and therefore visible.\n   */\n  _filterTiles(tiles) {\n    tiles = scout.nvl(tiles, this.tiles);\n    if (this.filters.length === 0) {\n      return tiles.slice();\n    }\n    return tiles.filter(function(tile) {\n      return tile.filterAccepted;\n    });\n  }\n\n  findTileIndexAt(x, y, startIndex, reverse) {\n    startIndex = scout.nvl(startIndex, 0);\n    return arrays.findIndexFrom(this.filteredTiles, startIndex, function(tile, i) {\n      return tile.gridData.x === x && tile.gridData.y === y;\n    }, reverse);\n  }\n\n  /**\n   * If the max range is used, the live list of filtered tiles is returned, because every tile has to be in the range.\n   */\n  findTilesInRange(viewRange, filter) {\n    if (viewRange.equals(this.virtualScrolling.maxViewRange())) {\n      // Directly return all tiles if max view range\n      return this.filteredTiles;\n    }\n\n    var tiles = [];\n    for (var row = viewRange.from; row < viewRange.to; row++) {\n      this.eachTileInRow(row, function(tile) { // jshint ignore:line\n        if (!filter || filter(tile)) {\n          tiles.push(tile);\n        }\n      });\n    }\n    return tiles;\n  }\n\n  findTilesInRow(row) {\n    var tiles = [];\n    this.eachTileInRow(row, function(tile) {\n      tiles.push(tile);\n    });\n    return tiles;\n  }\n\n  /**\n   * Executes the given function for each tile in a row.\n   */\n  eachTileInRow(row, func) {\n    var startIndex = row * this.gridColumnCount;\n    var tiles = [];\n    for (var i = startIndex; i < startIndex + this.gridColumnCount; i++) {\n      if (this.filteredTiles[i]) {\n        func(this.filteredTiles[i], i);\n      }\n    }\n    return tiles;\n  }\n\n  setVirtual(virtual) {\n    this.setProperty('virtual', virtual);\n  }\n\n  _setVirtual(virtual) {\n    this._setProperty('virtual', virtual);\n    this.virtualScrolling.setEnabled(this.virtual);\n  }\n\n  _renderVirtual() {\n    this._updateVirtualScrollable();\n    if (!this.rendering) {\n      // No need to do it while rendering, will be done by the layout. But needs to be done if virtual changes on the fly\n      this.setViewRangeSize(this.calculateViewRangeSize(), false);\n    }\n\n    if (this.rendered) {\n      // When virtual toggles, remove all tiles and render them anew (to have the correct tiles rendered in the new mode)\n      this._removeAllTiles();\n      if (this.virtual) {\n        // RenderViewPort may do nothing if all tiles are already in the view port, but fillers may not be created yet\n        this._renderFiller();\n      }\n    }\n    if (!this.virtual) {\n      // Render all tiles (on toggle and initially) (_renderViewRange is not used in non virtual mode because filtered tiles need to be rendered as well)\n      this._renderAllTiles();\n    }\n\n    this._renderViewPort();\n    this.invalidateLayoutTree();\n  }\n\n  _updateVirtualScrollable() {\n    var $scrollable = this.virtualScrolling.$scrollable;\n    if ($scrollable) {\n      $scrollable.off('scroll', this._scrollParentScrollHandler);\n    }\n    if (!this.virtual || this.removing) {\n      this.virtualScrolling.set$Scrollable(null);\n      return;\n    }\n    if (this.scrollable) {\n      this.virtualScrolling.set$Scrollable(this.$container);\n    } else {\n      this.virtualScrolling.set$Scrollable(this.$container.scrollParent());\n      this.virtualScrolling.$scrollable.on('scroll', this._scrollParentScrollHandler);\n    }\n  }\n\n  calculateViewRangeSize() {\n    return this.virtualScrolling.calculateViewRangeSize();\n  }\n\n  setViewRangeSize(viewRangeSize, updateViewPort) {\n    if (this.viewRangeSize === viewRangeSize) {\n      return;\n    }\n    this._setProperty('viewRangeSize', viewRangeSize);\n    this.virtualScrolling.setViewRangeSize(viewRangeSize, updateViewPort);\n  }\n\n  _heightForRow(row) {\n    var height = 0;\n\n    height = this.htmlComp.layout.rowHeight;\n    if (row !== this.rowCount() - 1) {\n      // Add row gap unless it is the last row\n      height += this.htmlComp.layout.vgap;\n    }\n\n    if (!numbers.isNumber(height)) {\n      throw new Error('Calculated height is not a number: ' + height);\n    }\n    return height;\n  }\n\n  /**\n   * Used for virtual scrolling to calculate the view range size.\n   * @returns {number} the configured rowHeight + vgap / 2. Reason: the gaps are only between rows, the first and last row therefore only have 1 gap.\n   */\n  _minRowHeight() {\n    return this.htmlComp.layout.rowHeight + this.htmlComp.layout.vgap / 2;\n  }\n\n  rowCount(gridColumnCount) {\n    gridColumnCount = scout.nvl(gridColumnCount, this.gridColumnCount);\n    return Math.ceil(this.filteredTiles.length / gridColumnCount);\n  }\n\n  /**\n   * Calculates and renders the rows which should be visible in the current viewport based on scroll top.\n   */\n  _renderViewPort() {\n    if (!this.isAttachedAndRendered()) {\n      // if grid is not attached the correct viewPort can not be evaluated. Mark for render after attach.\n      this._renderViewPortAfterAttach = true;\n      return;\n    }\n    if (!this.virtual) {\n      return;\n    }\n    this.virtualScrolling._renderViewPort();\n  }\n\n  /**\n   * Renders the rows visible in the viewport and removes the other rows\n   */\n  _renderViewRange(viewRange) {\n    if (viewRange.equals(this.viewRangeRendered)) {\n      if (viewRange.size() === 0) {\n        // Iif view range is empty initially viewRangeRendered will be empty as well -> make sure fillers are rendered correctly (used for pref size)\n        this._renderFiller();\n      }\n      // Range already rendered -> do nothing\n      return;\n    }\n    var rangesToRemove = this.viewRangeRendered.subtract(viewRange).filter(function(range) {\n      return range.size() > 0;\n    });\n    rangesToRemove.forEach(function(range) {\n      this._removeTilesInRange(range);\n    }.bind(this));\n\n    var rangesToRender = viewRange.subtract(this.viewRangeRendered).filter(function(range) {\n      return range.size() > 0;\n    });\n    rangesToRender.forEach(function(range) {\n      this._renderTilesInRange(range);\n    }.bind(this));\n\n    this._renderFiller();\n  }\n\n  _renderTilesInRange(range) {\n    var numRowsRendered = 0;\n    var tilesRendered = 0;\n    var tiles = this.filteredTiles;\n    if (tiles.length === 0) {\n      return;\n    }\n\n    var maxRange = this.virtualScrolling.maxViewRange();\n    range = maxRange.intersect(range);\n    var newRange = this.viewRangeRendered.union(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n\n    for (var row = range.from; row < range.to; row++) {\n      this.eachTileInRow(row, renderTile.bind(this));\n      numRowsRendered++;\n    }\n\n    if ($.log.isTraceEnabled()) {\n      $.log.trace(numRowsRendered + ' new rows rendered from ' + range);\n      $.log.trace(this._rowsRenderedInfo());\n    }\n\n    function renderTile(tile) {\n      if (tile.rendered) {\n        return;\n      }\n      this._renderTile(tile);\n      tilesRendered++;\n    }\n  }\n\n  /**\n   * @returns {Tile[]} the newly rendered tiles\n   */\n  _renderTileDelta(filterResult) {\n    if (!this.virtual) {\n      return [];\n    }\n    var prevTiles = this.renderedTiles();\n    var newViewRange = this.virtualScrolling.calculateCurrentViewRange();\n    var newTiles = this.findTilesInRange(newViewRange);\n\n    var tilesToRemove = arrays.diff(prevTiles, newTiles);\n    var tilesToRender = arrays.diff(newTiles, prevTiles);\n    if (filterResult) {\n      filterResult.newlyHiddenTiles.forEach(function(tile) {\n        if (tile.rendered) {\n          this._removeTileByFilter(tile);\n        }\n      }, this);\n    }\n\n    // tilesToRemove contains newlyHiddenTiles as well but remove() does nothing if it is already removing\n    tilesToRemove.forEach(function(tile) {\n      tile.remove();\n    });\n    tilesToRender.forEach(function(tile) {\n      this._renderTile(tile);\n    }, this);\n\n    if (filterResult) {\n      // Suppress because Tile.js would invalidate which leads to poor performance if grid is used in a Group.js and group is being expanded while tiles are shown\n      // invalidating will be done afterwards anyway so no need to do it for each tile\n      this.htmlComp.suppressInvalidate = true;\n      filterResult.newlyShownTiles.forEach(function(tile) {\n        if (tile.rendered) {\n          this._renderTileVisibleForFilter(tile);\n        }\n      }, this);\n      this.htmlComp.suppressInvalidate = false;\n    }\n\n    this.viewRangeRendered = newViewRange;\n    this._renderFiller();\n    if (!this.htmlComp.layouting) {\n      // If a tile is inserted while a group of the tile accordion is being expanded,\n      // invalidating may create a loop because the group resizes the body which triggers the TileGridLayout and eventually calls this function again -> Don't invalidate while layouting\n      this.invalidateLayoutTree();\n    }\n    return tilesToRender;\n  }\n\n  _removeTileByFilter(tile) {\n    // In virtual mode, filtered tiles are not rendered. In normal mode, the filter animation is triggerd by _renderVisible of the tile.\n    // Since the tile is removed immediately, the invisible animation would not start, so we use the remove animation instead.\n    // But because the delete animation is a different one to the filter animation, the removeClass needs to be swapped\n    // Remove class first to make sure animation won't be finished before the animationend listener is attached in Widget._removeAnimated (which may happen because a setTimeout is used there)\n    tile.$container.removeClass('animate-invisible');\n    tile.animateRemoval = true;\n    tile.animateRemovalClass = 'animate-invisible';\n    tile.remove();\n    this._onAnimatedTileRemove(tile);\n    tile.animateRemoval = false;\n    // Remove animation is started by a set timeout -> use set timeout as well to come after\n    setTimeout(function() {\n      // Reset to default\n      tile.animateRemovalClass = 'animate-remove';\n    });\n  }\n\n  _renderTileVisibleForFilter(tile) {\n    if (!tile.filterAccepted || tile.$container.hasClass('animate-visible')) {\n      return;\n    }\n    if (tile.removalPending) {\n      return;\n    }\n    // Start filter animation (at the time setFilterAccepted was set the tile was not rendered)\n    tile.$container.setVisible(false);\n    tile._renderVisible();\n  }\n\n  _renderTileOrder(prevTiles) {\n    // Loop through the tiles and move every html element to the end of the container\n    // Only move if the order is different to the old order\n    // This is actually only necessary to make debugging easier, since the tiles are positioned absolutely it would work without it\n    var different = false;\n    this.tiles.forEach(function(tile, i) {\n      if (prevTiles[i] !== tile || different) {\n        // Start ordering as soon as the order of the arrays starts to differ\n        if (this.virtual && !tile.rendered) {\n          // In non virtual mode, every tile is rendered, even the filtered one. So if a tile is not rendered ignore it in virtual, but fail in non virtual\n          return;\n        }\n        different = true;\n        tile.$container.appendTo(this.$container);\n      }\n    }, this);\n\n    if (different && !this.virtual) {\n      // In virtual mode this is done by _renderTileDelta()\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _rowsRenderedInfo() {\n    var numRenderedTiles = this.$container.children('.tile').length;\n    var renderedRowsRange = '(' + this.viewRangeRendered + ')';\n    return numRenderedTiles + ' tiles rendered in range ' + renderedRowsRange;\n  }\n\n  _removeTilesInRange(range) {\n    var numRowsRemoved = 0;\n    var newRange = this.viewRangeRendered.subtract(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only remove rows at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n\n    for (var i = range.from; i < range.to; i++) {\n      this._removeTilesInRow(i);\n      numRowsRemoved++;\n    }\n\n    if ($.log.isTraceEnabled()) {\n      $.log.trace(numRowsRemoved + ' rows removed from ' + range + '.');\n      $.log.trace(this._rowsRenderedInfo());\n    }\n  }\n\n  _removeTilesInRow(row) {\n    var tiles = this.findTilesInRow(row);\n    tiles.forEach(function(tile) {\n      tile.remove();\n    });\n  }\n\n  rowHasRenderedTiles(row) {\n    var tilesInRow = this.findTilesInRow(row);\n    return tilesInRow.some(function(tile) {\n      return tile.rendered && !tile.removing;\n    });\n  }\n\n  ensureTileRendered(tile) {\n    if (!tile.rendered) {\n      var rowIndex = tile.gridData.y;\n      this.virtualScrolling._renderViewRangeForRowIndex(rowIndex);\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _renderFiller() {\n    if (!this.$fillBefore) {\n      this.$fillBefore = this.$container.prependDiv('filler');\n    }\n\n    var fillBeforeHeight = this._calculateFillerHeight(new Range(0, this.viewRangeRendered.from));\n    this.$fillBefore.cssHeight(fillBeforeHeight);\n    this.$fillBefore.css('width', '100%');\n    $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeHeight);\n\n    if (!this.$fillAfter) {\n      this.$fillAfter = this.$container.appendDiv('filler');\n    }\n    // Make sure filler is always at the end\n    this.$fillAfter.appendTo(this.$container);\n\n    var renderedTilesHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.from, this.viewRangeRendered.to));\n    this.$fillAfter.cssTop(fillBeforeHeight + renderedTilesHeight);\n\n    var fillAfterHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.to, this.rowCount()));\n    this.$fillAfter.cssHeight(fillAfterHeight);\n    this.$fillAfter.css('width', '100%');\n\n    $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterHeight);\n  }\n\n  _calculateFillerHeight(range) {\n    var totalHeight = 0;\n    for (var i = range.from; i < range.to; i++) {\n      totalHeight += this._heightForRow(i);\n    }\n    return totalHeight;\n  }\n\n  /**\n   * If virtual is false, the live list of filtered tiles is returned, because every tile has to be rendered. If virtual is true, the rendered tiles are collected and returned.\n   */\n  renderedTiles() {\n    if (!this.rendered) {\n      return [];\n    }\n    if (!this.virtual) {\n      return this.filteredTiles;\n    }\n    var tiles = [];\n    this.$container.children('.tile').each(function(i, elem) {\n      var tile = scout.widget(elem);\n      if (!tile.removalPending) {\n        // Don't return the tiles which are being removed\n        // Otherwise delta could be wrong if called while removing. Example: filter is added and removed right after while the tiles are still being removed -> RenderTileDelta has to render the tiles being removed\n        tiles.push(tile);\n      }\n    });\n    return tiles;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}