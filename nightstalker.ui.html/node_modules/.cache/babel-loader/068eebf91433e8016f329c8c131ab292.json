{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { CollapseHandle, CompositeField, graphics, GroupBox, HtmlComponent, HtmlEnvironment, KeyStroke, scout, SplitBoxCollapseKeyStroke, SplitBoxFirstCollapseKeyStroke, SplitBoxLayout, SplitBoxSecondCollapseKeyStroke } from '../../../index';\nimport $ from 'jquery';\n\nvar SplitBox = /*#__PURE__*/function (_CompositeField) {\n  _inherits(SplitBox, _CompositeField);\n\n  var _super = _createSuper(SplitBox);\n\n  function SplitBox() {\n    var _this;\n\n    _classCallCheck(this, SplitBox);\n\n    _this = _super.call(this);\n\n    _this._addWidgetProperties(['firstField', 'secondField', 'collapsibleField']);\n\n    _this._addPreserveOnPropertyChangeProperties(['collapsibleField']);\n\n    _this.firstField = null;\n    _this.secondField = null;\n    _this.collapsibleField = null;\n    _this.fieldCollapsed = false;\n    _this.toggleCollapseKeyStroke = null;\n    _this.firstCollapseKeyStroke = null;\n    _this.secondCollapseKeyStroke = null;\n    _this.splitHorizontal = true; // true = split x-axis, false = split y-axis\n\n    _this.splitterEnabled = true;\n    _this.splitterPosition = 0.5;\n    _this.minSplitterPosition = 0;\n    _this.splitterPositionType = SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST;\n    _this.fieldMinimized = false;\n    _this.minimizeEnabled = true;\n    _this._$splitArea = null;\n    _this._$splitter = null;\n    return _this;\n  }\n\n  _createClass(SplitBox, [{\n    key: \"_init\",\n    value: function _init(model) {\n      _get(_getPrototypeOf(SplitBox.prototype), \"_init\", this).call(this, model);\n\n      this._setToggleCollapseKeyStroke(this.toggleCollapseKeyStroke);\n\n      this._setFirstCollapseKeyStroke(this.firstCollapseKeyStroke);\n\n      this._setSecondCollapseKeyStroke(this.secondCollapseKeyStroke);\n\n      this._updateCollapseHandle();\n\n      this._initResponsive();\n    }\n    /**\n     * Set the group boxes of the split box to responsive if not set otherwise.\n     */\n\n  }, {\n    key: \"_initResponsive\",\n    value: function _initResponsive() {\n      this.getFields().forEach(function (field) {\n        if (field instanceof GroupBox && field.responsive === null) {\n          field.setResponsive(true);\n        }\n      });\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      this.addContainer(this.$parent, 'split-box'); // This widget does not support label, mandatoryIndicator and status\n      // Create split area\n\n      this._$splitArea = this.$parent.makeDiv('split-area');\n      this.addField(this._$splitArea);\n      this.htmlSplitArea = HtmlComponent.install(this._$splitArea, this.session);\n      this.htmlSplitArea.setLayout(new SplitBoxLayout(this));\n      this._$window = this.$parent.window();\n      this._$body = this.$parent.body(); // Add fields and splitter\n\n      if (this.firstField) {\n        this.firstField.render(this._$splitArea);\n        this.firstField.$container.addClass('first-field').addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n        this.firstField.on('propertyChange', onInnerFieldPropertyChange.bind(this));\n\n        if (this.secondField) {\n          this.secondField.render(this._$splitArea);\n          this.secondField.$container.addClass('second-field').addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n          this.secondField.on('propertyChange', onInnerFieldPropertyChange.bind(this));\n          this._$splitter = this._$splitArea.appendDiv('splitter').addClass(this.splitHorizontal ? 'x-axis' : 'y-axis').on('mousedown', resizeSplitter.bind(this));\n        }\n      }\n\n      this._updateFieldVisibilityClasses(); // --- Helper functions ---\n\n\n      function resizeSplitter(event) {\n        if (event.which !== 1) {\n          return; // only handle left mouse button\n        }\n\n        if (this.splitterEnabled) {\n          // Update mouse position (see resizeMove() for details)\n          var mousePosition = {\n            x: event.pageX,\n            y: event.pageY\n          }; // Add listeners (we add them to the window to make sure we get the mouseup event even when the cursor it outside the window)\n\n          this._$window.on('mousemove.splitbox', resizeMove.bind(this)).on('mouseup.splitbox', resizeEnd.bind(this)); // Ensure the correct cursor is always shown while moving\n\n\n          this._$body.addClass(this.splitHorizontal ? 'col-resize' : 'row-resize');\n\n          $('iframe').addClass('dragging-in-progress'); // Get initial area and splitter bounds\n\n          var splitAreaPosition = this._$splitArea.offset();\n\n          var splitAreaSize = graphics.size(this._$splitArea, true);\n\n          var splitterPosition = this._$splitter.offset();\n\n          var splitterSize = graphics.size(this._$splitter, true); // Create temporary splitter\n\n          var $tempSplitter = this._$splitArea.appendDiv('temp-splitter').addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n\n          if (this.splitHorizontal) {\n            // \"|\"\n            $tempSplitter.cssLeft(splitterPosition.left - splitAreaPosition.left);\n          } else {\n            // \"--\"\n            $tempSplitter.cssTop(splitterPosition.top - splitAreaPosition.top);\n          }\n\n          this._$splitter.addClass('dragging');\n        }\n\n        var newSplitterPosition = this.splitterPosition;\n        var SNAP_SIZE = 10;\n\n        function resizeMove(event) {\n          if (event.pageX === mousePosition.x && event.pageY === mousePosition.y) {\n            // Chrome bug: https://code.google.com/p/chromium/issues/detail?id=161464\n            // When holding the mouse, but not moving it, a 'mousemove' event is fired every second nevertheless.\n            return;\n          }\n\n          mousePosition = {\n            x: event.pageX,\n            y: event.pageY\n          };\n\n          if (this.splitHorizontal) {\n            // \"|\"\n            // Calculate target splitter position (in area)\n            var targetSplitterPositionLeft = event.pageX - splitAreaPosition.left; // De-normalize minimum splitter position to allowed splitter range in pixel [minSplitterPositionLeft, maxSplitterPositionLeft]\n\n            var minSplitterPositionLeft;\n            var maxSplitterPositionLeft; // Splitter width plus margin on right side, if temporary splitter position is x, the splitter div position is x-splitterOffset\n\n            var splitterOffset = Math.floor((splitterSize.width + HtmlEnvironment.get().fieldMandatoryIndicatorWidth) / 2);\n\n            if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST) {\n              minSplitterPositionLeft = scout.nvl(this.minSplitterPosition, 0); // allow to move the splitter to right side, leaving minimal space for splitter div without right margin (=total splitter size minus offset)\n\n              maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset;\n            } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n              minSplitterPositionLeft = (splitAreaSize.width - splitterSize.width) * scout.nvl(this.minSplitterPosition, 0); // allow to move the splitter to right side, leaving minimal space for splitter div without right margin (=total splitter size minus offset)\n\n              maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset;\n            } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n              minSplitterPositionLeft = 0; // allow to move the splitter to right side, leaving minimal space for splitter div without right margin, reserving space for minimum splitter size\n\n              maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset - scout.nvl(this.minSplitterPosition, 0);\n            } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n              minSplitterPositionLeft = 0; // allow to move the splitter to right side, leaving minimal space for splitter div without right margin, reserving space for minimum splitter size\n\n              maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset - Math.floor(scout.nvl(this.minSplitterPosition, 0) * (splitAreaSize.width - splitterSize.width));\n            } // Snap to begin and end\n\n\n            var tempSplitterOffsetX = splitterOffset;\n\n            if (targetSplitterPositionLeft < minSplitterPositionLeft + splitterOffset + SNAP_SIZE) {\n              // snap left if minimum position is reached (+ snap range)\n              targetSplitterPositionLeft = minSplitterPositionLeft; // set splitter directly to left minimal bound\n\n              tempSplitterOffsetX = 0; // setting splitter to left minimal bound, does not require an additional offset\n            } else if (targetSplitterPositionLeft > maxSplitterPositionLeft - SNAP_SIZE) {\n              targetSplitterPositionLeft = maxSplitterPositionLeft;\n            } // Update temporary splitter\n\n\n            $tempSplitter.cssLeft(targetSplitterPositionLeft - tempSplitterOffsetX); // Normalize target position (available splitter area is (splitAreaSize.width - splitterSize.width))\n\n            newSplitterPosition = targetSplitterPositionLeft - tempSplitterOffsetX;\n\n            if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n              newSplitterPosition = newSplitterPosition / (splitAreaSize.width - splitterSize.width);\n            } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n              newSplitterPosition = 1 - newSplitterPosition / (splitAreaSize.width - splitterSize.width);\n            } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n              newSplitterPosition = splitAreaSize.width - splitterSize.width - newSplitterPosition;\n            }\n          } else {\n            // \"--\"\n            // Calculate target splitter position (in area)\n            var targetSplitterPositionTop = event.pageY - splitAreaPosition.top; // Snap to begin and end\n\n            var tempSplitterOffsetY = Math.floor(splitterSize.height / 2);\n\n            if (targetSplitterPositionTop < SNAP_SIZE) {\n              targetSplitterPositionTop = 0;\n              tempSplitterOffsetY = 0;\n            } else if (splitAreaSize.height - targetSplitterPositionTop < SNAP_SIZE) {\n              targetSplitterPositionTop = splitAreaSize.height;\n              tempSplitterOffsetY = splitterSize.height;\n            } // Update temporary splitter\n\n\n            $tempSplitter.cssTop(targetSplitterPositionTop - tempSplitterOffsetY); // Normalize target position\n\n            newSplitterPosition = targetSplitterPositionTop - tempSplitterOffsetY;\n\n            if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n              newSplitterPosition = newSplitterPosition / (splitAreaSize.height - splitterSize.height);\n            } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n              newSplitterPosition = 1 - newSplitterPosition / (splitAreaSize.height - splitterSize.height);\n            } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n              newSplitterPosition = splitAreaSize.height - newSplitterPosition - splitterSize.height;\n            }\n          }\n        }\n\n        function resizeEnd(event) {\n          if (event.which !== 1) {\n            return; // only handle left mouse button\n          } // Remove listeners and reset cursor\n\n\n          this._$window.off('mousemove.splitbox').off('mouseup.splitbox');\n\n          if ($tempSplitter) {\n            // instead of check for this.splitterEnabled, if splitter is currently moving it must be finished correctly\n            this._$body.removeClass(this.splitHorizontal ? 'col-resize' : 'row-resize');\n\n            $('iframe').removeClass('dragging-in-progress'); // Remove temporary splitter\n\n            $tempSplitter.remove();\n\n            this._$splitter.removeClass('dragging'); // Update split box\n\n\n            this.newSplitterPosition(newSplitterPosition, true);\n          }\n        }\n\n        return false;\n      }\n\n      function onInnerFieldPropertyChange(event) {\n        if (event.propertyName === 'visible') {\n          this._updateFieldVisibilityClasses(); // Mark layout as invalid\n\n\n          this.htmlSplitArea.invalidateLayoutTree(false);\n        }\n      }\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      _get(_getPrototypeOf(SplitBox.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderSplitterPosition();\n\n      this._renderSplitterEnabled();\n\n      this._renderCollapsibleField(); // renders collapsibleField _and_ fieldCollapsed\n\n\n      this._renderCollapseHandle(); // renders collapseHandle _and_ toggleCollapseKeyStroke _and_ firstCollapseKeyStroke _and_ secondCollapseKeyStroke\n\n\n      this._renderFieldMinimized();\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      this._$splitArea = null;\n      this._$splitter = null;\n\n      _get(_getPrototypeOf(SplitBox.prototype), \"_remove\", this).call(this);\n    }\n  }, {\n    key: \"_setSplitterPosition\",\n    value: function _setSplitterPosition(splitterPosition) {\n      this._setProperty('splitterPosition', splitterPosition); // If splitter position is explicitly set by an event, no recalculation is necessary\n\n\n      this._oldSplitterPositionType = null;\n    }\n  }, {\n    key: \"_renderSplitterPosition\",\n    value: function _renderSplitterPosition() {\n      this.newSplitterPosition(this.splitterPosition, false); // do not update (override) field minimized if new position is set by model\n    }\n  }, {\n    key: \"_setSplitterPositionType\",\n    value: function _setSplitterPositionType(splitterPositionType) {\n      if (this.rendered && !this._oldSplitterPositionType) {\n        this._oldSplitterPositionType = this.splitterPositionType; // We need to recalculate the splitter position. Because this requires the proper\n        // size of the split box, this can only be done in _renderSplitterPositionType().\n      }\n\n      this._setProperty('splitterPositionType', splitterPositionType);\n    }\n  }, {\n    key: \"_renderSplitterPositionType\",\n    value: function _renderSplitterPositionType() {\n      if (this._oldSplitterPositionType) {\n        // splitterPositionType changed while the split box was rendered --> convert splitterPosition\n        // to the target type such that the current position in screen does not change.\n        var splitAreaSize = this.htmlSplitArea.size(),\n            splitterPosition = this.splitterPosition,\n            splitterSize = graphics.size(this._$splitter, true),\n            minSplitterPosition = this.minSplitterPosition,\n            totalSize = 0;\n\n        if (this.splitHorizontal) {\n          // \"|\"\n          totalSize = splitAreaSize.width - splitterSize.width;\n        } else {\n          // \"--\"\n          totalSize = splitAreaSize.height - splitterSize.height;\n        } // Convert value depending on the old and new type system\n\n\n        var oldIsRelative = this._isSplitterPositionTypeRelative(this._oldSplitterPositionType);\n\n        var newIsRelative = this._isSplitterPositionTypeRelative(this.splitterPositionType);\n\n        var oldIsAbsolute = !oldIsRelative;\n        var newIsAbsolute = !newIsRelative;\n\n        if (oldIsRelative && newIsAbsolute) {\n          // From relative to absolute\n          if (this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND || this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST) {\n            splitterPosition = totalSize - totalSize * splitterPosition; // changed from first to second field or from second to first field, invert splitter position\n          } else {\n            splitterPosition = totalSize * splitterPosition;\n          } // convert minimum splitter position\n\n\n          if (minSplitterPosition) {\n            minSplitterPosition = totalSize * minSplitterPosition;\n          }\n        } else if (oldIsAbsolute && newIsRelative) {\n          // From absolute to relative\n          if (this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND || this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            splitterPosition = (totalSize - splitterPosition) / totalSize; // changed from first to second field or from second to first field, invert splitter position\n          } else {\n            splitterPosition = splitterPosition / totalSize;\n          } // convert minimum splitter position\n\n\n          if (minSplitterPosition) {\n            minSplitterPosition = minSplitterPosition / totalSize;\n          }\n        } else if (oldIsAbsolute && newIsAbsolute) {\n          splitterPosition = totalSize - splitterPosition; // do not convert minimum splitter position, unit did not change\n        } else {\n          // oldIsRelative && newIsRelative\n          splitterPosition = 1 - splitterPosition; // do not convert minimum splitter position, unit did not change\n        } // set new minimum splitter position\n\n\n        this.setMinSplitterPosition(minSplitterPosition); // Set as new splitter position\n\n        this._oldSplitterPositionType = null;\n        this.newSplitterPosition(splitterPosition, true);\n      }\n    }\n  }, {\n    key: \"_isSplitterPositionTypeRelative\",\n    value: function _isSplitterPositionTypeRelative(positionType) {\n      return positionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST || positionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND;\n    }\n  }, {\n    key: \"_renderSplitterEnabled\",\n    value: function _renderSplitterEnabled() {\n      if (this._$splitter) {\n        this._$splitter.setEnabled(this.splitterEnabled);\n      }\n    }\n  }, {\n    key: \"setFieldCollapsed\",\n    value: function setFieldCollapsed(collapsed) {\n      this.setProperty('fieldCollapsed', collapsed);\n\n      this._updateCollapseHandleButtons();\n    }\n  }, {\n    key: \"_renderFieldCollapsed\",\n    value: function _renderFieldCollapsed() {\n      this._renderCollapsibleField();\n    }\n  }, {\n    key: \"setCollapsibleField\",\n    value: function setCollapsibleField(field) {\n      this.setProperty('collapsibleField', field);\n\n      this._updateCollapseHandle();\n    }\n  }, {\n    key: \"_updateCollapseHandle\",\n    value: function _updateCollapseHandle() {\n      // always unregister key stroke first (although it may have been added by _setToggleCollapseKeyStroke before)\n      if (this.toggleCollapseKeyStroke) {\n        this.unregisterKeyStrokes(this.toggleCollapseKeyStroke);\n      }\n\n      if (this.firstCollapseKeyStroke) {\n        this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n      }\n\n      if (this.secondCollapseKeyStroke) {\n        this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n      }\n\n      if (this.collapsibleField) {\n        var horizontalAlignment = CollapseHandle.HorizontalAlignment.LEFT;\n\n        if (this.collapsibleField !== this.firstField) {\n          horizontalAlignment = CollapseHandle.HorizontalAlignment.RIGHT;\n        }\n\n        if (!this._collapseHandle) {\n          // create new collapse handle\n          this._collapseHandle = scout.create('CollapseHandle', {\n            parent: this,\n            horizontalAlignment: horizontalAlignment\n          });\n\n          this._collapseHandle.on('action', this.collapseHandleButtonPressed.bind(this));\n\n          if (this.toggleCollapseKeyStroke) {\n            this.registerKeyStrokes(this.toggleCollapseKeyStroke);\n          }\n\n          if (this.firstCollapseKeyStroke) {\n            this.registerKeyStrokes(this.firstCollapseKeyStroke);\n          }\n\n          if (this.secondCollapseKeyStroke) {\n            this.registerKeyStrokes(this.secondCollapseKeyStroke);\n          }\n\n          if (this.rendered) {\n            this._renderCollapseHandle();\n          }\n        } else {\n          // update existing collapse handle\n          this._collapseHandle.setHorizontalAlignment(horizontalAlignment);\n        }\n\n        this._updateCollapseHandleButtons();\n      } else {\n        if (this._collapseHandle) {\n          this._collapseHandle.destroy();\n\n          this._collapseHandle = null;\n        }\n      }\n    }\n  }, {\n    key: \"_updateCollapseHandleButtons\",\n    value: function _updateCollapseHandleButtons() {\n      if (!this._collapseHandle) {\n        return;\n      }\n\n      var leftVisible,\n          rightVisible,\n          collapsed = this.fieldCollapsed,\n          minimized = this.fieldMinimized,\n          minimizable = this._isMinimizable(),\n          positionTypeFirstField = this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST || this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST,\n          positionNotAccordingCollapsibleField = positionTypeFirstField && this.collapsibleField === this.secondField || !positionTypeFirstField && this.collapsibleField === this.firstField;\n\n      if (positionTypeFirstField) {\n        if (positionNotAccordingCollapsibleField) {\n          leftVisible = !minimized && minimizable || collapsed; // left = decrease collapsible field size. Decrease field in this order [minimized <- default <- collapsed]\n\n          rightVisible = !collapsed; // right = increase collapsible field size. Increase field in this order [minimized -> default -> collapsed]\n        } else {\n          leftVisible = !collapsed; // left = increase collapsible field size. Increase field in this order [default <- minimized <- collapsed]\n\n          rightVisible = collapsed || minimized && minimizable; // right = decrease collapsible field size. Decrease field in this order [default -> minimized -> collapsed]\n        }\n      } else {\n        if (positionNotAccordingCollapsibleField) {\n          leftVisible = !collapsed; // left = decrease collapsible field size. Decrease field in this order [collapsed <- default <- minimized]\n\n          rightVisible = !minimized && minimizable || collapsed; // right = increase collapsible field size. Increase field in this order [collapsed -> default -> minimized]\n        } else {\n          leftVisible = collapsed || minimized && minimizable; // left = decrease collapsible field size. Decrease field in this order [collapsed <- minimized <- default]\n\n          rightVisible = !collapsed; // right = increase collapsible field size. Increase field in this order [collapsed -> minimized -> default]\n        }\n      }\n\n      this._collapseHandle.setLeftVisible(leftVisible);\n\n      this._collapseHandle.setRightVisible(rightVisible); // update allowed keystrokes\n\n\n      if (this.firstCollapseKeyStroke) {\n        if (leftVisible) {\n          this.registerKeyStrokes(this.firstCollapseKeyStroke);\n        } else {\n          this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n        }\n      }\n\n      if (this.secondCollapseKeyStroke) {\n        if (rightVisible) {\n          this.registerKeyStrokes(this.secondCollapseKeyStroke);\n        } else {\n          this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n        }\n      }\n    }\n  }, {\n    key: \"getEffectiveSplitterPosition\",\n    value: function getEffectiveSplitterPosition() {\n      if (this._isMinimizable() && this.fieldMinimized) {\n        return this.minSplitterPosition;\n      }\n\n      return this.splitterPosition;\n    }\n  }, {\n    key: \"setMinSplitterPosition\",\n    value: function setMinSplitterPosition(minSplitterPosition) {\n      this.setProperty('minSplitterPosition', minSplitterPosition);\n\n      this._updateCollapseHandleButtons();\n    }\n  }, {\n    key: \"_renderMinSplitterPosition\",\n    value: function _renderMinSplitterPosition() {\n      // minimum splitter position is considered automatically when layout is updated\n      if (this.rendered) {\n        // don't invalidate layout on initial rendering\n        this.htmlSplitArea.invalidateLayoutTree(false);\n      }\n    }\n  }, {\n    key: \"setFieldMinimized\",\n    value: function setFieldMinimized(minimized) {\n      this.setProperty('fieldMinimized', minimized);\n\n      this._updateCollapseHandleButtons();\n    }\n  }, {\n    key: \"_renderFieldMinimized\",\n    value: function _renderFieldMinimized() {\n      this.$container.removeClass('first-field-minimized second-field-minimized');\n\n      if (this.firstField) {\n        this.firstField.$container.removeClass('minimized');\n      }\n\n      if (this.secondField) {\n        this.secondField.$container.removeClass('minimized');\n      }\n\n      if (this.collapsibleField && this.fieldMinimized) {\n        this.collapsibleField.$container.addClass('minimized');\n        this.$container.toggleClass('first-field-minimized', this.firstField === this.collapsibleField);\n        this.$container.toggleClass('second-field-minimized', this.secondField === this.collapsibleField);\n      } // field minimized state is considered automatically when layout is updated\n\n\n      if (this.rendered) {\n        // don't invalidate layout on initial rendering\n        this.htmlSplitArea.invalidateLayoutTree(false);\n      }\n    }\n  }, {\n    key: \"setMinimizeEnabled\",\n    value: function setMinimizeEnabled(enabled) {\n      this.setProperty('minimizeEnabled', enabled);\n\n      if (this._isMinimizable() && this._isSplitterPositionInMinimalRange(this.splitterPosition)) {\n        this.setFieldMinimized(true);\n      }\n\n      this._updateCollapseHandleButtons();\n    }\n  }, {\n    key: \"_renderMinimizeEnabled\",\n    value: function _renderMinimizeEnabled() {\n      // minimize enabled is considered automatically when layout is updated\n      if (this.rendered) {\n        // don't invalidate layout on initial rendering\n        this.htmlSplitArea.invalidateLayoutTree(false);\n      }\n    }\n  }, {\n    key: \"_isMinimizable\",\n    value: function _isMinimizable() {\n      return !!this.minSplitterPosition && this.minimizeEnabled;\n    }\n  }, {\n    key: \"_renderCollapsibleField\",\n    value: function _renderCollapsibleField() {\n      this.$container.removeClass('first-field-collapsed second-field-collapsed');\n\n      if (this.firstField) {\n        this.firstField.$container.removeClass('collapsed');\n      }\n\n      if (this.secondField) {\n        this.secondField.$container.removeClass('collapsed');\n      }\n\n      if (this.collapsibleField && this.fieldCollapsed) {\n        this.collapsibleField.$container.addClass('collapsed');\n        this.$container.toggleClass('first-field-collapsed', this.firstField === this.collapsibleField);\n        this.$container.toggleClass('second-field-collapsed', this.secondField === this.collapsibleField);\n      }\n\n      if (this.rendered) {\n        // don't invalidate layout on initial rendering\n        this.htmlSplitArea.invalidateLayoutTree(false);\n      }\n    }\n  }, {\n    key: \"_setToggleCollapseKeyStroke\",\n    value: function _setToggleCollapseKeyStroke(keyStroke) {\n      if (keyStroke) {\n        if (this.toggleCollapseKeyStroke instanceof KeyStroke) {\n          this.unregisterKeyStrokes(this.collapseKeyStroke);\n        }\n\n        this.toggleCollapseKeyStroke = new SplitBoxCollapseKeyStroke(this, keyStroke);\n\n        if (this._collapseHandle) {\n          this.registerKeyStrokes(this.toggleCollapseKeyStroke);\n        }\n      }\n    }\n  }, {\n    key: \"_setFirstCollapseKeyStroke\",\n    value: function _setFirstCollapseKeyStroke(keyStroke) {\n      if (keyStroke) {\n        if (this.firstCollapseKeyStroke instanceof KeyStroke) {\n          this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n        }\n\n        this.firstCollapseKeyStroke = new SplitBoxFirstCollapseKeyStroke(this, keyStroke);\n\n        if (this._collapseHandle) {\n          this.registerKeyStrokes(this.firstCollapseKeyStroke);\n        }\n      }\n    }\n  }, {\n    key: \"_setSecondCollapseKeyStroke\",\n    value: function _setSecondCollapseKeyStroke(keyStroke) {\n      if (keyStroke) {\n        if (this.secondCollapseKeyStroke instanceof KeyStroke) {\n          this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n        }\n\n        this.secondCollapseKeyStroke = new SplitBoxSecondCollapseKeyStroke(this, keyStroke);\n\n        if (this._collapseHandle) {\n          this.registerKeyStrokes(this.secondCollapseKeyStroke);\n        }\n      }\n    }\n  }, {\n    key: \"_renderCollapseHandle\",\n    value: function _renderCollapseHandle() {\n      if (this._collapseHandle) {\n        this._collapseHandle.render();\n      }\n    }\n  }, {\n    key: \"newSplitterPosition\",\n    value: function newSplitterPosition(_newSplitterPosition, updateFieldMinimizedState) {\n      if (this._isSplitterPositionTypeRelative(this.splitterPositionType)) {\n        // Ensure range 0..1\n        _newSplitterPosition = Math.max(0, Math.min(1, _newSplitterPosition));\n      } else {\n        // Ensure not negative\n        _newSplitterPosition = Math.max(0, _newSplitterPosition);\n      } // Ensure splitter within allowed range, toggle field minimized state if new splitter position is within minimal range\n\n\n      if (this._isMinimizable() && this._isSplitterPositionInMinimalRange(_newSplitterPosition)) {\n        this.setFieldMinimized(true);\n        return;\n      } // Set new value (send to server if changed\n\n\n      var positionChanged = this.splitterPosition !== _newSplitterPosition;\n      this.splitterPosition = _newSplitterPosition;\n\n      if (positionChanged) {\n        this.trigger('positionChange', {\n          position: _newSplitterPosition\n        });\n\n        if (updateFieldMinimizedState) {\n          this._updateFieldMinimized();\n        }\n      }\n\n      this._updateCollapseHandleButtons(); // Mark layout as invalid\n\n\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }, {\n    key: \"_updateFieldMinimized\",\n    value: function _updateFieldMinimized() {\n      if (this._isMinimizable()) {\n        this.setFieldMinimized(this._isSplitterPositionInMinimalRange(this.splitterPosition));\n      } else {\n        this.setFieldMinimized(false);\n      }\n    }\n  }, {\n    key: \"_isSplitterPositionInMinimalRange\",\n    value: function _isSplitterPositionInMinimalRange(newSplitterPosition) {\n      if (!this._isMinimizable()) {\n        return false;\n      }\n\n      return newSplitterPosition <= this.minSplitterPosition;\n    }\n  }, {\n    key: \"toggleFieldCollapsed\",\n    value: function toggleFieldCollapsed() {\n      this.setFieldCollapsed(!this.fieldCollapsed);\n    }\n  }, {\n    key: \"collapseHandleButtonPressed\",\n    value: function collapseHandleButtonPressed(event) {\n      var collapsed = this.fieldCollapsed,\n          minimized = this.fieldMinimized,\n          minimizable = this._isMinimizable(),\n          positionTypeFirstField = this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST || this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST,\n          increaseField = !!event.left && !positionTypeFirstField || !!event.right && positionTypeFirstField;\n\n      if (positionTypeFirstField && this.collapsibleField === this.secondField || !positionTypeFirstField && this.collapsibleField === this.firstField) {\n        // Splitter is not positioned according (absolute or relative) to collapsible field\n        // - Mode toggles to increase collapsible field size: field collapsed --> field default --> field minimized\n        // - Mode toggles to decrease collapsible field size: field collapsed <-- field default <-- field minimized\n        if (increaseField) {\n          if (collapsed) {// not possible, button is not visible (field is collapsed and cannot further increase its size)\n          } else if (minimized && minimizable) {\n            this.setFieldMinimized(false);\n          } else {\n            this.setFieldCollapsed(true);\n          }\n        } else {\n          if (collapsed) {\n            this.setFieldCollapsed(false);\n          } else if (minimized) {// not possible, button is not visible (field is minimized and cannot further decrease its size)\n          } else if (minimizable) {\n            this.setFieldMinimized(true);\n          }\n        }\n      } else {\n        // Splitter is positioned according (absolute or relative) to collapsible field\n        // - Mode toggles to increase collapsible field size: field collapsed --> field minimized --> field default\n        // - Mode toggles to decrease collapsible field size: field collapsed <-- field minimized <-- field default\n        if (increaseField) {\n          if (collapsed) {\n            this.setFieldCollapsed(false);\n          } else if (minimized) {\n            this.setFieldMinimized(false);\n          } else {// not possible, button is not visible (field has default size and cannot further increase its size)\n          }\n        } else {\n          if (collapsed) {// not possible, button is not visible (field is collapsed and cannot further decrease its size)\n          } else if (minimized || !minimizable) {\n            this.setFieldCollapsed(true);\n          } else {\n            this.setFieldMinimized(true);\n          }\n        }\n      }\n    }\n    /**\n     * @override CompositeField.js\n     */\n\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      var fields = [];\n\n      if (this.firstField) {\n        fields.push(this.firstField);\n      }\n\n      if (this.secondField) {\n        fields.push(this.secondField);\n      }\n\n      return fields;\n    }\n  }, {\n    key: \"_updateFieldVisibilityClasses\",\n    value: function _updateFieldVisibilityClasses() {\n      if (!this.rendered && !this.rendering) {\n        return;\n      }\n\n      var hasFirstField = this.firstField && this.firstField.isVisible();\n      var hasSecondField = this.secondField && this.secondField.isVisible();\n      var hasTwoFields = hasFirstField && hasSecondField;\n      var hasOneField = !hasTwoFields && (hasFirstField || hasSecondField); // Mark container if only one field is visible (i.e. there is no splitter)\n\n      this.$container.toggleClass('single-field', hasOneField);\n    }\n  }]);\n\n  return SplitBox;\n}(CompositeField);\n\n_defineProperty(SplitBox, \"SPLITTER_POSITION_TYPE_RELATIVE_FIRST\", 'relativeFirst');\n\n_defineProperty(SplitBox, \"SPLITTER_POSITION_TYPE_RELATIVE_SECOND\", 'relativeSecond');\n\n_defineProperty(SplitBox, \"SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST\", 'absoluteFirst');\n\n_defineProperty(SplitBox, \"SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND\", 'absoluteSecond');\n\nexport { SplitBox as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/form/fields/splitbox/SplitBox.js"],"names":["CollapseHandle","CompositeField","graphics","GroupBox","HtmlComponent","HtmlEnvironment","KeyStroke","scout","SplitBoxCollapseKeyStroke","SplitBoxFirstCollapseKeyStroke","SplitBoxLayout","SplitBoxSecondCollapseKeyStroke","$","SplitBox","_addWidgetProperties","_addPreserveOnPropertyChangeProperties","firstField","secondField","collapsibleField","fieldCollapsed","toggleCollapseKeyStroke","firstCollapseKeyStroke","secondCollapseKeyStroke","splitHorizontal","splitterEnabled","splitterPosition","minSplitterPosition","splitterPositionType","SPLITTER_POSITION_TYPE_RELATIVE_FIRST","fieldMinimized","minimizeEnabled","_$splitArea","_$splitter","model","_setToggleCollapseKeyStroke","_setFirstCollapseKeyStroke","_setSecondCollapseKeyStroke","_updateCollapseHandle","_initResponsive","getFields","forEach","field","responsive","setResponsive","addContainer","$parent","makeDiv","addField","htmlSplitArea","install","session","setLayout","_$window","window","_$body","body","render","$container","addClass","on","onInnerFieldPropertyChange","bind","appendDiv","resizeSplitter","_updateFieldVisibilityClasses","event","which","mousePosition","x","pageX","y","pageY","resizeMove","resizeEnd","splitAreaPosition","offset","splitAreaSize","size","splitterSize","$tempSplitter","cssLeft","left","cssTop","top","newSplitterPosition","SNAP_SIZE","targetSplitterPositionLeft","minSplitterPositionLeft","maxSplitterPositionLeft","splitterOffset","Math","floor","width","get","fieldMandatoryIndicatorWidth","SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST","nvl","SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND","SPLITTER_POSITION_TYPE_RELATIVE_SECOND","tempSplitterOffsetX","targetSplitterPositionTop","tempSplitterOffsetY","height","off","removeClass","remove","propertyName","invalidateLayoutTree","_renderSplitterPosition","_renderSplitterEnabled","_renderCollapsibleField","_renderCollapseHandle","_renderFieldMinimized","_setProperty","_oldSplitterPositionType","rendered","totalSize","oldIsRelative","_isSplitterPositionTypeRelative","newIsRelative","oldIsAbsolute","newIsAbsolute","setMinSplitterPosition","positionType","setEnabled","collapsed","setProperty","_updateCollapseHandleButtons","unregisterKeyStrokes","horizontalAlignment","HorizontalAlignment","LEFT","RIGHT","_collapseHandle","create","parent","collapseHandleButtonPressed","registerKeyStrokes","setHorizontalAlignment","destroy","leftVisible","rightVisible","minimized","minimizable","_isMinimizable","positionTypeFirstField","positionNotAccordingCollapsibleField","setLeftVisible","setRightVisible","toggleClass","enabled","_isSplitterPositionInMinimalRange","setFieldMinimized","keyStroke","collapseKeyStroke","updateFieldMinimizedState","max","min","positionChanged","trigger","position","_updateFieldMinimized","setFieldCollapsed","increaseField","right","fields","push","rendering","hasFirstField","isVisible","hasSecondField","hasTwoFields","hasOneField"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  CollapseHandle,\n  CompositeField,\n  graphics,\n  GroupBox,\n  HtmlComponent,\n  HtmlEnvironment,\n  KeyStroke,\n  scout,\n  SplitBoxCollapseKeyStroke,\n  SplitBoxFirstCollapseKeyStroke,\n  SplitBoxLayout,\n  SplitBoxSecondCollapseKeyStroke\n} from '../../../index';\nimport $ from 'jquery';\n\nexport default class SplitBox extends CompositeField {\n\n  constructor() {\n    super();\n    this._addWidgetProperties(['firstField', 'secondField', 'collapsibleField']);\n    this._addPreserveOnPropertyChangeProperties(['collapsibleField']);\n\n    this.firstField = null;\n    this.secondField = null;\n    this.collapsibleField = null;\n    this.fieldCollapsed = false;\n    this.toggleCollapseKeyStroke = null;\n    this.firstCollapseKeyStroke = null;\n    this.secondCollapseKeyStroke = null;\n    this.splitHorizontal = true; // true = split x-axis, false = split y-axis\n    this.splitterEnabled = true;\n    this.splitterPosition = 0.5;\n    this.minSplitterPosition = 0;\n    this.splitterPositionType = SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST;\n    this.fieldMinimized = false;\n    this.minimizeEnabled = true;\n\n    this._$splitArea = null;\n    this._$splitter = null;\n  }\n\n  static SPLITTER_POSITION_TYPE_RELATIVE_FIRST = 'relativeFirst';\n  static SPLITTER_POSITION_TYPE_RELATIVE_SECOND = 'relativeSecond';\n  static SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST = 'absoluteFirst';\n  static SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND = 'absoluteSecond';\n\n  _init(model) {\n    super._init(model);\n    this._setToggleCollapseKeyStroke(this.toggleCollapseKeyStroke);\n    this._setFirstCollapseKeyStroke(this.firstCollapseKeyStroke);\n    this._setSecondCollapseKeyStroke(this.secondCollapseKeyStroke);\n    this._updateCollapseHandle();\n    this._initResponsive();\n  }\n\n  /**\n   * Set the group boxes of the split box to responsive if not set otherwise.\n   */\n  _initResponsive() {\n    this.getFields().forEach(function(field) {\n      if (field instanceof GroupBox && field.responsive === null) {\n        field.setResponsive(true);\n      }\n    });\n  }\n\n  _render() {\n    this.addContainer(this.$parent, 'split-box');\n    // This widget does not support label, mandatoryIndicator and status\n\n    // Create split area\n    this._$splitArea = this.$parent.makeDiv('split-area');\n    this.addField(this._$splitArea);\n    this.htmlSplitArea = HtmlComponent.install(this._$splitArea, this.session);\n    this.htmlSplitArea.setLayout(new SplitBoxLayout(this));\n    this._$window = this.$parent.window();\n    this._$body = this.$parent.body();\n\n    // Add fields and splitter\n    if (this.firstField) {\n      this.firstField.render(this._$splitArea);\n      this.firstField.$container\n        .addClass('first-field')\n        .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n      this.firstField.on('propertyChange', onInnerFieldPropertyChange.bind(this));\n\n      if (this.secondField) {\n        this.secondField.render(this._$splitArea);\n        this.secondField.$container\n          .addClass('second-field')\n          .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n        this.secondField.on('propertyChange', onInnerFieldPropertyChange.bind(this));\n\n        this._$splitter = this._$splitArea.appendDiv('splitter')\n          .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis')\n          .on('mousedown', resizeSplitter.bind(this));\n      }\n    }\n    this._updateFieldVisibilityClasses();\n\n    // --- Helper functions ---\n\n    function resizeSplitter(event) {\n      if (event.which !== 1) {\n        return; // only handle left mouse button\n      }\n      if (this.splitterEnabled) {\n        // Update mouse position (see resizeMove() for details)\n        var mousePosition = {\n          x: event.pageX,\n          y: event.pageY\n        };\n\n        // Add listeners (we add them to the window to make sure we get the mouseup event even when the cursor it outside the window)\n        this._$window\n          .on('mousemove.splitbox', resizeMove.bind(this))\n          .on('mouseup.splitbox', resizeEnd.bind(this));\n        // Ensure the correct cursor is always shown while moving\n        this._$body.addClass(this.splitHorizontal ? 'col-resize' : 'row-resize');\n        $('iframe').addClass('dragging-in-progress');\n\n        // Get initial area and splitter bounds\n        var splitAreaPosition = this._$splitArea.offset();\n        var splitAreaSize = graphics.size(this._$splitArea, true);\n        var splitterPosition = this._$splitter.offset();\n        var splitterSize = graphics.size(this._$splitter, true);\n\n        // Create temporary splitter\n        var $tempSplitter = this._$splitArea.appendDiv('temp-splitter')\n          .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');\n        if (this.splitHorizontal) { // \"|\"\n          $tempSplitter.cssLeft(splitterPosition.left - splitAreaPosition.left);\n        } else { // \"--\"\n          $tempSplitter.cssTop(splitterPosition.top - splitAreaPosition.top);\n        }\n        this._$splitter.addClass('dragging');\n      }\n\n      var newSplitterPosition = this.splitterPosition;\n      var SNAP_SIZE = 10;\n\n      function resizeMove(event) {\n        if (event.pageX === mousePosition.x && event.pageY === mousePosition.y) {\n          // Chrome bug: https://code.google.com/p/chromium/issues/detail?id=161464\n          // When holding the mouse, but not moving it, a 'mousemove' event is fired every second nevertheless.\n          return;\n        }\n        mousePosition = {\n          x: event.pageX,\n          y: event.pageY\n        };\n\n        if (this.splitHorizontal) { // \"|\"\n          // Calculate target splitter position (in area)\n          var targetSplitterPositionLeft = event.pageX - splitAreaPosition.left;\n\n          // De-normalize minimum splitter position to allowed splitter range in pixel [minSplitterPositionLeft, maxSplitterPositionLeft]\n          var minSplitterPositionLeft;\n          var maxSplitterPositionLeft;\n\n          // Splitter width plus margin on right side, if temporary splitter position is x, the splitter div position is x-splitterOffset\n          var splitterOffset = Math.floor((splitterSize.width + HtmlEnvironment.get().fieldMandatoryIndicatorWidth) / 2);\n\n          if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST) {\n            minSplitterPositionLeft = scout.nvl(this.minSplitterPosition, 0);\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin (=total splitter size minus offset)\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset;\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            minSplitterPositionLeft = (splitAreaSize.width - splitterSize.width) * scout.nvl(this.minSplitterPosition, 0);\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin (=total splitter size minus offset)\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset;\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n            minSplitterPositionLeft = 0;\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin, reserving space for minimum splitter size\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset - scout.nvl(this.minSplitterPosition, 0);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n            minSplitterPositionLeft = 0;\n            // allow to move the splitter to right side, leaving minimal space for splitter div without right margin, reserving space for minimum splitter size\n            maxSplitterPositionLeft = splitAreaSize.width - splitterSize.width + splitterOffset - Math.floor(scout.nvl(this.minSplitterPosition, 0) * (splitAreaSize.width - splitterSize.width));\n          }\n\n          // Snap to begin and end\n          var tempSplitterOffsetX = splitterOffset;\n\n          if (targetSplitterPositionLeft < (minSplitterPositionLeft + splitterOffset + SNAP_SIZE)) { // snap left if minimum position is reached (+ snap range)\n            targetSplitterPositionLeft = minSplitterPositionLeft; // set splitter directly to left minimal bound\n            tempSplitterOffsetX = 0; // setting splitter to left minimal bound, does not require an additional offset\n          } else if (targetSplitterPositionLeft > (maxSplitterPositionLeft - SNAP_SIZE)) {\n            targetSplitterPositionLeft = maxSplitterPositionLeft;\n          }\n\n          // Update temporary splitter\n          $tempSplitter.cssLeft(targetSplitterPositionLeft - tempSplitterOffsetX);\n\n          // Normalize target position (available splitter area is (splitAreaSize.width - splitterSize.width))\n          newSplitterPosition = (targetSplitterPositionLeft - tempSplitterOffsetX);\n          if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            newSplitterPosition = newSplitterPosition / (splitAreaSize.width - splitterSize.width);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n            newSplitterPosition = 1 - (newSplitterPosition / (splitAreaSize.width - splitterSize.width));\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n            newSplitterPosition = splitAreaSize.width - splitterSize.width - newSplitterPosition;\n          }\n        } else { // \"--\"\n          // Calculate target splitter position (in area)\n          var targetSplitterPositionTop = event.pageY - splitAreaPosition.top;\n\n          // Snap to begin and end\n          var tempSplitterOffsetY = Math.floor(splitterSize.height / 2);\n          if (targetSplitterPositionTop < SNAP_SIZE) {\n            targetSplitterPositionTop = 0;\n            tempSplitterOffsetY = 0;\n          } else if (splitAreaSize.height - targetSplitterPositionTop < SNAP_SIZE) {\n            targetSplitterPositionTop = splitAreaSize.height;\n            tempSplitterOffsetY = splitterSize.height;\n          }\n\n          // Update temporary splitter\n          $tempSplitter.cssTop(targetSplitterPositionTop - tempSplitterOffsetY);\n          // Normalize target position\n          newSplitterPosition = targetSplitterPositionTop - tempSplitterOffsetY;\n          if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) {\n            newSplitterPosition = newSplitterPosition / (splitAreaSize.height - splitterSize.height);\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) {\n            newSplitterPosition = 1 - (newSplitterPosition / (splitAreaSize.height - splitterSize.height));\n          } else if (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {\n            newSplitterPosition = splitAreaSize.height - newSplitterPosition - splitterSize.height;\n          }\n        }\n      }\n\n      function resizeEnd(event) {\n        if (event.which !== 1) {\n          return; // only handle left mouse button\n        }\n        // Remove listeners and reset cursor\n        this._$window\n          .off('mousemove.splitbox')\n          .off('mouseup.splitbox');\n        if ($tempSplitter) { // instead of check for this.splitterEnabled, if splitter is currently moving it must be finished correctly\n          this._$body.removeClass((this.splitHorizontal ? 'col-resize' : 'row-resize'));\n          $('iframe').removeClass('dragging-in-progress');\n\n          // Remove temporary splitter\n          $tempSplitter.remove();\n          this._$splitter.removeClass('dragging');\n\n          // Update split box\n          this.newSplitterPosition(newSplitterPosition, true);\n        }\n      }\n\n      return false;\n    }\n\n    function onInnerFieldPropertyChange(event) {\n      if (event.propertyName === 'visible') {\n        this._updateFieldVisibilityClasses();\n        // Mark layout as invalid\n        this.htmlSplitArea.invalidateLayoutTree(false);\n      }\n    }\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderSplitterPosition();\n    this._renderSplitterEnabled();\n    this._renderCollapsibleField(); // renders collapsibleField _and_ fieldCollapsed\n    this._renderCollapseHandle(); // renders collapseHandle _and_ toggleCollapseKeyStroke _and_ firstCollapseKeyStroke _and_ secondCollapseKeyStroke\n    this._renderFieldMinimized();\n  }\n\n  _remove() {\n    this._$splitArea = null;\n    this._$splitter = null;\n    super._remove();\n  }\n\n  _setSplitterPosition(splitterPosition) {\n    this._setProperty('splitterPosition', splitterPosition);\n    // If splitter position is explicitly set by an event, no recalculation is necessary\n    this._oldSplitterPositionType = null;\n  }\n\n  _renderSplitterPosition() {\n    this.newSplitterPosition(this.splitterPosition, false); // do not update (override) field minimized if new position is set by model\n  }\n\n  _setSplitterPositionType(splitterPositionType) {\n    if (this.rendered && !this._oldSplitterPositionType) {\n      this._oldSplitterPositionType = this.splitterPositionType;\n      // We need to recalculate the splitter position. Because this requires the proper\n      // size of the split box, this can only be done in _renderSplitterPositionType().\n    }\n    this._setProperty('splitterPositionType', splitterPositionType);\n  }\n\n  _renderSplitterPositionType() {\n    if (this._oldSplitterPositionType) {\n      // splitterPositionType changed while the split box was rendered --> convert splitterPosition\n      // to the target type such that the current position in screen does not change.\n      var splitAreaSize = this.htmlSplitArea.size(),\n        splitterPosition = this.splitterPosition,\n        splitterSize = graphics.size(this._$splitter, true),\n        minSplitterPosition = this.minSplitterPosition,\n        totalSize = 0;\n      if (this.splitHorizontal) { // \"|\"\n        totalSize = splitAreaSize.width - splitterSize.width;\n      } else { // \"--\"\n        totalSize = splitAreaSize.height - splitterSize.height;\n      }\n\n      // Convert value depending on the old and new type system\n      var oldIsRelative = this._isSplitterPositionTypeRelative(this._oldSplitterPositionType);\n      var newIsRelative = this._isSplitterPositionTypeRelative(this.splitterPositionType);\n      var oldIsAbsolute = !oldIsRelative;\n      var newIsAbsolute = !newIsRelative;\n      if (oldIsRelative && newIsAbsolute) {\n        // From relative to absolute\n        if ((this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) ||\n          (this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST)) {\n          splitterPosition = totalSize - (totalSize * splitterPosition); // changed from first to second field or from second to first field, invert splitter position\n        } else {\n          splitterPosition = totalSize * splitterPosition;\n        }\n        // convert minimum splitter position\n        if (minSplitterPosition) {\n          minSplitterPosition = totalSize * minSplitterPosition;\n        }\n      } else if (oldIsAbsolute && newIsRelative) {\n        // From absolute to relative\n        if ((this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND) ||\n          (this._oldSplitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND && this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST)) {\n          splitterPosition = (totalSize - splitterPosition) / totalSize; // changed from first to second field or from second to first field, invert splitter position\n        } else {\n          splitterPosition = splitterPosition / totalSize;\n        }\n\n        // convert minimum splitter position\n        if (minSplitterPosition) {\n          minSplitterPosition = minSplitterPosition / totalSize;\n        }\n      } else if (oldIsAbsolute && newIsAbsolute) {\n        splitterPosition = (totalSize - splitterPosition);\n        // do not convert minimum splitter position, unit did not change\n      } else { // oldIsRelative && newIsRelative\n        splitterPosition = 1 - splitterPosition;\n        // do not convert minimum splitter position, unit did not change\n      }\n      // set new minimum splitter position\n      this.setMinSplitterPosition(minSplitterPosition);\n\n      // Set as new splitter position\n      this._oldSplitterPositionType = null;\n      this.newSplitterPosition(splitterPosition, true);\n    }\n  }\n\n  _isSplitterPositionTypeRelative(positionType) {\n    return (positionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) || (positionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_SECOND);\n  }\n\n  _renderSplitterEnabled() {\n    if (this._$splitter) {\n      this._$splitter.setEnabled(this.splitterEnabled);\n    }\n  }\n\n  setFieldCollapsed(collapsed) {\n    this.setProperty('fieldCollapsed', collapsed);\n    this._updateCollapseHandleButtons();\n  }\n\n  _renderFieldCollapsed() {\n    this._renderCollapsibleField();\n  }\n\n  setCollapsibleField(field) {\n    this.setProperty('collapsibleField', field);\n    this._updateCollapseHandle();\n  }\n\n  _updateCollapseHandle() {\n    // always unregister key stroke first (although it may have been added by _setToggleCollapseKeyStroke before)\n    if (this.toggleCollapseKeyStroke) {\n      this.unregisterKeyStrokes(this.toggleCollapseKeyStroke);\n    }\n    if (this.firstCollapseKeyStroke) {\n      this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n    }\n    if (this.secondCollapseKeyStroke) {\n      this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n    }\n\n    if (this.collapsibleField) {\n      var horizontalAlignment = CollapseHandle.HorizontalAlignment.LEFT;\n      if (this.collapsibleField !== this.firstField) {\n        horizontalAlignment = CollapseHandle.HorizontalAlignment.RIGHT;\n      }\n\n      if (!this._collapseHandle) {\n        // create new collapse handle\n        this._collapseHandle = scout.create('CollapseHandle', {\n          parent: this,\n          horizontalAlignment: horizontalAlignment\n        });\n        this._collapseHandle.on('action', this.collapseHandleButtonPressed.bind(this));\n        if (this.toggleCollapseKeyStroke) {\n          this.registerKeyStrokes(this.toggleCollapseKeyStroke);\n        }\n        if (this.firstCollapseKeyStroke) {\n          this.registerKeyStrokes(this.firstCollapseKeyStroke);\n        }\n        if (this.secondCollapseKeyStroke) {\n          this.registerKeyStrokes(this.secondCollapseKeyStroke);\n        }\n        if (this.rendered) {\n          this._renderCollapseHandle();\n        }\n      } else {\n        // update existing collapse handle\n        this._collapseHandle.setHorizontalAlignment(horizontalAlignment);\n      }\n\n      this._updateCollapseHandleButtons();\n    } else {\n      if (this._collapseHandle) {\n        this._collapseHandle.destroy();\n        this._collapseHandle = null;\n      }\n    }\n  }\n\n  _updateCollapseHandleButtons() {\n    if (!this._collapseHandle) {\n      return;\n    }\n    var leftVisible, rightVisible,\n      collapsed = this.fieldCollapsed,\n      minimized = this.fieldMinimized,\n      minimizable = this._isMinimizable(),\n      positionTypeFirstField = ((this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) || (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST)),\n      positionNotAccordingCollapsibleField = (positionTypeFirstField && this.collapsibleField === this.secondField) || (!positionTypeFirstField && this.collapsibleField === this.firstField);\n\n    if (positionTypeFirstField) {\n      if (positionNotAccordingCollapsibleField) {\n        leftVisible = (!minimized && minimizable) || collapsed; // left = decrease collapsible field size. Decrease field in this order [minimized <- default <- collapsed]\n        rightVisible = !collapsed; // right = increase collapsible field size. Increase field in this order [minimized -> default -> collapsed]\n      } else {\n        leftVisible = !collapsed; // left = increase collapsible field size. Increase field in this order [default <- minimized <- collapsed]\n        rightVisible = collapsed || (minimized && minimizable); // right = decrease collapsible field size. Decrease field in this order [default -> minimized -> collapsed]\n      }\n    } else {\n      if (positionNotAccordingCollapsibleField) {\n        leftVisible = !collapsed; // left = decrease collapsible field size. Decrease field in this order [collapsed <- default <- minimized]\n        rightVisible = (!minimized && minimizable) || collapsed; // right = increase collapsible field size. Increase field in this order [collapsed -> default -> minimized]\n      } else {\n        leftVisible = collapsed || (minimized && minimizable); // left = decrease collapsible field size. Decrease field in this order [collapsed <- minimized <- default]\n        rightVisible = !collapsed; // right = increase collapsible field size. Increase field in this order [collapsed -> minimized -> default]\n      }\n    }\n\n    this._collapseHandle.setLeftVisible(leftVisible);\n    this._collapseHandle.setRightVisible(rightVisible);\n\n    // update allowed keystrokes\n    if (this.firstCollapseKeyStroke) {\n      if (leftVisible) {\n        this.registerKeyStrokes(this.firstCollapseKeyStroke);\n      } else {\n        this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n      }\n    }\n    if (this.secondCollapseKeyStroke) {\n      if (rightVisible) {\n        this.registerKeyStrokes(this.secondCollapseKeyStroke);\n      } else {\n        this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n      }\n    }\n  }\n\n  getEffectiveSplitterPosition() {\n    if (this._isMinimizable() && this.fieldMinimized) {\n      return this.minSplitterPosition;\n    }\n    return this.splitterPosition;\n  }\n\n  setMinSplitterPosition(minSplitterPosition) {\n    this.setProperty('minSplitterPosition', minSplitterPosition);\n    this._updateCollapseHandleButtons();\n  }\n\n  _renderMinSplitterPosition() {\n    // minimum splitter position is considered automatically when layout is updated\n    if (this.rendered) { // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n\n  setFieldMinimized(minimized) {\n    this.setProperty('fieldMinimized', minimized);\n    this._updateCollapseHandleButtons();\n  }\n\n  _renderFieldMinimized() {\n    this.$container.removeClass('first-field-minimized second-field-minimized');\n    if (this.firstField) {\n      this.firstField.$container.removeClass('minimized');\n    }\n    if (this.secondField) {\n      this.secondField.$container.removeClass('minimized');\n    }\n    if (this.collapsibleField && this.fieldMinimized) {\n      this.collapsibleField.$container.addClass('minimized');\n      this.$container.toggleClass('first-field-minimized', this.firstField === this.collapsibleField);\n      this.$container.toggleClass('second-field-minimized', this.secondField === this.collapsibleField);\n    }\n\n    // field minimized state is considered automatically when layout is updated\n    if (this.rendered) { // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n\n  setMinimizeEnabled(enabled) {\n    this.setProperty('minimizeEnabled', enabled);\n    if (this._isMinimizable() && this._isSplitterPositionInMinimalRange(this.splitterPosition)) {\n      this.setFieldMinimized(true);\n    }\n\n    this._updateCollapseHandleButtons();\n  }\n\n  _renderMinimizeEnabled() {\n    // minimize enabled is considered automatically when layout is updated\n    if (this.rendered) { // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n\n  _isMinimizable() {\n    return !!this.minSplitterPosition && this.minimizeEnabled;\n  }\n\n  _renderCollapsibleField() {\n    this.$container.removeClass('first-field-collapsed second-field-collapsed');\n    if (this.firstField) {\n      this.firstField.$container.removeClass('collapsed');\n    }\n    if (this.secondField) {\n      this.secondField.$container.removeClass('collapsed');\n    }\n    if (this.collapsibleField && this.fieldCollapsed) {\n      this.collapsibleField.$container.addClass('collapsed');\n      this.$container.toggleClass('first-field-collapsed', this.firstField === this.collapsibleField);\n      this.$container.toggleClass('second-field-collapsed', this.secondField === this.collapsibleField);\n    }\n    if (this.rendered) { // don't invalidate layout on initial rendering\n      this.htmlSplitArea.invalidateLayoutTree(false);\n    }\n  }\n\n  _setToggleCollapseKeyStroke(keyStroke) {\n    if (keyStroke) {\n      if (this.toggleCollapseKeyStroke instanceof KeyStroke) {\n        this.unregisterKeyStrokes(this.collapseKeyStroke);\n      }\n      this.toggleCollapseKeyStroke = new SplitBoxCollapseKeyStroke(this, keyStroke);\n      if (this._collapseHandle) {\n        this.registerKeyStrokes(this.toggleCollapseKeyStroke);\n      }\n    }\n  }\n\n  _setFirstCollapseKeyStroke(keyStroke) {\n    if (keyStroke) {\n      if (this.firstCollapseKeyStroke instanceof KeyStroke) {\n        this.unregisterKeyStrokes(this.firstCollapseKeyStroke);\n      }\n      this.firstCollapseKeyStroke = new SplitBoxFirstCollapseKeyStroke(this, keyStroke);\n      if (this._collapseHandle) {\n        this.registerKeyStrokes(this.firstCollapseKeyStroke);\n      }\n    }\n  }\n\n  _setSecondCollapseKeyStroke(keyStroke) {\n    if (keyStroke) {\n      if (this.secondCollapseKeyStroke instanceof KeyStroke) {\n        this.unregisterKeyStrokes(this.secondCollapseKeyStroke);\n      }\n      this.secondCollapseKeyStroke = new SplitBoxSecondCollapseKeyStroke(this, keyStroke);\n      if (this._collapseHandle) {\n        this.registerKeyStrokes(this.secondCollapseKeyStroke);\n      }\n    }\n  }\n\n  _renderCollapseHandle() {\n    if (this._collapseHandle) {\n      this._collapseHandle.render();\n    }\n  }\n\n  newSplitterPosition(newSplitterPosition, updateFieldMinimizedState) {\n    if (this._isSplitterPositionTypeRelative(this.splitterPositionType)) {\n      // Ensure range 0..1\n      newSplitterPosition = Math.max(0, Math.min(1, newSplitterPosition));\n    } else {\n      // Ensure not negative\n      newSplitterPosition = Math.max(0, newSplitterPosition);\n    }\n\n    // Ensure splitter within allowed range, toggle field minimized state if new splitter position is within minimal range\n    if (this._isMinimizable() && this._isSplitterPositionInMinimalRange(newSplitterPosition)) {\n      this.setFieldMinimized(true);\n      return;\n    }\n\n    // Set new value (send to server if changed\n    var positionChanged = (this.splitterPosition !== newSplitterPosition);\n    this.splitterPosition = newSplitterPosition;\n\n    if (positionChanged) {\n      this.trigger('positionChange', {\n        position: newSplitterPosition\n      });\n\n      if (updateFieldMinimizedState) {\n        this._updateFieldMinimized();\n      }\n    }\n\n    this._updateCollapseHandleButtons();\n\n    // Mark layout as invalid\n    this.htmlSplitArea.invalidateLayoutTree(false);\n  }\n\n  _updateFieldMinimized() {\n    if (this._isMinimizable()) {\n      this.setFieldMinimized(this._isSplitterPositionInMinimalRange(this.splitterPosition));\n    } else {\n      this.setFieldMinimized(false);\n    }\n  }\n\n  _isSplitterPositionInMinimalRange(newSplitterPosition) {\n    if (!this._isMinimizable()) {\n      return false;\n    }\n    return newSplitterPosition <= this.minSplitterPosition;\n  }\n\n  toggleFieldCollapsed() {\n    this.setFieldCollapsed(!this.fieldCollapsed);\n  }\n\n  collapseHandleButtonPressed(event) {\n    var collapsed = this.fieldCollapsed,\n      minimized = this.fieldMinimized,\n      minimizable = this._isMinimizable(),\n      positionTypeFirstField = ((this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_RELATIVE_FIRST) || (this.splitterPositionType === SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST)),\n      increaseField = (!!event.left && !positionTypeFirstField) || (!!event.right && positionTypeFirstField);\n\n    if ((positionTypeFirstField && this.collapsibleField === this.secondField) || (!positionTypeFirstField && this.collapsibleField === this.firstField)) {\n      // Splitter is not positioned according (absolute or relative) to collapsible field\n      // - Mode toggles to increase collapsible field size: field collapsed --> field default --> field minimized\n      // - Mode toggles to decrease collapsible field size: field collapsed <-- field default <-- field minimized\n      if (increaseField) {\n        if (collapsed) {\n          // not possible, button is not visible (field is collapsed and cannot further increase its size)\n        } else if (minimized && minimizable) {\n          this.setFieldMinimized(false);\n        } else {\n          this.setFieldCollapsed(true);\n        }\n      } else {\n        if (collapsed) {\n          this.setFieldCollapsed(false);\n        } else if (minimized) {\n          // not possible, button is not visible (field is minimized and cannot further decrease its size)\n        } else if (minimizable) {\n          this.setFieldMinimized(true);\n        }\n      }\n    } else {\n      // Splitter is positioned according (absolute or relative) to collapsible field\n      // - Mode toggles to increase collapsible field size: field collapsed --> field minimized --> field default\n      // - Mode toggles to decrease collapsible field size: field collapsed <-- field minimized <-- field default\n      if (increaseField) {\n        if (collapsed) {\n          this.setFieldCollapsed(false);\n        } else if (minimized) {\n          this.setFieldMinimized(false);\n        } else {\n          // not possible, button is not visible (field has default size and cannot further increase its size)\n        }\n      } else {\n        if (collapsed) {\n          // not possible, button is not visible (field is collapsed and cannot further decrease its size)\n        } else if (minimized || !minimizable) {\n          this.setFieldCollapsed(true);\n        } else {\n          this.setFieldMinimized(true);\n        }\n      }\n    }\n  }\n\n  /**\n   * @override CompositeField.js\n   */\n  getFields() {\n    var fields = [];\n    if (this.firstField) {\n      fields.push(this.firstField);\n    }\n    if (this.secondField) {\n      fields.push(this.secondField);\n    }\n    return fields;\n  }\n\n  _updateFieldVisibilityClasses() {\n    if (!this.rendered && !this.rendering) {\n      return;\n    }\n    var hasFirstField = (this.firstField && this.firstField.isVisible());\n    var hasSecondField = (this.secondField && this.secondField.isVisible());\n    var hasTwoFields = hasFirstField && hasSecondField;\n    var hasOneField = !hasTwoFields && (hasFirstField || hasSecondField);\n\n    // Mark container if only one field is visible (i.e. there is no splitter)\n    this.$container.toggleClass('single-field', hasOneField);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}