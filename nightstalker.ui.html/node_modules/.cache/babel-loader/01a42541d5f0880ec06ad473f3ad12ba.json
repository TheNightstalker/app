{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, HorizontalGrid, PlaceholderTile } from '../index';\nimport $ from 'jquery';\n\nvar TileGridSelectionHandler = /*#__PURE__*/function () {\n  function TileGridSelectionHandler(tileGrid) {\n    _classCallCheck(this, TileGridSelectionHandler);\n\n    this.tileGrid = tileGrid;\n  }\n\n  _createClass(TileGridSelectionHandler, [{\n    key: \"selectTileOnMouseDown\",\n    value: function selectTileOnMouseDown(event) {\n      if (!this.isSelectable()) {\n        return;\n      }\n\n      var $tile = $(event.currentTarget);\n      var tile = $tile.data('widget');\n\n      if (tile instanceof PlaceholderTile) {\n        return;\n      }\n\n      if (tile.selected && event.which === 3) {\n        // Do not toggle if context menus should be shown and tile already is selected\n        return;\n      } // Clicking a tile selects it, CTRL-click toggles the selection\n\n\n      var selected = true;\n\n      if (event.ctrlKey) {\n        selected = !tile.selected;\n      } // If multiSelect is enabled, CTRL-Click on a tile adds or removes that tile to or from the selection\n\n\n      if (event.ctrlKey && this.isMultiSelect()) {\n        if (selected) {\n          this.addTilesToSelection(tile);\n\n          this._checkAndSetFocusedTile(event, tile);\n        } else {\n          this.deselectTile(tile);\n\n          this._checkAndSetFocusedTile(event, null);\n        }\n\n        return;\n      } // Shift-Click adds or removes the tiles between the last focused tile and the clicked tile to or from the selection\n\n\n      if (event.shiftKey && this.isMultiSelect()) {\n        if (!this.isHorizontalGridActive()) {\n          return;\n        }\n\n        var tiles = this.getVisibleTiles();\n        var focusedTile = this.getFocusedTile();\n\n        if (!focusedTile) {\n          focusedTile = tiles[0];\n        }\n\n        var result = this.computeSelectionBetween(tiles.indexOf(focusedTile), tiles.indexOf(tile), true);\n\n        if (result) {\n          this.selectTiles(result.selectedTiles);\n\n          this._checkAndSetFocusedTile(event, result.focusedTile);\n        }\n\n        return;\n      } // If multi selection is disabled or no CTRL key is pressed, only the clicked tile may be selected\n\n\n      if (selected) {\n        this.selectTile(tile);\n\n        this._checkAndSetFocusedTile(event, tile);\n      } else {\n        this.deselectAllTiles();\n\n        this._checkAndSetFocusedTile(event, null);\n      }\n    }\n  }, {\n    key: \"getFilteredTiles\",\n    value: function getFilteredTiles() {\n      return this.tileGrid.filteredTiles;\n    }\n  }, {\n    key: \"getFilteredTileCount\",\n    value: function getFilteredTileCount() {\n      return this.tileGrid.filteredTiles.length;\n    }\n  }, {\n    key: \"getVisibleTiles\",\n    value: function getVisibleTiles() {\n      return this.tileGrid.filteredTiles;\n    }\n  }, {\n    key: \"getVisibleTileCount\",\n    value: function getVisibleTileCount() {\n      return this.tileGrid.filteredTiles.length;\n    }\n  }, {\n    key: \"getGridColumnCount\",\n    value: function getGridColumnCount() {\n      return this.tileGrid.gridColumnCount;\n    }\n  }, {\n    key: \"getVisibleGridRowCount\",\n    value: function getVisibleGridRowCount() {\n      return this.tileGrid.logicalGrid.gridRows;\n    }\n  }, {\n    key: \"getVisibleGridX\",\n    value: function getVisibleGridX(tile) {\n      return tile.gridData.x;\n    }\n  }, {\n    key: \"getVisibleGridY\",\n    value: function getVisibleGridY(tile) {\n      return tile.gridData.y;\n    }\n  }, {\n    key: \"getSelectedTiles\",\n    value: function getSelectedTiles(event) {\n      return this.tileGrid.selectedTiles;\n    }\n  }, {\n    key: \"isSelectable\",\n    value: function isSelectable() {\n      return this.tileGrid.selectable;\n    }\n  }, {\n    key: \"isMultiSelect\",\n    value: function isMultiSelect() {\n      return this.tileGrid.multiSelect;\n    }\n  }, {\n    key: \"addTilesToSelection\",\n    value: function addTilesToSelection(tiles) {\n      this.tileGrid.addTilesToSelection(tiles);\n    }\n  }, {\n    key: \"selectTile\",\n    value: function selectTile(tile) {\n      this.tileGrid.selectTile(tile);\n    }\n  }, {\n    key: \"selectTiles\",\n    value: function selectTiles(tiles) {\n      this.tileGrid.selectTiles(tiles);\n    }\n  }, {\n    key: \"deselectTile\",\n    value: function deselectTile(tile) {\n      this.tileGrid.deselectTile(tile);\n    }\n  }, {\n    key: \"deselectTiles\",\n    value: function deselectTiles(tiles) {\n      this.tileGrid.deselectTiles(tiles);\n    }\n  }, {\n    key: \"deselectAllTiles\",\n    value: function deselectAllTiles() {\n      this.tileGrid.deselectAllTiles();\n    }\n  }, {\n    key: \"toggleSelection\",\n    value: function toggleSelection() {\n      this.tileGrid.toggleSelection();\n    }\n  }, {\n    key: \"getFocusedTile\",\n    value: function getFocusedTile() {\n      return this.tileGrid.focusedTile;\n    }\n    /**\n     * Only sets the focus if event does not prevent the default and the tile does not have the class 'unfocusable'.\n     */\n\n  }, {\n    key: \"_checkAndSetFocusedTile\",\n    value: function _checkAndSetFocusedTile(event, tile) {\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n\n      if (tile && tile.rendered && tile.$container.hasClass('unfocusable')) {\n        return;\n      }\n\n      this.setFocusedTile(tile);\n    }\n  }, {\n    key: \"setFocusedTile\",\n    value: function setFocusedTile(tile) {\n      this.tileGrid.setFocusedTile(tile);\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(tile) {\n      this.tileGrid.scrollTo(tile);\n    }\n  }, {\n    key: \"scrollToTop\",\n    value: function scrollToTop() {\n      this.tileGrid.scrollToTop();\n    }\n  }, {\n    key: \"scrollToBottom\",\n    value: function scrollToBottom() {\n      this.tileGrid.scrollToBottom();\n    }\n  }, {\n    key: \"findVisibleTileIndexAt\",\n    value: function findVisibleTileIndexAt(x, y, startIndex, reverse) {\n      return this.tileGrid.findTileIndexAt(x, y, startIndex, reverse);\n    }\n  }, {\n    key: \"getTileGridByRow\",\n    value: function getTileGridByRow(rowIndex) {\n      if (rowIndex < 0 || rowIndex >= this.getVisibleGridRowCount()) {\n        return null;\n      }\n\n      return this.tileGrid;\n    }\n  }, {\n    key: \"isHorizontalGridActive\",\n    value: function isHorizontalGridActive() {\n      return this.tileGrid.logicalGrid instanceof HorizontalGrid;\n    }\n  }, {\n    key: \"computeSelectionX\",\n    value: function computeSelectionX(xDiff, extend) {\n      var tiles = this.getVisibleTiles();\n      var focusedTile = null;\n      var focusedTileIndex = -1;\n\n      var result = this._computeFocusedTile(xDiff, extend);\n\n      if (result.selectedTiles !== null) {\n        // New selection could be determined already -> return it;\n        return result;\n      }\n\n      focusedTile = result.focusedTile;\n      focusedTileIndex = tiles.indexOf(focusedTile);\n      return this.computeSelectionBetween(focusedTileIndex, focusedTileIndex + xDiff, extend);\n    }\n  }, {\n    key: \"computeSelectionY\",\n    value: function computeSelectionY(yDiff, extend) {\n      var tiles = this.getVisibleTiles();\n      var focusedTile = null;\n      var focusedTileRow = -1;\n      var focusedTileColumn = -1;\n      var focusedTileIndex = -1;\n      var rowCount = this.getVisibleGridRowCount();\n\n      var result = this._computeFocusedTile(yDiff, extend);\n\n      if (result.selectedTiles !== null) {\n        // New selection could be determined already -> return it;\n        return result;\n      }\n\n      focusedTile = result.focusedTile;\n      focusedTileIndex = tiles.indexOf(focusedTile);\n      focusedTileRow = this.getVisibleGridY(focusedTile);\n      focusedTileColumn = this.getVisibleGridX(focusedTile);\n\n      if (yDiff > 0 && focusedTileRow === rowCount - 1 || yDiff < 0 && focusedTileRow === 0) {\n        // Do nothing if focused tile is in the last row (navigate down) or first row (navigate up)\n        return;\n      }\n\n      var newFocusedTileIndex = this.findVisibleTileIndexAt(focusedTileColumn, focusedTileRow + yDiff, focusedTileIndex, yDiff < 0);\n\n      if (newFocusedTileIndex < 0) {\n        var tileGrid = this.getTileGridByRow(focusedTileRow + yDiff);\n\n        if (!tileGrid) {\n          return;\n        }\n\n        newFocusedTileIndex = tiles.indexOf(arrays.last(tileGrid.filteredTiles));\n      }\n\n      return this.computeSelectionBetween(focusedTileIndex, newFocusedTileIndex, extend);\n    }\n  }, {\n    key: \"computeSelectionToFirst\",\n    value: function computeSelectionToFirst(extend) {\n      var tiles = this.getVisibleTiles();\n      var focusedTile = this.getFocusedTile();\n      var focusedTileIndex = -1;\n      var selectedTiles = this.getSelectedTiles();\n\n      if (selectedTiles.length === 0) {\n        // Select first tile if no tiles are selected\n        focusedTile = arrays.first(tiles);\n        return {\n          selectedTiles: [focusedTile],\n          focusedTile: focusedTile\n        };\n      } // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n\n\n      if (!focusedTile) {\n        focusedTile = arrays.last(selectedTiles);\n      }\n\n      focusedTileIndex = tiles.indexOf(focusedTile);\n      return this.computeSelectionBetween(focusedTileIndex, 0, extend);\n    }\n  }, {\n    key: \"computeSelectionToLast\",\n    value: function computeSelectionToLast(extend) {\n      var tiles = this.getVisibleTiles();\n      var focusedTile = this.getFocusedTile();\n      var focusedTileIndex = -1;\n      var selectedTiles = this.getSelectedTiles();\n\n      if (selectedTiles.length === 0) {\n        // Select last tile if no tiles are selected\n        focusedTile = arrays.last(tiles);\n        return {\n          selectedTiles: [focusedTile],\n          focusedTile: focusedTile\n        };\n      } // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n\n\n      if (!focusedTile) {\n        focusedTile = arrays.last(selectedTiles);\n      }\n\n      focusedTileIndex = tiles.indexOf(focusedTile);\n      return this.computeSelectionBetween(focusedTileIndex, tiles.length - 1, extend);\n    }\n  }, {\n    key: \"_computeFocusedTile\",\n    value: function _computeFocusedTile(diff, extend) {\n      var tiles = this.getVisibleTiles();\n      var selectedTiles = this.getSelectedTiles();\n      var focusedTile = this.getFocusedTile();\n\n      if (selectedTiles.length === 0) {\n        if (diff > 0) {\n          // Select first tile if no tiles are selected (navigate down/right)\n          focusedTile = arrays.first(tiles);\n        } else {\n          // Select first tile if no tiles are selected (navigate up/left)\n          focusedTile = arrays.last(tiles);\n        }\n\n        return {\n          focusedTile: focusedTile,\n          selectedTiles: [focusedTile]\n        };\n      } // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n\n\n      if (!focusedTile) {\n        if (diff > 0) {\n          // Navigate down/right\n          focusedTile = arrays.last(selectedTiles);\n        } else {\n          // Navigate up/left\n          focusedTile = arrays.first(selectedTiles);\n        }\n      }\n\n      return {\n        focusedTile: focusedTile,\n        selectedTiles: null\n      };\n    }\n  }, {\n    key: \"computeSelectionBetween\",\n    value: function computeSelectionBetween(focusedTileIndex, newFocusedTileIndex, extend) {\n      var tiles = this.getVisibleTiles();\n      var selectedTiles = this.getSelectedTiles();\n      var newFocusedTile = tiles[newFocusedTileIndex];\n\n      if (focusedTileIndex < 0 || focusedTileIndex > tiles.length - 1 || newFocusedTileIndex < 0 || newFocusedTileIndex > tiles.length - 1 || focusedTileIndex === newFocusedTileIndex) {\n        // Do nothing if indices are out of bounds or equal\n        return;\n      }\n\n      if (!extend) {\n        // Select only the tile at the newFocusedTileindex\n        return {\n          selectedTiles: [newFocusedTile],\n          focusedTile: newFocusedTile\n        };\n      } // Adjust existing selection\n\n\n      var newSelectedTiles = [];\n\n      if (!newFocusedTile.selected) {\n        // Add all tiles between focused tile and newly focused tile to selection\n        if (newFocusedTileIndex > focusedTileIndex) {\n          newSelectedTiles = arrays.union(selectedTiles, tiles.slice(focusedTileIndex, newFocusedTileIndex + 1));\n          newFocusedTile = this._findLastSelectedTileAfter(tiles, newFocusedTileIndex);\n        } else {\n          newSelectedTiles = arrays.union(tiles.slice(newFocusedTileIndex, focusedTileIndex + 1), selectedTiles);\n          newFocusedTile = this._findLastSelectedTileBefore(tiles, newFocusedTileIndex);\n        }\n      } else {\n        // TOOO CGU what is Bug #172929 about? Do we need to consider this as well?\n        if (newFocusedTileIndex > focusedTileIndex) {\n          // Remove all tiles between focused tile and newly focused tile from selection if newly focused tile already is selected\n          newSelectedTiles = selectedTiles.slice();\n          arrays.removeAll(newSelectedTiles, tiles.slice(focusedTileIndex, newFocusedTileIndex));\n        } else {\n          newSelectedTiles = selectedTiles.slice();\n          arrays.removeAll(newSelectedTiles, tiles.slice(newFocusedTileIndex + 1, focusedTileIndex + 1));\n        }\n      }\n\n      return {\n        selectedTiles: newSelectedTiles,\n        focusedTile: newFocusedTile\n      };\n    }\n  }, {\n    key: \"executeSelection\",\n    value: function executeSelection(instruction) {\n      if (!instruction) {\n        return;\n      }\n\n      if (instruction.selectedTiles.length > 0) {\n        this.selectTiles(instruction.selectedTiles);\n        this.scrollTo(instruction.focusedTile); // Scroll to the very top or very bottom if newly focused tile is on top or on bottom\n        // Especially important for tile accordion because scrolling to top should reveal the group header as well\n\n        var focusedTileRow = this.getVisibleGridY(instruction.focusedTile);\n        var rowCount = this.getVisibleGridRowCount();\n\n        if (focusedTileRow === 0) {\n          this.scrollToTop();\n        } else if (focusedTileRow === rowCount - 1) {\n          this.scrollToBottom();\n        }\n      }\n\n      this.setFocusedTile(instruction.focusedTile);\n    }\n    /**\n     * Searches for the last selected tile in the current selection block, starting from tileIndex. Expects tile at tileIndex to be selected.\n     */\n\n  }, {\n    key: \"_findLastSelectedTileBefore\",\n    value: function _findLastSelectedTileBefore(tiles, tileIndex) {\n      if (tileIndex === 0) {\n        return tiles[tileIndex];\n      }\n\n      var tile = arrays.findFromReverse(tiles, tileIndex, function (tile, i) {\n        var previousTile = tiles[i - 1];\n\n        if (!previousTile) {\n          return false;\n        }\n\n        return !previousTile.selected;\n      }); // when no tile has been found, use first tile in tileGrid\n\n      if (!tile) {\n        tile = tiles[0];\n      }\n\n      return tile;\n    }\n    /**\n     * Searches for the last selected tile in the current selection block, starting from tileIndex. Expects tile at tileIndex to be selected.\n     */\n\n  }, {\n    key: \"_findLastSelectedTileAfter\",\n    value: function _findLastSelectedTileAfter(tiles, tileIndex) {\n      if (tileIndex === tiles.length - 1) {\n        return tiles[tileIndex];\n      }\n\n      var tile = arrays.findFrom(tiles, tileIndex, function (tile, i) {\n        var nextTile = tiles[i + 1];\n\n        if (!nextTile) {\n          return false;\n        }\n\n        return !nextTile.selected;\n      }); // when no tile has been found, use last tile in tileGrid\n\n      if (!tile) {\n        tile = tiles[tiles.length - 1];\n      }\n\n      return tile;\n    }\n  }]);\n\n  return TileGridSelectionHandler;\n}();\n\nexport { TileGridSelectionHandler as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/tile/TileGridSelectionHandler.js"],"names":["arrays","HorizontalGrid","PlaceholderTile","$","TileGridSelectionHandler","tileGrid","event","isSelectable","$tile","currentTarget","tile","data","selected","which","ctrlKey","isMultiSelect","addTilesToSelection","_checkAndSetFocusedTile","deselectTile","shiftKey","isHorizontalGridActive","tiles","getVisibleTiles","focusedTile","getFocusedTile","result","computeSelectionBetween","indexOf","selectTiles","selectedTiles","selectTile","deselectAllTiles","filteredTiles","length","gridColumnCount","logicalGrid","gridRows","gridData","x","y","selectable","multiSelect","deselectTiles","toggleSelection","isDefaultPrevented","rendered","$container","hasClass","setFocusedTile","scrollTo","scrollToTop","scrollToBottom","startIndex","reverse","findTileIndexAt","rowIndex","getVisibleGridRowCount","xDiff","extend","focusedTileIndex","_computeFocusedTile","yDiff","focusedTileRow","focusedTileColumn","rowCount","getVisibleGridY","getVisibleGridX","newFocusedTileIndex","findVisibleTileIndexAt","getTileGridByRow","last","getSelectedTiles","first","diff","newFocusedTile","newSelectedTiles","union","slice","_findLastSelectedTileAfter","_findLastSelectedTileBefore","removeAll","instruction","tileIndex","findFromReverse","i","previousTile","findFrom","nextTile"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, HorizontalGrid, PlaceholderTile} from '../index';\nimport $ from 'jquery';\n\nexport default class TileGridSelectionHandler {\n\n  constructor(tileGrid) {\n    this.tileGrid = tileGrid;\n  }\n\n  selectTileOnMouseDown(event) {\n    if (!this.isSelectable()) {\n      return;\n    }\n\n    var $tile = $(event.currentTarget);\n    var tile = $tile.data('widget');\n\n    if (tile instanceof PlaceholderTile) {\n      return;\n    }\n    if (tile.selected && event.which === 3) {\n      // Do not toggle if context menus should be shown and tile already is selected\n      return;\n    }\n\n    // Clicking a tile selects it, CTRL-click toggles the selection\n    var selected = true;\n    if (event.ctrlKey) {\n      selected = !tile.selected;\n    }\n\n    // If multiSelect is enabled, CTRL-Click on a tile adds or removes that tile to or from the selection\n    if (event.ctrlKey && this.isMultiSelect()) {\n      if (selected) {\n        this.addTilesToSelection(tile);\n        this._checkAndSetFocusedTile(event, tile);\n      } else {\n        this.deselectTile(tile);\n        this._checkAndSetFocusedTile(event, null);\n      }\n      return;\n    }\n\n    // Shift-Click adds or removes the tiles between the last focused tile and the clicked tile to or from the selection\n    if (event.shiftKey && this.isMultiSelect()) {\n      if (!this.isHorizontalGridActive()) {\n        return;\n      }\n      var tiles = this.getVisibleTiles();\n      var focusedTile = this.getFocusedTile();\n      if (!focusedTile) {\n        focusedTile = tiles[0];\n      }\n      var result = this.computeSelectionBetween(tiles.indexOf(focusedTile), tiles.indexOf(tile), true);\n      if (result) {\n        this.selectTiles(result.selectedTiles);\n        this._checkAndSetFocusedTile(event, result.focusedTile);\n      }\n      return;\n    }\n\n    // If multi selection is disabled or no CTRL key is pressed, only the clicked tile may be selected\n    if (selected) {\n      this.selectTile(tile);\n      this._checkAndSetFocusedTile(event, tile);\n    } else {\n      this.deselectAllTiles();\n      this._checkAndSetFocusedTile(event, null);\n    }\n  }\n\n  getFilteredTiles() {\n    return this.tileGrid.filteredTiles;\n  }\n\n  getFilteredTileCount() {\n    return this.tileGrid.filteredTiles.length;\n  }\n\n  getVisibleTiles() {\n    return this.tileGrid.filteredTiles;\n  }\n\n  getVisibleTileCount() {\n    return this.tileGrid.filteredTiles.length;\n  }\n\n  getGridColumnCount() {\n    return this.tileGrid.gridColumnCount;\n  }\n\n  getVisibleGridRowCount() {\n    return this.tileGrid.logicalGrid.gridRows;\n  }\n\n  getVisibleGridX(tile) {\n    return tile.gridData.x;\n  }\n\n  getVisibleGridY(tile) {\n    return tile.gridData.y;\n  }\n\n  getSelectedTiles(event) {\n    return this.tileGrid.selectedTiles;\n  }\n\n  isSelectable() {\n    return this.tileGrid.selectable;\n  }\n\n  isMultiSelect() {\n    return this.tileGrid.multiSelect;\n  }\n\n  addTilesToSelection(tiles) {\n    this.tileGrid.addTilesToSelection(tiles);\n  }\n\n  selectTile(tile) {\n    this.tileGrid.selectTile(tile);\n  }\n\n  selectTiles(tiles) {\n    this.tileGrid.selectTiles(tiles);\n  }\n\n  deselectTile(tile) {\n    this.tileGrid.deselectTile(tile);\n  }\n\n  deselectTiles(tiles) {\n    this.tileGrid.deselectTiles(tiles);\n  }\n\n  deselectAllTiles() {\n    this.tileGrid.deselectAllTiles();\n  }\n\n  toggleSelection() {\n    this.tileGrid.toggleSelection();\n  }\n\n  getFocusedTile() {\n    return this.tileGrid.focusedTile;\n  }\n\n  /**\n   * Only sets the focus if event does not prevent the default and the tile does not have the class 'unfocusable'.\n   */\n  _checkAndSetFocusedTile(event, tile) {\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    if (tile && tile.rendered && tile.$container.hasClass('unfocusable')) {\n      return;\n    }\n    this.setFocusedTile(tile);\n  }\n\n  setFocusedTile(tile) {\n    this.tileGrid.setFocusedTile(tile);\n  }\n\n  scrollTo(tile) {\n    this.tileGrid.scrollTo(tile);\n  }\n\n  scrollToTop() {\n    this.tileGrid.scrollToTop();\n  }\n\n  scrollToBottom() {\n    this.tileGrid.scrollToBottom();\n  }\n\n  findVisibleTileIndexAt(x, y, startIndex, reverse) {\n    return this.tileGrid.findTileIndexAt(x, y, startIndex, reverse);\n  }\n\n  getTileGridByRow(rowIndex) {\n    if (rowIndex < 0 || rowIndex >= this.getVisibleGridRowCount()) {\n      return null;\n    }\n    return this.tileGrid;\n  }\n\n  isHorizontalGridActive() {\n    return this.tileGrid.logicalGrid instanceof HorizontalGrid;\n  }\n\n  computeSelectionX(xDiff, extend) {\n    var tiles = this.getVisibleTiles();\n    var focusedTile = null;\n    var focusedTileIndex = -1;\n    var result = this._computeFocusedTile(xDiff, extend);\n    if (result.selectedTiles !== null) {\n      // New selection could be determined already -> return it;\n      return result;\n    }\n    focusedTile = result.focusedTile;\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    return this.computeSelectionBetween(focusedTileIndex, focusedTileIndex + xDiff, extend);\n  }\n\n  computeSelectionY(yDiff, extend) {\n    var tiles = this.getVisibleTiles();\n    var focusedTile = null;\n    var focusedTileRow = -1;\n    var focusedTileColumn = -1;\n    var focusedTileIndex = -1;\n    var rowCount = this.getVisibleGridRowCount();\n    var result = this._computeFocusedTile(yDiff, extend);\n    if (result.selectedTiles !== null) {\n      // New selection could be determined already -> return it;\n      return result;\n    }\n    focusedTile = result.focusedTile;\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    focusedTileRow = this.getVisibleGridY(focusedTile);\n    focusedTileColumn = this.getVisibleGridX(focusedTile);\n    if (yDiff > 0 && focusedTileRow === rowCount - 1 ||\n      yDiff < 0 && focusedTileRow === 0) {\n      // Do nothing if focused tile is in the last row (navigate down) or first row (navigate up)\n      return;\n    }\n\n    var newFocusedTileIndex = this.findVisibleTileIndexAt(focusedTileColumn, focusedTileRow + yDiff, focusedTileIndex, yDiff < 0);\n    if (newFocusedTileIndex < 0) {\n      var tileGrid = this.getTileGridByRow(focusedTileRow + yDiff);\n      if (!tileGrid) {\n        return;\n      }\n      newFocusedTileIndex = tiles.indexOf(arrays.last(tileGrid.filteredTiles));\n    }\n    return this.computeSelectionBetween(focusedTileIndex, newFocusedTileIndex, extend);\n  }\n\n  computeSelectionToFirst(extend) {\n    var tiles = this.getVisibleTiles();\n    var focusedTile = this.getFocusedTile();\n    var focusedTileIndex = -1;\n    var selectedTiles = this.getSelectedTiles();\n    if (selectedTiles.length === 0) {\n      // Select first tile if no tiles are selected\n      focusedTile = arrays.first(tiles);\n      return {\n        selectedTiles: [focusedTile],\n        focusedTile: focusedTile\n      };\n    }\n\n    // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n    if (!focusedTile) {\n      focusedTile = arrays.last(selectedTiles);\n    }\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    return this.computeSelectionBetween(focusedTileIndex, 0, extend);\n  }\n\n  computeSelectionToLast(extend) {\n    var tiles = this.getVisibleTiles();\n    var focusedTile = this.getFocusedTile();\n    var focusedTileIndex = -1;\n    var selectedTiles = this.getSelectedTiles();\n    if (selectedTiles.length === 0) {\n      // Select last tile if no tiles are selected\n      focusedTile = arrays.last(tiles);\n      return {\n        selectedTiles: [focusedTile],\n        focusedTile: focusedTile\n      };\n    }\n\n    // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n    if (!focusedTile) {\n      focusedTile = arrays.last(selectedTiles);\n    }\n    focusedTileIndex = tiles.indexOf(focusedTile);\n    return this.computeSelectionBetween(focusedTileIndex, tiles.length - 1, extend);\n  }\n\n  _computeFocusedTile(diff, extend) {\n    var tiles = this.getVisibleTiles();\n    var selectedTiles = this.getSelectedTiles();\n    var focusedTile = this.getFocusedTile();\n    if (selectedTiles.length === 0) {\n      if (diff > 0) {\n        // Select first tile if no tiles are selected (navigate down/right)\n        focusedTile = arrays.first(tiles);\n      } else {\n        // Select first tile if no tiles are selected (navigate up/left)\n        focusedTile = arrays.last(tiles);\n      }\n      return {\n        focusedTile: focusedTile,\n        selectedTiles: [focusedTile]\n      };\n    }\n\n    // Focused tile may be null if tile has been deleted or if the user has not made a selection before\n    if (!focusedTile) {\n      if (diff > 0) {\n        // Navigate down/right\n        focusedTile = arrays.last(selectedTiles);\n      } else {\n        // Navigate up/left\n        focusedTile = arrays.first(selectedTiles);\n      }\n    }\n    return {\n      focusedTile: focusedTile,\n      selectedTiles: null\n    };\n  }\n\n  computeSelectionBetween(focusedTileIndex, newFocusedTileIndex, extend) {\n    var tiles = this.getVisibleTiles();\n    var selectedTiles = this.getSelectedTiles();\n    var newFocusedTile = tiles[newFocusedTileIndex];\n\n    if (focusedTileIndex < 0 || focusedTileIndex > tiles.length - 1 ||\n      newFocusedTileIndex < 0 || newFocusedTileIndex > tiles.length - 1 ||\n      focusedTileIndex === newFocusedTileIndex) {\n      // Do nothing if indices are out of bounds or equal\n      return;\n    }\n\n    if (!extend) {\n      // Select only the tile at the newFocusedTileindex\n      return {\n        selectedTiles: [newFocusedTile],\n        focusedTile: newFocusedTile\n      };\n    }\n\n    // Adjust existing selection\n    var newSelectedTiles = [];\n    if (!newFocusedTile.selected) {\n      // Add all tiles between focused tile and newly focused tile to selection\n      if (newFocusedTileIndex > focusedTileIndex) {\n        newSelectedTiles = arrays.union(selectedTiles, tiles.slice(focusedTileIndex, newFocusedTileIndex + 1));\n        newFocusedTile = this._findLastSelectedTileAfter(tiles, newFocusedTileIndex);\n      } else {\n        newSelectedTiles = arrays.union(tiles.slice(newFocusedTileIndex, focusedTileIndex + 1), selectedTiles);\n        newFocusedTile = this._findLastSelectedTileBefore(tiles, newFocusedTileIndex);\n      }\n    } else {\n      // TOOO CGU what is Bug #172929 about? Do we need to consider this as well?\n      if (newFocusedTileIndex > focusedTileIndex) {\n        // Remove all tiles between focused tile and newly focused tile from selection if newly focused tile already is selected\n        newSelectedTiles = selectedTiles.slice();\n        arrays.removeAll(newSelectedTiles, tiles.slice(focusedTileIndex, newFocusedTileIndex));\n      } else {\n        newSelectedTiles = selectedTiles.slice();\n        arrays.removeAll(newSelectedTiles, tiles.slice(newFocusedTileIndex + 1, focusedTileIndex + 1));\n      }\n    }\n\n    return {\n      selectedTiles: newSelectedTiles,\n      focusedTile: newFocusedTile\n    };\n  }\n\n  executeSelection(instruction) {\n    if (!instruction) {\n      return;\n    }\n    if (instruction.selectedTiles.length > 0) {\n      this.selectTiles(instruction.selectedTiles);\n      this.scrollTo(instruction.focusedTile);\n\n      // Scroll to the very top or very bottom if newly focused tile is on top or on bottom\n      // Especially important for tile accordion because scrolling to top should reveal the group header as well\n      var focusedTileRow = this.getVisibleGridY(instruction.focusedTile);\n      var rowCount = this.getVisibleGridRowCount();\n      if (focusedTileRow === 0) {\n        this.scrollToTop();\n      } else if (focusedTileRow === rowCount - 1) {\n        this.scrollToBottom();\n      }\n    }\n    this.setFocusedTile(instruction.focusedTile);\n  }\n\n  /**\n   * Searches for the last selected tile in the current selection block, starting from tileIndex. Expects tile at tileIndex to be selected.\n   */\n  _findLastSelectedTileBefore(tiles, tileIndex) {\n    if (tileIndex === 0) {\n      return tiles[tileIndex];\n    }\n    var tile = arrays.findFromReverse(tiles, tileIndex, function(tile, i) {\n      var previousTile = tiles[i - 1];\n      if (!previousTile) {\n        return false;\n      }\n      return !previousTile.selected;\n    });\n    // when no tile has been found, use first tile in tileGrid\n    if (!tile) {\n      tile = tiles[0];\n    }\n    return tile;\n  }\n\n  /**\n   * Searches for the last selected tile in the current selection block, starting from tileIndex. Expects tile at tileIndex to be selected.\n   */\n  _findLastSelectedTileAfter(tiles, tileIndex) {\n    if (tileIndex === tiles.length - 1) {\n      return tiles[tileIndex];\n    }\n    var tile = arrays.findFrom(tiles, tileIndex, function(tile, i) {\n      var nextTile = tiles[i + 1];\n      if (!nextTile) {\n        return false;\n      }\n      return !nextTile.selected;\n    });\n    // when no tile has been found, use last tile in tileGrid\n    if (!tile) {\n      tile = tiles[tiles.length - 1];\n    }\n    return tile;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}