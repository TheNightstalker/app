{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { App, objects, Outline, scout, TreeAdapter } from '../../index';\n\nvar OutlineAdapter = /*#__PURE__*/function (_TreeAdapter) {\n  _inherits(OutlineAdapter, _TreeAdapter);\n\n  var _super = _createSuper(OutlineAdapter);\n\n  function OutlineAdapter() {\n    var _this;\n\n    _classCallCheck(this, OutlineAdapter);\n\n    _this = _super.call(this);\n    _this._nodeIdToRowMap = {};\n    _this._detailTableRowInitHandler = _this._onDetailTableRowInit.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * We must call onWidgetPageInit because this adapter cannot process the 'pageInit' event\n   * while the widget is initialized, since the listener is not attached until the widget\n   * is created completely.\n   */\n\n\n  _createClass(OutlineAdapter, [{\n    key: \"_postCreateWidget\",\n    value: function _postCreateWidget() {\n      var outline = this.widget;\n      outline.visitNodes(this._onWidgetPageInit.bind(this));\n    }\n  }, {\n    key: \"_onPageChanged\",\n    value: function _onPageChanged(event) {\n      var page = this.widget._nodeById(event.nodeId);\n\n      page.overviewIconId = event.overviewIconId;\n      page.detailFormVisible = event.detailFormVisible;\n      var detailForm = this.session.getOrCreateWidget(event.detailForm, this.widget);\n\n      if (detailForm !== page.detailForm) {\n        page.setDetailForm(detailForm);\n      }\n\n      page.navigateButtonsVisible = event.navigateButtonsVisible;\n      page.detailTableVisible = event.detailTableVisible;\n      var detailTable = this.session.getOrCreateWidget(event.detailTable, this.widget);\n\n      if (page.detailTable !== detailTable) {\n        if (page.detailTable) {\n          this._destroyDetailTable(page);\n        }\n\n        page.setDetailTable(detailTable);\n\n        if (page.detailTable) {\n          this._initDetailTable(page);\n        }\n      }\n\n      this.widget.pageChanged(page);\n    }\n  }, {\n    key: \"_onWidgetEvent\",\n    value: function _onWidgetEvent(event) {\n      if (event.type === 'pageInit') {\n        this._onWidgetPageInit(event.page);\n      } else {\n        _get(_getPrototypeOf(OutlineAdapter.prototype), \"_onWidgetEvent\", this).call(this, event);\n      }\n    }\n  }, {\n    key: \"onModelAction\",\n    value: function onModelAction(event) {\n      if (event.type === 'pageChanged') {\n        this._onPageChanged(event);\n      } else {\n        _get(_getPrototypeOf(OutlineAdapter.prototype), \"onModelAction\", this).call(this, event);\n      }\n    }\n  }, {\n    key: \"_onWidgetPageInit\",\n    value: function _onWidgetPageInit(page) {\n      if (page.detailTable) {\n        this._initDetailTable(page);\n      }\n\n      this._linkNodeWithRowLater(page);\n    }\n  }, {\n    key: \"_initDetailTable\",\n    value: function _initDetailTable(page) {\n      // link already existing rows now\n      page.detailTable.rows.forEach(this._linkNodeWithRow.bind(this)); // rows which are inserted later are linked by _onDetailTableRowInit\n\n      page.detailTable.on('rowInit', this._detailTableRowInitHandler);\n    }\n  }, {\n    key: \"_destroyDetailTable\",\n    value: function _destroyDetailTable(page) {\n      this._nodeIdToRowMap = {};\n      page.detailTable.rows.forEach(this._unlinkNodeWithRow.bind(this));\n      page.detailTable.off('rowInit', this._detailTableRowInitHandler);\n    }\n  }, {\n    key: \"_linkNodeWithRow\",\n    value: function _linkNodeWithRow(row) {\n      scout.assertParameter('row', row);\n      var node,\n          nodeId = row.nodeId;\n\n      if (nodeId === undefined) {\n        // nodeId is undefined if no node exists for that row (e.g. happens if the page containing the row is a leaf page)\n        return;\n      }\n\n      node = this.widget.nodesMap[nodeId];\n\n      if (node) {\n        node.linkWithRow(row);\n      } else {\n        // Prepare for linking later because node has not been inserted yet\n        // see: #_linkNodeWithRowLater\n        this._nodeIdToRowMap[nodeId] = row;\n      }\n    }\n  }, {\n    key: \"_unlinkNodeWithRow\",\n    value: function _unlinkNodeWithRow(row) {\n      var node = this.widget.nodesMap[row.nodeId];\n\n      if (node) {\n        node.unlinkWithRow(row);\n      }\n    }\n  }, {\n    key: \"_onDetailTableRowInit\",\n    value: function _onDetailTableRowInit(event) {\n      var node,\n          outline = this.widget,\n          nodeId = event.row.nodeId;\n\n      this._linkNodeWithRow(event.row);\n\n      node = this.widget.nodesMap[nodeId]; // If a row, which was already linked to a node, gets initialized again, re-apply the filter to make sure the node has the correct state\n\n      if (outline.rendered && node && outline._applyFiltersForNode(node)) {\n        if (node.isFilterAccepted()) {\n          outline._addToVisibleFlatList(node, false);\n        } else {\n          outline._removeFromFlatList(node, false);\n        }\n      }\n\n      if (this.widget.isSelectedNode(node) && !this.widget.detailContent) {\n        // Table row detail could not be created because the link from page to row was missing at the time the node got selected -> do it now\n        this.widget.updateDetailContent();\n      }\n    }\n    /**\n     * Link node with row, if it hasn't been linked yet.\n     */\n\n  }, {\n    key: \"_linkNodeWithRowLater\",\n    value: function _linkNodeWithRowLater(page) {\n      if (!page.parentNode || !page.parentNode.detailTable) {\n        return;\n      }\n\n      if (!this._nodeIdToRowMap.hasOwnProperty(page.id)) {\n        return;\n      }\n\n      var row = this._nodeIdToRowMap[page.id];\n      page.linkWithRow(row);\n      delete this._nodeIdToRowMap[page.id];\n    }\n    /**\n     * Static method to modify the prototype of Outline.\n     */\n\n  }], [{\n    key: \"modifyOutlinePrototype\",\n    value: function modifyOutlinePrototype() {\n      if (!App.get().remote) {\n        return;\n      }\n\n      objects.replacePrototypeFunction(Outline, '_computeDetailContent', OutlineAdapter._computeDetailContentRemote, true);\n      objects.replacePrototypeFunction(Outline, 'updateDetailMenus', OutlineAdapter.updateDetailMenusRemote, true);\n    }\n    /**\n     * Replacement for Outline#_computeDetailContent(). 'This' points to the outline.\n     */\n\n  }, {\n    key: \"_computeDetailContentRemote\",\n    value: function _computeDetailContentRemote() {\n      if (!this.modelAdapter) {\n        return this._computeDetailContentOrig();\n      }\n\n      var selectedPage = this.selectedNode();\n\n      if (!selectedPage) {\n        // Detail content is shown for the selected node only\n        return null;\n      } // if there is a detail form, use this\n\n\n      if (selectedPage.detailForm || selectedPage.detailFormResolved) {\n        // If there is a detail form -> return (and set flag to true to make updateDetailMenusRemote work)\n        selectedPage.detailFormResolved = true;\n        return this._computeDetailContentOrig();\n      } // It is not known yet whether there is a detail form -> wait for the requests to be processed before showing the table row detail\n\n\n      if (!this.session.areRequestsPending() && !this.session.areEventsQueued()) {\n        // There are no requests pending -> return (and set flag to true to make updateDetailMenusRemote work)\n        selectedPage.detailFormResolved = true;\n        return this._computeDetailContentOrig();\n      } // Wait for the requests to complete\n\n\n      this.session.listen().done(function (selectedPage) {\n        if (selectedPage.detailFormResolved) {\n          // No need to update detail content again if resolved is true\n          return;\n        } // Make sure the next time the page is selected it returns immediately and does not wait for requests to be completed\n\n\n        selectedPage.detailFormResolved = true;\n        this.updateDetailContent();\n      }.bind(this, selectedPage));\n    }\n    /**\n     * Replacement for Outline#updateDetailMenusRemote(). 'This' points to the outline.\n     */\n\n  }, {\n    key: \"updateDetailMenusRemote\",\n    value: function updateDetailMenusRemote() {\n      if (!this.modelAdapter) {\n        return this.updateDetailMenusOrig();\n      }\n\n      if (this.selectedNode() && this.selectedNode().detailFormResolved) {\n        return this.updateDetailMenusOrig();\n      }\n    }\n  }]);\n\n  return OutlineAdapter;\n}(TreeAdapter);\n\nexport { OutlineAdapter as default };\nApp.addListener('bootstrap', OutlineAdapter.modifyOutlinePrototype);","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/desktop/outline/OutlineAdapter.js"],"names":["App","objects","Outline","scout","TreeAdapter","OutlineAdapter","_nodeIdToRowMap","_detailTableRowInitHandler","_onDetailTableRowInit","bind","outline","widget","visitNodes","_onWidgetPageInit","event","page","_nodeById","nodeId","overviewIconId","detailFormVisible","detailForm","session","getOrCreateWidget","setDetailForm","navigateButtonsVisible","detailTableVisible","detailTable","_destroyDetailTable","setDetailTable","_initDetailTable","pageChanged","type","_onPageChanged","_linkNodeWithRowLater","rows","forEach","_linkNodeWithRow","on","_unlinkNodeWithRow","off","row","assertParameter","node","undefined","nodesMap","linkWithRow","unlinkWithRow","rendered","_applyFiltersForNode","isFilterAccepted","_addToVisibleFlatList","_removeFromFlatList","isSelectedNode","detailContent","updateDetailContent","parentNode","hasOwnProperty","id","get","remote","replacePrototypeFunction","_computeDetailContentRemote","updateDetailMenusRemote","modelAdapter","_computeDetailContentOrig","selectedPage","selectedNode","detailFormResolved","areRequestsPending","areEventsQueued","listen","done","updateDetailMenusOrig","addListener","modifyOutlinePrototype"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {App, objects, Outline, scout, TreeAdapter} from '../../index';\n\nexport default class OutlineAdapter extends TreeAdapter {\n\n  constructor() {\n    super();\n    this._nodeIdToRowMap = {};\n    this._detailTableRowInitHandler = this._onDetailTableRowInit.bind(this);\n  }\n\n  /**\n   * We must call onWidgetPageInit because this adapter cannot process the 'pageInit' event\n   * while the widget is initialized, since the listener is not attached until the widget\n   * is created completely.\n   */\n  _postCreateWidget() {\n    var outline = this.widget;\n    outline.visitNodes(this._onWidgetPageInit.bind(this));\n  }\n\n  _onPageChanged(event) {\n    var page = this.widget._nodeById(event.nodeId);\n    page.overviewIconId = event.overviewIconId;\n\n    page.detailFormVisible = event.detailFormVisible;\n    var detailForm = this.session.getOrCreateWidget(event.detailForm, this.widget);\n    if (detailForm !== page.detailForm) {\n      page.setDetailForm(detailForm);\n    }\n\n    page.navigateButtonsVisible = event.navigateButtonsVisible;\n    page.detailTableVisible = event.detailTableVisible;\n    var detailTable = this.session.getOrCreateWidget(event.detailTable, this.widget);\n    if (page.detailTable !== detailTable) {\n      if (page.detailTable) {\n        this._destroyDetailTable(page);\n      }\n      page.setDetailTable(detailTable);\n      if (page.detailTable) {\n        this._initDetailTable(page);\n      }\n    }\n\n    this.widget.pageChanged(page);\n  }\n\n  _onWidgetEvent(event) {\n    if (event.type === 'pageInit') {\n      this._onWidgetPageInit(event.page);\n    } else {\n      super._onWidgetEvent(event);\n    }\n  }\n\n  onModelAction(event) {\n    if (event.type === 'pageChanged') {\n      this._onPageChanged(event);\n    } else {\n      super.onModelAction(event);\n    }\n  }\n\n  _onWidgetPageInit(page) {\n    if (page.detailTable) {\n      this._initDetailTable(page);\n    }\n    this._linkNodeWithRowLater(page);\n  }\n\n  _initDetailTable(page) {\n    // link already existing rows now\n    page.detailTable.rows.forEach(this._linkNodeWithRow.bind(this));\n    // rows which are inserted later are linked by _onDetailTableRowInit\n    page.detailTable.on('rowInit', this._detailTableRowInitHandler);\n  }\n\n  _destroyDetailTable(page) {\n    this._nodeIdToRowMap = {};\n    page.detailTable.rows.forEach(this._unlinkNodeWithRow.bind(this));\n    page.detailTable.off('rowInit', this._detailTableRowInitHandler);\n  }\n\n  _linkNodeWithRow(row) {\n    scout.assertParameter('row', row);\n    var node,\n      nodeId = row.nodeId;\n\n    if (nodeId === undefined) {\n      // nodeId is undefined if no node exists for that row (e.g. happens if the page containing the row is a leaf page)\n      return;\n    }\n\n    node = this.widget.nodesMap[nodeId];\n    if (node) {\n      node.linkWithRow(row);\n    } else {\n      // Prepare for linking later because node has not been inserted yet\n      // see: #_linkNodeWithRowLater\n      this._nodeIdToRowMap[nodeId] = row;\n    }\n  }\n\n  _unlinkNodeWithRow(row) {\n    var node = this.widget.nodesMap[row.nodeId];\n    if (node) {\n      node.unlinkWithRow(row);\n    }\n  }\n\n  _onDetailTableRowInit(event) {\n    var node,\n      outline = this.widget,\n      nodeId = event.row.nodeId;\n    this._linkNodeWithRow(event.row);\n    node = this.widget.nodesMap[nodeId];\n\n    // If a row, which was already linked to a node, gets initialized again, re-apply the filter to make sure the node has the correct state\n    if (outline.rendered && node && outline._applyFiltersForNode(node)) {\n      if (node.isFilterAccepted()) {\n        outline._addToVisibleFlatList(node, false);\n      } else {\n        outline._removeFromFlatList(node, false);\n      }\n    }\n    if (this.widget.isSelectedNode(node) && !this.widget.detailContent) {\n      // Table row detail could not be created because the link from page to row was missing at the time the node got selected -> do it now\n      this.widget.updateDetailContent();\n    }\n  }\n\n  /**\n   * Link node with row, if it hasn't been linked yet.\n   */\n  _linkNodeWithRowLater(page) {\n    if (!page.parentNode || !page.parentNode.detailTable) {\n      return;\n    }\n    if (!this._nodeIdToRowMap.hasOwnProperty(page.id)) {\n      return;\n    }\n    var row = this._nodeIdToRowMap[page.id];\n    page.linkWithRow(row);\n    delete this._nodeIdToRowMap[page.id];\n  }\n\n  /**\n   * Static method to modify the prototype of Outline.\n   */\n  static modifyOutlinePrototype() {\n    if (!App.get().remote) {\n      return;\n    }\n\n    objects.replacePrototypeFunction(Outline, '_computeDetailContent', OutlineAdapter._computeDetailContentRemote, true);\n    objects.replacePrototypeFunction(Outline, 'updateDetailMenus', OutlineAdapter.updateDetailMenusRemote, true);\n  }\n\n  /**\n   * Replacement for Outline#_computeDetailContent(). 'This' points to the outline.\n   */\n  static _computeDetailContentRemote() {\n    if (!this.modelAdapter) {\n      return this._computeDetailContentOrig();\n    }\n\n    var selectedPage = this.selectedNode();\n    if (!selectedPage) {\n      // Detail content is shown for the selected node only\n      return null;\n    }\n\n    // if there is a detail form, use this\n    if (selectedPage.detailForm || selectedPage.detailFormResolved) {\n      // If there is a detail form -> return (and set flag to true to make updateDetailMenusRemote work)\n      selectedPage.detailFormResolved = true;\n      return this._computeDetailContentOrig();\n    }\n\n    // It is not known yet whether there is a detail form -> wait for the requests to be processed before showing the table row detail\n    if (!this.session.areRequestsPending() && !this.session.areEventsQueued()) {\n      // There are no requests pending -> return (and set flag to true to make updateDetailMenusRemote work)\n      selectedPage.detailFormResolved = true;\n      return this._computeDetailContentOrig();\n    }\n\n    // Wait for the requests to complete\n    this.session.listen().done(function(selectedPage) {\n      if (selectedPage.detailFormResolved) {\n        // No need to update detail content again if resolved is true\n        return;\n      }\n      // Make sure the next time the page is selected it returns immediately and does not wait for requests to be completed\n      selectedPage.detailFormResolved = true;\n      this.updateDetailContent();\n    }.bind(this, selectedPage));\n  }\n\n  /**\n   * Replacement for Outline#updateDetailMenusRemote(). 'This' points to the outline.\n   */\n  static updateDetailMenusRemote() {\n    if (!this.modelAdapter) {\n      return this.updateDetailMenusOrig();\n    }\n    if (this.selectedNode() && this.selectedNode().detailFormResolved) {\n      return this.updateDetailMenusOrig();\n    }\n  }\n}\n\nApp.addListener('bootstrap', OutlineAdapter.modifyOutlinePrototype);\n"]},"metadata":{},"sourceType":"module"}