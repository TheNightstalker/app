{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { DateFormatPatternDefinition, DateFormatPatternType, dates, numbers, objects, scout, strings } from '../index';\n/**\n * Custom JavaScript Date Format\n *\n * Support for formatting and parsing dates based on a pattern string and some locale\n * information from the server model. A subset of the standard Java pattern strings\n * (see SimpleDateFormat) with the most commonly used patterns is supported.\n *\n * This object only operates on the local time zone.\n * <p>\n * locale.dateFormatSymbols contains:\n * <ul>\n * <li>weekdays start with Sunday (starts at 0 and not 1 as it does in java)</li>\n * <li>weekdaysShort start with Sunday (starts at 0 and not 1 as it does in java)</li>\n * <li>months start with January</li>\n * <li>monthsShort start with January<7li>\n * <li>am</li>\n * <li>pm</li>\n *</ul>\n *\n * @see http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html\n */\n\nvar DateFormat = /*#__PURE__*/function () {\n  function DateFormat(locale, pattern, options) {\n    _classCallCheck(this, DateFormat);\n\n    // NOSONAR\n    options = options || {};\n    /* jshint sub:true */\n\n    this.locale = locale;\n    scout.assertParameter('locale', this.locale);\n    this.pattern = pattern || locale.dateFormatPatternDefault;\n    scout.assertParameter('pattern', this.pattern);\n    this.symbols = locale.dateFormatSymbols;\n    this.symbols.firstDayOfWeek = 1; // monday // TODO [7.0] cgu: deliver from server\n\n    this.symbols.weekdaysOrdered = dates.orderWeekdays(this.symbols.weekdays, this.symbols.firstDayOfWeek);\n    this.symbols.weekdaysShortOrdered = dates.orderWeekdays(this.symbols.weekdaysShort, this.symbols.firstDayOfWeek);\n    this.symbols.monthsToNumber;\n    this.symbols.monthsShortToNumber; // Relevant during analyze(). When this is true (default), terms of the same \"pattern type\" (e.g. \"d\" and \"dd\") will\n    // also be considered. Otherwise, analyze() behaves like parse(), i.g. the pattern must match exactly.\n    // Example: \"2.10\" will match the pattern \"dd.MM.yyy\" when lenient=true. If lenient is false, it won't match.\n\n    this.lenient = scout.nvl(options.lenient, true); // List of terms, e.g. split up parts of this.pattern. The length of this array is equal\n    // to the length of this._formatFunctions, this._parseFunctions and this._analyzeFunctions.\n\n    this._terms = []; // List of format function to be called _in that exact order_ to convert this.pattern\n    // to a formatted date string (by sequentially replacing all terms with real values).\n\n    this._formatFunctions = []; // List of parse functions to be called _in that exact order_ to convert an input\n    // string to a valid JavaScript Date object. This order matches the recognized terms\n    // in the pattern. Unrecognized terms are represented by a \"constant\" function that\n    // matches the string itself (e.g. separator characters or spaces).\n\n    this._parseFunctions = []; // Array of arrays, same order as _parseFunctions, but term functions are a list of term functions (to support lenient parsing)\n\n    this._analyzeFunctions = []; // Build a list of all pattern definitions. This list is then used to build the list of\n    // format, parse and analyze functions according to this.pattern.\n    //\n    // !!! PLEASE NOTE !!!\n    // The order of these definitions is important! For each term in the pattern, the list\n    // is scanned from the beginning until a definition accepts the term. If the wrong\n    // definition was picked, results would be unpredictable.\n    //\n    // Following the following rules ensures that the algorithm can pick the best matching\n    // pattern format definition for each term in the pattern:\n    // - Sort definitions by time span, from large (year) to small (milliseconds).\n    // - Two definitions of the same type should be sorted by term length, from long\n    //   (e.g. MMMM) to short (e.g. M).\n\n    this._patternDefinitions = [// --- Year ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.YEAR,\n      terms: ['yyyy'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return strings.padZeroLeft(formatContext.inputDate.getFullYear(), 4).slice(-4);\n      },\n      parseRegExp: /^(\\d{4})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.matchInfo.year = match;\n        parseContext.dateInfo.year = Number(match);\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.YEAR,\n      terms: ['yyy', 'yy', 'y'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        var year = String(formatContext.inputDate.getFullYear());\n        var length = formatContext.exactLength ? acceptedTerm.length : 2;\n\n        if (length === 1) {\n          // Return max. 2 digits, no leading zero\n          return year.slice(-length);\n        } // Return max. 2 digits with zero padding\n\n\n        return strings.padZeroLeft(year, length).slice(-length);\n      },\n      parseRegExp: /^(\\d{1,3})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        if (match.length === 3) {\n          parseContext.dateInfo.year = Number(match);\n          parseContext.matchInfo.year = match;\n          return;\n        }\n\n        var startYear = (parseContext.startDate || new Date()).getFullYear(); // Construct a new year using the startYear's century and the entered 'short year'\n\n        var year = Number(strings.padZeroLeft(startYear, 4).substr(0, 2) + strings.padZeroLeft(match, 2)); // Ensure max. 50 years distance between 'startYear' and 'year'\n\n        var distance = year - startYear;\n\n        if (distance <= -50) {\n          year += 100;\n        } else if (distance > 50) {\n          year -= 100;\n        }\n\n        parseContext.dateInfo.year = year;\n        parseContext.matchInfo.year = match;\n      }\n    }), // --- Month ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MONTH,\n      terms: ['MMMM'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return this.dateFormat.symbols.months[formatContext.inputDate.getMonth()];\n      },\n      parseFunction: function parseFunction(parseContext, acceptedTerm) {\n        var i, symbol, re, m;\n\n        for (i = 0; i < this.dateFormat.symbols.months.length; i++) {\n          symbol = this.dateFormat.symbols.months[i];\n\n          if (!symbol) {\n            continue; // Ignore empty symbols (otherwise, pattern would match everything)\n          }\n\n          re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n\n          if (m) {\n            // match found\n            parseContext.dateInfo.month = i;\n            parseContext.matchInfo.month = m[1];\n            parseContext.inputString = m[2];\n            return m[1];\n          }\n        } // No match found so far. In analyze mode, check prefixes.\n\n\n        if (parseContext.analyze) {\n          for (i = 0; i < this.dateFormat.symbols.months.length; i++) {\n            symbol = this.dateFormat.symbols.months[i];\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(symbol);\n\n            if (m) {\n              // match found\n              parseContext.dateInfo.month = i;\n              parseContext.matchInfo.month = symbol;\n              parseContext.inputString = '';\n              return m[1];\n            }\n          }\n        }\n\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MONTH,\n      terms: ['MMM'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return this.dateFormat.symbols.monthsShort[formatContext.inputDate.getMonth()];\n      },\n      parseFunction: function parseFunction(parseContext, acceptedTerm) {\n        var i, symbol, re, m;\n\n        for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {\n          symbol = this.dateFormat.symbols.monthsShort[i];\n\n          if (!symbol) {\n            continue; // Ignore empty symbols (otherwise, pattern would match everything)\n          }\n\n          re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n\n          if (m) {\n            // match found\n            parseContext.dateInfo.month = i;\n            parseContext.matchInfo.month = m[1];\n            parseContext.inputString = m[2];\n            return m[1];\n          }\n        } // No match found so far. In analyze mode, check prefixes.\n\n\n        if (parseContext.analyze) {\n          for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {\n            symbol = this.dateFormat.symbols.monthsShort[i];\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(symbol);\n\n            if (m) {\n              // match found\n              parseContext.dateInfo.month = i;\n              parseContext.matchInfo.month = symbol;\n              parseContext.inputString = '';\n              return m[1];\n            }\n          }\n        }\n\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MONTH,\n      terms: ['MM'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return strings.padZeroLeft(formatContext.inputDate.getMonth() + 1, 2);\n      },\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        var month = Number(match);\n        parseContext.dateInfo.month = month - 1;\n        parseContext.matchInfo.month = match;\n      },\n      parseFunction: function parseFunction(parseContext, acceptedTerm) {\n        // Special case! When regexp did not match, check if input is '0'. In this case (and only\n        // if we are in analyze mode), predict '01' as input.\n        if (parseContext.analyze) {\n          if (parseContext.inputString === '0') {\n            // Use current dateInfo to create a date\n            var date = this.dateFormat._dateInfoToDate(parseContext.dateInfo);\n\n            if (!date) {\n              return null; // parsing failed (dateInfo does not seem to contain a valid string)\n            }\n\n            var month = date.getMonth();\n\n            if (month >= 9) {\n              month = 0;\n\n              if (parseContext.dateInfo.year === undefined) {\n                parseContext.dateInfo.year = Number(date.getFullYear()) + 1;\n              } else {\n                parseContext.dateInfo.year = parseContext.dateInfo.year + 1;\n              }\n            }\n\n            parseContext.dateInfo.month = month;\n            parseContext.matchInfo.month = strings.padZeroLeft(String(month + 1), 2);\n            parseContext.inputString = '';\n            return '0';\n          }\n        }\n\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MONTH,\n      terms: ['M'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return String(formatContext.inputDate.getMonth() + 1);\n      },\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        var month = Number(match);\n        parseContext.dateInfo.month = month - 1;\n        parseContext.matchInfo.month = match;\n      }\n    }), // --- Week in year ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.WEEK_IN_YEAR,\n      terms: ['ww'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return strings.padZeroLeft(dates.weekInYear(formatContext.inputDate), 2);\n      },\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.matchInfo.week = match;\n        parseContext.hints.weekInYear = Number(match);\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.WEEK_IN_YEAR,\n      terms: ['w'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return String(dates.weekInYear(formatContext.inputDate));\n      },\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.matchInfo.week = match;\n        parseContext.hints.weekInYear = Number(match);\n      }\n    }), // --- Day in month ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.DAY_IN_MONTH,\n      terms: ['dd'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return strings.padZeroLeft(formatContext.inputDate.getDate(), 2);\n      },\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.day = Number(match);\n        parseContext.matchInfo.day = match;\n      },\n      parseFunction: function parseFunction(parseContext, acceptedTerm) {\n        // Special case! When regexp did not match, check if input is '0'. In this case (and only\n        // if we are in analyze mode), predict '01' as input.\n        if (parseContext.analyze) {\n          if (parseContext.inputString === '0') {\n            parseContext.dateInfo.day = 1;\n            parseContext.matchInfo.day = '01';\n            parseContext.inputString = '';\n            return '0';\n          }\n        }\n\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.DAY_IN_MONTH,\n      terms: ['d'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return String(formatContext.inputDate.getDate());\n      },\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.day = Number(match);\n        parseContext.matchInfo.day = match;\n      }\n    }), // --- Weekday ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.WEEKDAY,\n      terms: ['EEEE'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return this.dateFormat.symbols.weekdays[formatContext.inputDate.getDay()];\n      },\n      parseFunction: function parseFunction(parseContext, acceptedTerm) {\n        var i, symbol, re, m;\n\n        for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {\n          symbol = this.dateFormat.symbols.weekdays[i];\n\n          if (!symbol) {\n            continue; // Ignore empty symbols (otherwise, pattern would match everything)\n          }\n\n          re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n\n          if (m) {\n            // match found\n            parseContext.matchInfo.weekday = m[1];\n            parseContext.hints.weekday = i;\n            parseContext.inputString = m[2];\n            return m[1];\n          }\n        } // No match found so far. In analyze mode, check prefixes.\n\n\n        if (parseContext.analyze) {\n          for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {\n            symbol = this.dateFormat.symbols.weekdays[i];\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(symbol);\n\n            if (m) {\n              // match found\n              parseContext.matchInfo.weekday = symbol;\n              parseContext.hints.weekday = i;\n              parseContext.inputString = '';\n              return m[1];\n            }\n          }\n        }\n\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.WEEKDAY,\n      terms: ['EEE', 'EE', 'E'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return this.dateFormat.symbols.weekdaysShort[formatContext.inputDate.getDay()];\n      },\n      parseFunction: function parseFunction(parseContext, acceptedTerm) {\n        var i, symbol, re, m;\n\n        for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {\n          symbol = this.dateFormat.symbols.weekdaysShort[i];\n\n          if (!symbol) {\n            continue; // Ignore empty symbols (otherwise, pattern would match everything)\n          }\n\n          re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n\n          if (m) {\n            // match found\n            parseContext.matchInfo.weekday = m[1];\n            parseContext.hints.weekday = i;\n            parseContext.inputString = m[2];\n            return m[1];\n          }\n        } // No match found so far. In analyze mode, check prefixes.\n\n\n        if (parseContext.analyze) {\n          for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {\n            symbol = this.dateFormat.symbols.weekdaysShort[i];\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(symbol);\n\n            if (m) {\n              // match found\n              parseContext.matchInfo.weekday = symbol;\n              parseContext.hints.weekday = i;\n              parseContext.inputString = '';\n              return m[1];\n            }\n          }\n        }\n\n        return null; // no match found\n      }\n    }), // --- Hour (24h) ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.HOUR_24,\n      terms: ['HH'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return strings.padZeroLeft(formatContext.inputDate.getHours(), 2);\n      },\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.hours = Number(match);\n        parseContext.matchInfo.hours = match;\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.HOUR_24,\n      terms: ['H'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return String(formatContext.inputDate.getHours());\n      },\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.hours = Number(match);\n        parseContext.matchInfo.hours = match;\n      }\n    }), // --- Hour (12h) ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.HOUR_12,\n      terms: ['hh'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        if (formatContext.inputDate.getHours() % 12 === 0) {\n          return '12'; // there is no hour '0' in 12-hour format\n        }\n\n        return strings.padZeroLeft(formatContext.inputDate.getHours() % 12, 2);\n      },\n      parseRegExp: /^(10|11|12|0[1-9])(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.hours = Number(match) + (parseContext.hints.pm ? 12 : 0);\n        parseContext.matchInfo.hours = match;\n      },\n      parseFunction: function parseFunction(parseContext, acceptedTerm) {\n        // Special case! When regexp did not match and input is a single '0', predict '01'\n        if (parseContext.analyze) {\n          if (parseContext.inputString === '0') {\n            parseContext.dateInfo.hours = 1;\n            parseContext.matchInfo.hours = '01';\n            parseContext.inputString = '';\n            return parseContext.inputString;\n          }\n        }\n\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.HOUR_12,\n      terms: ['h'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        if (formatContext.inputDate.getHours() % 12 === 0) {\n          return '12'; // there is no hour '0' in 12-hour format\n        }\n\n        return String(formatContext.inputDate.getHours() % 12);\n      },\n      parseRegExp: /^(10|11|12|0?[1-9])(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.hours = Number(match) + (parseContext.hints.pm ? 12 : 0);\n        parseContext.matchInfo.hours = match;\n      }\n    }), // --- AM/PM marker ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.AM_PM,\n      terms: ['a'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        if (formatContext.inputDate.getHours() < 12) {\n          return this.dateFormat.symbols.am;\n        }\n\n        return this.dateFormat.symbols.pm;\n      },\n      parseFunction: function parseFunction(parseContext, acceptedTerm) {\n        var re = new RegExp('^(' + strings.quote(this.dateFormat.symbols.am) + ')(.*)$', 'i');\n        var m = re.exec(parseContext.inputString);\n        parseContext.matchInfo.ampm = null;\n\n        if (m) {\n          // match found\n          parseContext.matchInfo.ampm = m[1];\n          parseContext.inputString = m[2];\n          parseContext.hints.am = true;\n          parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12;\n          return m[1];\n        }\n\n        re = new RegExp('^(' + strings.quote(this.dateFormat.symbols.pm) + ')(.*)$', 'i');\n        m = re.exec(parseContext.inputString);\n\n        if (m) {\n          // match found\n          parseContext.matchInfo.ampm = m[1];\n          parseContext.inputString = m[2];\n          parseContext.hints.pm = true;\n          parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12 + 12;\n          return m[1];\n        } // No match found so far. In analyze mode, check prefixes.\n\n\n        if (parseContext.analyze) {\n          re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n          m = re.exec(this.dateFormat.symbols.am);\n\n          if (m) {\n            parseContext.matchInfo.ampm = this.dateFormat.symbols.am;\n            parseContext.inputString = '';\n            parseContext.hints.am = true;\n            parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12;\n            return m[1];\n          }\n\n          m = re.exec(this.dateFormat.symbols.pm);\n\n          if (m) {\n            parseContext.matchInfo.ampm = this.dateFormat.symbols.pm;\n            parseContext.inputString = '';\n            parseContext.hints.pm = true;\n            parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12 + 12;\n            return m[1];\n          }\n        }\n\n        return null; // no match found\n      }\n    }), // --- Minute ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MINUTE,\n      terms: ['mm'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return strings.padZeroLeft(formatContext.inputDate.getMinutes(), 2);\n      },\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.minutes = Number(match);\n        parseContext.matchInfo.minutes = match;\n      },\n      parseFunction: function parseFunction(parseContext, acceptedTerm) {\n        // Special case! When regexp did not match, check if input + '0' would make a\n        // valid minutes value. If yes, predict this value.\n        if (parseContext.analyze) {\n          if (scout.isOneOf(parseContext.inputString, '0', '1', '2', '3', '4', '5')) {\n            var tenMinutes = parseContext.inputString + '0';\n            parseContext.dateInfo.minutes = Number(tenMinutes);\n            parseContext.matchInfo.minutes = tenMinutes;\n            parseContext.inputString = '';\n            return parseContext.inputString;\n          }\n        }\n\n        return null; // no match found\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MINUTE,\n      terms: ['m'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return String(formatContext.inputDate.getMinutes());\n      },\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.minutes = Number(match);\n        parseContext.matchInfo.minutes = match;\n      }\n    }), // --- Second ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.SECOND,\n      terms: ['ss'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return strings.padZeroLeft(formatContext.inputDate.getSeconds(), 2);\n      },\n      parseRegExp: /^(\\d{2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.seconds = Number(match);\n        parseContext.matchInfo.seconds = match;\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.SECOND,\n      terms: ['s'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return String(formatContext.inputDate.getSeconds());\n      },\n      parseRegExp: /^(\\d{1,2})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.seconds = Number(match);\n        parseContext.matchInfo.seconds = match;\n      }\n    }), // --- Millisecond ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MILLISECOND,\n      terms: ['SSS'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return strings.padZeroLeft(formatContext.inputDate.getMilliseconds(), 3);\n      },\n      parseRegExp: /^(\\d{3})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.milliseconds = Number(match);\n        parseContext.matchInfo.milliseconds = match;\n      }\n    }), new DateFormatPatternDefinition({\n      type: DateFormatPatternType.MILLISECOND,\n      terms: ['S'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        return String(formatContext.inputDate.getMilliseconds());\n      },\n      parseRegExp: /^(\\d{1,3})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        parseContext.dateInfo.milliseconds = Number(match);\n        parseContext.matchInfo.milliseconds = match;\n      }\n    }), // --- Time zone ---\n    new DateFormatPatternDefinition({\n      type: DateFormatPatternType.TIMEZONE,\n      terms: ['Z'],\n      dateFormat: this,\n      formatFunction: function formatFunction(formatContext, acceptedTerm) {\n        var offset = Math.abs(formatContext.inputDate.getTimezoneOffset()),\n            isNegative = offset !== formatContext.inputDate.getTimezoneOffset();\n        return (isNegative ? '-' : '+') + strings.padZeroLeft(Math.floor(offset / 60), 2) + strings.padZeroLeft(offset % 60, 2);\n      },\n      parseRegExp: /^([+|-]\\d{4})(.*)$/,\n      applyMatchFunction: function applyMatchFunction(parseContext, match, acceptedTerm) {\n        var offset = Number(match.substr(1, 2)) * 60 + Number(match.substr(3, 2));\n\n        if (match.charAt(0) === '-') {\n          offset *= -1;\n        }\n\n        parseContext.dateInfo.timezone = offset;\n        parseContext.matchInfo.timezone = match;\n      }\n    })]; // Build a map of pattern definitions by pattern type\n\n    this._patternLibrary = {};\n\n    for (var i = 0; i < this._patternDefinitions.length; i++) {\n      var patternDefinition = this._patternDefinitions[i];\n      var type = patternDefinition.type;\n\n      if (type) {\n        if (!this._patternLibrary[type]) {\n          this._patternLibrary[type] = [];\n        }\n\n        this._patternLibrary[type].push(patternDefinition);\n      }\n    }\n\n    this._compile();\n  }\n\n  _createClass(DateFormat, [{\n    key: \"_compile\",\n    value: function _compile() {\n      var i, j, patternDefinitions, patternDefinition, re, m, term, termAccepted, analyseFunctions; // Build format, parse and analyze functions for all terms in the DateFormat's pattern.\n      // A term is a continuous sequence of the same character.\n\n      re = /(.)\\1*/g;\n\n      while (m = re.exec(this.pattern)) {\n        term = m[0];\n\n        this._terms.push(term);\n\n        termAccepted = false;\n\n        for (i = 0; i < this._patternDefinitions.length; i++) {\n          patternDefinition = this._patternDefinitions[i];\n          var acceptedTerm = patternDefinition.accept(term);\n\n          if (acceptedTerm) {\n            // 1. Create and install format function\n            this._formatFunctions.push(patternDefinition.createFormatFunction(acceptedTerm)); // 2. Create and install parse function\n\n\n            this._parseFunctions.push(patternDefinition.createParseFunction(acceptedTerm)); // 3. Create and install analyze functions\n\n\n            analyseFunctions = [patternDefinition.createParseFunction(acceptedTerm)];\n\n            if (this.lenient) {\n              // In lenient mode, add all other parse functions of the same type\n              patternDefinitions = this._patternLibrary[patternDefinition.type];\n\n              for (j = 0; j < patternDefinitions.length; j++) {\n                if (patternDefinitions[j] !== patternDefinition) {\n                  analyseFunctions.push(patternDefinitions[j].createParseFunction(acceptedTerm));\n                }\n              }\n            }\n\n            this._analyzeFunctions.push(analyseFunctions); // Term was processed, continue with next term\n\n\n            termAccepted = true;\n            break;\n          }\n        } // In case term was not accepted by any pattern definition, assume it is a constant string\n\n\n        if (!termAccepted) {\n          // 1. Create and install constant format function\n          this._formatFunctions.push(this._createConstantStringFormatFunction(term)); // 2./3. Create and install parse and analyse functions\n\n\n          var constantStringParseFunction = this._createConstantStringParseFunction(term);\n\n          this._parseFunctions.push(constantStringParseFunction);\n\n          this._analyzeFunctions.push([constantStringParseFunction]);\n        }\n      }\n    }\n    /**\n     * Returns a format function for constant terms (e.g. all parts of a pattern that don't\n     * have a DateFormatPatternDefinition).\n     */\n\n  }, {\n    key: \"_createConstantStringFormatFunction\",\n    value: function _createConstantStringFormatFunction(term) {\n      return function (formatContext) {\n        formatContext.formattedString += term;\n      };\n    }\n    /**\n     * Returns a parse function for constant terms (e.g. all parts of a pattern that don't\n     * have a DateFormatPatternDefinition).\n     */\n\n  }, {\n    key: \"_createConstantStringParseFunction\",\n    value: function _createConstantStringParseFunction(term) {\n      return function (parseContext) {\n        if (strings.startsWith(parseContext.inputString, term)) {\n          parseContext.inputString = parseContext.inputString.substr(term.length);\n          parseContext.parsedPattern += term;\n          return true;\n        } // In analyze mode, constant terms are optional (this supports \"020318\" --> \"02.03.2018\")\n\n\n        return parseContext.analyze;\n      };\n    }\n    /**\n     * Formats the given date according to the date pattern. If the date is missing, the\n     * empty string is returned.\n     *\n     * @param exactLength\n     *          May be set to true to force the patterns to use the exact length. For example,\n     *          the year pattern 'yyy' would normally format the year using 2 digits. If\n     *          the parameter is true, 3 are used. This is mainly useful, when an \"analyzed\"\n     *          date should be formatted again using the \"parsedPattern\".\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(date, exactLength) {\n      if (!date) {\n        return '';\n      }\n\n      var formatContext = this._createFormatContext(date);\n\n      formatContext.exactLength = scout.nvl(exactLength, false); // Apply all formatter functions for this DateFormat to the pattern to replace the\n      // different terms with the corresponding value from the given date.\n\n      for (var i = 0; i < this._formatFunctions.length; i++) {\n        var formatFunction = this._formatFunctions[i];\n        formatFunction(formatContext);\n      }\n\n      return formatContext.formattedString;\n    }\n    /**\n     * Analyzes the given string and returns an information object with all recognized information\n     * for the current date format.\n     *\n     * The result object contains the following properties:\n     *\n     * inputString:\n     *   The original input for the analysis.\n     *\n     * dateInfo:\n     *   An object with all numeric date parts that could be parsed from the input string. Unrecognized\n     *   parts are undefined, all others are converted to numbers. Those values may be directly\n     *   used in the JavaScript Date() type (month is zero-based!).\n     *   Valid properties:\n     *   - year, month, day, hours, minutes, seconds, milliseconds, timezone\n     *\n     * matchInfo:\n     *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.\n     *   While dateInfo may contain the year 1995, the matchInfo may contain \"95\". Also note that\n     *   the month is \"one-based\", as opposed to dateInfo.month!\n     *   Valid properties:\n     *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds, timezone\n     *\n     * hints:\n     *   An object that contains further recognized date parts that are not needed to define the exact time.\n     *   Valid properties:\n     *   - am [true / false]\n     *   - pm [true / false]\n     *   - weekday [number 0-6; 0=sun, 1=mon, etc.]\n     *   - weekInYear [number 1-53]\n     *\n     * parsedPattern:\n     *   The pattern that was used to parse the input. This may differ from the date format's pattern.\n     *   Example: dateFormat=\"dd.MM.YYYY\", inputString=\"5.7.2015\" --> parsedPattern=\"d.M.yyyy\"\n     *\n     * matchedPattern:\n     *   The pattern that was recognized in the input. Unlike \"parsedPattern\", this may not be a full pattern.\n     *   Example: dateFormat=\"dd.MM.YYYY\", inputString=\"5.7.\" --> parsedPattern=\"d.M.yyyy\", matchedPattern=\"d.M.\"\n     *\n     * predictedDate:\n     *   The date that could be predicted from the recognized inputs. If the second method argument\n     *   'startDate' is set, this date is used as basis for this predicted date. Otherwise, 'today' is used.\n     *\n     * error:\n     *   Boolean that indicates if analyzing the input was successful (e.g. if the pattern could be parsed\n     *   and a date could be predicted).\n     */\n\n  }, {\n    key: \"analyze\",\n    value: function analyze(text, startDate) {\n      var analyzeInfo = this._createAnalyzeInfo(text);\n\n      if (!text) {\n        return analyzeInfo;\n      }\n\n      var parseContext = this._createParseContext(text);\n\n      parseContext.analyze = true; // Mark context as \"analyze mode\"\n\n      parseContext.startDate = startDate;\n      var matchedPattern = '';\n\n      for (var i = 0; i < this._terms.length; i++) {\n        if (parseContext.inputString.length > 0) {\n          var parseFunctions = this._analyzeFunctions[i];\n          var parsed = false;\n\n          for (var j = 0; j < parseFunctions.length; j++) {\n            var parseFunction = parseFunctions[j];\n\n            if (parseFunction(parseContext)) {\n              parsed = true;\n              break;\n            }\n          }\n\n          if (!parsed) {\n            // Parsing failed\n            analyzeInfo.error = true;\n            return analyzeInfo;\n          }\n\n          matchedPattern = parseContext.parsedPattern;\n        } else {\n          // Input is fully consumed, now just add the remaining terms from the pattern\n          parseContext.parsedPattern += this._terms[i];\n        }\n      }\n\n      if (parseContext.inputString.length > 0) {\n        // There is still input, but the pattern has no more terms --> parsing failed\n        analyzeInfo.error = true;\n        return analyzeInfo;\n      } // Try to generate a valid predicted date with the information retrieved so far\n\n\n      startDate = this._prepareStartDate(startDate); // When weekday is included in pattern, try to find a suitable start date #235975\n\n      var dayInWeek = parseContext.hints.weekday;\n      var dayInMonth = parseContext.dateInfo.day;\n\n      if (dayInWeek !== undefined) {\n        if (dayInMonth !== undefined && dayInMonth <= 31) {\n          startDate = dates.shiftToNextDayAndDate(startDate, dayInWeek, dayInMonth);\n        } else {\n          startDate = dates.shiftToNextDayOfType(startDate, dayInWeek);\n        }\n      }\n\n      var predictedDate = this._dateInfoToDate(parseContext.dateInfo, startDate, parseContext.hints); // Update analyzeInfo\n\n\n      analyzeInfo.dateInfo = parseContext.dateInfo;\n      analyzeInfo.matchInfo = parseContext.matchInfo;\n      analyzeInfo.hints = parseContext.hints;\n      analyzeInfo.parsedPattern = parseContext.parsedPattern;\n      analyzeInfo.matchedPattern = matchedPattern;\n      analyzeInfo.predictedDate = predictedDate;\n      analyzeInfo.error = !predictedDate;\n      return analyzeInfo;\n    }\n    /**\n     * Parses the given text with the current date format. If the text does not match exactly\n     * with the pattern, \"null\" is returned. Otherwise, the parsed date is returned.\n     *\n     * The argument 'startDate' is optional. It may set the date where parsed information should\n     * be applied to (e.g. relevant for 2-digit years).\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(text, startDate) {\n      if (!text) {\n        return null;\n      }\n\n      var parseContext = this._createParseContext(text);\n\n      parseContext.startDate = startDate;\n\n      for (var i = 0; i < this._parseFunctions.length; i++) {\n        var parseFunction = this._parseFunctions[i];\n\n        if (!parseFunction(parseContext)) {\n          return null; // Parsing failed\n        }\n\n        if (parseContext.inputString.length === 0) {\n          break; // Everything parsed!\n        }\n      }\n\n      if (parseContext.inputString.length > 0) {\n        // Input remaining but no more parse functions available -> parsing failed\n        return null;\n      } // Build date from dateInfo\n\n\n      var date = this._dateInfoToDate(parseContext.dateInfo, startDate);\n\n      if (!date) {\n        return null; // dateInfo could not be converted to a valid date -> parsing failed\n      } // Handle hints\n\n\n      if (parseContext.hints.weekday !== undefined) {\n        if (date.getDay() !== parseContext.hints.weekday) {\n          return null; // Date and weekday don't match -> parsing failed\n        }\n      } // Return valid date\n\n\n      return date;\n    }\n    /**\n     * @param {Object} dateInfo\n     * @param {Date} [startDate]\n     * @param {Object} [hints]\n     * @returns {null|Date}\n     * @private\n     */\n\n  }, {\n    key: \"_dateInfoToDate\",\n    value: function _dateInfoToDate(dateInfo, startDate, hints) {\n      if (!dateInfo) {\n        return null;\n      } // Default date\n\n\n      startDate = this._prepareStartDate(startDate); // Apply date info (Start with \"zero date\", otherwise the date may become invalid\n      // due to JavaScript's automatic date correction, e.g. dateInfo = { day: 11, month: 1 }\n      // and startDate = 2015-07-29 would result in invalid date 2015-03-11, because February\n      // 2015 does not have 29 days and is \"corrected\" to March.)\n\n      var result = new Date(1970, 0, 1);\n      var validDay = scout.nvl(dateInfo.day, startDate.getDate());\n      var validMonth = scout.nvl(dateInfo.month, startDate.getMonth());\n      var validYear = scout.nvl(dateInfo.year, startDate.getFullYear()); // When user entered the day but not (yet) the month, adjust month if possible to propose a valid date\n\n      if (dateInfo.day && !dateInfo.month) {\n        // If day \"31\" does not exist in the proposed month, use the next month\n        if (dateInfo.day === 31) {\n          var monthsWithThirthyOneDays = [0, 2, 4, 6, 7, 9, 11];\n\n          if (!scout.isOneOf(validMonth, monthsWithThirthyOneDays)) {\n            validMonth = validMonth + 1;\n          }\n        } else if (dateInfo.day >= 29 && validMonth === 1) {\n          // If day is \"29\" or \"30\" and month is february, use next month (except day is \"29\" and the year is a leap year)\n          if (dateInfo.day > 29 || !dates.isLeapYear(validYear)) {\n            validMonth = validMonth + 1;\n          }\n        }\n      } // ensure valid day for selected month for dateInfo without day\n\n\n      if (!dateInfo.day && dateInfo.month) {\n        var lastOfMonth = dates.shift(new Date(validYear, dateInfo.month + 1, 1), 0, 0, -1);\n        validDay = Math.min(lastOfMonth.getDate(), startDate.getDate());\n      }\n\n      result.setFullYear(validYear, validMonth, validDay);\n      result.setHours(scout.nvl(dateInfo.hours, startDate.getHours()), scout.nvl(dateInfo.minutes, startDate.getMinutes()), scout.nvl(dateInfo.seconds, startDate.getSeconds()), scout.nvl(dateInfo.milliseconds, startDate.getMilliseconds())); // Validate. A date is considered valid if the value from the dateInfo did\n      // not change (JS date automatically converts illegal values, e.g. day 32 is\n      // converted to first day of next month).\n\n      if (!isValid(result.getFullYear(), dateInfo.year)) {\n        return null;\n      }\n\n      if (!isValid(result.getMonth(), dateInfo.month)) {\n        return null;\n      }\n\n      if (!isValid(result.getDate(), dateInfo.day)) {\n        return null;\n      }\n\n      if (!isValid(result.getHours(), dateInfo.hours)) {\n        return null;\n      }\n\n      if (!isValid(result.getMinutes(), dateInfo.minutes)) {\n        return null;\n      }\n\n      if (!isValid(result.getSeconds(), dateInfo.seconds)) {\n        return null;\n      }\n\n      if (!isValid(result.getMilliseconds(), dateInfo.milliseconds)) {\n        return null;\n      }\n\n      if (!isValid(result.getDay(), objects.optProperty(hints, 'weekday'))) {\n        return null;\n      } // Adjust time zone\n\n\n      if (numbers.isNumber(dateInfo.timezone)) {\n        result.setMinutes(result.getMinutes() - result.getTimezoneOffset() + dateInfo.timezone);\n      }\n\n      return result; // ----- Helper functions -----\n\n      function isValid(value, expectedValue) {\n        return objects.isNullOrUndefined(expectedValue) || expectedValue === value;\n      }\n    }\n    /**\n     * Returns the date where parsed information should be applied to. The given\n     * startDate is used when specified, otherwise a new date is created (today).\n     */\n\n  }, {\n    key: \"_prepareStartDate\",\n    value: function _prepareStartDate(startDate) {\n      if (startDate) {\n        // It is important that we don't alter the argument 'startDate', but create an independent copy!\n        return new Date(startDate.getTime());\n      }\n\n      return dates.trunc(new Date()); // clear time\n    }\n    /**\n     * Returns the \"format context\", an object that is initially filled with the input date and is then\n     * passed through the various formatting functions. As the formatting progresses, the format context object\n     * is updated accordingly. At the end of the process, the object contains the result.\n     *\n     * The format context contains the following properties:\n     *\n     * inputDate:\n     *   The date to be formatted.\n     *\n     * formattedString:\n     *   The result of the formatting. The string is initially empty. During the format process, the\n     *   formatted parts will be appended to the string until the final string is complete.\n     *\n     * exactLength:\n     *   Flag to force the format functions to use the exact length of the accepted term. The default\n     *   is false, which will use the canonical length. For example, the year pattern 'yyy' will\n     *   format the year using 2 digits by default. If the parameter is true, 3 are used. This is mainly\n     *   useful, when an \"analyzed\" date should be formatted again using the \"parsedPattern\".\n     */\n\n  }, {\n    key: \"_createFormatContext\",\n    value: function _createFormatContext(inputDate) {\n      return {\n        inputDate: inputDate,\n        formattedString: '',\n        exactLength: false\n      };\n    }\n    /**\n     * Returns the \"parse context\", an object that is initially filled with the input string and is then\n     * passed through the various parsing functions. As the parsing progresses, the parse context object\n     * is updated accordingly. At the end of the process, the object contains the result.\n     *\n     * The parse context contains the following properties:\n     *\n     * inputString:\n     *   The original input for the parsing. This string will be consumed during the parse process,\n     *   and will be empty at the end.\n     *\n     * dateInfo:\n     *   An object with all numeric date parts that could be parsed from the input string. Unrecognized\n     *   parts are undefined, all others are converted to numbers. Those values may be directly\n     *   used in the JavaScript Date() type (month is zero-based!).\n     *   Valid properties:\n     *   - year, month, day, hours, minutes, seconds, milliseconds\n     *\n     * matchInfo:\n     *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.\n     *   While dateInfo may contain the year 1995, the matchInfo may contain \"95\". Also note that\n     *   the month is \"one-based\", as opposed to dateInfo.month!\n     *   Valid properties:\n     *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds\n     *\n     * hints:\n     *   An object that contains further recognized date parts that are not needed to define the exact time.\n     *   Valid properties:\n     *   - am [true / false]\n     *   - pm [true / false]\n     *   - weekday [number 0-6; 0=sun, 1=mon, etc.]\n     *   - weekInYear [number 1-53]\n     *\n     * analyze:\n     *   A flag that indicates if the \"analyze mode\" is on. This is true when analyze() was called, and\n     *   false when parse() was called. It may alter the behavior of the parse functions, i.e. they will\n     *   not fail in analyze mode when the pattern does not match exactly.\n     *\n     * startDate:\n     *   A date to be used as reference for date calculations. Is used for example when mapping a 2-digit\n     *   year to a 4-digit year.\n     */\n\n  }, {\n    key: \"_createParseContext\",\n    value: function _createParseContext(inputText) {\n      return {\n        inputString: inputText,\n        dateInfo: {},\n        matchInfo: {},\n        hints: {},\n        parsedPattern: '',\n        analyze: false,\n        startDate: null\n      };\n    }\n    /**\n     * @see analyze()\n     */\n\n  }, {\n    key: \"_createAnalyzeInfo\",\n    value: function _createAnalyzeInfo(inputText) {\n      return {\n        inputString: inputText,\n        dateInfo: {},\n        matchInfo: {},\n        hints: {},\n        parsedPattern: '',\n        matchedPattern: '',\n        predictedDate: null,\n        error: false\n      };\n    }\n  }], [{\n    key: \"ensure\",\n    value: function ensure(locale, format) {\n      if (!format) {\n        return format;\n      }\n\n      if (format instanceof DateFormat) {\n        return format;\n      }\n\n      return new DateFormat(locale, format);\n    }\n  }]);\n\n  return DateFormat;\n}();\n\nexport { DateFormat as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/text/DateFormat.js"],"names":["DateFormatPatternDefinition","DateFormatPatternType","dates","numbers","objects","scout","strings","DateFormat","locale","pattern","options","assertParameter","dateFormatPatternDefault","symbols","dateFormatSymbols","firstDayOfWeek","weekdaysOrdered","orderWeekdays","weekdays","weekdaysShortOrdered","weekdaysShort","monthsToNumber","monthsShortToNumber","lenient","nvl","_terms","_formatFunctions","_parseFunctions","_analyzeFunctions","_patternDefinitions","type","YEAR","terms","dateFormat","formatFunction","formatContext","acceptedTerm","padZeroLeft","inputDate","getFullYear","slice","parseRegExp","applyMatchFunction","parseContext","match","matchInfo","year","dateInfo","Number","String","length","exactLength","startYear","startDate","Date","substr","distance","MONTH","months","getMonth","parseFunction","i","symbol","re","m","RegExp","quote","exec","inputString","month","analyze","monthsShort","date","_dateInfoToDate","undefined","WEEK_IN_YEAR","weekInYear","week","hints","DAY_IN_MONTH","getDate","day","WEEKDAY","getDay","weekday","HOUR_24","getHours","hours","HOUR_12","pm","AM_PM","am","ampm","MINUTE","getMinutes","minutes","isOneOf","tenMinutes","SECOND","getSeconds","seconds","MILLISECOND","getMilliseconds","milliseconds","TIMEZONE","offset","Math","abs","getTimezoneOffset","isNegative","floor","charAt","timezone","_patternLibrary","patternDefinition","push","_compile","j","patternDefinitions","term","termAccepted","analyseFunctions","accept","createFormatFunction","createParseFunction","_createConstantStringFormatFunction","constantStringParseFunction","_createConstantStringParseFunction","formattedString","startsWith","parsedPattern","_createFormatContext","text","analyzeInfo","_createAnalyzeInfo","_createParseContext","matchedPattern","parseFunctions","parsed","error","_prepareStartDate","dayInWeek","dayInMonth","shiftToNextDayAndDate","shiftToNextDayOfType","predictedDate","result","validDay","validMonth","validYear","monthsWithThirthyOneDays","isLeapYear","lastOfMonth","shift","min","setFullYear","setHours","isValid","optProperty","isNumber","setMinutes","value","expectedValue","isNullOrUndefined","getTime","trunc","inputText","format"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {DateFormatPatternDefinition, DateFormatPatternType, dates, numbers, objects, scout, strings} from '../index';\n\n/**\n * Custom JavaScript Date Format\n *\n * Support for formatting and parsing dates based on a pattern string and some locale\n * information from the server model. A subset of the standard Java pattern strings\n * (see SimpleDateFormat) with the most commonly used patterns is supported.\n *\n * This object only operates on the local time zone.\n * <p>\n * locale.dateFormatSymbols contains:\n * <ul>\n * <li>weekdays start with Sunday (starts at 0 and not 1 as it does in java)</li>\n * <li>weekdaysShort start with Sunday (starts at 0 and not 1 as it does in java)</li>\n * <li>months start with January</li>\n * <li>monthsShort start with January<7li>\n * <li>am</li>\n * <li>pm</li>\n *</ul>\n *\n * @see http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html\n */\nexport default class DateFormat {\n\n  constructor(locale, pattern, options) { // NOSONAR\n    options = options || {};\n\n    /* jshint sub:true */\n    this.locale = locale;\n    scout.assertParameter('locale', this.locale);\n    this.pattern = pattern || locale.dateFormatPatternDefault;\n    scout.assertParameter('pattern', this.pattern);\n\n    this.symbols = locale.dateFormatSymbols;\n    this.symbols.firstDayOfWeek = 1; // monday // TODO [7.0] cgu: deliver from server\n    this.symbols.weekdaysOrdered = dates.orderWeekdays(this.symbols.weekdays, this.symbols.firstDayOfWeek);\n    this.symbols.weekdaysShortOrdered = dates.orderWeekdays(this.symbols.weekdaysShort, this.symbols.firstDayOfWeek);\n    this.symbols.monthsToNumber;\n    this.symbols.monthsShortToNumber;\n\n    // Relevant during analyze(). When this is true (default), terms of the same \"pattern type\" (e.g. \"d\" and \"dd\") will\n    // also be considered. Otherwise, analyze() behaves like parse(), i.g. the pattern must match exactly.\n    // Example: \"2.10\" will match the pattern \"dd.MM.yyy\" when lenient=true. If lenient is false, it won't match.\n    this.lenient = scout.nvl(options.lenient, true);\n\n    // List of terms, e.g. split up parts of this.pattern. The length of this array is equal\n    // to the length of this._formatFunctions, this._parseFunctions and this._analyzeFunctions.\n    this._terms = [];\n\n    // List of format function to be called _in that exact order_ to convert this.pattern\n    // to a formatted date string (by sequentially replacing all terms with real values).\n    this._formatFunctions = [];\n\n    // List of parse functions to be called _in that exact order_ to convert an input\n    // string to a valid JavaScript Date object. This order matches the recognized terms\n    // in the pattern. Unrecognized terms are represented by a \"constant\" function that\n    // matches the string itself (e.g. separator characters or spaces).\n    this._parseFunctions = [];\n\n    // Array of arrays, same order as _parseFunctions, but term functions are a list of term functions (to support lenient parsing)\n    this._analyzeFunctions = [];\n\n    // Build a list of all pattern definitions. This list is then used to build the list of\n    // format, parse and analyze functions according to this.pattern.\n    //\n    // !!! PLEASE NOTE !!!\n    // The order of these definitions is important! For each term in the pattern, the list\n    // is scanned from the beginning until a definition accepts the term. If the wrong\n    // definition was picked, results would be unpredictable.\n    //\n    // Following the following rules ensures that the algorithm can pick the best matching\n    // pattern format definition for each term in the pattern:\n    // - Sort definitions by time span, from large (year) to small (milliseconds).\n    // - Two definitions of the same type should be sorted by term length, from long\n    //   (e.g. MMMM) to short (e.g. M).\n    this._patternDefinitions = [\n      // --- Year ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.YEAR,\n        terms: ['yyyy'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return strings.padZeroLeft(formatContext.inputDate.getFullYear(), 4).slice(-4);\n        },\n        parseRegExp: /^(\\d{4})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.matchInfo.year = match;\n          parseContext.dateInfo.year = Number(match);\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.YEAR,\n        terms: ['yyy', 'yy', 'y'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          var year = String(formatContext.inputDate.getFullYear());\n          var length = (formatContext.exactLength ? acceptedTerm.length : 2);\n          if (length === 1) {\n            // Return max. 2 digits, no leading zero\n            return year.slice(-length);\n          }\n          // Return max. 2 digits with zero padding\n          return strings.padZeroLeft(year, length).slice(-length);\n        },\n        parseRegExp: /^(\\d{1,3})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          if (match.length === 3) {\n            parseContext.dateInfo.year = Number(match);\n            parseContext.matchInfo.year = match;\n            return;\n          }\n          var startYear = (parseContext.startDate || new Date()).getFullYear();\n          // Construct a new year using the startYear's century and the entered 'short year'\n          var year = Number(\n            strings.padZeroLeft(startYear, 4).substr(0, 2) +\n            strings.padZeroLeft(match, 2));\n          // Ensure max. 50 years distance between 'startYear' and 'year'\n          var distance = year - startYear;\n          if (distance <= -50) {\n            year += 100;\n          } else if (distance > 50) {\n            year -= 100;\n          }\n          parseContext.dateInfo.year = year;\n          parseContext.matchInfo.year = match;\n        }\n      }),\n      // --- Month ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MONTH,\n        terms: ['MMMM'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return this.dateFormat.symbols.months[formatContext.inputDate.getMonth()];\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          var i, symbol, re, m;\n          for (i = 0; i < this.dateFormat.symbols.months.length; i++) {\n            symbol = this.dateFormat.symbols.months[i];\n            if (!symbol) {\n              continue; // Ignore empty symbols (otherwise, pattern would match everything)\n            }\n            re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n            m = re.exec(parseContext.inputString);\n            if (m) { // match found\n              parseContext.dateInfo.month = i;\n              parseContext.matchInfo.month = m[1];\n              parseContext.inputString = m[2];\n              return m[1];\n            }\n          }\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            for (i = 0; i < this.dateFormat.symbols.months.length; i++) {\n              symbol = this.dateFormat.symbols.months[i];\n              re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n              m = re.exec(symbol);\n              if (m) { // match found\n                parseContext.dateInfo.month = i;\n                parseContext.matchInfo.month = symbol;\n                parseContext.inputString = '';\n                return m[1];\n              }\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MONTH,\n        terms: ['MMM'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return this.dateFormat.symbols.monthsShort[formatContext.inputDate.getMonth()];\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          var i, symbol, re, m;\n          for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {\n            symbol = this.dateFormat.symbols.monthsShort[i];\n            if (!symbol) {\n              continue; // Ignore empty symbols (otherwise, pattern would match everything)\n            }\n            re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n            m = re.exec(parseContext.inputString);\n            if (m) { // match found\n              parseContext.dateInfo.month = i;\n              parseContext.matchInfo.month = m[1];\n              parseContext.inputString = m[2];\n              return m[1];\n            }\n          }\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {\n              symbol = this.dateFormat.symbols.monthsShort[i];\n              re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n              m = re.exec(symbol);\n              if (m) { // match found\n                parseContext.dateInfo.month = i;\n                parseContext.matchInfo.month = symbol;\n                parseContext.inputString = '';\n                return m[1];\n              }\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MONTH,\n        terms: ['MM'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return strings.padZeroLeft(formatContext.inputDate.getMonth() + 1, 2);\n        },\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          var month = Number(match);\n          parseContext.dateInfo.month = month - 1;\n          parseContext.matchInfo.month = match;\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          // Special case! When regexp did not match, check if input is '0'. In this case (and only\n          // if we are in analyze mode), predict '01' as input.\n          if (parseContext.analyze) {\n            if (parseContext.inputString === '0') {\n              // Use current dateInfo to create a date\n              var date = this.dateFormat._dateInfoToDate(parseContext.dateInfo);\n              if (!date) {\n                return null; // parsing failed (dateInfo does not seem to contain a valid string)\n              }\n              var month = date.getMonth();\n              if (month >= 9) {\n                month = 0;\n                if (parseContext.dateInfo.year === undefined) {\n                  parseContext.dateInfo.year = Number(date.getFullYear()) + 1;\n                } else {\n                  parseContext.dateInfo.year = parseContext.dateInfo.year + 1;\n                }\n              }\n              parseContext.dateInfo.month = month;\n              parseContext.matchInfo.month = strings.padZeroLeft(String(month + 1), 2);\n              parseContext.inputString = '';\n              return '0';\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MONTH,\n        terms: ['M'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return String(formatContext.inputDate.getMonth() + 1);\n        },\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          var month = Number(match);\n          parseContext.dateInfo.month = month - 1;\n          parseContext.matchInfo.month = match;\n        }\n      }),\n      // --- Week in year ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.WEEK_IN_YEAR,\n        terms: ['ww'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return strings.padZeroLeft(dates.weekInYear(formatContext.inputDate), 2);\n        },\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.matchInfo.week = match;\n          parseContext.hints.weekInYear = Number(match);\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.WEEK_IN_YEAR,\n        terms: ['w'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return String(dates.weekInYear(formatContext.inputDate));\n        },\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.matchInfo.week = match;\n          parseContext.hints.weekInYear = Number(match);\n        }\n      }),\n      // --- Day in month ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.DAY_IN_MONTH,\n        terms: ['dd'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return strings.padZeroLeft(formatContext.inputDate.getDate(), 2);\n        },\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.day = Number(match);\n          parseContext.matchInfo.day = match;\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          // Special case! When regexp did not match, check if input is '0'. In this case (and only\n          // if we are in analyze mode), predict '01' as input.\n          if (parseContext.analyze) {\n            if (parseContext.inputString === '0') {\n              parseContext.dateInfo.day = 1;\n              parseContext.matchInfo.day = '01';\n              parseContext.inputString = '';\n              return '0';\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.DAY_IN_MONTH,\n        terms: ['d'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return String(formatContext.inputDate.getDate());\n        },\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.day = Number(match);\n          parseContext.matchInfo.day = match;\n        }\n      }),\n      // --- Weekday ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.WEEKDAY,\n        terms: ['EEEE'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return this.dateFormat.symbols.weekdays[formatContext.inputDate.getDay()];\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          var i, symbol, re, m;\n          for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {\n            symbol = this.dateFormat.symbols.weekdays[i];\n            if (!symbol) {\n              continue; // Ignore empty symbols (otherwise, pattern would match everything)\n            }\n            re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n            m = re.exec(parseContext.inputString);\n            if (m) { // match found\n              parseContext.matchInfo.weekday = m[1];\n              parseContext.hints.weekday = i;\n              parseContext.inputString = m[2];\n              return m[1];\n            }\n          }\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {\n              symbol = this.dateFormat.symbols.weekdays[i];\n              re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n              m = re.exec(symbol);\n              if (m) { // match found\n                parseContext.matchInfo.weekday = symbol;\n                parseContext.hints.weekday = i;\n                parseContext.inputString = '';\n                return m[1];\n              }\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.WEEKDAY,\n        terms: ['EEE', 'EE', 'E'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return this.dateFormat.symbols.weekdaysShort[formatContext.inputDate.getDay()];\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          var i, symbol, re, m;\n          for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {\n            symbol = this.dateFormat.symbols.weekdaysShort[i];\n            if (!symbol) {\n              continue; // Ignore empty symbols (otherwise, pattern would match everything)\n            }\n            re = new RegExp('^(' + strings.quote(symbol) + ')(.*)$', 'i');\n            m = re.exec(parseContext.inputString);\n            if (m) { // match found\n              parseContext.matchInfo.weekday = m[1];\n              parseContext.hints.weekday = i;\n              parseContext.inputString = m[2];\n              return m[1];\n            }\n          }\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {\n              symbol = this.dateFormat.symbols.weekdaysShort[i];\n              re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n              m = re.exec(symbol);\n              if (m) { // match found\n                parseContext.matchInfo.weekday = symbol;\n                parseContext.hints.weekday = i;\n                parseContext.inputString = '';\n                return m[1];\n              }\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      // --- Hour (24h) ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.HOUR_24,\n        terms: ['HH'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return strings.padZeroLeft(formatContext.inputDate.getHours(), 2);\n        },\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.hours = Number(match);\n          parseContext.matchInfo.hours = match;\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.HOUR_24,\n        terms: ['H'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return String(formatContext.inputDate.getHours());\n        },\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.hours = Number(match);\n          parseContext.matchInfo.hours = match;\n        }\n      }),\n      // --- Hour (12h) ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.HOUR_12,\n        terms: ['hh'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          if (formatContext.inputDate.getHours() % 12 === 0) {\n            return '12'; // there is no hour '0' in 12-hour format\n          }\n          return strings.padZeroLeft(formatContext.inputDate.getHours() % 12, 2);\n        },\n        parseRegExp: /^(10|11|12|0[1-9])(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.hours = Number(match) + (parseContext.hints.pm ? 12 : 0);\n          parseContext.matchInfo.hours = match;\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          // Special case! When regexp did not match and input is a single '0', predict '01'\n          if (parseContext.analyze) {\n            if (parseContext.inputString === '0') {\n              parseContext.dateInfo.hours = 1;\n              parseContext.matchInfo.hours = '01';\n              parseContext.inputString = '';\n              return parseContext.inputString;\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.HOUR_12,\n        terms: ['h'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          if (formatContext.inputDate.getHours() % 12 === 0) {\n            return '12'; // there is no hour '0' in 12-hour format\n          }\n          return String(formatContext.inputDate.getHours() % 12);\n        },\n        parseRegExp: /^(10|11|12|0?[1-9])(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.hours = Number(match) + (parseContext.hints.pm ? 12 : 0);\n          parseContext.matchInfo.hours = match;\n        }\n      }),\n      // --- AM/PM marker ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.AM_PM,\n        terms: ['a'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          if (formatContext.inputDate.getHours() < 12) {\n            return this.dateFormat.symbols.am;\n          }\n          return this.dateFormat.symbols.pm;\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          var re = new RegExp('^(' + strings.quote(this.dateFormat.symbols.am) + ')(.*)$', 'i');\n          var m = re.exec(parseContext.inputString);\n          parseContext.matchInfo.ampm = null;\n          if (m) { // match found\n            parseContext.matchInfo.ampm = m[1];\n            parseContext.inputString = m[2];\n            parseContext.hints.am = true;\n            parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12;\n            return m[1];\n          }\n          re = new RegExp('^(' + strings.quote(this.dateFormat.symbols.pm) + ')(.*)$', 'i');\n          m = re.exec(parseContext.inputString);\n          if (m) { // match found\n            parseContext.matchInfo.ampm = m[1];\n            parseContext.inputString = m[2];\n            parseContext.hints.pm = true;\n            parseContext.dateInfo.hours = (parseContext.dateInfo.hours % 12) + 12;\n            return m[1];\n          }\n\n          // No match found so far. In analyze mode, check prefixes.\n          if (parseContext.analyze) {\n            re = new RegExp('^(' + strings.quote(parseContext.inputString) + ')(.*)$', 'i');\n            m = re.exec(this.dateFormat.symbols.am);\n            if (m) {\n              parseContext.matchInfo.ampm = this.dateFormat.symbols.am;\n              parseContext.inputString = '';\n              parseContext.hints.am = true;\n              parseContext.dateInfo.hours = parseContext.dateInfo.hours % 12;\n              return m[1];\n            }\n            m = re.exec(this.dateFormat.symbols.pm);\n            if (m) {\n              parseContext.matchInfo.ampm = this.dateFormat.symbols.pm;\n              parseContext.inputString = '';\n              parseContext.hints.pm = true;\n              parseContext.dateInfo.hours = (parseContext.dateInfo.hours % 12) + 12;\n              return m[1];\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      // --- Minute ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MINUTE,\n        terms: ['mm'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return strings.padZeroLeft(formatContext.inputDate.getMinutes(), 2);\n        },\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.minutes = Number(match);\n          parseContext.matchInfo.minutes = match;\n        },\n        parseFunction: function(parseContext, acceptedTerm) {\n          // Special case! When regexp did not match, check if input + '0' would make a\n          // valid minutes value. If yes, predict this value.\n          if (parseContext.analyze) {\n            if (scout.isOneOf(parseContext.inputString, '0', '1', '2', '3', '4', '5')) {\n              var tenMinutes = parseContext.inputString + '0';\n              parseContext.dateInfo.minutes = Number(tenMinutes);\n              parseContext.matchInfo.minutes = tenMinutes;\n              parseContext.inputString = '';\n              return parseContext.inputString;\n            }\n          }\n          return null; // no match found\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MINUTE,\n        terms: ['m'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return String(formatContext.inputDate.getMinutes());\n        },\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.minutes = Number(match);\n          parseContext.matchInfo.minutes = match;\n        }\n      }),\n      // --- Second ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.SECOND,\n        terms: ['ss'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return strings.padZeroLeft(formatContext.inputDate.getSeconds(), 2);\n        },\n        parseRegExp: /^(\\d{2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.seconds = Number(match);\n          parseContext.matchInfo.seconds = match;\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.SECOND,\n        terms: ['s'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return String(formatContext.inputDate.getSeconds());\n        },\n        parseRegExp: /^(\\d{1,2})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.seconds = Number(match);\n          parseContext.matchInfo.seconds = match;\n        }\n      }),\n      // --- Millisecond ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MILLISECOND,\n        terms: ['SSS'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return strings.padZeroLeft(formatContext.inputDate.getMilliseconds(), 3);\n        },\n        parseRegExp: /^(\\d{3})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.milliseconds = Number(match);\n          parseContext.matchInfo.milliseconds = match;\n        }\n      }),\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.MILLISECOND,\n        terms: ['S'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          return String(formatContext.inputDate.getMilliseconds());\n        },\n        parseRegExp: /^(\\d{1,3})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          parseContext.dateInfo.milliseconds = Number(match);\n          parseContext.matchInfo.milliseconds = match;\n        }\n      }),\n\n      // --- Time zone ---\n      new DateFormatPatternDefinition({\n        type: DateFormatPatternType.TIMEZONE,\n        terms: ['Z'],\n        dateFormat: this,\n        formatFunction: function(formatContext, acceptedTerm) {\n          var offset = Math.abs(formatContext.inputDate.getTimezoneOffset()),\n            isNegative = offset !== formatContext.inputDate.getTimezoneOffset();\n          return (isNegative ? '-' : '+') + strings.padZeroLeft(Math.floor(offset / 60), 2) + strings.padZeroLeft(offset % 60, 2);\n        },\n        parseRegExp: /^([+|-]\\d{4})(.*)$/,\n        applyMatchFunction: function(parseContext, match, acceptedTerm) {\n          var offset = Number(match.substr(1, 2)) * 60 + Number(match.substr(3, 2));\n          if (match.charAt(0) === '-') {\n            offset *= -1;\n          }\n          parseContext.dateInfo.timezone = offset;\n          parseContext.matchInfo.timezone = match;\n        }\n      })\n    ];\n\n    // Build a map of pattern definitions by pattern type\n    this._patternLibrary = {};\n    for (var i = 0; i < this._patternDefinitions.length; i++) {\n      var patternDefinition = this._patternDefinitions[i];\n      var type = patternDefinition.type;\n      if (type) {\n        if (!this._patternLibrary[type]) {\n          this._patternLibrary[type] = [];\n        }\n        this._patternLibrary[type].push(patternDefinition);\n      }\n    }\n\n    this._compile();\n  }\n\n  _compile() {\n    var i, j, patternDefinitions, patternDefinition, re, m, term, termAccepted, analyseFunctions;\n\n    // Build format, parse and analyze functions for all terms in the DateFormat's pattern.\n    // A term is a continuous sequence of the same character.\n    re = /(.)\\1*/g;\n    while ((m = re.exec(this.pattern))) {\n      term = m[0];\n      this._terms.push(term);\n\n      termAccepted = false;\n      for (i = 0; i < this._patternDefinitions.length; i++) {\n        patternDefinition = this._patternDefinitions[i];\n        var acceptedTerm = patternDefinition.accept(term);\n        if (acceptedTerm) {\n          // 1. Create and install format function\n          this._formatFunctions.push(patternDefinition.createFormatFunction(acceptedTerm));\n\n          // 2. Create and install parse function\n          this._parseFunctions.push(patternDefinition.createParseFunction(acceptedTerm));\n\n          // 3. Create and install analyze functions\n          analyseFunctions = [patternDefinition.createParseFunction(acceptedTerm)];\n          if (this.lenient) {\n            // In lenient mode, add all other parse functions of the same type\n            patternDefinitions = this._patternLibrary[patternDefinition.type];\n            for (j = 0; j < patternDefinitions.length; j++) {\n              if (patternDefinitions[j] !== patternDefinition) {\n                analyseFunctions.push(patternDefinitions[j].createParseFunction(acceptedTerm));\n              }\n            }\n          }\n          this._analyzeFunctions.push(analyseFunctions);\n\n          // Term was processed, continue with next term\n          termAccepted = true;\n          break;\n        }\n      }\n\n      // In case term was not accepted by any pattern definition, assume it is a constant string\n      if (!termAccepted) {\n        // 1. Create and install constant format function\n        this._formatFunctions.push(this._createConstantStringFormatFunction(term));\n        // 2./3. Create and install parse and analyse functions\n        var constantStringParseFunction = this._createConstantStringParseFunction(term);\n        this._parseFunctions.push(constantStringParseFunction);\n        this._analyzeFunctions.push([constantStringParseFunction]);\n      }\n    }\n  }\n\n  /**\n   * Returns a format function for constant terms (e.g. all parts of a pattern that don't\n   * have a DateFormatPatternDefinition).\n   */\n  _createConstantStringFormatFunction(term) {\n    return function(formatContext) {\n      formatContext.formattedString += term;\n    };\n  }\n\n  /**\n   * Returns a parse function for constant terms (e.g. all parts of a pattern that don't\n   * have a DateFormatPatternDefinition).\n   */\n  _createConstantStringParseFunction(term) {\n    return function(parseContext) {\n      if (strings.startsWith(parseContext.inputString, term)) {\n        parseContext.inputString = parseContext.inputString.substr(term.length);\n        parseContext.parsedPattern += term;\n        return true;\n      }\n      // In analyze mode, constant terms are optional (this supports \"020318\" --> \"02.03.2018\")\n      return parseContext.analyze;\n    };\n  }\n\n  /**\n   * Formats the given date according to the date pattern. If the date is missing, the\n   * empty string is returned.\n   *\n   * @param exactLength\n   *          May be set to true to force the patterns to use the exact length. For example,\n   *          the year pattern 'yyy' would normally format the year using 2 digits. If\n   *          the parameter is true, 3 are used. This is mainly useful, when an \"analyzed\"\n   *          date should be formatted again using the \"parsedPattern\".\n   */\n  format(date, exactLength) {\n    if (!date) {\n      return '';\n    }\n\n    var formatContext = this._createFormatContext(date);\n    formatContext.exactLength = scout.nvl(exactLength, false);\n    // Apply all formatter functions for this DateFormat to the pattern to replace the\n    // different terms with the corresponding value from the given date.\n    for (var i = 0; i < this._formatFunctions.length; i++) {\n      var formatFunction = this._formatFunctions[i];\n      formatFunction(formatContext);\n    }\n    return formatContext.formattedString;\n  }\n\n  /**\n   * Analyzes the given string and returns an information object with all recognized information\n   * for the current date format.\n   *\n   * The result object contains the following properties:\n   *\n   * inputString:\n   *   The original input for the analysis.\n   *\n   * dateInfo:\n   *   An object with all numeric date parts that could be parsed from the input string. Unrecognized\n   *   parts are undefined, all others are converted to numbers. Those values may be directly\n   *   used in the JavaScript Date() type (month is zero-based!).\n   *   Valid properties:\n   *   - year, month, day, hours, minutes, seconds, milliseconds, timezone\n   *\n   * matchInfo:\n   *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.\n   *   While dateInfo may contain the year 1995, the matchInfo may contain \"95\". Also note that\n   *   the month is \"one-based\", as opposed to dateInfo.month!\n   *   Valid properties:\n   *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds, timezone\n   *\n   * hints:\n   *   An object that contains further recognized date parts that are not needed to define the exact time.\n   *   Valid properties:\n   *   - am [true / false]\n   *   - pm [true / false]\n   *   - weekday [number 0-6; 0=sun, 1=mon, etc.]\n   *   - weekInYear [number 1-53]\n   *\n   * parsedPattern:\n   *   The pattern that was used to parse the input. This may differ from the date format's pattern.\n   *   Example: dateFormat=\"dd.MM.YYYY\", inputString=\"5.7.2015\" --> parsedPattern=\"d.M.yyyy\"\n   *\n   * matchedPattern:\n   *   The pattern that was recognized in the input. Unlike \"parsedPattern\", this may not be a full pattern.\n   *   Example: dateFormat=\"dd.MM.YYYY\", inputString=\"5.7.\" --> parsedPattern=\"d.M.yyyy\", matchedPattern=\"d.M.\"\n   *\n   * predictedDate:\n   *   The date that could be predicted from the recognized inputs. If the second method argument\n   *   'startDate' is set, this date is used as basis for this predicted date. Otherwise, 'today' is used.\n   *\n   * error:\n   *   Boolean that indicates if analyzing the input was successful (e.g. if the pattern could be parsed\n   *   and a date could be predicted).\n   */\n  analyze(text, startDate) {\n    var analyzeInfo = this._createAnalyzeInfo(text);\n    if (!text) {\n      return analyzeInfo;\n    }\n\n    var parseContext = this._createParseContext(text);\n    parseContext.analyze = true; // Mark context as \"analyze mode\"\n    parseContext.startDate = startDate;\n    var matchedPattern = '';\n    for (var i = 0; i < this._terms.length; i++) {\n      if (parseContext.inputString.length > 0) {\n        var parseFunctions = this._analyzeFunctions[i];\n        var parsed = false;\n        for (var j = 0; j < parseFunctions.length; j++) {\n          var parseFunction = parseFunctions[j];\n          if (parseFunction(parseContext)) {\n            parsed = true;\n            break;\n          }\n        }\n        if (!parsed) {\n          // Parsing failed\n          analyzeInfo.error = true;\n          return analyzeInfo;\n        }\n        matchedPattern = parseContext.parsedPattern;\n      } else {\n        // Input is fully consumed, now just add the remaining terms from the pattern\n        parseContext.parsedPattern += this._terms[i];\n      }\n    }\n\n    if (parseContext.inputString.length > 0) {\n      // There is still input, but the pattern has no more terms --> parsing failed\n      analyzeInfo.error = true;\n      return analyzeInfo;\n    }\n\n    // Try to generate a valid predicted date with the information retrieved so far\n    startDate = this._prepareStartDate(startDate);\n\n    // When weekday is included in pattern, try to find a suitable start date #235975\n    var dayInWeek = parseContext.hints.weekday;\n    var dayInMonth = parseContext.dateInfo.day;\n    if (dayInWeek !== undefined) {\n      if (dayInMonth !== undefined && dayInMonth <= 31) {\n        startDate = dates.shiftToNextDayAndDate(startDate, dayInWeek, dayInMonth);\n      } else {\n        startDate = dates.shiftToNextDayOfType(startDate, dayInWeek);\n      }\n    }\n\n    var predictedDate = this._dateInfoToDate(parseContext.dateInfo, startDate, parseContext.hints);\n\n    // Update analyzeInfo\n    analyzeInfo.dateInfo = parseContext.dateInfo;\n    analyzeInfo.matchInfo = parseContext.matchInfo;\n    analyzeInfo.hints = parseContext.hints;\n    analyzeInfo.parsedPattern = parseContext.parsedPattern;\n    analyzeInfo.matchedPattern = matchedPattern;\n    analyzeInfo.predictedDate = predictedDate;\n    analyzeInfo.error = (!predictedDate);\n    return analyzeInfo;\n  }\n\n  /**\n   * Parses the given text with the current date format. If the text does not match exactly\n   * with the pattern, \"null\" is returned. Otherwise, the parsed date is returned.\n   *\n   * The argument 'startDate' is optional. It may set the date where parsed information should\n   * be applied to (e.g. relevant for 2-digit years).\n   */\n  parse(text, startDate) {\n    if (!text) {\n      return null;\n    }\n\n    var parseContext = this._createParseContext(text);\n    parseContext.startDate = startDate;\n    for (var i = 0; i < this._parseFunctions.length; i++) {\n      var parseFunction = this._parseFunctions[i];\n      if (!parseFunction(parseContext)) {\n        return null; // Parsing failed\n      }\n      if (parseContext.inputString.length === 0) {\n        break; // Everything parsed!\n      }\n    }\n    if (parseContext.inputString.length > 0) {\n      // Input remaining but no more parse functions available -> parsing failed\n      return null;\n    }\n\n    // Build date from dateInfo\n    var date = this._dateInfoToDate(parseContext.dateInfo, startDate);\n    if (!date) {\n      return null; // dateInfo could not be converted to a valid date -> parsing failed\n    }\n\n    // Handle hints\n    if (parseContext.hints.weekday !== undefined) {\n      if (date.getDay() !== parseContext.hints.weekday) {\n        return null; // Date and weekday don't match -> parsing failed\n      }\n    }\n\n    // Return valid date\n    return date;\n  }\n\n  /**\n   * @param {Object} dateInfo\n   * @param {Date} [startDate]\n   * @param {Object} [hints]\n   * @returns {null|Date}\n   * @private\n   */\n  _dateInfoToDate(dateInfo, startDate, hints) {\n    if (!dateInfo) {\n      return null;\n    }\n\n    // Default date\n    startDate = this._prepareStartDate(startDate);\n\n    // Apply date info (Start with \"zero date\", otherwise the date may become invalid\n    // due to JavaScript's automatic date correction, e.g. dateInfo = { day: 11, month: 1 }\n    // and startDate = 2015-07-29 would result in invalid date 2015-03-11, because February\n    // 2015 does not have 29 days and is \"corrected\" to March.)\n    var result = new Date(1970, 0, 1);\n\n    var validDay = scout.nvl(dateInfo.day, startDate.getDate());\n    var validMonth = scout.nvl(dateInfo.month, startDate.getMonth());\n    var validYear = scout.nvl(dateInfo.year, startDate.getFullYear());\n    // When user entered the day but not (yet) the month, adjust month if possible to propose a valid date\n    if (dateInfo.day && !dateInfo.month) {\n      // If day \"31\" does not exist in the proposed month, use the next month\n      if (dateInfo.day === 31) {\n        var monthsWithThirthyOneDays = [0, 2, 4, 6, 7, 9, 11];\n        if (!scout.isOneOf(validMonth, monthsWithThirthyOneDays)) {\n          validMonth = validMonth + 1;\n        }\n      } else if (dateInfo.day >= 29 && validMonth === 1) {\n        // If day is \"29\" or \"30\" and month is february, use next month (except day is \"29\" and the year is a leap year)\n        if (dateInfo.day > 29 || !dates.isLeapYear(validYear)) {\n          validMonth = validMonth + 1;\n        }\n      }\n    }\n\n    // ensure valid day for selected month for dateInfo without day\n    if (!dateInfo.day && dateInfo.month) {\n      var lastOfMonth = dates.shift(new Date(validYear, dateInfo.month + 1, 1), 0, 0, -1);\n      validDay = Math.min(lastOfMonth.getDate(), startDate.getDate());\n    }\n\n    result.setFullYear(\n      validYear,\n      validMonth,\n      validDay\n    );\n\n    result.setHours(\n      scout.nvl(dateInfo.hours, startDate.getHours()),\n      scout.nvl(dateInfo.minutes, startDate.getMinutes()),\n      scout.nvl(dateInfo.seconds, startDate.getSeconds()),\n      scout.nvl(dateInfo.milliseconds, startDate.getMilliseconds())\n    );\n\n    // Validate. A date is considered valid if the value from the dateInfo did\n    // not change (JS date automatically converts illegal values, e.g. day 32 is\n    // converted to first day of next month).\n    if (!isValid(result.getFullYear(), dateInfo.year)) {\n      return null;\n    }\n    if (!isValid(result.getMonth(), dateInfo.month)) {\n      return null;\n    }\n    if (!isValid(result.getDate(), dateInfo.day)) {\n      return null;\n    }\n    if (!isValid(result.getHours(), dateInfo.hours)) {\n      return null;\n    }\n    if (!isValid(result.getMinutes(), dateInfo.minutes)) {\n      return null;\n    }\n    if (!isValid(result.getSeconds(), dateInfo.seconds)) {\n      return null;\n    }\n    if (!isValid(result.getMilliseconds(), dateInfo.milliseconds)) {\n      return null;\n    }\n    if (!isValid(result.getDay(), objects.optProperty(hints, 'weekday'))) {\n      return null;\n    }\n\n    // Adjust time zone\n    if (numbers.isNumber(dateInfo.timezone)) {\n      result.setMinutes(result.getMinutes() - result.getTimezoneOffset() + dateInfo.timezone);\n    }\n\n    return result;\n\n    // ----- Helper functions -----\n\n    function isValid(value, expectedValue) {\n      return objects.isNullOrUndefined(expectedValue) || expectedValue === value;\n    }\n  }\n\n  /**\n   * Returns the date where parsed information should be applied to. The given\n   * startDate is used when specified, otherwise a new date is created (today).\n   */\n  _prepareStartDate(startDate) {\n    if (startDate) {\n      // It is important that we don't alter the argument 'startDate', but create an independent copy!\n      return new Date(startDate.getTime());\n    }\n    return dates.trunc(new Date()); // clear time\n  }\n\n  /**\n   * Returns the \"format context\", an object that is initially filled with the input date and is then\n   * passed through the various formatting functions. As the formatting progresses, the format context object\n   * is updated accordingly. At the end of the process, the object contains the result.\n   *\n   * The format context contains the following properties:\n   *\n   * inputDate:\n   *   The date to be formatted.\n   *\n   * formattedString:\n   *   The result of the formatting. The string is initially empty. During the format process, the\n   *   formatted parts will be appended to the string until the final string is complete.\n   *\n   * exactLength:\n   *   Flag to force the format functions to use the exact length of the accepted term. The default\n   *   is false, which will use the canonical length. For example, the year pattern 'yyy' will\n   *   format the year using 2 digits by default. If the parameter is true, 3 are used. This is mainly\n   *   useful, when an \"analyzed\" date should be formatted again using the \"parsedPattern\".\n   */\n  _createFormatContext(inputDate) {\n    return {\n      inputDate: inputDate,\n      formattedString: '',\n      exactLength: false\n    };\n  }\n\n  /**\n   * Returns the \"parse context\", an object that is initially filled with the input string and is then\n   * passed through the various parsing functions. As the parsing progresses, the parse context object\n   * is updated accordingly. At the end of the process, the object contains the result.\n   *\n   * The parse context contains the following properties:\n   *\n   * inputString:\n   *   The original input for the parsing. This string will be consumed during the parse process,\n   *   and will be empty at the end.\n   *\n   * dateInfo:\n   *   An object with all numeric date parts that could be parsed from the input string. Unrecognized\n   *   parts are undefined, all others are converted to numbers. Those values may be directly\n   *   used in the JavaScript Date() type (month is zero-based!).\n   *   Valid properties:\n   *   - year, month, day, hours, minutes, seconds, milliseconds\n   *\n   * matchInfo:\n   *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.\n   *   While dateInfo may contain the year 1995, the matchInfo may contain \"95\". Also note that\n   *   the month is \"one-based\", as opposed to dateInfo.month!\n   *   Valid properties:\n   *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds\n   *\n   * hints:\n   *   An object that contains further recognized date parts that are not needed to define the exact time.\n   *   Valid properties:\n   *   - am [true / false]\n   *   - pm [true / false]\n   *   - weekday [number 0-6; 0=sun, 1=mon, etc.]\n   *   - weekInYear [number 1-53]\n   *\n   * analyze:\n   *   A flag that indicates if the \"analyze mode\" is on. This is true when analyze() was called, and\n   *   false when parse() was called. It may alter the behavior of the parse functions, i.e. they will\n   *   not fail in analyze mode when the pattern does not match exactly.\n   *\n   * startDate:\n   *   A date to be used as reference for date calculations. Is used for example when mapping a 2-digit\n   *   year to a 4-digit year.\n   */\n  _createParseContext(inputText) {\n    return {\n      inputString: inputText,\n      dateInfo: {},\n      matchInfo: {},\n      hints: {},\n      parsedPattern: '',\n      analyze: false,\n      startDate: null\n    };\n  }\n\n  /**\n   * @see analyze()\n   */\n  _createAnalyzeInfo(inputText) {\n    return {\n      inputString: inputText,\n      dateInfo: {},\n      matchInfo: {},\n      hints: {},\n      parsedPattern: '',\n      matchedPattern: '',\n      predictedDate: null,\n      error: false\n    };\n  }\n\n  static ensure(locale, format) {\n    if (!format) {\n      return format;\n    }\n    if (format instanceof DateFormat) {\n      return format;\n    }\n    return new DateFormat(locale, format);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}