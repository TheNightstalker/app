{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, objects, Table } from '../index';\n\nvar TableUpdateBuffer = /*#__PURE__*/function () {\n  function TableUpdateBuffer(table) {\n    _classCallCheck(this, TableUpdateBuffer);\n\n    this._rowMap = {};\n    this.promises = [];\n    this.table = table;\n  }\n  /**\n   * The buffer is active if it contains at least one promise. When all promises resolve the buffer will be processed.\n   */\n\n\n  _createClass(TableUpdateBuffer, [{\n    key: \"pushPromise\",\n    value: function pushPromise(promise) {\n      this.promises.push(promise); // Also make sure viewport is not rendered as long as update events are buffered\n      // Otherwise the other cells might already be visible during buffering\n\n      this.table._renderViewportBlocked = true;\n      this.table.setLoading(true);\n\n      var handler = function () {\n        arrays.remove(this.promises, promise); // process immediately when all promises have resolved\n\n        if (this.promises.length === 0) {\n          this.process();\n        }\n      }.bind(this); // Use then instead of always to ensure it is always executed asynchronous, even for null values\n\n\n      promise.then(handler, handler);\n    }\n  }, {\n    key: \"isBuffering\",\n    value: function isBuffering() {\n      return this.promises.length > 0;\n    }\n  }, {\n    key: \"buffer\",\n    value: function buffer(rows) {\n      rows = arrays.ensure(rows); // Don't buffer duplicate rows\n\n      rows.forEach(function (row) {\n        this._rowMap[row.id] = row;\n      }, this);\n    }\n    /**\n     * Calls {@link Table.prototype.updateRows} with the buffered rows and renders the viewport if the rendering was blocked.\n     */\n\n  }, {\n    key: \"process\",\n    value: function process() {\n      if (this.table.destroyed) {\n        return;\n      }\n\n      var rows = objects.values(this._rowMap);\n      this.table.updateRows(rows);\n      this._rowMap = {}; // Update the viewport as well if rendering was blocked\n\n      this.table.setLoading(false);\n      this.table._renderViewportBlocked = false;\n\n      if (this.table._isDataRendered()) {\n        this.table._renderViewport();\n      }\n    }\n  }]);\n\n  return TableUpdateBuffer;\n}();\n\nexport { TableUpdateBuffer as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/table/TableUpdateBuffer.js"],"names":["arrays","objects","Table","TableUpdateBuffer","table","_rowMap","promises","promise","push","_renderViewportBlocked","setLoading","handler","remove","length","process","bind","then","rows","ensure","forEach","row","id","destroyed","values","updateRows","_isDataRendered","_renderViewport"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,MAAR,EAAgBC,OAAhB,EAAyBC,KAAzB,QAAqC,UAArC;;IAEqBC,iB;AAEnB,6BAAYC,KAAZ,EAAmB;AAAA;;AACjB,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKF,KAAL,GAAaA,KAAb;AACD;AAED;AACF;AACA;;;;;gCACcG,O,EAAS;AACnB,WAAKD,QAAL,CAAcE,IAAd,CAAmBD,OAAnB,EADmB,CAGnB;AACA;;AACA,WAAKH,KAAL,CAAWK,sBAAX,GAAoC,IAApC;AACA,WAAKL,KAAL,CAAWM,UAAX,CAAsB,IAAtB;;AAEA,UAAIC,OAAO,GAAG,YAAW;AACvBX,QAAAA,MAAM,CAACY,MAAP,CAAc,KAAKN,QAAnB,EAA6BC,OAA7B,EADuB,CAGvB;;AACA,YAAI,KAAKD,QAAL,CAAcO,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,eAAKC,OAAL;AACD;AACF,OAPa,CAOZC,IAPY,CAOP,IAPO,CAAd,CARmB,CAgBnB;;;AACAR,MAAAA,OAAO,CAACS,IAAR,CAAaL,OAAb,EAAsBA,OAAtB;AACD;;;kCAEa;AACZ,aAAO,KAAKL,QAAL,CAAcO,MAAd,GAAuB,CAA9B;AACD;;;2BAEMI,I,EAAM;AACXA,MAAAA,IAAI,GAAGjB,MAAM,CAACkB,MAAP,CAAcD,IAAd,CAAP,CADW,CAGX;;AACAA,MAAAA,IAAI,CAACE,OAAL,CAAa,UAASC,GAAT,EAAc;AACzB,aAAKf,OAAL,CAAae,GAAG,CAACC,EAAjB,IAAuBD,GAAvB;AACD,OAFD,EAEG,IAFH;AAGD;AAED;AACF;AACA;;;;8BACY;AACR,UAAI,KAAKhB,KAAL,CAAWkB,SAAf,EAA0B;AACxB;AACD;;AAED,UAAIL,IAAI,GAAGhB,OAAO,CAACsB,MAAR,CAAe,KAAKlB,OAApB,CAAX;AACA,WAAKD,KAAL,CAAWoB,UAAX,CAAsBP,IAAtB;AACA,WAAKZ,OAAL,GAAe,EAAf,CAPQ,CASR;;AACA,WAAKD,KAAL,CAAWM,UAAX,CAAsB,KAAtB;AACA,WAAKN,KAAL,CAAWK,sBAAX,GAAoC,KAApC;;AACA,UAAI,KAAKL,KAAL,CAAWqB,eAAX,EAAJ,EAAkC;AAChC,aAAKrB,KAAL,CAAWsB,eAAX;AACD;AACF;;;;;;SA9DkBvB,iB","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, objects, Table} from '../index';\n\nexport default class TableUpdateBuffer {\n\n  constructor(table) {\n    this._rowMap = {};\n    this.promises = [];\n    this.table = table;\n  }\n\n  /**\n   * The buffer is active if it contains at least one promise. When all promises resolve the buffer will be processed.\n   */\n  pushPromise(promise) {\n    this.promises.push(promise);\n\n    // Also make sure viewport is not rendered as long as update events are buffered\n    // Otherwise the other cells might already be visible during buffering\n    this.table._renderViewportBlocked = true;\n    this.table.setLoading(true);\n\n    var handler = function() {\n      arrays.remove(this.promises, promise);\n\n      // process immediately when all promises have resolved\n      if (this.promises.length === 0) {\n        this.process();\n      }\n    }.bind(this);\n    // Use then instead of always to ensure it is always executed asynchronous, even for null values\n    promise.then(handler, handler);\n  }\n\n  isBuffering() {\n    return this.promises.length > 0;\n  }\n\n  buffer(rows) {\n    rows = arrays.ensure(rows);\n\n    // Don't buffer duplicate rows\n    rows.forEach(function(row) {\n      this._rowMap[row.id] = row;\n    }, this);\n  }\n\n  /**\n   * Calls {@link Table.prototype.updateRows} with the buffered rows and renders the viewport if the rendering was blocked.\n   */\n  process() {\n    if (this.table.destroyed) {\n      return;\n    }\n\n    var rows = objects.values(this._rowMap);\n    this.table.updateRows(rows);\n    this._rowMap = {};\n\n    // Update the viewport as well if rendering was blocked\n    this.table.setLoading(false);\n    this.table._renderViewportBlocked = false;\n    if (this.table._isDataRendered()) {\n      this.table._renderViewport();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}