{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { keys, KeyStroke, TagBar } from '../../../index';\nimport $ from 'jquery';\n/**\n * @param fieldAdapter acts as an interface so we can use the same key-stroke for TagField and TagFieldPopup.\n *\n */\n\nvar TagFieldNavigationKeyStroke = /*#__PURE__*/function (_KeyStroke) {\n  _inherits(TagFieldNavigationKeyStroke, _KeyStroke);\n\n  var _super = _createSuper(TagFieldNavigationKeyStroke);\n\n  function TagFieldNavigationKeyStroke(fieldAdapter) {\n    var _this;\n\n    _classCallCheck(this, TagFieldNavigationKeyStroke);\n\n    _this = _super.call(this);\n    _this.fieldAdapter = fieldAdapter;\n    _this.which = [keys.LEFT, keys.RIGHT];\n    _this.preventDefault = false;\n    _this.preventInvokeAcceptInputOnActiveValueField = true;\n    return _this;\n  }\n\n  _createClass(TagFieldNavigationKeyStroke, [{\n    key: \"_accept\",\n    value: function _accept(event) {\n      var accepted = _get(_getPrototypeOf(TagFieldNavigationKeyStroke.prototype), \"_accept\", this).call(this, event);\n\n      if (!accepted) {\n        return false;\n      }\n\n      return this.fieldAdapter.enabled();\n    }\n  }, {\n    key: \"handle\",\n    value: function handle(event) {\n      if (event.which === keys.LEFT) {\n        this._focusTagElement(-1);\n      } else if (event.which === keys.RIGHT) {\n        this._focusTagElement(1);\n      }\n    }\n  }, {\n    key: \"_focusTagElement\",\n    value: function _focusTagElement(direction) {\n      var UNDEFINED = -1;\n      var INPUT = -2; // find overflow-icon and all tag-elements\n\n      var $focusTargets = TagBar.findFocusableTagElements(this.fieldAdapter.$container());\n      var numTargets = $focusTargets.length;\n\n      if (numTargets === 0) {\n        return;\n      } // check which element has the focus\n\n\n      var focusIndex = UNDEFINED;\n      $focusTargets.each(function (index) {\n        var $element = $(this);\n\n        if ($element.hasClass('focused')) {\n          focusIndex = index;\n        }\n      });\n\n      if (focusIndex === UNDEFINED) {\n        // no tag-elements focused currently\n        if (direction === -1) {\n          focusIndex = numTargets - 1;\n        }\n      } else {\n        var nextFocusIndex = focusIndex + direction;\n\n        if (nextFocusIndex >= numTargets) {\n          focusIndex = INPUT;\n        } else if (nextFocusIndex < 0) {\n          focusIndex = UNDEFINED;\n        } else {\n          TagBar.unfocusTagElement($focusTargets.eq(focusIndex));\n          focusIndex = nextFocusIndex;\n        }\n      }\n\n      if (focusIndex === UNDEFINED) {// leave focus untouched\n      } else if (focusIndex === INPUT) {\n        this.fieldAdapter.focus();\n      } else {\n        TagBar.focusTagElement($focusTargets.eq(focusIndex));\n      }\n    }\n  }]);\n\n  return TagFieldNavigationKeyStroke;\n}(KeyStroke);\n\nexport { TagFieldNavigationKeyStroke as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/form/fields/tagfield/TagFieldNavigationKeyStroke.js"],"names":["keys","KeyStroke","TagBar","$","TagFieldNavigationKeyStroke","fieldAdapter","which","LEFT","RIGHT","preventDefault","preventInvokeAcceptInputOnActiveValueField","event","accepted","enabled","_focusTagElement","direction","UNDEFINED","INPUT","$focusTargets","findFocusableTagElements","$container","numTargets","length","focusIndex","each","index","$element","hasClass","nextFocusIndex","unfocusTagElement","eq","focus","focusTagElement"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,IAAR,EAAcC,SAAd,EAAyBC,MAAzB,QAAsC,gBAAtC;AACA,OAAOC,CAAP,MAAc,QAAd;AAEA;AACA;AACA;AACA;;IACqBC,2B;;;;;AAEnB,uCAAYC,YAAZ,EAA0B;AAAA;;AAAA;;AACxB;AACA,UAAKA,YAAL,GAAoBA,YAApB;AACA,UAAKC,KAAL,GAAa,CAACN,IAAI,CAACO,IAAN,EAAYP,IAAI,CAACQ,KAAjB,CAAb;AACA,UAAKC,cAAL,GAAsB,KAAtB;AACA,UAAKC,0CAAL,GAAkD,IAAlD;AALwB;AAMzB;;;;4BAEOC,K,EAAO;AACb,UAAIC,QAAQ,4FAAiBD,KAAjB,CAAZ;;AACA,UAAI,CAACC,QAAL,EAAe;AACb,eAAO,KAAP;AACD;;AACD,aAAO,KAAKP,YAAL,CAAkBQ,OAAlB,EAAP;AACD;;;2BAEMF,K,EAAO;AACZ,UAAIA,KAAK,CAACL,KAAN,KAAgBN,IAAI,CAACO,IAAzB,EAA+B;AAC7B,aAAKO,gBAAL,CAAsB,CAAC,CAAvB;AACD,OAFD,MAEO,IAAIH,KAAK,CAACL,KAAN,KAAgBN,IAAI,CAACQ,KAAzB,EAAgC;AACrC,aAAKM,gBAAL,CAAsB,CAAtB;AACD;AACF;;;qCAEgBC,S,EAAW;AAC1B,UAAIC,SAAS,GAAG,CAAC,CAAjB;AACA,UAAIC,KAAK,GAAG,CAAC,CAAb,CAF0B,CAI1B;;AACA,UAAIC,aAAa,GAAGhB,MAAM,CAACiB,wBAAP,CAAgC,KAAKd,YAAL,CAAkBe,UAAlB,EAAhC,CAApB;AACA,UAAIC,UAAU,GAAGH,aAAa,CAACI,MAA/B;;AACA,UAAID,UAAU,KAAK,CAAnB,EAAsB;AACpB;AACD,OATyB,CAW1B;;;AACA,UAAIE,UAAU,GAAGP,SAAjB;AACAE,MAAAA,aAAa,CAACM,IAAd,CAAmB,UAASC,KAAT,EAAgB;AACjC,YAAIC,QAAQ,GAAGvB,CAAC,CAAC,IAAD,CAAhB;;AACA,YAAIuB,QAAQ,CAACC,QAAT,CAAkB,SAAlB,CAAJ,EAAkC;AAChCJ,UAAAA,UAAU,GAAGE,KAAb;AACD;AACF,OALD;;AAOA,UAAIF,UAAU,KAAKP,SAAnB,EAA8B;AAC5B;AACA,YAAID,SAAS,KAAK,CAAC,CAAnB,EAAsB;AACpBQ,UAAAA,UAAU,GAAGF,UAAU,GAAG,CAA1B;AACD;AACF,OALD,MAKO;AACL,YAAIO,cAAc,GAAGL,UAAU,GAAGR,SAAlC;;AACA,YAAIa,cAAc,IAAIP,UAAtB,EAAkC;AAChCE,UAAAA,UAAU,GAAGN,KAAb;AACD,SAFD,MAEO,IAAIW,cAAc,GAAG,CAArB,EAAwB;AAC7BL,UAAAA,UAAU,GAAGP,SAAb;AACD,SAFM,MAEA;AACLd,UAAAA,MAAM,CAAC2B,iBAAP,CAAyBX,aAAa,CAACY,EAAd,CAAiBP,UAAjB,CAAzB;AACAA,UAAAA,UAAU,GAAGK,cAAb;AACD;AACF;;AAED,UAAIL,UAAU,KAAKP,SAAnB,EAA8B,CAC5B;AACD,OAFD,MAEO,IAAIO,UAAU,KAAKN,KAAnB,EAA0B;AAC/B,aAAKZ,YAAL,CAAkB0B,KAAlB;AACD,OAFM,MAEA;AACL7B,QAAAA,MAAM,CAAC8B,eAAP,CAAuBd,aAAa,CAACY,EAAd,CAAiBP,UAAjB,CAAvB;AACD;AACF;;;;EAtEsDtB,S;;SAApCG,2B","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {keys, KeyStroke, TagBar} from '../../../index';\nimport $ from 'jquery';\n\n/**\n * @param fieldAdapter acts as an interface so we can use the same key-stroke for TagField and TagFieldPopup.\n *\n */\nexport default class TagFieldNavigationKeyStroke extends KeyStroke {\n\n  constructor(fieldAdapter) {\n    super();\n    this.fieldAdapter = fieldAdapter;\n    this.which = [keys.LEFT, keys.RIGHT];\n    this.preventDefault = false;\n    this.preventInvokeAcceptInputOnActiveValueField = true;\n  }\n\n  _accept(event) {\n    var accepted = super._accept(event);\n    if (!accepted) {\n      return false;\n    }\n    return this.fieldAdapter.enabled();\n  }\n\n  handle(event) {\n    if (event.which === keys.LEFT) {\n      this._focusTagElement(-1);\n    } else if (event.which === keys.RIGHT) {\n      this._focusTagElement(1);\n    }\n  }\n\n  _focusTagElement(direction) {\n    var UNDEFINED = -1;\n    var INPUT = -2;\n\n    // find overflow-icon and all tag-elements\n    var $focusTargets = TagBar.findFocusableTagElements(this.fieldAdapter.$container());\n    var numTargets = $focusTargets.length;\n    if (numTargets === 0) {\n      return;\n    }\n\n    // check which element has the focus\n    var focusIndex = UNDEFINED;\n    $focusTargets.each(function(index) {\n      var $element = $(this);\n      if ($element.hasClass('focused')) {\n        focusIndex = index;\n      }\n    });\n\n    if (focusIndex === UNDEFINED) {\n      // no tag-elements focused currently\n      if (direction === -1) {\n        focusIndex = numTargets - 1;\n      }\n    } else {\n      var nextFocusIndex = focusIndex + direction;\n      if (nextFocusIndex >= numTargets) {\n        focusIndex = INPUT;\n      } else if (nextFocusIndex < 0) {\n        focusIndex = UNDEFINED;\n      } else {\n        TagBar.unfocusTagElement($focusTargets.eq(focusIndex));\n        focusIndex = nextFocusIndex;\n      }\n    }\n\n    if (focusIndex === UNDEFINED) {\n      // leave focus untouched\n    } else if (focusIndex === INPUT) {\n      this.fieldAdapter.focus();\n    } else {\n      TagBar.focusTagElement($focusTargets.eq(focusIndex));\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}