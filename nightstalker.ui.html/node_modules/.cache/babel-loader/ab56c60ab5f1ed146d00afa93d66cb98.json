{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, GroupBoxMenuItemsOrder, HtmlComponent, keys, KeyStrokeContext, Menu, MenuBarLayout, MenuBarLeftKeyStroke, MenuBarRightKeyStroke, MenuDestinations, menus, scout, Widget } from '../../index';\nimport ComboMenu from '../ComboMenu';\n\nvar MenuBar = /*#__PURE__*/function (_Widget) {\n  _inherits(MenuBar, _Widget);\n\n  var _super = _createSuper(MenuBar);\n\n  function MenuBar() {\n    var _this;\n\n    _classCallCheck(this, MenuBar);\n\n    _this = _super.call(this);\n    _this.menuSorter = null;\n    _this.menuFilter = null;\n    _this.position = MenuBar.Position.TOP;\n    _this.tabbable = true;\n    _this.menuboxLeft = null;\n    _this.menuboxRight = null;\n    _this.menuItems = []; // original list of menuItems that was passed to setMenuItems(), only used to check if menubar has changed\n\n    _this.orderedMenuItems = {\n      left: [],\n      right: [],\n      all: []\n    };\n    _this.defaultMenu = null;\n    _this.visible = false;\n    _this.ellipsisPosition = MenuBar.EllipsisPosition.RIGHT;\n    _this._menuItemPropertyChangeHandler = _this._onMenuItemPropertyChange.bind(_assertThisInitialized(_this));\n    _this._focusHandler = _this._onMenuItemFocus.bind(_assertThisInitialized(_this));\n    _this.hiddenByUi = false;\n\n    _this._addWidgetProperties('menuItems');\n\n    return _this;\n  }\n\n  _createClass(MenuBar, [{\n    key: \"_init\",\n    value: function _init(options) {\n      _get(_getPrototypeOf(MenuBar.prototype), \"_init\", this).call(this, options);\n\n      this.menuSorter = options.menuOrder || new GroupBoxMenuItemsOrder();\n      this.menuSorter.menuBar = this;\n\n      if (options.menuFilter) {\n        this.menuFilter = function (menus, destination, onlyVisible, enableDisableKeyStroke) {\n          return options.menuFilter(menus, MenuDestinations.MENU_BAR, onlyVisible, enableDisableKeyStroke);\n        };\n      }\n\n      this.menuboxLeft = scout.create('MenubarBox', {\n        parent: this,\n        cssClass: 'left',\n        tooltipPosition: this._oppositePosition()\n      });\n      this.menuboxRight = scout.create('MenubarBox', {\n        parent: this,\n        cssClass: 'right',\n        tooltipPosition: this._oppositePosition()\n      });\n\n      this._setMenuItems(arrays.ensure(this.menuItems));\n\n      this.updateVisibility();\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      _get(_getPrototypeOf(MenuBar.prototype), \"_destroy\", this).call(this);\n\n      this._detachMenuHandlers();\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_createKeyStrokeContext\",\n    value: function _createKeyStrokeContext() {\n      return new KeyStrokeContext();\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      _get(_getPrototypeOf(MenuBar.prototype), \"_initKeyStrokeContext\", this).call(this);\n\n      this.keyStrokeContext.registerKeyStroke([new MenuBarLeftKeyStroke(this), new MenuBarRightKeyStroke(this)]);\n    }\n    /**\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      this.$container = this.$parent.appendDiv('menubar');\n      this.htmlComp = HtmlComponent.install(this.$container, this.session);\n      this.htmlComp.setLayout(new MenuBarLayout(this));\n      this.menuboxRight.render(this.$container);\n      this.menuboxLeft.render(this.$container);\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      _get(_getPrototypeOf(MenuBar.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderMenuItems();\n\n      this._renderPosition();\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(position) {\n      this.setProperty('position', position);\n    }\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition(position) {\n      this._setProperty('position', position);\n\n      this.menuboxLeft.setTooltipPosition(this._oppositePosition());\n      this.menuboxRight.setTooltipPosition(this._oppositePosition());\n    }\n  }, {\n    key: \"_renderPosition\",\n    value: function _renderPosition() {\n      this.$container.toggleClass('bottom', this.position === MenuBar.Position.BOTTOM);\n    }\n  }, {\n    key: \"_oppositePosition\",\n    value: function _oppositePosition() {\n      return this.position === MenuBar.Position.TOP ? MenuBar.Position.BOTTOM : MenuBar.Position.TOP;\n    }\n  }, {\n    key: \"setEllipsisPosition\",\n    value: function setEllipsisPosition(ellipsisPosition) {\n      this.setProperty('ellipsisPosition', ellipsisPosition);\n    }\n    /**\n     * Set the filter of the menu bar to all the menu items.\n     */\n\n  }, {\n    key: \"_setChildMenuFilters\",\n    value: function _setChildMenuFilters() {\n      this.orderedMenuItems.all.forEach(function (item) {\n        item.setMenuFilter(this.menuFilter);\n      }, this);\n    }\n    /**\n     * This function can be called multiple times. The function attaches the menu handlers only if they are not yet added.\n     */\n\n  }, {\n    key: \"_attachMenuHandlers\",\n    value: function _attachMenuHandlers() {\n      this.orderedMenuItems.all.forEach(function (item) {\n        if (item.events.count('propertyChange', this._menuItemPropertyChangeHandler) === 0) {\n          item.on('propertyChange', this._menuItemPropertyChangeHandler);\n        }\n\n        if (item.events.count('focus', this._focusHandler) === 0) {\n          item.on('focus', this._focusHandler);\n        }\n      }, this);\n    }\n  }, {\n    key: \"_detachMenuHandlers\",\n    value: function _detachMenuHandlers() {\n      this.orderedMenuItems.all.forEach(function (item) {\n        item.off('propertyChange', this._menuItemPropertyChangeHandler);\n        item.off('focus', this._focusHandler);\n      }.bind(this));\n    }\n  }, {\n    key: \"setMenuItems\",\n    value: function setMenuItems(menuItems) {\n      menuItems = arrays.ensure(menuItems);\n\n      if (arrays.equals(this.menuItems, menuItems)) {\n        // Ensure existing menus are correctly linked even if the given menuItems are the same (see TableSpec for reasons)\n        this.menuboxRight.link(this.menuboxRight.menuItems);\n        this.menuboxLeft.link(this.menuboxLeft.menuItems);\n        return;\n      }\n\n      this.setProperty('menuItems', menuItems);\n    }\n  }, {\n    key: \"_setMenuItems\",\n    value: function _setMenuItems(menuItems, rightFirst) {\n      // remove property listeners of old menu items.\n      this._detachMenuHandlers();\n\n      this.orderedMenuItems = this._createOrderedMenus(menuItems);\n\n      if (rightFirst) {\n        this.menuboxRight.setMenuItems(this.orderedMenuItems.right);\n        this.menuboxLeft.setMenuItems(this.orderedMenuItems.left);\n      } else {\n        this.menuboxLeft.setMenuItems(this.orderedMenuItems.left);\n        this.menuboxRight.setMenuItems(this.orderedMenuItems.right);\n      }\n\n      this._setChildMenuFilters();\n\n      this._attachMenuHandlers();\n\n      this.updateVisibility();\n      this.updateDefaultMenu();\n\n      this._updateTabbableMenu();\n\n      this._setProperty('menuItems', menuItems);\n    }\n  }, {\n    key: \"_renderMenuItems\",\n    value: function _renderMenuItems() {\n      this.updateLeftOfButtonMarker();\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_removeMenuItems\",\n    value: function _removeMenuItems() {// NOP: by implementing this function we avoid the call to Widget.js#_internalRemoveWidgets\n      // which would remove our menuItems, because they are defined as widget-property (see constructor).\n    }\n  }, {\n    key: \"_createOrderedMenus\",\n    value: function _createOrderedMenus(menuItems) {\n      var orderedMenuItems = this.menuSorter.order(menuItems, this),\n          ellipsisIndex = -1,\n          ellipsis;\n      orderedMenuItems.right.forEach(function (item) {\n        item.rightAligned = true;\n      });\n\n      if (orderedMenuItems.all.length > 0) {\n        if (this._ellipsis) {\n          // Disconnect existing child actions from ellipsis menu\n          this._ellipsis.setChildActions([]);\n\n          this._ellipsis.destroy();\n        }\n\n        ellipsis = scout.create('EllipsisMenu', {\n          parent: this,\n          cssClass: 'overflow-menu-item'\n        });\n        this._ellipsis = ellipsis; // add ellipsis to the correct position\n\n        if (this.ellipsisPosition === MenuBar.EllipsisPosition.RIGHT) {\n          // try right\n          var reverseIndexPosition = this._getFirstStackableIndexPosition(orderedMenuItems.right.slice().reverse());\n\n          if (reverseIndexPosition > -1) {\n            ellipsisIndex = orderedMenuItems.right.length - reverseIndexPosition;\n            ellipsis.rightAligned = true;\n            orderedMenuItems.right.splice(ellipsisIndex, 0, ellipsis);\n          } else {\n            // try left\n            reverseIndexPosition = this._getFirstStackableIndexPosition(orderedMenuItems.left.slice().reverse());\n\n            if (reverseIndexPosition > -1) {\n              ellipsisIndex = orderedMenuItems.left.length - reverseIndexPosition;\n              orderedMenuItems.left.splice(ellipsisIndex, 0, ellipsis);\n            }\n          }\n        } else {\n          // try left\n          ellipsisIndex = this._getFirstStackableIndexPosition(orderedMenuItems.left);\n\n          if (ellipsisIndex > -1) {\n            orderedMenuItems.left.splice(ellipsisIndex, 0, ellipsis);\n          } else {\n            // try right\n            ellipsisIndex = this._getFirstStackableIndexPosition(orderedMenuItems.right);\n\n            if (ellipsisIndex > -1) {\n              ellipsis.rightAligned = true;\n              orderedMenuItems.right.splice(ellipsisIndex, 0, ellipsis);\n            }\n          }\n        }\n\n        orderedMenuItems.all = orderedMenuItems.left.concat(orderedMenuItems.right);\n      }\n\n      return orderedMenuItems;\n    }\n  }, {\n    key: \"_getFirstStackableIndexPosition\",\n    value: function _getFirstStackableIndexPosition(menuList) {\n      var foundIndex = -1;\n      menuList.some(function (menu, index) {\n        if (menu.stackable && menu.visible) {\n          foundIndex = index;\n          return true;\n        }\n\n        return false;\n      }, this);\n      return foundIndex;\n    }\n  }, {\n    key: \"_updateTabbableMenu\",\n    value: function _updateTabbableMenu() {\n      // Make first valid MenuItem tabbable so that it can be focused. All other items\n      // are not tabbable. But they can be selected with the arrow keys.\n      if (this.tabbable) {\n        if (this.defaultMenu && this.defaultMenu.enabledComputed) {\n          this.setTabbableMenu(this.defaultMenu);\n        } else {\n          this.setTabbableMenu(arrays.find(this.orderedMenuItems.all, function (item) {\n            return item.isTabTarget();\n          }));\n        }\n      }\n    }\n  }, {\n    key: \"setTabbableMenu\",\n    value: function setTabbableMenu(menu) {\n      if (!this.tabbable || menu === this.tabbableMenu) {\n        return;\n      }\n\n      if (this.tabbableMenu) {\n        this.tabbableMenu.setTabbable(false);\n      }\n\n      this.tabbableMenu = menu;\n\n      if (menu) {\n        menu.setTabbable(true);\n      }\n    }\n    /**\n     * Sets the property hiddenByUi. This does not automatically update the visibility of the menus.\n     * We assume that #updateVisibility() is called later anyway.\n     *\n     * @param {boolean} hiddenByUi\n     */\n\n  }, {\n    key: \"setHiddenByUi\",\n    value: function setHiddenByUi(hiddenByUi) {\n      this.setProperty('hiddenByUi', hiddenByUi);\n    }\n  }, {\n    key: \"updateVisibility\",\n    value: function updateVisibility() {\n      menus.updateSeparatorVisibility(this.orderedMenuItems.left);\n      menus.updateSeparatorVisibility(this.orderedMenuItems.right);\n      this.setVisible(!this.hiddenByUi && this.orderedMenuItems.all.some(function (m) {\n        return m.visible && !m.ellipsis;\n      }));\n    }\n    /**\n     * First rendered item that is enabled and reacts to ENTER keystroke shall be marked as 'defaultMenu'\n     */\n\n  }, {\n    key: \"updateDefaultMenu\",\n    value: function updateDefaultMenu() {\n      var i, item;\n      var defaultMenu = null;\n\n      for (i = 0; i < this.orderedMenuItems.all.length; i++) {\n        item = this.orderedMenuItems.all[i];\n\n        if (!item.visible || !item.enabled || item.defaultMenu === false) {\n          // Invisible or disabled menus and menus that explicitly have the \"defaultMenu\"\n          // property set to false cannot be the default menu.\n          continue;\n        }\n\n        if (item.defaultMenu) {\n          defaultMenu = item;\n          break;\n        }\n\n        if (!defaultMenu && this._isDefaultKeyStroke(item.actionKeyStroke)) {\n          defaultMenu = item;\n        }\n      }\n\n      this.setDefaultMenu(defaultMenu);\n\n      if (defaultMenu && defaultMenu.isTabTarget()) {\n        this.setTabbableMenu(defaultMenu);\n      }\n    }\n  }, {\n    key: \"_isDefaultKeyStroke\",\n    value: function _isDefaultKeyStroke(keyStroke) {\n      return scout.isOneOf(keys.ENTER, keyStroke.which) && !keyStroke.ctrl && !keyStroke.alt && !keyStroke.shift;\n    }\n  }, {\n    key: \"setDefaultMenu\",\n    value: function setDefaultMenu(defaultMenu) {\n      this.setProperty('defaultMenu', defaultMenu);\n    }\n  }, {\n    key: \"_setDefaultMenu\",\n    value: function _setDefaultMenu(defaultMenu) {\n      if (this.defaultMenu) {\n        this.defaultMenu.setMenuStyle(Menu.MenuStyle.NONE);\n      }\n\n      if (defaultMenu) {\n        defaultMenu.setMenuStyle(Menu.MenuStyle.DEFAULT);\n      }\n\n      this._setProperty('defaultMenu', defaultMenu);\n    }\n    /**\n     * Add class 'left-of-button' to every menu item which is on the left of a button\n     */\n\n  }, {\n    key: \"updateLeftOfButtonMarker\",\n    value: function updateLeftOfButtonMarker() {\n      this._updateLeftOfButtonMarker(this.orderedMenuItems.left);\n\n      this._updateLeftOfButtonMarker(this.orderedMenuItems.right);\n    }\n  }, {\n    key: \"_updateLeftOfButtonMarker\",\n    value: function _updateLeftOfButtonMarker(items) {\n      var item, previousItem;\n      items = items.filter(function (item) {\n        return item.visible && item.rendered;\n      });\n\n      for (var i = 0; i < items.length; i++) {\n        item = items[i];\n        item.$container.removeClass('left-of-button');\n\n        if (i > 0 && item.isButton()) {\n          previousItem = items[i - 1];\n          previousItem.$container.addClass('left-of-button');\n        }\n      }\n    }\n  }, {\n    key: \"_onMenuItemPropertyChange\",\n    value: function _onMenuItemPropertyChange(event) {\n      // We do not update the items directly, because this listener may be fired many times in one\n      // user request (because many menus change one or more properties). Therefore, we just invalidate\n      // the MenuBarLayout. It will be updated automatically after the user request has finished,\n      // because the layout calls rebuildItemsInternal().\n      if (event.propertyName === 'overflown' || event.propertyName === 'enabled' || event.propertyName === 'visible' || event.propertyName === 'hidden') {\n        if (!this.tabbableMenu || event.source === this.tabbableMenu) {\n          this._updateTabbableMenu();\n        }\n      }\n\n      if (event.propertyName === 'overflown' || event.propertyName === 'hidden') {\n        if (!this.defaultMenu || event.source === this.defaultMenu) {\n          this.updateDefaultMenu();\n        }\n      }\n\n      if (event.propertyName === 'horizontalAlignment') {\n        // reorder\n        this.reorderMenus(event.newValue <= 0);\n      }\n\n      if (event.propertyName === 'visible') {\n        var oldVisible = this.visible;\n        this.updateVisibility();\n\n        if (!oldVisible && this.visible) {\n          // If the menubar was previously invisible (because all menus were invisible) but\n          // is now visible, the menuboxes and the menus have to be rendered now. Otherwise,\n          // calculating the preferred size of the menubar, e.g. in the TableLayout, would\n          // return the wrong value (even if the menubar itself is visible).\n          this.revalidateLayout();\n        } // recalculate position of ellipsis if any menu item changed visibility.\n        // separators may change visibility during reordering menu items. Since separators do not have any\n        // impact of right/left order of menu items they have not to be considered to enforce a reorder.\n\n\n        if (!event.source.separator) {\n          this.reorderMenus();\n        }\n      }\n\n      if (event.propertyName === 'keyStroke' || event.propertyName === 'enabled' || event.propertyName === 'defaultMenu' || event.propertyName === 'visible') {\n        this.updateDefaultMenu();\n      }\n    }\n  }, {\n    key: \"_onMenuItemFocus\",\n    value: function _onMenuItemFocus(event) {\n      this.setTabbableMenu(event.source);\n    }\n  }, {\n    key: \"reorderMenus\",\n    value: function reorderMenus(rightFirst) {\n      var menuItems = this.menuItems;\n\n      this._setMenuItems(menuItems, rightFirst);\n\n      if (this.rendered) {\n        this.updateLeftOfButtonMarker();\n      }\n    }\n  }, {\n    key: \"_allMenusAsFlatList\",\n    value: function _allMenusAsFlatList() {\n      return arrays.flatMap(this.orderedMenuItems.all, function (item) {\n        if (item instanceof ComboMenu) {\n          return item.childActions;\n        }\n\n        return [item];\n      });\n    }\n  }]);\n\n  return MenuBar;\n}(Widget);\n\n_defineProperty(MenuBar, \"EllipsisPosition\", {\n  LEFT: 'left',\n  RIGHT: 'right'\n});\n\n_defineProperty(MenuBar, \"Position\", {\n  TOP: 'top',\n  BOTTOM: 'bottom'\n});\n\nexport { MenuBar as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/menu/menubar/MenuBar.js"],"names":["arrays","GroupBoxMenuItemsOrder","HtmlComponent","keys","KeyStrokeContext","Menu","MenuBarLayout","MenuBarLeftKeyStroke","MenuBarRightKeyStroke","MenuDestinations","menus","scout","Widget","ComboMenu","MenuBar","menuSorter","menuFilter","position","Position","TOP","tabbable","menuboxLeft","menuboxRight","menuItems","orderedMenuItems","left","right","all","defaultMenu","visible","ellipsisPosition","EllipsisPosition","RIGHT","_menuItemPropertyChangeHandler","_onMenuItemPropertyChange","bind","_focusHandler","_onMenuItemFocus","hiddenByUi","_addWidgetProperties","options","menuOrder","menuBar","destination","onlyVisible","enableDisableKeyStroke","MENU_BAR","create","parent","cssClass","tooltipPosition","_oppositePosition","_setMenuItems","ensure","updateVisibility","_detachMenuHandlers","keyStrokeContext","registerKeyStroke","$container","$parent","appendDiv","htmlComp","install","session","setLayout","render","_renderMenuItems","_renderPosition","setProperty","_setProperty","setTooltipPosition","toggleClass","BOTTOM","forEach","item","setMenuFilter","events","count","on","off","equals","link","rightFirst","_createOrderedMenus","setMenuItems","_setChildMenuFilters","_attachMenuHandlers","updateDefaultMenu","_updateTabbableMenu","updateLeftOfButtonMarker","invalidateLayoutTree","order","ellipsisIndex","ellipsis","rightAligned","length","_ellipsis","setChildActions","destroy","reverseIndexPosition","_getFirstStackableIndexPosition","slice","reverse","splice","concat","menuList","foundIndex","some","menu","index","stackable","enabledComputed","setTabbableMenu","find","isTabTarget","tabbableMenu","setTabbable","updateSeparatorVisibility","setVisible","m","i","enabled","_isDefaultKeyStroke","actionKeyStroke","setDefaultMenu","keyStroke","isOneOf","ENTER","which","ctrl","alt","shift","setMenuStyle","MenuStyle","NONE","DEFAULT","_updateLeftOfButtonMarker","items","previousItem","filter","rendered","removeClass","isButton","addClass","event","propertyName","source","reorderMenus","newValue","oldVisible","revalidateLayout","separator","flatMap","childActions","LEFT"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  arrays,\n  GroupBoxMenuItemsOrder,\n  HtmlComponent,\n  keys,\n  KeyStrokeContext,\n  Menu,\n  MenuBarLayout,\n  MenuBarLeftKeyStroke,\n  MenuBarRightKeyStroke,\n  MenuDestinations,\n  menus,\n  scout,\n  Widget\n} from '../../index';\nimport ComboMenu from '../ComboMenu';\n\nexport default class MenuBar extends Widget {\n\n  constructor() {\n    super();\n\n    this.menuSorter = null;\n    this.menuFilter = null;\n    this.position = MenuBar.Position.TOP;\n    this.tabbable = true;\n    this.menuboxLeft = null;\n    this.menuboxRight = null;\n    this.menuItems = []; // original list of menuItems that was passed to setMenuItems(), only used to check if menubar has changed\n    this.orderedMenuItems = {\n      left: [],\n      right: [],\n      all: []\n    };\n    this.defaultMenu = null;\n    this.visible = false;\n    this.ellipsisPosition = MenuBar.EllipsisPosition.RIGHT;\n    this._menuItemPropertyChangeHandler = this._onMenuItemPropertyChange.bind(this);\n    this._focusHandler = this._onMenuItemFocus.bind(this);\n    this.hiddenByUi = false;\n    this._addWidgetProperties('menuItems');\n  }\n\n  static EllipsisPosition = {\n    LEFT: 'left',\n    RIGHT: 'right'\n  };\n\n  static Position = {\n    TOP: 'top',\n    BOTTOM: 'bottom'\n  };\n\n  _init(options) {\n    super._init(options);\n\n    this.menuSorter = options.menuOrder || new GroupBoxMenuItemsOrder();\n    this.menuSorter.menuBar = this;\n    if (options.menuFilter) {\n      this.menuFilter = function(menus, destination, onlyVisible, enableDisableKeyStroke) {\n        return options.menuFilter(menus, MenuDestinations.MENU_BAR, onlyVisible, enableDisableKeyStroke);\n      };\n    }\n\n    this.menuboxLeft = scout.create('MenubarBox', {\n      parent: this,\n      cssClass: 'left',\n      tooltipPosition: this._oppositePosition()\n    });\n    this.menuboxRight = scout.create('MenubarBox', {\n      parent: this,\n      cssClass: 'right',\n      tooltipPosition: this._oppositePosition()\n    });\n\n    this._setMenuItems(arrays.ensure(this.menuItems));\n    this.updateVisibility();\n  }\n\n  _destroy() {\n    super._destroy();\n    this._detachMenuHandlers();\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke([\n      new MenuBarLeftKeyStroke(this),\n      new MenuBarRightKeyStroke(this)\n    ]);\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _render() {\n    this.$container = this.$parent.appendDiv('menubar');\n\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(new MenuBarLayout(this));\n\n    this.menuboxRight.render(this.$container);\n    this.menuboxLeft.render(this.$container);\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderMenuItems();\n    this._renderPosition();\n  }\n\n  setPosition(position) {\n    this.setProperty('position', position);\n  }\n\n  _setPosition(position) {\n    this._setProperty('position', position);\n    this.menuboxLeft.setTooltipPosition(this._oppositePosition());\n    this.menuboxRight.setTooltipPosition(this._oppositePosition());\n  }\n\n  _renderPosition() {\n    this.$container.toggleClass('bottom', this.position === MenuBar.Position.BOTTOM);\n  }\n\n  _oppositePosition() {\n    return this.position === MenuBar.Position.TOP ?\n      MenuBar.Position.BOTTOM : MenuBar.Position.TOP;\n  }\n\n  setEllipsisPosition(ellipsisPosition) {\n    this.setProperty('ellipsisPosition', ellipsisPosition);\n  }\n\n  /**\n   * Set the filter of the menu bar to all the menu items.\n   */\n  _setChildMenuFilters() {\n    this.orderedMenuItems.all.forEach(function(item) {\n      item.setMenuFilter(this.menuFilter);\n    }, this);\n  }\n\n  /**\n   * This function can be called multiple times. The function attaches the menu handlers only if they are not yet added.\n   */\n  _attachMenuHandlers() {\n    this.orderedMenuItems.all.forEach(function(item) {\n      if (item.events.count('propertyChange', this._menuItemPropertyChangeHandler) === 0) {\n        item.on('propertyChange', this._menuItemPropertyChangeHandler);\n      }\n      if (item.events.count('focus', this._focusHandler) === 0) {\n        item.on('focus', this._focusHandler);\n      }\n    }, this);\n  }\n\n  _detachMenuHandlers() {\n    this.orderedMenuItems.all.forEach(function(item) {\n      item.off('propertyChange', this._menuItemPropertyChangeHandler);\n      item.off('focus', this._focusHandler);\n    }.bind(this));\n  }\n\n  setMenuItems(menuItems) {\n    menuItems = arrays.ensure(menuItems);\n    if (arrays.equals(this.menuItems, menuItems)) {\n      // Ensure existing menus are correctly linked even if the given menuItems are the same (see TableSpec for reasons)\n      this.menuboxRight.link(this.menuboxRight.menuItems);\n      this.menuboxLeft.link(this.menuboxLeft.menuItems);\n      return;\n    }\n    this.setProperty('menuItems', menuItems);\n  }\n\n  _setMenuItems(menuItems, rightFirst) {\n    // remove property listeners of old menu items.\n    this._detachMenuHandlers();\n    this.orderedMenuItems = this._createOrderedMenus(menuItems);\n\n    if (rightFirst) {\n      this.menuboxRight.setMenuItems(this.orderedMenuItems.right);\n      this.menuboxLeft.setMenuItems(this.orderedMenuItems.left);\n\n    } else {\n      this.menuboxLeft.setMenuItems(this.orderedMenuItems.left);\n      this.menuboxRight.setMenuItems(this.orderedMenuItems.right);\n    }\n\n    this._setChildMenuFilters();\n    this._attachMenuHandlers();\n\n    this.updateVisibility();\n    this.updateDefaultMenu();\n    this._updateTabbableMenu();\n\n    this._setProperty('menuItems', menuItems);\n  }\n\n  _renderMenuItems() {\n    this.updateLeftOfButtonMarker();\n    this.invalidateLayoutTree();\n  }\n\n  _removeMenuItems() {\n    // NOP: by implementing this function we avoid the call to Widget.js#_internalRemoveWidgets\n    // which would remove our menuItems, because they are defined as widget-property (see constructor).\n  }\n\n  _createOrderedMenus(menuItems) {\n    var orderedMenuItems = this.menuSorter.order(menuItems, this),\n      ellipsisIndex = -1,\n      ellipsis;\n    orderedMenuItems.right.forEach(function(item) {\n      item.rightAligned = true;\n    });\n\n    if (orderedMenuItems.all.length > 0) {\n      if (this._ellipsis) {\n        // Disconnect existing child actions from ellipsis menu\n        this._ellipsis.setChildActions([]);\n        this._ellipsis.destroy();\n      }\n      ellipsis = scout.create('EllipsisMenu', {\n        parent: this,\n        cssClass: 'overflow-menu-item'\n      });\n      this._ellipsis = ellipsis;\n\n      // add ellipsis to the correct position\n      if (this.ellipsisPosition === MenuBar.EllipsisPosition.RIGHT) {\n        // try right\n        var reverseIndexPosition = this._getFirstStackableIndexPosition(orderedMenuItems.right.slice().reverse());\n        if (reverseIndexPosition > -1) {\n          ellipsisIndex = orderedMenuItems.right.length - reverseIndexPosition;\n          ellipsis.rightAligned = true;\n          orderedMenuItems.right.splice(ellipsisIndex, 0, ellipsis);\n        } else {\n          // try left\n          reverseIndexPosition = this._getFirstStackableIndexPosition(orderedMenuItems.left.slice().reverse());\n          if (reverseIndexPosition > -1) {\n            ellipsisIndex = orderedMenuItems.left.length - reverseIndexPosition;\n            orderedMenuItems.left.splice(ellipsisIndex, 0, ellipsis);\n          }\n        }\n      } else {\n        // try left\n        ellipsisIndex = this._getFirstStackableIndexPosition(orderedMenuItems.left);\n        if (ellipsisIndex > -1) {\n          orderedMenuItems.left.splice(ellipsisIndex, 0, ellipsis);\n        } else {\n          // try right\n          ellipsisIndex = this._getFirstStackableIndexPosition(orderedMenuItems.right);\n          if (ellipsisIndex > -1) {\n            ellipsis.rightAligned = true;\n            orderedMenuItems.right.splice(ellipsisIndex, 0, ellipsis);\n          }\n        }\n      }\n      orderedMenuItems.all = orderedMenuItems.left.concat(orderedMenuItems.right);\n    }\n    return orderedMenuItems;\n  }\n\n  _getFirstStackableIndexPosition(menuList) {\n    var foundIndex = -1;\n    menuList.some(function(menu, index) {\n      if (menu.stackable && menu.visible) {\n        foundIndex = index;\n        return true;\n      }\n      return false;\n    }, this);\n\n    return foundIndex;\n  }\n\n  _updateTabbableMenu() {\n    // Make first valid MenuItem tabbable so that it can be focused. All other items\n    // are not tabbable. But they can be selected with the arrow keys.\n    if (this.tabbable) {\n      if (this.defaultMenu && this.defaultMenu.enabledComputed) {\n        this.setTabbableMenu(this.defaultMenu);\n      } else {\n        this.setTabbableMenu(arrays.find(this.orderedMenuItems.all, function(item) {\n          return item.isTabTarget();\n        }));\n      }\n    }\n  }\n\n  setTabbableMenu(menu) {\n    if (!this.tabbable || menu === this.tabbableMenu) {\n      return;\n    }\n    if (this.tabbableMenu) {\n      this.tabbableMenu.setTabbable(false);\n    }\n    this.tabbableMenu = menu;\n    if (menu) {\n      menu.setTabbable(true);\n    }\n  }\n\n  /**\n   * Sets the property hiddenByUi. This does not automatically update the visibility of the menus.\n   * We assume that #updateVisibility() is called later anyway.\n   *\n   * @param {boolean} hiddenByUi\n   */\n  setHiddenByUi(hiddenByUi) {\n    this.setProperty('hiddenByUi', hiddenByUi);\n  }\n\n  updateVisibility() {\n    menus.updateSeparatorVisibility(this.orderedMenuItems.left);\n    menus.updateSeparatorVisibility(this.orderedMenuItems.right);\n    this.setVisible(!this.hiddenByUi && this.orderedMenuItems.all.some(function(m) {\n      return m.visible && !m.ellipsis;\n    }));\n  }\n\n  /**\n   * First rendered item that is enabled and reacts to ENTER keystroke shall be marked as 'defaultMenu'\n   */\n  updateDefaultMenu() {\n    var i, item;\n    var defaultMenu = null;\n    for (i = 0; i < this.orderedMenuItems.all.length; i++) {\n      item = this.orderedMenuItems.all[i];\n\n      if (!item.visible || !item.enabled || item.defaultMenu === false) {\n        // Invisible or disabled menus and menus that explicitly have the \"defaultMenu\"\n        // property set to false cannot be the default menu.\n        continue;\n      }\n      if (item.defaultMenu) {\n        defaultMenu = item;\n        break;\n      }\n      if (!defaultMenu && this._isDefaultKeyStroke(item.actionKeyStroke)) {\n        defaultMenu = item;\n      }\n    }\n\n    this.setDefaultMenu(defaultMenu);\n    if (defaultMenu && defaultMenu.isTabTarget()) {\n      this.setTabbableMenu(defaultMenu);\n    }\n  }\n\n  _isDefaultKeyStroke(keyStroke) {\n    return scout.isOneOf(keys.ENTER, keyStroke.which) &&\n      !keyStroke.ctrl &&\n      !keyStroke.alt &&\n      !keyStroke.shift;\n  }\n\n  setDefaultMenu(defaultMenu) {\n    this.setProperty('defaultMenu', defaultMenu);\n  }\n\n  _setDefaultMenu(defaultMenu) {\n    if (this.defaultMenu) {\n      this.defaultMenu.setMenuStyle(Menu.MenuStyle.NONE);\n    }\n    if (defaultMenu) {\n      defaultMenu.setMenuStyle(Menu.MenuStyle.DEFAULT);\n    }\n    this._setProperty('defaultMenu', defaultMenu);\n  }\n\n  /**\n   * Add class 'left-of-button' to every menu item which is on the left of a button\n   */\n  updateLeftOfButtonMarker() {\n    this._updateLeftOfButtonMarker(this.orderedMenuItems.left);\n    this._updateLeftOfButtonMarker(this.orderedMenuItems.right);\n  }\n\n  _updateLeftOfButtonMarker(items) {\n    var item, previousItem;\n\n    items = items.filter(function(item) {\n      return item.visible && item.rendered;\n    });\n\n    for (var i = 0; i < items.length; i++) {\n      item = items[i];\n      item.$container.removeClass('left-of-button');\n      if (i > 0 && item.isButton()) {\n        previousItem = items[i - 1];\n        previousItem.$container.addClass('left-of-button');\n      }\n    }\n  }\n\n  _onMenuItemPropertyChange(event) {\n    // We do not update the items directly, because this listener may be fired many times in one\n    // user request (because many menus change one or more properties). Therefore, we just invalidate\n    // the MenuBarLayout. It will be updated automatically after the user request has finished,\n    // because the layout calls rebuildItemsInternal().\n    if (event.propertyName === 'overflown' || event.propertyName === 'enabled' || event.propertyName === 'visible' || event.propertyName === 'hidden') {\n      if (!this.tabbableMenu || event.source === this.tabbableMenu) {\n        this._updateTabbableMenu();\n      }\n    }\n    if (event.propertyName === 'overflown' || event.propertyName === 'hidden') {\n      if (!this.defaultMenu || event.source === this.defaultMenu) {\n        this.updateDefaultMenu();\n      }\n    }\n    if (event.propertyName === 'horizontalAlignment') {\n      // reorder\n      this.reorderMenus(event.newValue <= 0);\n    }\n    if (event.propertyName === 'visible') {\n      var oldVisible = this.visible;\n      this.updateVisibility();\n      if (!oldVisible && this.visible) {\n        // If the menubar was previously invisible (because all menus were invisible) but\n        // is now visible, the menuboxes and the menus have to be rendered now. Otherwise,\n        // calculating the preferred size of the menubar, e.g. in the TableLayout, would\n        // return the wrong value (even if the menubar itself is visible).\n        this.revalidateLayout();\n      }\n      // recalculate position of ellipsis if any menu item changed visibility.\n      // separators may change visibility during reordering menu items. Since separators do not have any\n      // impact of right/left order of menu items they have not to be considered to enforce a reorder.\n      if (!event.source.separator) {\n        this.reorderMenus();\n      }\n    }\n    if (event.propertyName === 'keyStroke' || event.propertyName === 'enabled' || event.propertyName === 'defaultMenu' || event.propertyName === 'visible') {\n      this.updateDefaultMenu();\n    }\n  }\n\n  _onMenuItemFocus(event) {\n    this.setTabbableMenu(event.source);\n  }\n\n  reorderMenus(rightFirst) {\n    var menuItems = this.menuItems;\n    this._setMenuItems(menuItems, rightFirst);\n    if (this.rendered) {\n      this.updateLeftOfButtonMarker();\n    }\n  }\n\n  _allMenusAsFlatList() {\n    return arrays.flatMap(this.orderedMenuItems.all, item => {\n      if (item instanceof ComboMenu) {\n        return item.childActions;\n      }\n      return [item];\n    });\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}