{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { AbstractGrid, LogicalGridMatrix, LogicalGridMatrixCell, LogicalGridMatrixCursor } from '../../../index';\n\nvar VerticalGridMatrix = /*#__PURE__*/function (_LogicalGridMatrix) {\n  _inherits(VerticalGridMatrix, _LogicalGridMatrix);\n\n  var _super = _createSuper(VerticalGridMatrix);\n\n  function VerticalGridMatrix(columnCount, rowCount, x, y) {\n    var _this;\n\n    _classCallCheck(this, VerticalGridMatrix);\n\n    _this = _super.call(this, new LogicalGridMatrixCursor(x || 0, y || 0, columnCount, rowCount, LogicalGridMatrixCursor.VERTICAL));\n    _this._widgets = [];\n    _this._widgetGridDatas = [];\n    return _this;\n  }\n\n  _createClass(VerticalGridMatrix, [{\n    key: \"resetAll\",\n    value: function resetAll(columnCount, rowCount) {\n      this._widgetGridDatas = [];\n      this._assignedCells = [];\n      this._widgetIndexes = [];\n      this._cursor = new LogicalGridMatrixCursor(this._cursor.startX, this._cursor.startY, columnCount, rowCount, LogicalGridMatrixCursor.VERTICAL);\n    }\n  }, {\n    key: \"computeGridData\",\n    value: function computeGridData(widgets) {\n      this._widgets = widgets;\n      return widgets.every(function (f, i) {\n        this._widgetGridDatas[i] = AbstractGrid.getGridDataFromHints(f, this._cursor.columnCount);\n        return this._add(f, this._widgetGridDatas[i]);\n      }.bind(this));\n    }\n  }, {\n    key: \"getGridData\",\n    value: function getGridData(f) {\n      return this._widgetGridDatas[this._widgets.indexOf(f)];\n    }\n  }, {\n    key: \"_addAssignedCells\",\n    value: function _addAssignedCells(cells) {\n      cells.forEach(function (v, i) {\n        if (v) {\n          v.forEach(function (w, j) {\n            if (w) {\n              this._setAssignedCell({\n                x: i,\n                y: j\n              }, w);\n            }\n          }.bind(this));\n        }\n      }.bind(this));\n    }\n  }, {\n    key: \"_getAssignedCells\",\n    value: function _getAssignedCells() {\n      return this._assignedCells;\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(f, gd) {\n      var idx = this._cursor.currentIndex();\n\n      if (gd.w > 1) {\n        // try to reorganize widgets above\n        var x = idx.x,\n            y = idx.y; // try to move left if the right border of the widget is outside the column range\n\n        while (x + gd.w > this._cursor.startX + this._cursor.columnCount) {\n          // shift left and bottom\n          x--;\n          y = this._cursor.rowCount - 1;\n        }\n\n        this._reorganizeGridAbove(x, y, gd.w);\n      }\n\n      if (!this._nextFree(gd.w, gd.h)) {\n        return false;\n      }\n\n      idx = this._cursor.currentIndex();\n      gd.x = idx.x;\n      gd.y = idx.y; // add widget\n\n      for (var xx = idx.x; xx < idx.x + gd.w; xx++) {\n        for (var yy = idx.y; yy < idx.y + gd.h; yy++) {\n          this._setAssignedCell({\n            x: xx,\n            y: yy\n          }, new LogicalGridMatrixCell(f, gd));\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_reorganizeGridAbove\",\n    value: function _reorganizeGridAbove(x, y, w) {\n      var widgetsToReorganize = [];\n\n      var addWidgetToReorganize = function addWidgetToReorganize(f) {\n        if (widgetsToReorganize.indexOf(f) === -1) {\n          widgetsToReorganize.push(f);\n        }\n      };\n\n      var occupiedCells = [];\n\n      var setOccupiedCell = function setOccupiedCell(x, y, val) {\n        if (!occupiedCells[x]) {\n          occupiedCells[x] = [];\n        }\n\n        occupiedCells[x][y] = val;\n      };\n\n      var reorgBounds = {\n        x: x,\n        y: 0,\n        w: w,\n        h: y + 1\n      }; // x, y, w, h\n\n      var minY = y;\n      var usedCells = 0;\n      var continueLoop = true;\n\n      for (var yi = y; yi >= 0 && continueLoop; yi--) {\n        for (var xi = x; xi < x + w && continueLoop; xi++) {\n          var idx = {\n            x: xi,\n            y: yi\n          };\n\n          var cell = this._getAssignedCell(idx);\n\n          if (cell && !cell.isEmpty()) {\n            var gd = cell.data;\n\n            if (this._horizontalMatchesOrOverlaps(reorgBounds, gd)) {\n              continueLoop = false;\n            } else if (this._horizontalOverlapsOnSide(reorgBounds, gd)) {\n              // freeze the cells for reorganization\n              setOccupiedCell(idx.x, idx.y, cell);\n              usedCells++;\n              minY = Math.min(idx.y, minY);\n            } else {\n              // add widget to reorganization\n              this._setAssignedCell(idx, null);\n\n              addWidgetToReorganize(cell.widget);\n              usedCells++;\n              minY = Math.min(idx.y, minY);\n            }\n          }\n        }\n      }\n\n      if (widgetsToReorganize.length === 0) {\n        return;\n      }\n\n      widgetsToReorganize.sort(function (a, b) {\n        return this._widgets.indexOf(a) < this._widgets.indexOf(b) ? -1 : 1;\n      }.bind(this));\n      reorgBounds.y = minY;\n      var reorgMatrix = new VerticalGridMatrix(reorgBounds.w, Math.floor((usedCells + reorgBounds.w - 1) / reorgBounds.w), reorgBounds.x, reorgBounds.y);\n\n      reorgMatrix._addAssignedCells(occupiedCells);\n\n      while (!reorgMatrix.computeGridData(widgetsToReorganize)) {\n        reorgMatrix.resetAll(reorgMatrix.getColumnCount(), reorgMatrix.getRowCount() + 1);\n      }\n\n      this._cursor.reset();\n\n      this._addAssignedCells(reorgMatrix._getAssignedCells());\n\n      reorgMatrix._widgetGridDatas.forEach(function (v, i) {\n        this._widgetGridDatas[this._widgets.indexOf(reorgMatrix._widgets[i])] = v;\n      }.bind(this));\n    }\n  }, {\n    key: \"_horizontalMatchesOrOverlaps\",\n    value: function _horizontalMatchesOrOverlaps(bounds, gd) {\n      return bounds.x >= gd.x && bounds.x + bounds.w <= gd.x + gd.w;\n    }\n  }, {\n    key: \"_horizontalOverlapsOnSide\",\n    value: function _horizontalOverlapsOnSide(bounds, gd) {\n      return bounds.x > gd.x || bounds.x + bounds.w < gd.x + gd.w;\n    }\n  }]);\n\n  return VerticalGridMatrix;\n}(LogicalGridMatrix);\n\nexport { VerticalGridMatrix as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/layout/logicalgrid/matrix/VerticalGridMatrix.js"],"names":["AbstractGrid","LogicalGridMatrix","LogicalGridMatrixCell","LogicalGridMatrixCursor","VerticalGridMatrix","columnCount","rowCount","x","y","VERTICAL","_widgets","_widgetGridDatas","_assignedCells","_widgetIndexes","_cursor","startX","startY","widgets","every","f","i","getGridDataFromHints","_add","bind","indexOf","cells","forEach","v","w","j","_setAssignedCell","gd","idx","currentIndex","_reorganizeGridAbove","_nextFree","h","xx","yy","widgetsToReorganize","addWidgetToReorganize","push","occupiedCells","setOccupiedCell","val","reorgBounds","minY","usedCells","continueLoop","yi","xi","cell","_getAssignedCell","isEmpty","data","_horizontalMatchesOrOverlaps","_horizontalOverlapsOnSide","Math","min","widget","length","sort","a","b","reorgMatrix","floor","_addAssignedCells","computeGridData","resetAll","getColumnCount","getRowCount","reset","_getAssignedCells","bounds"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {AbstractGrid, LogicalGridMatrix, LogicalGridMatrixCell, LogicalGridMatrixCursor} from '../../../index';\n\nexport default class VerticalGridMatrix extends LogicalGridMatrix {\n\n  constructor(columnCount, rowCount, x, y) {\n    super(new LogicalGridMatrixCursor(x || 0, y || 0, columnCount, rowCount, LogicalGridMatrixCursor.VERTICAL));\n\n    this._widgets = [];\n    this._widgetGridDatas = [];\n  }\n\n  resetAll(columnCount, rowCount) {\n    this._widgetGridDatas = [];\n    this._assignedCells = [];\n    this._widgetIndexes = [];\n    this._cursor = new LogicalGridMatrixCursor(this._cursor.startX, this._cursor.startY, columnCount, rowCount, LogicalGridMatrixCursor.VERTICAL);\n  }\n\n  computeGridData(widgets) {\n    this._widgets = widgets;\n    return widgets.every(function(f, i) {\n      this._widgetGridDatas[i] = AbstractGrid.getGridDataFromHints(f, this._cursor.columnCount);\n      return this._add(f, this._widgetGridDatas[i]);\n    }.bind(this));\n  }\n\n  getGridData(f) {\n    return this._widgetGridDatas[this._widgets.indexOf(f)];\n  }\n\n  _addAssignedCells(cells) {\n    cells.forEach(function(v, i) {\n      if (v) {\n        v.forEach(function(w, j) {\n          if (w) {\n            this._setAssignedCell({\n              x: i,\n              y: j\n            }, w);\n          }\n        }.bind(this));\n      }\n    }.bind(this));\n  }\n\n  _getAssignedCells() {\n    return this._assignedCells;\n  }\n\n  _add(f, gd) {\n    var idx = this._cursor.currentIndex();\n    if (gd.w > 1) {\n      // try to reorganize widgets above\n      var x = idx.x,\n        y = idx.y;\n      // try to move left if the right border of the widget is outside the column range\n      while (x + gd.w > this._cursor.startX + this._cursor.columnCount) {\n        // shift left and bottom\n        x--;\n        y = this._cursor.rowCount - 1;\n      }\n      this._reorganizeGridAbove(x, y, gd.w);\n    }\n    if (!this._nextFree(gd.w, gd.h)) {\n      return false;\n    }\n    idx = this._cursor.currentIndex();\n    gd.x = idx.x;\n    gd.y = idx.y;\n    // add widget\n    for (var xx = idx.x; xx < idx.x + gd.w; xx++) {\n      for (var yy = idx.y; yy < idx.y + gd.h; yy++) {\n        this._setAssignedCell({\n          x: xx,\n          y: yy\n        }, new LogicalGridMatrixCell(f, gd));\n      }\n    }\n    return true;\n  }\n\n  _reorganizeGridAbove(x, y, w) {\n    var widgetsToReorganize = [];\n    var addWidgetToReorganize = function(f) {\n      if (widgetsToReorganize.indexOf(f) === -1) {\n        widgetsToReorganize.push(f);\n      }\n    };\n    var occupiedCells = [];\n    var setOccupiedCell = function(x, y, val) {\n      if (!occupiedCells[x]) {\n        occupiedCells[x] = [];\n      }\n      occupiedCells[x][y] = val;\n    };\n    var reorgBounds = {\n      x: x,\n      y: 0,\n      w: w,\n      h: y + 1\n    }; // x, y, w, h\n\n    var minY = y;\n    var usedCells = 0;\n    var continueLoop = true;\n    for (var yi = y; yi >= 0 && continueLoop; yi--) {\n      for (var xi = x; xi < x + w && continueLoop; xi++) {\n        var idx = {\n          x: xi,\n          y: yi\n        };\n        var cell = this._getAssignedCell(idx);\n        if (cell && !cell.isEmpty()) {\n          var gd = cell.data;\n          if (this._horizontalMatchesOrOverlaps(reorgBounds, gd)) {\n            continueLoop = false;\n          } else if (this._horizontalOverlapsOnSide(reorgBounds, gd)) {\n            // freeze the cells for reorganization\n            setOccupiedCell(idx.x, idx.y, cell);\n            usedCells++;\n            minY = Math.min(idx.y, minY);\n          } else {\n            // add widget to reorganization\n            this._setAssignedCell(idx, null);\n            addWidgetToReorganize(cell.widget);\n            usedCells++;\n            minY = Math.min(idx.y, minY);\n          }\n        }\n      }\n    }\n    if (widgetsToReorganize.length === 0) {\n      return;\n    }\n    widgetsToReorganize.sort(function(a, b) {\n      return this._widgets.indexOf(a) < this._widgets.indexOf(b) ? -1 : 1;\n    }.bind(this));\n    reorgBounds.y = minY;\n\n    var reorgMatrix = new VerticalGridMatrix(reorgBounds.w, Math.floor((usedCells + reorgBounds.w - 1) / reorgBounds.w), reorgBounds.x, reorgBounds.y);\n    reorgMatrix._addAssignedCells(occupiedCells);\n    while (!reorgMatrix.computeGridData(widgetsToReorganize)) {\n      reorgMatrix.resetAll(reorgMatrix.getColumnCount(), reorgMatrix.getRowCount() + 1);\n    }\n    this._cursor.reset();\n    this._addAssignedCells(reorgMatrix._getAssignedCells());\n    reorgMatrix._widgetGridDatas.forEach(function(v, i) {\n      this._widgetGridDatas[this._widgets.indexOf(reorgMatrix._widgets[i])] = v;\n    }.bind(this));\n  }\n\n  _horizontalMatchesOrOverlaps(bounds, gd) {\n    return bounds.x >= gd.x && bounds.x + bounds.w <= gd.x + gd.w;\n  }\n\n  _horizontalOverlapsOnSide(bounds, gd) {\n    return bounds.x > gd.x || bounds.x + bounds.w < gd.x + gd.w;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}