{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { CellEditorCancelEditKeyStroke, CellEditorCompleteEditKeyStroke, CellEditorPopupLayout, CellEditorTabKeyStroke, FormField, graphics, Point, Popup, scout } from '../../index';\nimport $ from 'jquery';\n\nvar CellEditorPopup = /*#__PURE__*/function (_Popup) {\n  _inherits(CellEditorPopup, _Popup);\n\n  var _super = _createSuper(CellEditorPopup);\n\n  function CellEditorPopup() {\n    var _this;\n\n    _classCallCheck(this, CellEditorPopup);\n\n    _this = _super.call(this);\n    _this.table = null;\n    _this.column = null;\n    _this.row = null;\n    _this.cell = null;\n    _this._pendingCompleteCellEdit = null;\n    _this._keyStrokeHandler = _this._onKeyStroke.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(CellEditorPopup, [{\n    key: \"_init\",\n    value: function _init(options) {\n      options.scrollType = options.scrollType || 'position';\n\n      _get(_getPrototypeOf(CellEditorPopup.prototype), \"_init\", this).call(this, options);\n\n      this.table = options.column.table;\n      this.link(this.cell.field);\n    }\n  }, {\n    key: \"_createLayout\",\n    value: function _createLayout() {\n      return new CellEditorPopupLayout(this);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      _get(_getPrototypeOf(CellEditorPopup.prototype), \"_initKeyStrokeContext\", this).call(this);\n\n      this.keyStrokeContext.registerKeyStroke([new CellEditorCompleteEditKeyStroke(this), new CellEditorTabKeyStroke(this)]);\n    }\n    /**\n     * @override Popup.js\n     */\n\n  }, {\n    key: \"_createCloseKeyStroke\",\n    value: function _createCloseKeyStroke() {\n      return new CellEditorCancelEditKeyStroke(this);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_open\",\n    value: function _open($parent, event) {\n      this.render($parent, event);\n      this.position();\n      this.pack();\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      _get(_getPrototypeOf(CellEditorPopup.prototype), \"_render\", this).call(this); // determine CSS class for first and last column, required for additional margins/padding in cell-editor\n\n\n      var cssClass = '',\n          visibleCols = this.table.visibleColumns(),\n          colPos = visibleCols.indexOf(this.column);\n\n      if (colPos === 0) {\n        // first cell\n        cssClass = 'first';\n      } else if (colPos === visibleCols.length - 1) {\n        // last cell\n        cssClass = 'last';\n      }\n\n      this.$container.addClass('cell-editor-popup ' + cssClass).data('popup', this);\n      var field = this.cell.field;\n      field.mode = FormField.Mode.CELLEDITOR; // hint that this field is used within a cell-editor\n\n      field.render();\n      field.prepareForCellEdit({\n        cssClass: cssClass\n      }); // Make sure cell content is not visible while the editor is open (especially necessary for transparent editors like checkboxes)\n\n      this.$anchor.css('visibility', 'hidden');\n\n      this._rowOrderChangedFunc = function (event) {\n        if (event.animating) {\n          // row is only set while animating\n          if (event.row === this.row) {\n            this.position();\n          }\n        } else {\n          this.position();\n        }\n      }.bind(this);\n\n      this.table.on('rowOrderChanged', this._rowOrderChangedFunc); // Set table style to focused, so that it looks as it still has the focus.\n      // This prevents flickering if the cell editor gets opened, especially when tabbing to the next cell editor.\n\n      if (this.table.enabled) {\n        this.table.$container.addClass('focused');\n      }\n\n      this.session.keyStrokeManager.on('keyStroke', this._keyStrokeHandler);\n    }\n  }, {\n    key: \"_postRender\",\n    value: function _postRender() {\n      _get(_getPrototypeOf(CellEditorPopup.prototype), \"_postRender\", this).call(this); // installs the focus context for this popup\n      // If applicable, invoke the field's function 'onCellEditorRendered' to signal the cell-editor to be rendered.\n\n\n      var field = this.cell.field;\n\n      if (field.onCellEditorRendered) {\n        field.onCellEditorRendered({\n          openFieldPopup: this.table.openFieldPopupOnCellEdit,\n          cellEditorPopup: this\n        });\n      }\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      _get(_getPrototypeOf(CellEditorPopup.prototype), \"_remove\", this).call(this); // uninstalls the focus context for this popup\n\n\n      this.session.keyStrokeManager.off('keyStroke', this._keyStrokeHandler);\n      this.table.off('rowOrderChanged', this._rowOrderChangedFunc); // table may have been removed in the meantime\n\n      if (this.table.rendered) {\n        this.table.$container.removeClass('focused');\n      }\n\n      this.$anchor.css('visibility', '');\n    }\n  }, {\n    key: \"position\",\n    value: function position() {\n      var cellBounds,\n          rowBounds,\n          $tableData = this.table.$data,\n          $row = this.row.$row,\n          $cell = this.$anchor,\n          insetsLeft = $tableData.cssPxValue('padding-left') + $row.cssBorderLeftWidth();\n      cellBounds = graphics.bounds($cell);\n      cellBounds.x += $cell.cssMarginX(); // first cell popup has a negative left margin\n\n      rowBounds = graphics.bounds($row);\n      rowBounds.y += $row.cssMarginY(); // row has a negative top margin\n\n      this.setLocation(new Point(insetsLeft + cellBounds.x, $tableData.scrollTop() + rowBounds.y));\n    }\n    /**\n     * @returns {Promise} resolved when acceptInput is performed on the editor field\n     */\n\n  }, {\n    key: \"completeEdit\",\n    value: function completeEdit(waitForAcceptInput) {\n      if (this._pendingCompleteCellEdit) {\n        // Make sure complete cell edit does not get sent twice since it will lead to exceptions. This may happen if user clicks very fast multiple times.\n        return this._pendingCompleteCellEdit;\n      } // There is no blur event when the popup gets closed -> trigger blur so that the field may react (accept display text, close popups etc.)\n      // When acceptInput returns a promise, we must wait until input is accepted\n      // Otherwise call completeEdit immediately, also call it immediately if waitForAcceptInput is false (see _onKeyStroke)\n\n\n      var field = this.cell.field;\n      var acceptInputPromise = field.acceptInput();\n\n      if (!acceptInputPromise || !scout.nvl(waitForAcceptInput, true)) {\n        this._pendingCompleteCellEdit = $.resolvedPromise();\n        this.table.completeCellEdit();\n      } else {\n        this._pendingCompleteCellEdit = acceptInputPromise.then(function () {\n          this.table.completeCellEdit();\n        }.bind(this));\n      }\n\n      this._pendingCompleteCellEdit.then(function () {\n        this._pendingCompleteCellEdit = null;\n      }.bind(this));\n\n      return this._pendingCompleteCellEdit;\n    }\n  }, {\n    key: \"isCompleteCellEditRequested\",\n    value: function isCompleteCellEditRequested() {\n      return !!this._pendingCompleteCellEdit;\n    }\n  }, {\n    key: \"cancelEdit\",\n    value: function cancelEdit() {\n      this.table.cancelCellEdit();\n      this.remove();\n    }\n  }, {\n    key: \"_onMouseDownOutside\",\n    value: function _onMouseDownOutside(event) {\n      this.completeEdit();\n    }\n  }, {\n    key: \"_onKeyStroke\",\n    value: function _onKeyStroke(event) {\n      if (!this.session.keyStrokeManager.invokeAcceptInputOnActiveValueField(event.keyStroke, event.keyStrokeContext)) {\n        return;\n      }\n\n      if (this.$container.isOrHas(event.keyStrokeContext.$getScopeTarget())) {\n        // Don't interfere with key strokes of the popup or children of the popup (otherwise pressing enter would close both the popup and the form at once)\n        return;\n      } // Make sure completeEdit is called immediately after calling acceptInput.\n      // Otherwise the key stroke will be executed before completing the edit which prevents the input from being saved\n\n\n      this.completeEdit(false);\n    }\n  }, {\n    key: \"waitForCompleteCellEdit\",\n    value: function waitForCompleteCellEdit() {\n      if (this._pendingCompleteCellEdit) {\n        return this._pendingCompleteCellEdit.promise();\n      }\n\n      return $.resolvedPromise();\n    }\n  }]);\n\n  return CellEditorPopup;\n}(Popup);\n\nexport { CellEditorPopup as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/table/editor/CellEditorPopup.js"],"names":["CellEditorCancelEditKeyStroke","CellEditorCompleteEditKeyStroke","CellEditorPopupLayout","CellEditorTabKeyStroke","FormField","graphics","Point","Popup","scout","$","CellEditorPopup","table","column","row","cell","_pendingCompleteCellEdit","_keyStrokeHandler","_onKeyStroke","bind","options","scrollType","link","field","keyStrokeContext","registerKeyStroke","$parent","event","render","position","pack","cssClass","visibleCols","visibleColumns","colPos","indexOf","length","$container","addClass","data","mode","Mode","CELLEDITOR","prepareForCellEdit","$anchor","css","_rowOrderChangedFunc","animating","on","enabled","session","keyStrokeManager","onCellEditorRendered","openFieldPopup","openFieldPopupOnCellEdit","cellEditorPopup","off","rendered","removeClass","cellBounds","rowBounds","$tableData","$data","$row","$cell","insetsLeft","cssPxValue","cssBorderLeftWidth","bounds","x","cssMarginX","y","cssMarginY","setLocation","scrollTop","waitForAcceptInput","acceptInputPromise","acceptInput","nvl","resolvedPromise","completeCellEdit","then","cancelCellEdit","remove","completeEdit","invokeAcceptInputOnActiveValueField","keyStroke","isOrHas","$getScopeTarget","promise"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {CellEditorCancelEditKeyStroke, CellEditorCompleteEditKeyStroke, CellEditorPopupLayout, CellEditorTabKeyStroke, FormField, graphics, Point, Popup, scout} from '../../index';\nimport $ from 'jquery';\n\nexport default class CellEditorPopup extends Popup {\n\n  constructor() {\n    super();\n    this.table = null;\n    this.column = null;\n    this.row = null;\n    this.cell = null;\n    this._pendingCompleteCellEdit = null;\n    this._keyStrokeHandler = this._onKeyStroke.bind(this);\n  }\n\n  _init(options) {\n    options.scrollType = options.scrollType || 'position';\n    super._init(options);\n\n    this.table = options.column.table;\n    this.link(this.cell.field);\n  }\n\n  _createLayout() {\n    return new CellEditorPopupLayout(this);\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke([\n      new CellEditorCompleteEditKeyStroke(this),\n      new CellEditorTabKeyStroke(this)\n    ]);\n  }\n\n  /**\n   * @override Popup.js\n   */\n  _createCloseKeyStroke() {\n    return new CellEditorCancelEditKeyStroke(this);\n  }\n\n  /**\n   * @override\n   */\n  _open($parent, event) {\n    this.render($parent, event);\n    this.position();\n    this.pack();\n  }\n\n  _render() {\n    super._render();\n\n    // determine CSS class for first and last column, required for additional margins/padding in cell-editor\n    var cssClass = '',\n      visibleCols = this.table.visibleColumns(),\n      colPos = visibleCols.indexOf(this.column);\n    if (colPos === 0) { // first cell\n      cssClass = 'first';\n    } else if (colPos === visibleCols.length - 1) { // last cell\n      cssClass = 'last';\n    }\n\n    this.$container\n      .addClass('cell-editor-popup ' + cssClass)\n      .data('popup', this);\n\n    var field = this.cell.field;\n    field.mode = FormField.Mode.CELLEDITOR; // hint that this field is used within a cell-editor\n    field.render();\n    field.prepareForCellEdit({\n      cssClass: cssClass\n    });\n\n    // Make sure cell content is not visible while the editor is open (especially necessary for transparent editors like checkboxes)\n    this.$anchor.css('visibility', 'hidden');\n\n    this._rowOrderChangedFunc = function(event) {\n      if (event.animating) {\n        // row is only set while animating\n        if (event.row === this.row) {\n          this.position();\n        }\n      } else {\n        this.position();\n      }\n    }.bind(this);\n    this.table.on('rowOrderChanged', this._rowOrderChangedFunc);\n    // Set table style to focused, so that it looks as it still has the focus.\n    // This prevents flickering if the cell editor gets opened, especially when tabbing to the next cell editor.\n    if (this.table.enabled) {\n      this.table.$container.addClass('focused');\n    }\n    this.session.keyStrokeManager.on('keyStroke', this._keyStrokeHandler);\n  }\n\n  _postRender() {\n    super._postRender(); // installs the focus context for this popup\n\n    // If applicable, invoke the field's function 'onCellEditorRendered' to signal the cell-editor to be rendered.\n    var field = this.cell.field;\n    if (field.onCellEditorRendered) {\n      field.onCellEditorRendered({\n        openFieldPopup: this.table.openFieldPopupOnCellEdit,\n        cellEditorPopup: this\n      });\n    }\n  }\n\n  _remove() {\n    super._remove(); // uninstalls the focus context for this popup\n\n    this.session.keyStrokeManager.off('keyStroke', this._keyStrokeHandler);\n    this.table.off('rowOrderChanged', this._rowOrderChangedFunc);\n    // table may have been removed in the meantime\n    if (this.table.rendered) {\n      this.table.$container.removeClass('focused');\n    }\n    this.$anchor.css('visibility', '');\n  }\n\n  position() {\n    var cellBounds, rowBounds,\n      $tableData = this.table.$data,\n      $row = this.row.$row,\n      $cell = this.$anchor,\n      insetsLeft = $tableData.cssPxValue('padding-left') + $row.cssBorderLeftWidth();\n\n    cellBounds = graphics.bounds($cell);\n    cellBounds.x += $cell.cssMarginX(); // first cell popup has a negative left margin\n    rowBounds = graphics.bounds($row);\n    rowBounds.y += $row.cssMarginY(); // row has a negative top margin\n    this.setLocation(new Point(insetsLeft + cellBounds.x, $tableData.scrollTop() + rowBounds.y));\n  }\n\n  /**\n   * @returns {Promise} resolved when acceptInput is performed on the editor field\n   */\n  completeEdit(waitForAcceptInput) {\n    if (this._pendingCompleteCellEdit) {\n      // Make sure complete cell edit does not get sent twice since it will lead to exceptions. This may happen if user clicks very fast multiple times.\n      return this._pendingCompleteCellEdit;\n    }\n\n    // There is no blur event when the popup gets closed -> trigger blur so that the field may react (accept display text, close popups etc.)\n    // When acceptInput returns a promise, we must wait until input is accepted\n    // Otherwise call completeEdit immediately, also call it immediately if waitForAcceptInput is false (see _onKeyStroke)\n    var field = this.cell.field;\n    var acceptInputPromise = field.acceptInput();\n    if (!acceptInputPromise || !scout.nvl(waitForAcceptInput, true)) {\n      this._pendingCompleteCellEdit = $.resolvedPromise();\n      this.table.completeCellEdit();\n    } else {\n      this._pendingCompleteCellEdit = acceptInputPromise.then(function() {\n        this.table.completeCellEdit();\n      }.bind(this));\n    }\n\n    this._pendingCompleteCellEdit.then(function() {\n      this._pendingCompleteCellEdit = null;\n    }.bind(this));\n\n    return this._pendingCompleteCellEdit;\n  }\n\n  isCompleteCellEditRequested() {\n    return !!this._pendingCompleteCellEdit;\n  }\n\n  cancelEdit() {\n    this.table.cancelCellEdit();\n    this.remove();\n  }\n\n  _onMouseDownOutside(event) {\n    this.completeEdit();\n  }\n\n  _onKeyStroke(event) {\n    if (!this.session.keyStrokeManager.invokeAcceptInputOnActiveValueField(event.keyStroke, event.keyStrokeContext)) {\n      return;\n    }\n    if (this.$container.isOrHas(event.keyStrokeContext.$getScopeTarget())) {\n      // Don't interfere with key strokes of the popup or children of the popup (otherwise pressing enter would close both the popup and the form at once)\n      return;\n    }\n    // Make sure completeEdit is called immediately after calling acceptInput.\n    // Otherwise the key stroke will be executed before completing the edit which prevents the input from being saved\n    this.completeEdit(false);\n  }\n\n  waitForCompleteCellEdit() {\n    if (this._pendingCompleteCellEdit) {\n      return this._pendingCompleteCellEdit.promise();\n    }\n    return $.resolvedPromise();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}