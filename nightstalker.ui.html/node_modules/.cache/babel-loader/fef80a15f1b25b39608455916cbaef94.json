{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, ObjectFactory, scout, strings } from './index';\n/**\n * This class contains a structured type description for a Scout class.\n * The model variant is optional.\n *\n * @param {string} typeDescriptor a string in the format '[namespace(s).]objectType[[:namespace(s).]modelVariant]'\n * @param {object} objectType\n * @param {object} [modelVariant]\n * @constructor\n */\n\nvar TypeDescriptor = /*#__PURE__*/function () {\n  function TypeDescriptor(typeDescriptor, objectType, modelVariant) {\n    _classCallCheck(this, TypeDescriptor);\n\n    this.typeDescriptor = typeDescriptor;\n    this.objectType = objectType;\n    this.modelVariant = modelVariant;\n  }\n\n  _createClass(TypeDescriptor, [{\n    key: \"createInstance\",\n    value: function createInstance(options) {\n      var i,\n          namespaces,\n          className,\n          namespace = window.scout; // default namespace\n\n      if (this.modelVariant) {\n        className = this.modelVariant.name + this.objectType.name;\n        namespaces = this.modelVariant.namespaces;\n      } else {\n        className = this.objectType.name;\n        namespaces = this.objectType.namespaces;\n      }\n\n      if (namespaces.length) {\n        namespace = window;\n\n        for (i = 0; i < namespaces.length; i++) {\n          namespace = namespace[namespaces[i]];\n\n          if (!namespace) {\n            throw this.error('Could not resolve namespace \"' + namespaces[i] + '\"');\n          }\n        }\n      }\n\n      if (!namespace[className]) {\n        // Try without variant if variantLenient is true\n        if (options.variantLenient && this.modelVariant) {\n          var infoWithoutVariant = new TypeDescriptor(this.typeDescriptor, this.objectType, null);\n          return infoWithoutVariant.createInstance(options);\n        }\n\n        throw this.error('Could not find \"' + className + '\" in namespace \"' + namespaces.join('.') + '\"');\n      }\n\n      return new namespace[className](options.model);\n    }\n  }, {\n    key: \"error\",\n    value: function error(details) {\n      return new Error('Failed to create object for objectType \"' + this.typeDescriptor + '\": ' + details);\n    }\n  }], [{\n    key: \"newInstance\",\n    value: function newInstance(typeDescriptor, options) {\n      var info = TypeDescriptor.parse(typeDescriptor);\n      return info.createInstance(options);\n    }\n    /**\n     * @param {string} typeDescriptor\n     * @returns {TypeDescriptor}\n     * @static\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(typeDescriptor) {\n      var typePart = null,\n          variantPart = null;\n\n      if (strings.contains(typeDescriptor, ObjectFactory.MODEL_VARIANT_SEPARATOR)) {\n        var tmp = typeDescriptor.split(ObjectFactory.MODEL_VARIANT_SEPARATOR);\n        typePart = parseDescriptorPart(tmp[0]);\n        variantPart = parseDescriptorPart(tmp[1]); // when type has namespaces but the variant has not, use type namespaces for variant too\n\n        if (arrays.empty(variantPart.namespaces) && !arrays.empty(typePart.namespaces)) {\n          variantPart.namespaces = typePart.namespaces;\n        }\n      } else {\n        typePart = parseDescriptorPart(typeDescriptor);\n      }\n\n      return new TypeDescriptor(typeDescriptor, typePart, variantPart);\n\n      function createInfo(name, namespaces) {\n        return {\n          name: name,\n          namespaces: scout.nvl(namespaces, []),\n          toString: function toString() {\n            var parts = namespaces.slice();\n            parts.push(name);\n            return strings.join(ObjectFactory.NAMESPACE_SEPARATOR, parts);\n          }\n        };\n      }\n\n      function parseDescriptorPart(descriptorPart) {\n        var namespaces = [];\n\n        if (strings.contains(descriptorPart, ObjectFactory.NAMESPACE_SEPARATOR)) {\n          var namespaceParts = descriptorPart.split(ObjectFactory.NAMESPACE_SEPARATOR);\n          namespaces = namespaceParts.slice(0, namespaceParts.length - 1);\n          descriptorPart = arrays.last(namespaceParts);\n        }\n\n        return createInfo(descriptorPart, namespaces);\n      }\n    }\n  }]);\n\n  return TypeDescriptor;\n}();\n\nexport { TypeDescriptor as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/TypeDescriptor.js"],"names":["arrays","ObjectFactory","scout","strings","TypeDescriptor","typeDescriptor","objectType","modelVariant","options","i","namespaces","className","namespace","window","name","length","error","variantLenient","infoWithoutVariant","createInstance","join","model","details","Error","info","parse","typePart","variantPart","contains","MODEL_VARIANT_SEPARATOR","tmp","split","parseDescriptorPart","empty","createInfo","nvl","toString","parts","slice","push","NAMESPACE_SEPARATOR","descriptorPart","namespaceParts","last"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, ObjectFactory, scout, strings} from './index';\n\n/**\n * This class contains a structured type description for a Scout class.\n * The model variant is optional.\n *\n * @param {string} typeDescriptor a string in the format '[namespace(s).]objectType[[:namespace(s).]modelVariant]'\n * @param {object} objectType\n * @param {object} [modelVariant]\n * @constructor\n */\nexport default class TypeDescriptor {\n\n  constructor(typeDescriptor, objectType, modelVariant) {\n    this.typeDescriptor = typeDescriptor;\n    this.objectType = objectType;\n    this.modelVariant = modelVariant;\n  }\n\n  createInstance(options) {\n    var i, namespaces, className,\n      namespace = window.scout; // default namespace\n\n    if (this.modelVariant) {\n      className = this.modelVariant.name + this.objectType.name;\n      namespaces = this.modelVariant.namespaces;\n    } else {\n      className = this.objectType.name;\n      namespaces = this.objectType.namespaces;\n    }\n\n    if (namespaces.length) {\n      namespace = window;\n      for (i = 0; i < namespaces.length; i++) {\n        namespace = namespace[namespaces[i]];\n        if (!namespace) {\n          throw this.error('Could not resolve namespace \"' + namespaces[i] + '\"');\n        }\n      }\n    }\n\n    if (!namespace[className]) { // Try without variant if variantLenient is true\n      if (options.variantLenient && this.modelVariant) {\n        var infoWithoutVariant = new TypeDescriptor(this.typeDescriptor, this.objectType, null);\n        return infoWithoutVariant.createInstance(options);\n      }\n      throw this.error('Could not find \"' + className + '\" in namespace \"' + namespaces.join('.') + '\"');\n    }\n\n    return new namespace[className](options.model);\n  }\n\n  error(details) {\n    return new Error('Failed to create object for objectType \"' + this.typeDescriptor + '\": ' + details);\n  }\n\n  static newInstance(typeDescriptor, options) {\n    var info = TypeDescriptor.parse(typeDescriptor);\n    return info.createInstance(options);\n  }\n\n  /**\n   * @param {string} typeDescriptor\n   * @returns {TypeDescriptor}\n   * @static\n   */\n  static parse(typeDescriptor) {\n    var typePart = null,\n      variantPart = null;\n\n    if (strings.contains(typeDescriptor, ObjectFactory.MODEL_VARIANT_SEPARATOR)) {\n      var tmp = typeDescriptor.split(ObjectFactory.MODEL_VARIANT_SEPARATOR);\n      typePart = parseDescriptorPart(tmp[0]);\n      variantPart = parseDescriptorPart(tmp[1]);\n\n      // when type has namespaces but the variant has not, use type namespaces for variant too\n      if (arrays.empty(variantPart.namespaces) && !arrays.empty(typePart.namespaces)) {\n        variantPart.namespaces = typePart.namespaces;\n      }\n    } else {\n      typePart = parseDescriptorPart(typeDescriptor);\n    }\n\n    return new TypeDescriptor(typeDescriptor, typePart, variantPart);\n\n    function createInfo(name, namespaces) {\n      return {\n        name: name,\n        namespaces: scout.nvl(namespaces, []),\n        toString: function() {\n          var parts = namespaces.slice();\n          parts.push(name);\n          return strings.join(ObjectFactory.NAMESPACE_SEPARATOR, parts);\n        }\n      };\n    }\n\n    function parseDescriptorPart(descriptorPart) {\n      var namespaces = [];\n\n      if (strings.contains(descriptorPart, ObjectFactory.NAMESPACE_SEPARATOR)) {\n        var namespaceParts = descriptorPart.split(ObjectFactory.NAMESPACE_SEPARATOR);\n        namespaces = namespaceParts.slice(0, namespaceParts.length - 1);\n        descriptorPart = arrays.last(namespaceParts);\n      }\n\n      return createInfo(descriptorPart, namespaces);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}