{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { AbstractLayout, arrays, Dimension, graphics, HtmlComponent, MenuBarLayout, RowLayout, scout, scrollbars } from '../index';\n\nvar TableLayout = /*#__PURE__*/function (_AbstractLayout) {\n  _inherits(TableLayout, _AbstractLayout);\n\n  var _super = _createSuper(TableLayout);\n\n  function TableLayout(table) {\n    var _this;\n\n    _classCallCheck(this, TableLayout);\n\n    _this = _super.call(this);\n    _this.table = table;\n    _this._dataHeightPositive = false;\n    return _this;\n  }\n\n  _createClass(TableLayout, [{\n    key: \"layout\",\n    value: function layout($container) {\n      var menuBarHeight = 0,\n          footerHeight = 0,\n          headerHeight = 0,\n          tileTableHeight = 0,\n          controlContainerHeight = 0,\n          controlContainerInsets,\n          tileAccordion = this.table.tableTileGridMediator ? this.table.tableTileGridMediator.tileAccordion : null,\n          $data = this.table.$data,\n          dataMargins = graphics.margins(scout.nvl($data, this.table.$container)),\n          dataMarginsHeight = dataMargins.top + dataMargins.bottom,\n          menuBar = this.table.menuBar,\n          footer = this.table.footer,\n          header = this.table.header,\n          tileTableHeader = this.table.tileTableHeader,\n          visibleColumns = this.table.visibleColumns(),\n          lastColumn = visibleColumns[visibleColumns.length - 1],\n          htmlContainer = this.table.htmlComp,\n          containerSize = htmlContainer.availableSize({\n        exact: true\n      }).subtract(htmlContainer.insets());\n\n      if (this.table.menuBarVisible && menuBar.visible) {\n        var htmlMenuBar = HtmlComponent.get(menuBar.$container);\n        var menuBarSize = MenuBarLayout.size(htmlMenuBar, containerSize);\n        htmlMenuBar.setSize(menuBarSize);\n        menuBarHeight = menuBarSize.height;\n      }\n\n      if (header) {\n        headerHeight = graphics.size(header.$container).height;\n\n        if (header.menuBar) {\n          header.menuBar.validateLayout();\n        }\n      }\n\n      if (footer) {\n        // Layout table footer and add size of footer (including the control content) to 'height'\n        footerHeight = graphics.size(footer.$container).height;\n        controlContainerHeight = footer.computeControlContainerHeight(this.table, footer.selectedControl, !this._dataHeightPositive);\n        controlContainerInsets = graphics.insets(footer.$controlContainer);\n\n        if (!footer.animating) {\n          // closing or opening: height is about to be changed\n          footer.$controlContainer.cssHeight(controlContainerHeight);\n          footer.$controlContent.outerHeight(controlContainerHeight - controlContainerInsets.vertical());\n          footer.revalidateLayout();\n        }\n      }\n\n      if (tileTableHeader && tileTableHeader.visible) {\n        var groupBoxSize = tileTableHeader.htmlComp.prefSize({\n          widthHint: containerSize.width\n        });\n        groupBoxSize.width = containerSize.width;\n        groupBoxSize = groupBoxSize.subtract(tileTableHeader.htmlComp.margins());\n        tileTableHeader.htmlComp.setSize(groupBoxSize);\n        tileTableHeight = groupBoxSize.height;\n      }\n\n      var controlsHeight = dataMarginsHeight + menuBarHeight + controlContainerHeight + footerHeight + headerHeight + tileTableHeight;\n      var dataHeight = containerSize.height - controlsHeight;\n\n      if ($data) {\n        $data.css('height', 'calc(100% - ' + controlsHeight + 'px)');\n        this._dataHeightPositive = $data.height() > 0;\n      } else {\n        if (tileAccordion && tileAccordion.htmlComp) {\n          tileAccordion.htmlComp.setSize(new Dimension(containerSize.width, dataHeight));\n          scrollbars.update(tileAccordion.$container);\n          this._dataHeightPositive = dataHeight > 0;\n        }\n      }\n\n      if (!this.table.tileMode) {\n        this._layoutColumns(); // Size of last column may have to be adjusted due to the header menu items\n\n\n        if (header) {\n          header.resizeHeaderItem(lastColumn);\n        }\n\n        this.table.setViewRangeSize(this.table.calculateViewRangeSize());\n\n        if (!htmlContainer.layouted) {\n          this.table._renderScrollTop();\n        } // Always render viewport (not only when viewRangeSize changes), because view range depends on scroll position and data height\n\n\n        this.table._renderViewport(); // Make sure tooltips and editor popup are at correct position after layouting (e.g after window resizing)\n\n\n        this.table.tooltips.forEach(function (tooltip) {\n          if (tooltip.rendered) {\n            tooltip.position();\n          }\n        });\n\n        if (this.table.cellEditorPopup && this.table.cellEditorPopup.rendered) {\n          this.table.cellEditorPopup.position();\n          this.table.cellEditorPopup.pack();\n        }\n\n        this.table.updateScrollbars();\n      }\n    }\n  }, {\n    key: \"_layoutColumns\",\n    value: function _layoutColumns(widthHint) {\n      this._autoOptimizeColumnsWidths();\n\n      var htmlContainer = this.table.htmlComp;\n      var columnLayoutDirty = this.table.columnLayoutDirty || !htmlContainer.sizeCached;\n\n      if (!columnLayoutDirty) {\n        var width = widthHint || htmlContainer.size().width;\n        columnLayoutDirty = htmlContainer.sizeCached.width !== width;\n      } // Auto resize only if table width or column structure has changed\n\n\n      if (columnLayoutDirty) {\n        if (this.table.autoResizeColumns) {\n          this._autoResizeColumns(widthHint);\n        } // This is already done in _renderRowsInRange, but it is necessary here as well if the zoom level changes dynamically (or autoResizeColumns toggles)\n\n\n        this._updateRealColumnWidths();\n\n        this.table.columnLayoutDirty = false;\n      }\n    }\n    /**\n     * Workaround for Chrome bug, see {@link Table._updateRealColumnWidths}\n     */\n\n  }, {\n    key: \"_updateRealColumnWidths\",\n    value: function _updateRealColumnWidths() {\n      if (this.table._updateRealColumnWidths()) {\n        this.table._updateRowWidth();\n\n        if (this.table.header && this.table.header.rendered) {\n          this.table.header.resizeHeaderItems();\n        }\n\n        this.table.$rows(true).css('width', this.table.rowWidth);\n      }\n    }\n    /**\n     * Resizes all visible columns with autoOptimizeWidth set to true, if necessary (means if autoOptimizeWidthRequired is true)\n     */\n\n  }, {\n    key: \"_autoOptimizeColumnsWidths\",\n    value: function _autoOptimizeColumnsWidths() {\n      this.table.visibleColumns().forEach(function (column) {\n        if (column.autoOptimizeWidth && column.autoOptimizeWidthRequired) {\n          this.table.resizeToFit(column, column.autoOptimizeMaxWidth);\n        }\n      }, this);\n    }\n    /**\n     * Resizes the visible columns to make them use all the available space.\n     */\n\n  }, {\n    key: \"_autoResizeColumns\",\n    value: function _autoResizeColumns(widthHint) {\n      var newWidth,\n          weight,\n          relevantColumns = [],\n          currentWidth = 0,\n          totalInitialWidth = 0,\n          tableWidth = widthHint || this.table.$data.width(),\n          availableWidth = Math.floor(tableWidth - this.table.rowBorderWidth); // Don't resize fixed and auto optimize width columns\n\n      this.table.visibleColumns().forEach(function (column) {\n        if (column.fixedWidth || column.autoOptimizeWidth) {\n          availableWidth -= column.width;\n        } else {\n          relevantColumns.push(column);\n          currentWidth += column.width;\n          totalInitialWidth += column.initialWidth;\n        }\n      });\n\n      if (availableWidth === currentWidth) {\n        // Columns already use the available space, no need to resize\n        return;\n      }\n\n      var remainingWidth = availableWidth; // First, filter columns which would get smaller than their minimal size\n\n      var minWidthColumns = relevantColumns.filter(function (column) {\n        // Use initial width as preferred width for auto resize columns.\n        // This makes sure the column doesn't get too small on small screens. The user can still make the column smaller though.\n        var minWidth = Math.max(column.minWidth, column.initialWidth);\n\n        if (totalInitialWidth === 0) {\n          weight = 1 / relevantColumns.length;\n        } else {\n          weight = column.initialWidth / totalInitialWidth;\n        }\n\n        newWidth = Math.floor(weight * remainingWidth);\n\n        if (newWidth < minWidth) {\n          newWidth = minWidth;\n          remainingWidth = Math.max(remainingWidth - newWidth, 0);\n          return true;\n        }\n\n        return false;\n      }); // Resize them to their minimal width\n\n      minWidthColumns.forEach(function (column, index) {\n        var minWidth = Math.max(column.minWidth, column.initialWidth);\n        arrays.remove(relevantColumns, column);\n        newWidth = minWidth;\n        totalInitialWidth -= column.initialWidth; // If this is the last column, add remaining space (due to rounding) to this column\n\n        if (index === minWidthColumns.length - 1 && remainingWidth > 0 && relevantColumns.length === 0) {\n          newWidth += remainingWidth;\n          remainingWidth = 0;\n        }\n\n        if (newWidth !== column.width) {\n          this.table.resizeColumn(column, newWidth);\n        }\n      }.bind(this)); // Then resize the others\n\n      availableWidth = remainingWidth;\n      relevantColumns.forEach(function (column, index) {\n        if (totalInitialWidth === 0) {\n          weight = 1 / relevantColumns.length;\n        } else {\n          weight = column.initialWidth / totalInitialWidth;\n        }\n\n        newWidth = Math.floor(weight * availableWidth);\n        remainingWidth -= newWidth; // If this is the last column, add remaining space (due to rounding) to this column\n\n        if (index === relevantColumns.length - 1 && remainingWidth > 0) {\n          newWidth += remainingWidth;\n          remainingWidth = 0;\n        }\n\n        if (newWidth !== column.width) {\n          this.table.resizeColumn(column, newWidth);\n        }\n      }.bind(this));\n    }\n  }, {\n    key: \"preferredLayoutSize\",\n    value: function preferredLayoutSize($container, options) {\n      if (this.table.tileMode) {\n        // Use RowLayout to calculate preferredLayoutSize of TileTableHeader, TileAccordion and Footer.\n        return new RowLayout().preferredLayoutSize($container, options);\n      } // If autoResizeColumns and text wrap is enabled, the height of the table depends on the width\n\n\n      this._layoutColumns(options.widthHint); // If table was not visible during renderViewport, the rows are not rendered yet (see _renderViewport)\n      // -> make sure rows are rendered otherwise preferred height cannot be determined\n\n\n      this.table._renderViewport();\n\n      return _get(_getPrototypeOf(TableLayout.prototype), \"preferredLayoutSize\", this).call(this, $container, options);\n    }\n  }]);\n\n  return TableLayout;\n}(AbstractLayout);\n\nexport { TableLayout as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/table/TableLayout.js"],"names":["AbstractLayout","arrays","Dimension","graphics","HtmlComponent","MenuBarLayout","RowLayout","scout","scrollbars","TableLayout","table","_dataHeightPositive","$container","menuBarHeight","footerHeight","headerHeight","tileTableHeight","controlContainerHeight","controlContainerInsets","tileAccordion","tableTileGridMediator","$data","dataMargins","margins","nvl","dataMarginsHeight","top","bottom","menuBar","footer","header","tileTableHeader","visibleColumns","lastColumn","length","htmlContainer","htmlComp","containerSize","availableSize","exact","subtract","insets","menuBarVisible","visible","htmlMenuBar","get","menuBarSize","size","setSize","height","validateLayout","computeControlContainerHeight","selectedControl","$controlContainer","animating","cssHeight","$controlContent","outerHeight","vertical","revalidateLayout","groupBoxSize","prefSize","widthHint","width","controlsHeight","dataHeight","css","update","tileMode","_layoutColumns","resizeHeaderItem","setViewRangeSize","calculateViewRangeSize","layouted","_renderScrollTop","_renderViewport","tooltips","forEach","tooltip","rendered","position","cellEditorPopup","pack","updateScrollbars","_autoOptimizeColumnsWidths","columnLayoutDirty","sizeCached","autoResizeColumns","_autoResizeColumns","_updateRealColumnWidths","_updateRowWidth","resizeHeaderItems","$rows","rowWidth","column","autoOptimizeWidth","autoOptimizeWidthRequired","resizeToFit","autoOptimizeMaxWidth","newWidth","weight","relevantColumns","currentWidth","totalInitialWidth","tableWidth","availableWidth","Math","floor","rowBorderWidth","fixedWidth","push","initialWidth","remainingWidth","minWidthColumns","filter","minWidth","max","index","remove","resizeColumn","bind","options","preferredLayoutSize"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,cAAR,EAAwBC,MAAxB,EAAgCC,SAAhC,EAA2CC,QAA3C,EAAqDC,aAArD,EAAoEC,aAApE,EAAmFC,SAAnF,EAA8FC,KAA9F,EAAqGC,UAArG,QAAsH,UAAtH;;IAEqBC,W;;;;;AAEnB,uBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACjB;AACA,UAAKA,KAAL,GAAaA,KAAb;AACA,UAAKC,mBAAL,GAA2B,KAA3B;AAHiB;AAIlB;;;;2BAEMC,U,EAAY;AACjB,UAAIC,aAAa,GAAG,CAApB;AAAA,UACEC,YAAY,GAAG,CADjB;AAAA,UAEEC,YAAY,GAAG,CAFjB;AAAA,UAGEC,eAAe,GAAG,CAHpB;AAAA,UAIEC,sBAAsB,GAAG,CAJ3B;AAAA,UAKEC,sBALF;AAAA,UAMEC,aAAa,GAAG,KAAKT,KAAL,CAAWU,qBAAX,GAAmC,KAAKV,KAAL,CAAWU,qBAAX,CAAiCD,aAApE,GAAoF,IANtG;AAAA,UAOEE,KAAK,GAAG,KAAKX,KAAL,CAAWW,KAPrB;AAAA,UAQEC,WAAW,GAAGnB,QAAQ,CAACoB,OAAT,CAAiBhB,KAAK,CAACiB,GAAN,CAAUH,KAAV,EAAiB,KAAKX,KAAL,CAAWE,UAA5B,CAAjB,CARhB;AAAA,UASEa,iBAAiB,GAAGH,WAAW,CAACI,GAAZ,GAAkBJ,WAAW,CAACK,MATpD;AAAA,UAUEC,OAAO,GAAG,KAAKlB,KAAL,CAAWkB,OAVvB;AAAA,UAWEC,MAAM,GAAG,KAAKnB,KAAL,CAAWmB,MAXtB;AAAA,UAYEC,MAAM,GAAG,KAAKpB,KAAL,CAAWoB,MAZtB;AAAA,UAaEC,eAAe,GAAG,KAAKrB,KAAL,CAAWqB,eAb/B;AAAA,UAcEC,cAAc,GAAG,KAAKtB,KAAL,CAAWsB,cAAX,EAdnB;AAAA,UAeEC,UAAU,GAAGD,cAAc,CAACA,cAAc,CAACE,MAAf,GAAwB,CAAzB,CAf7B;AAAA,UAgBEC,aAAa,GAAG,KAAKzB,KAAL,CAAW0B,QAhB7B;AAAA,UAiBEC,aAAa,GAAGF,aAAa,CAACG,aAAd,CAA4B;AAC1CC,QAAAA,KAAK,EAAE;AADmC,OAA5B,EAEbC,QAFa,CAEJL,aAAa,CAACM,MAAd,EAFI,CAjBlB;;AAqBA,UAAI,KAAK/B,KAAL,CAAWgC,cAAX,IAA6Bd,OAAO,CAACe,OAAzC,EAAkD;AAChD,YAAIC,WAAW,GAAGxC,aAAa,CAACyC,GAAd,CAAkBjB,OAAO,CAAChB,UAA1B,CAAlB;AACA,YAAIkC,WAAW,GAAGzC,aAAa,CAAC0C,IAAd,CAAmBH,WAAnB,EAAgCP,aAAhC,CAAlB;AACAO,QAAAA,WAAW,CAACI,OAAZ,CAAoBF,WAApB;AACAjC,QAAAA,aAAa,GAAGiC,WAAW,CAACG,MAA5B;AACD;;AACD,UAAInB,MAAJ,EAAY;AACVf,QAAAA,YAAY,GAAGZ,QAAQ,CAAC4C,IAAT,CAAcjB,MAAM,CAAClB,UAArB,EAAiCqC,MAAhD;;AACA,YAAInB,MAAM,CAACF,OAAX,EAAoB;AAClBE,UAAAA,MAAM,CAACF,OAAP,CAAesB,cAAf;AACD;AACF;;AACD,UAAIrB,MAAJ,EAAY;AACV;AACAf,QAAAA,YAAY,GAAGX,QAAQ,CAAC4C,IAAT,CAAclB,MAAM,CAACjB,UAArB,EAAiCqC,MAAhD;AACAhC,QAAAA,sBAAsB,GAAGY,MAAM,CAACsB,6BAAP,CAAqC,KAAKzC,KAA1C,EAAiDmB,MAAM,CAACuB,eAAxD,EAAyE,CAAC,KAAKzC,mBAA/E,CAAzB;AACAO,QAAAA,sBAAsB,GAAGf,QAAQ,CAACsC,MAAT,CAAgBZ,MAAM,CAACwB,iBAAvB,CAAzB;;AACA,YAAI,CAACxB,MAAM,CAACyB,SAAZ,EAAuB;AAAE;AACvBzB,UAAAA,MAAM,CAACwB,iBAAP,CAAyBE,SAAzB,CAAmCtC,sBAAnC;AACAY,UAAAA,MAAM,CAAC2B,eAAP,CAAuBC,WAAvB,CAAmCxC,sBAAsB,GAAGC,sBAAsB,CAACwC,QAAvB,EAA5D;AACA7B,UAAAA,MAAM,CAAC8B,gBAAP;AACD;AACF;;AACD,UAAI5B,eAAe,IAAIA,eAAe,CAACY,OAAvC,EAAgD;AAC9C,YAAIiB,YAAY,GAAG7B,eAAe,CAACK,QAAhB,CAAyByB,QAAzB,CAAkC;AACnDC,UAAAA,SAAS,EAAEzB,aAAa,CAAC0B;AAD0B,SAAlC,CAAnB;AAGAH,QAAAA,YAAY,CAACG,KAAb,GAAqB1B,aAAa,CAAC0B,KAAnC;AACAH,QAAAA,YAAY,GAAGA,YAAY,CAACpB,QAAb,CAAsBT,eAAe,CAACK,QAAhB,CAAyBb,OAAzB,EAAtB,CAAf;AACAQ,QAAAA,eAAe,CAACK,QAAhB,CAAyBY,OAAzB,CAAiCY,YAAjC;AACA5C,QAAAA,eAAe,GAAG4C,YAAY,CAACX,MAA/B;AACD;;AACD,UAAIe,cAAc,GAAGvC,iBAAiB,GAAGZ,aAApB,GAAoCI,sBAApC,GAA6DH,YAA7D,GAA4EC,YAA5E,GAA2FC,eAAhH;AACA,UAAIiD,UAAU,GAAG5B,aAAa,CAACY,MAAd,GAAuBe,cAAxC;;AACA,UAAI3C,KAAJ,EAAW;AACTA,QAAAA,KAAK,CAAC6C,GAAN,CAAU,QAAV,EAAoB,iBAAiBF,cAAjB,GAAkC,KAAtD;AACA,aAAKrD,mBAAL,GAA2BU,KAAK,CAAC4B,MAAN,KAAiB,CAA5C;AACD,OAHD,MAGO;AACL,YAAI9B,aAAa,IAAIA,aAAa,CAACiB,QAAnC,EAA6C;AAC3CjB,UAAAA,aAAa,CAACiB,QAAd,CAAuBY,OAAvB,CAA+B,IAAI9C,SAAJ,CAAcmC,aAAa,CAAC0B,KAA5B,EAAmCE,UAAnC,CAA/B;AACAzD,UAAAA,UAAU,CAAC2D,MAAX,CAAkBhD,aAAa,CAACP,UAAhC;AACA,eAAKD,mBAAL,GAA2BsD,UAAU,GAAG,CAAxC;AACD;AACF;;AAED,UAAI,CAAC,KAAKvD,KAAL,CAAW0D,QAAhB,EAA0B;AACxB,aAAKC,cAAL,GADwB,CAGxB;;;AACA,YAAIvC,MAAJ,EAAY;AACVA,UAAAA,MAAM,CAACwC,gBAAP,CAAwBrC,UAAxB;AACD;;AAED,aAAKvB,KAAL,CAAW6D,gBAAX,CAA4B,KAAK7D,KAAL,CAAW8D,sBAAX,EAA5B;;AAEA,YAAI,CAACrC,aAAa,CAACsC,QAAnB,EAA6B;AAC3B,eAAK/D,KAAL,CAAWgE,gBAAX;AACD,SAZuB,CAcxB;;;AACA,aAAKhE,KAAL,CAAWiE,eAAX,GAfwB,CAiBxB;;;AACA,aAAKjE,KAAL,CAAWkE,QAAX,CAAoBC,OAApB,CAA4B,UAASC,OAAT,EAAkB;AAC5C,cAAIA,OAAO,CAACC,QAAZ,EAAsB;AACpBD,YAAAA,OAAO,CAACE,QAAR;AACD;AACF,SAJD;;AAKA,YAAI,KAAKtE,KAAL,CAAWuE,eAAX,IAA8B,KAAKvE,KAAL,CAAWuE,eAAX,CAA2BF,QAA7D,EAAuE;AACrE,eAAKrE,KAAL,CAAWuE,eAAX,CAA2BD,QAA3B;AACA,eAAKtE,KAAL,CAAWuE,eAAX,CAA2BC,IAA3B;AACD;;AAED,aAAKxE,KAAL,CAAWyE,gBAAX;AACD;AACF;;;mCAEcrB,S,EAAW;AACxB,WAAKsB,0BAAL;;AAEA,UAAIjD,aAAa,GAAG,KAAKzB,KAAL,CAAW0B,QAA/B;AACA,UAAIiD,iBAAiB,GAAG,KAAK3E,KAAL,CAAW2E,iBAAX,IAAgC,CAAClD,aAAa,CAACmD,UAAvE;;AACA,UAAI,CAACD,iBAAL,EAAwB;AACtB,YAAItB,KAAK,GAAGD,SAAS,IAAI3B,aAAa,CAACY,IAAd,GAAqBgB,KAA9C;AACAsB,QAAAA,iBAAiB,GAAGlD,aAAa,CAACmD,UAAd,CAAyBvB,KAAzB,KAAmCA,KAAvD;AACD,OARuB,CASxB;;;AACA,UAAIsB,iBAAJ,EAAuB;AACrB,YAAI,KAAK3E,KAAL,CAAW6E,iBAAf,EAAkC;AAChC,eAAKC,kBAAL,CAAwB1B,SAAxB;AACD,SAHoB,CAIrB;;;AACA,aAAK2B,uBAAL;;AACA,aAAK/E,KAAL,CAAW2E,iBAAX,GAA+B,KAA/B;AACD;AACF;AAED;AACF;AACA;;;;8CAC4B;AACxB,UAAI,KAAK3E,KAAL,CAAW+E,uBAAX,EAAJ,EAA0C;AACxC,aAAK/E,KAAL,CAAWgF,eAAX;;AACA,YAAI,KAAKhF,KAAL,CAAWoB,MAAX,IAAqB,KAAKpB,KAAL,CAAWoB,MAAX,CAAkBiD,QAA3C,EAAqD;AACnD,eAAKrE,KAAL,CAAWoB,MAAX,CAAkB6D,iBAAlB;AACD;;AACD,aAAKjF,KAAL,CAAWkF,KAAX,CAAiB,IAAjB,EACG1B,GADH,CACO,OADP,EACgB,KAAKxD,KAAL,CAAWmF,QAD3B;AAED;AACF;AAED;AACF;AACA;;;;iDAC+B;AAC3B,WAAKnF,KAAL,CAAWsB,cAAX,GAA4B6C,OAA5B,CAAoC,UAASiB,MAAT,EAAiB;AACnD,YAAIA,MAAM,CAACC,iBAAP,IAA4BD,MAAM,CAACE,yBAAvC,EAAkE;AAChE,eAAKtF,KAAL,CAAWuF,WAAX,CAAuBH,MAAvB,EAA+BA,MAAM,CAACI,oBAAtC;AACD;AACF,OAJD,EAIG,IAJH;AAKD;AAED;AACF;AACA;;;;uCACqBpC,S,EAAW;AAC5B,UAAIqC,QAAJ;AAAA,UAAcC,MAAd;AAAA,UACEC,eAAe,GAAG,EADpB;AAAA,UAEEC,YAAY,GAAG,CAFjB;AAAA,UAGEC,iBAAiB,GAAG,CAHtB;AAAA,UAIEC,UAAU,GAAG1C,SAAS,IAAI,KAAKpD,KAAL,CAAWW,KAAX,CAAiB0C,KAAjB,EAJ5B;AAAA,UAKE0C,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWH,UAAU,GAAG,KAAK9F,KAAL,CAAWkG,cAAnC,CALnB,CAD4B,CAQ5B;;AACA,WAAKlG,KAAL,CAAWsB,cAAX,GAA4B6C,OAA5B,CAAoC,UAASiB,MAAT,EAAiB;AACnD,YAAIA,MAAM,CAACe,UAAP,IAAqBf,MAAM,CAACC,iBAAhC,EAAmD;AACjDU,UAAAA,cAAc,IAAIX,MAAM,CAAC/B,KAAzB;AACD,SAFD,MAEO;AACLsC,UAAAA,eAAe,CAACS,IAAhB,CAAqBhB,MAArB;AACAQ,UAAAA,YAAY,IAAIR,MAAM,CAAC/B,KAAvB;AACAwC,UAAAA,iBAAiB,IAAIT,MAAM,CAACiB,YAA5B;AACD;AACF,OARD;;AAUA,UAAIN,cAAc,KAAKH,YAAvB,EAAqC;AACnC;AACA;AACD;;AAED,UAAIU,cAAc,GAAGP,cAArB,CAxB4B,CA0B5B;;AACA,UAAIQ,eAAe,GAAGZ,eAAe,CAACa,MAAhB,CAAuB,UAASpB,MAAT,EAAiB;AAC5D;AACA;AACA,YAAIqB,QAAQ,GAAGT,IAAI,CAACU,GAAL,CAAStB,MAAM,CAACqB,QAAhB,EAA0BrB,MAAM,CAACiB,YAAjC,CAAf;;AACA,YAAIR,iBAAiB,KAAK,CAA1B,EAA6B;AAC3BH,UAAAA,MAAM,GAAG,IAAIC,eAAe,CAACnE,MAA7B;AACD,SAFD,MAEO;AACLkE,UAAAA,MAAM,GAAGN,MAAM,CAACiB,YAAP,GAAsBR,iBAA/B;AACD;;AACDJ,QAAAA,QAAQ,GAAGO,IAAI,CAACC,KAAL,CAAWP,MAAM,GAAGY,cAApB,CAAX;;AACA,YAAIb,QAAQ,GAAGgB,QAAf,EAAyB;AACvBhB,UAAAA,QAAQ,GAAGgB,QAAX;AACAH,UAAAA,cAAc,GAAGN,IAAI,CAACU,GAAL,CAASJ,cAAc,GAAGb,QAA1B,EAAoC,CAApC,CAAjB;AACA,iBAAO,IAAP;AACD;;AACD,eAAO,KAAP;AACD,OAhBqB,CAAtB,CA3B4B,CA6C5B;;AACAc,MAAAA,eAAe,CAACpC,OAAhB,CAAwB,UAASiB,MAAT,EAAiBuB,KAAjB,EAAwB;AAC9C,YAAIF,QAAQ,GAAGT,IAAI,CAACU,GAAL,CAAStB,MAAM,CAACqB,QAAhB,EAA0BrB,MAAM,CAACiB,YAAjC,CAAf;AACA9G,QAAAA,MAAM,CAACqH,MAAP,CAAcjB,eAAd,EAA+BP,MAA/B;AAEAK,QAAAA,QAAQ,GAAGgB,QAAX;AACAZ,QAAAA,iBAAiB,IAAIT,MAAM,CAACiB,YAA5B,CAL8C,CAM9C;;AACA,YAAIM,KAAK,KAAKJ,eAAe,CAAC/E,MAAhB,GAAyB,CAAnC,IAAwC8E,cAAc,GAAG,CAAzD,IAA8DX,eAAe,CAACnE,MAAhB,KAA2B,CAA7F,EAAgG;AAC9FiE,UAAAA,QAAQ,IAAIa,cAAZ;AACAA,UAAAA,cAAc,GAAG,CAAjB;AACD;;AACD,YAAIb,QAAQ,KAAKL,MAAM,CAAC/B,KAAxB,EAA+B;AAC7B,eAAKrD,KAAL,CAAW6G,YAAX,CAAwBzB,MAAxB,EAAgCK,QAAhC;AACD;AACF,OAduB,CActBqB,IAdsB,CAcjB,IAdiB,CAAxB,EA9C4B,CA8D5B;;AACAf,MAAAA,cAAc,GAAGO,cAAjB;AACAX,MAAAA,eAAe,CAACxB,OAAhB,CAAwB,UAASiB,MAAT,EAAiBuB,KAAjB,EAAwB;AAC9C,YAAId,iBAAiB,KAAK,CAA1B,EAA6B;AAC3BH,UAAAA,MAAM,GAAG,IAAIC,eAAe,CAACnE,MAA7B;AACD,SAFD,MAEO;AACLkE,UAAAA,MAAM,GAAGN,MAAM,CAACiB,YAAP,GAAsBR,iBAA/B;AACD;;AACDJ,QAAAA,QAAQ,GAAGO,IAAI,CAACC,KAAL,CAAWP,MAAM,GAAGK,cAApB,CAAX;AACAO,QAAAA,cAAc,IAAIb,QAAlB,CAP8C,CAQ9C;;AACA,YAAIkB,KAAK,KAAKhB,eAAe,CAACnE,MAAhB,GAAyB,CAAnC,IAAwC8E,cAAc,GAAG,CAA7D,EAAgE;AAC9Db,UAAAA,QAAQ,IAAIa,cAAZ;AACAA,UAAAA,cAAc,GAAG,CAAjB;AACD;;AACD,YAAIb,QAAQ,KAAKL,MAAM,CAAC/B,KAAxB,EAA+B;AAC7B,eAAKrD,KAAL,CAAW6G,YAAX,CAAwBzB,MAAxB,EAAgCK,QAAhC;AACD;AACF,OAhBuB,CAgBtBqB,IAhBsB,CAgBjB,IAhBiB,CAAxB;AAiBD;;;wCAEmB5G,U,EAAY6G,O,EAAS;AACvC,UAAI,KAAK/G,KAAL,CAAW0D,QAAf,EAAyB;AACvB;AACA,eAAO,IAAI9D,SAAJ,GAAgBoH,mBAAhB,CAAoC9G,UAApC,EAAgD6G,OAAhD,CAAP;AACD,OAJsC,CAKvC;;;AACA,WAAKpD,cAAL,CAAoBoD,OAAO,CAAC3D,SAA5B,EANuC,CAQvC;AACA;;;AACA,WAAKpD,KAAL,CAAWiE,eAAX;;AACA,kGAAiC/D,UAAjC,EAA6C6G,OAA7C;AACD;;;;EA1PsCzH,c;;SAApBS,W","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {AbstractLayout, arrays, Dimension, graphics, HtmlComponent, MenuBarLayout, RowLayout, scout, scrollbars} from '../index';\n\nexport default class TableLayout extends AbstractLayout {\n\n  constructor(table) {\n    super();\n    this.table = table;\n    this._dataHeightPositive = false;\n  }\n\n  layout($container) {\n    var menuBarHeight = 0,\n      footerHeight = 0,\n      headerHeight = 0,\n      tileTableHeight = 0,\n      controlContainerHeight = 0,\n      controlContainerInsets,\n      tileAccordion = this.table.tableTileGridMediator ? this.table.tableTileGridMediator.tileAccordion : null,\n      $data = this.table.$data,\n      dataMargins = graphics.margins(scout.nvl($data, this.table.$container)),\n      dataMarginsHeight = dataMargins.top + dataMargins.bottom,\n      menuBar = this.table.menuBar,\n      footer = this.table.footer,\n      header = this.table.header,\n      tileTableHeader = this.table.tileTableHeader,\n      visibleColumns = this.table.visibleColumns(),\n      lastColumn = visibleColumns[visibleColumns.length - 1],\n      htmlContainer = this.table.htmlComp,\n      containerSize = htmlContainer.availableSize({\n        exact: true\n      }).subtract(htmlContainer.insets());\n\n    if (this.table.menuBarVisible && menuBar.visible) {\n      var htmlMenuBar = HtmlComponent.get(menuBar.$container);\n      var menuBarSize = MenuBarLayout.size(htmlMenuBar, containerSize);\n      htmlMenuBar.setSize(menuBarSize);\n      menuBarHeight = menuBarSize.height;\n    }\n    if (header) {\n      headerHeight = graphics.size(header.$container).height;\n      if (header.menuBar) {\n        header.menuBar.validateLayout();\n      }\n    }\n    if (footer) {\n      // Layout table footer and add size of footer (including the control content) to 'height'\n      footerHeight = graphics.size(footer.$container).height;\n      controlContainerHeight = footer.computeControlContainerHeight(this.table, footer.selectedControl, !this._dataHeightPositive);\n      controlContainerInsets = graphics.insets(footer.$controlContainer);\n      if (!footer.animating) { // closing or opening: height is about to be changed\n        footer.$controlContainer.cssHeight(controlContainerHeight);\n        footer.$controlContent.outerHeight(controlContainerHeight - controlContainerInsets.vertical());\n        footer.revalidateLayout();\n      }\n    }\n    if (tileTableHeader && tileTableHeader.visible) {\n      var groupBoxSize = tileTableHeader.htmlComp.prefSize({\n        widthHint: containerSize.width\n      });\n      groupBoxSize.width = containerSize.width;\n      groupBoxSize = groupBoxSize.subtract(tileTableHeader.htmlComp.margins());\n      tileTableHeader.htmlComp.setSize(groupBoxSize);\n      tileTableHeight = groupBoxSize.height;\n    }\n    var controlsHeight = dataMarginsHeight + menuBarHeight + controlContainerHeight + footerHeight + headerHeight + tileTableHeight;\n    var dataHeight = containerSize.height - controlsHeight;\n    if ($data) {\n      $data.css('height', 'calc(100% - ' + controlsHeight + 'px)');\n      this._dataHeightPositive = $data.height() > 0;\n    } else {\n      if (tileAccordion && tileAccordion.htmlComp) {\n        tileAccordion.htmlComp.setSize(new Dimension(containerSize.width, dataHeight));\n        scrollbars.update(tileAccordion.$container);\n        this._dataHeightPositive = dataHeight > 0;\n      }\n    }\n\n    if (!this.table.tileMode) {\n      this._layoutColumns();\n\n      // Size of last column may have to be adjusted due to the header menu items\n      if (header) {\n        header.resizeHeaderItem(lastColumn);\n      }\n\n      this.table.setViewRangeSize(this.table.calculateViewRangeSize());\n\n      if (!htmlContainer.layouted) {\n        this.table._renderScrollTop();\n      }\n\n      // Always render viewport (not only when viewRangeSize changes), because view range depends on scroll position and data height\n      this.table._renderViewport();\n\n      // Make sure tooltips and editor popup are at correct position after layouting (e.g after window resizing)\n      this.table.tooltips.forEach(function(tooltip) {\n        if (tooltip.rendered) {\n          tooltip.position();\n        }\n      });\n      if (this.table.cellEditorPopup && this.table.cellEditorPopup.rendered) {\n        this.table.cellEditorPopup.position();\n        this.table.cellEditorPopup.pack();\n      }\n\n      this.table.updateScrollbars();\n    }\n  }\n\n  _layoutColumns(widthHint) {\n    this._autoOptimizeColumnsWidths();\n\n    var htmlContainer = this.table.htmlComp;\n    var columnLayoutDirty = this.table.columnLayoutDirty || !htmlContainer.sizeCached;\n    if (!columnLayoutDirty) {\n      var width = widthHint || htmlContainer.size().width;\n      columnLayoutDirty = htmlContainer.sizeCached.width !== width;\n    }\n    // Auto resize only if table width or column structure has changed\n    if (columnLayoutDirty) {\n      if (this.table.autoResizeColumns) {\n        this._autoResizeColumns(widthHint);\n      }\n      // This is already done in _renderRowsInRange, but it is necessary here as well if the zoom level changes dynamically (or autoResizeColumns toggles)\n      this._updateRealColumnWidths();\n      this.table.columnLayoutDirty = false;\n    }\n  }\n\n  /**\n   * Workaround for Chrome bug, see {@link Table._updateRealColumnWidths}\n   */\n  _updateRealColumnWidths() {\n    if (this.table._updateRealColumnWidths()) {\n      this.table._updateRowWidth();\n      if (this.table.header && this.table.header.rendered) {\n        this.table.header.resizeHeaderItems();\n      }\n      this.table.$rows(true)\n        .css('width', this.table.rowWidth);\n    }\n  }\n\n  /**\n   * Resizes all visible columns with autoOptimizeWidth set to true, if necessary (means if autoOptimizeWidthRequired is true)\n   */\n  _autoOptimizeColumnsWidths() {\n    this.table.visibleColumns().forEach(function(column) {\n      if (column.autoOptimizeWidth && column.autoOptimizeWidthRequired) {\n        this.table.resizeToFit(column, column.autoOptimizeMaxWidth);\n      }\n    }, this);\n  }\n\n  /**\n   * Resizes the visible columns to make them use all the available space.\n   */\n  _autoResizeColumns(widthHint) {\n    var newWidth, weight,\n      relevantColumns = [],\n      currentWidth = 0,\n      totalInitialWidth = 0,\n      tableWidth = widthHint || this.table.$data.width(),\n      availableWidth = Math.floor(tableWidth - this.table.rowBorderWidth);\n\n    // Don't resize fixed and auto optimize width columns\n    this.table.visibleColumns().forEach(function(column) {\n      if (column.fixedWidth || column.autoOptimizeWidth) {\n        availableWidth -= column.width;\n      } else {\n        relevantColumns.push(column);\n        currentWidth += column.width;\n        totalInitialWidth += column.initialWidth;\n      }\n    });\n\n    if (availableWidth === currentWidth) {\n      // Columns already use the available space, no need to resize\n      return;\n    }\n\n    var remainingWidth = availableWidth;\n\n    // First, filter columns which would get smaller than their minimal size\n    var minWidthColumns = relevantColumns.filter(function(column) {\n      // Use initial width as preferred width for auto resize columns.\n      // This makes sure the column doesn't get too small on small screens. The user can still make the column smaller though.\n      var minWidth = Math.max(column.minWidth, column.initialWidth);\n      if (totalInitialWidth === 0) {\n        weight = 1 / relevantColumns.length;\n      } else {\n        weight = column.initialWidth / totalInitialWidth;\n      }\n      newWidth = Math.floor(weight * remainingWidth);\n      if (newWidth < minWidth) {\n        newWidth = minWidth;\n        remainingWidth = Math.max(remainingWidth - newWidth, 0);\n        return true;\n      }\n      return false;\n    });\n\n    // Resize them to their minimal width\n    minWidthColumns.forEach(function(column, index) {\n      var minWidth = Math.max(column.minWidth, column.initialWidth);\n      arrays.remove(relevantColumns, column);\n\n      newWidth = minWidth;\n      totalInitialWidth -= column.initialWidth;\n      // If this is the last column, add remaining space (due to rounding) to this column\n      if (index === minWidthColumns.length - 1 && remainingWidth > 0 && relevantColumns.length === 0) {\n        newWidth += remainingWidth;\n        remainingWidth = 0;\n      }\n      if (newWidth !== column.width) {\n        this.table.resizeColumn(column, newWidth);\n      }\n    }.bind(this));\n\n    // Then resize the others\n    availableWidth = remainingWidth;\n    relevantColumns.forEach(function(column, index) {\n      if (totalInitialWidth === 0) {\n        weight = 1 / relevantColumns.length;\n      } else {\n        weight = column.initialWidth / totalInitialWidth;\n      }\n      newWidth = Math.floor(weight * availableWidth);\n      remainingWidth -= newWidth;\n      // If this is the last column, add remaining space (due to rounding) to this column\n      if (index === relevantColumns.length - 1 && remainingWidth > 0) {\n        newWidth += remainingWidth;\n        remainingWidth = 0;\n      }\n      if (newWidth !== column.width) {\n        this.table.resizeColumn(column, newWidth);\n      }\n    }.bind(this));\n  }\n\n  preferredLayoutSize($container, options) {\n    if (this.table.tileMode) {\n      // Use RowLayout to calculate preferredLayoutSize of TileTableHeader, TileAccordion and Footer.\n      return new RowLayout().preferredLayoutSize($container, options);\n    }\n    // If autoResizeColumns and text wrap is enabled, the height of the table depends on the width\n    this._layoutColumns(options.widthHint);\n\n    // If table was not visible during renderViewport, the rows are not rendered yet (see _renderViewport)\n    // -> make sure rows are rendered otherwise preferred height cannot be determined\n    this.table._renderViewport();\n    return super.preferredLayoutSize($container, options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}