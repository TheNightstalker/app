{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Column, LookupCall, LookupRow, scout, SmartField, strings } from '../../index';\nimport objects from '../../util/objects';\n\nvar SmartColumn = /*#__PURE__*/function (_Column) {\n  _inherits(SmartColumn, _Column);\n\n  var _super = _createSuper(SmartColumn);\n\n  function SmartColumn() {\n    var _this;\n\n    _classCallCheck(this, SmartColumn);\n\n    _this = _super.call(this);\n    _this.codeType = null;\n    _this.lookupCall = null;\n    _this.browseHierarchy = false;\n    _this.browseMaxRowCount = SmartField.DEFAULT_BROWSE_MAX_COUNT;\n    _this.browseAutoExpandAll = true;\n    _this.browseLoadIncremental = false;\n    _this.activeFilterEnabled = false;\n    _this._lookupCallBatchContext = null;\n    return _this;\n  }\n  /**\n   * @override\n   */\n\n\n  _createClass(SmartColumn, [{\n    key: \"_init\",\n    value: function _init(model) {\n      _get(_getPrototypeOf(SmartColumn.prototype), \"_init\", this).call(this, model);\n\n      this._setLookupCall(this.lookupCall);\n\n      this._setCodeType(this.codeType);\n    }\n  }, {\n    key: \"setLookupCall\",\n    value: function setLookupCall(lookupCall) {\n      if (this.lookupCall === lookupCall) {\n        return;\n      }\n\n      this._setLookupCall(lookupCall);\n    }\n  }, {\n    key: \"_setLookupCall\",\n    value: function _setLookupCall(lookupCall) {\n      this.lookupCall = LookupCall.ensure(lookupCall, this.session);\n    }\n  }, {\n    key: \"setCodeType\",\n    value: function setCodeType(codeType) {\n      if (this.codeType === codeType) {\n        return;\n      }\n\n      this._setCodeType(codeType);\n    }\n  }, {\n    key: \"_setCodeType\",\n    value: function _setCodeType(codeType) {\n      this.codeType = codeType;\n\n      if (!codeType) {\n        return;\n      }\n\n      this.lookupCall = scout.create('CodeLookupCall', {\n        session: this.session,\n        codeType: codeType\n      });\n    }\n  }, {\n    key: \"setBrowseHierarchy\",\n    value: function setBrowseHierarchy(browseHierarchy) {\n      this.browseHierarchy = browseHierarchy;\n    }\n  }, {\n    key: \"setBrowseMaxRowCount\",\n    value: function setBrowseMaxRowCount(browseMaxRowCount) {\n      this.browseMaxRowCount = browseMaxRowCount;\n    }\n  }, {\n    key: \"setBrowseAutoExpandAll\",\n    value: function setBrowseAutoExpandAll(browseAutoExpandAll) {\n      this.browseAutoExpandAll = browseAutoExpandAll;\n    }\n  }, {\n    key: \"setBrowseLoadIncremental\",\n    value: function setBrowseLoadIncremental(browseLoadIncremental) {\n      this.browseLoadIncremental = browseLoadIncremental;\n    }\n  }, {\n    key: \"setActiveFilterEnabled\",\n    value: function setActiveFilterEnabled(activeFilterEnabled) {\n      this.activeFilterEnabled = activeFilterEnabled;\n    }\n  }, {\n    key: \"_formatValue\",\n    value: function _formatValue(value) {\n      if (!this.lookupCall) {\n        return strings.nvl(value) + '';\n      }\n\n      if (this.lookupCall.batch) {\n        return this._batchFormatValue(value);\n      }\n\n      return this.lookupCall.textByKey(value);\n    }\n    /**\n     * Defers all invocations of the lookup call for the duration of the current event handler.\n     * Once the current event handler completes, all lookup calls are resolved in a single batch.\n     */\n\n  }, {\n    key: \"_batchFormatValue\",\n    value: function _batchFormatValue(key) {\n      if (objects.isNullOrUndefined(key)) {\n        return $.resolvedPromise('');\n      }\n\n      var currentBatchContext = this._lookupCallBatchContext;\n\n      if (!currentBatchContext) {\n        // create new batch context for this column\n        var batchResult = $.Deferred();\n        currentBatchContext = {\n          keySet: {},\n          result: batchResult.promise()\n        };\n        this._lookupCallBatchContext = currentBatchContext;\n        setTimeout(function () {\n          // reset batch context for next batch run\n          this._lookupCallBatchContext = null; // batch lookup texts\n\n          this.lookupCall.textsByKeys(Object.keys(currentBatchContext.keySet)).then(function (textMap) {\n            // resolve result in current batch context\n            batchResult.resolve(textMap);\n          }).catch(function (e) {\n            batchResult.reject(e);\n          });\n        }.bind(this));\n      } // add key to current batch\n\n\n      currentBatchContext.keySet[key] = true; // return text for current key\n\n      return currentBatchContext.result.then(function (textMap) {\n        return textMap[key] || '';\n      });\n    }\n    /**\n     * Create and set the lookup-row instead of call setValue() as this would execute a lookup by key\n     * which is not necessary, since the cell already contains text and value. This also avoids a problem\n     * with multiple lookups running at once, see ticket 236960.\n     */\n\n  }, {\n    key: \"_initEditorField\",\n    value: function _initEditorField(field, cell) {\n      if (objects.isNullOrUndefined(cell.value)) {\n        field.setValue(null);\n        return;\n      }\n\n      var lookupRow = new LookupRow();\n      lookupRow.key = cell.value;\n      lookupRow.text = cell.text;\n      field.setLookupRow(lookupRow);\n    }\n  }, {\n    key: \"_createEditor\",\n    value: function _createEditor(row) {\n      var field = scout.create('SmartField', {\n        parent: this.table,\n        codeType: this.codeType,\n        lookupCall: this.lookupCall,\n        browseHierarchy: this.browseHierarchy,\n        browseMaxRowCount: this.browseMaxRowCount,\n        browseAutoExpandAll: this.browseAutoExpandAll,\n        browseLoadIncremental: this.browseLoadIncremental,\n        activeFilterEnabled: this.activeFilterEnabled\n      });\n      field.on('prepareLookupCall', function (event) {\n        this.trigger('prepareLookupCall', {\n          lookupCall: event.lookupCall,\n          row: row\n        });\n      }.bind(this));\n      field.on('lookupCallDone', function (event) {\n        this.trigger('lookupCallDone', {\n          result: event.result\n        });\n      }.bind(this));\n      return field;\n    }\n    /**\n     * Since we don't know the type of the key from the lookup-row we must deal with numeric and string types here.\n     */\n\n  }, {\n    key: \"_hasCellValue\",\n    value: function _hasCellValue(cell) {\n      var value = cell.value;\n\n      if (objects.isNumber(value)) {\n        return !objects.isNullOrUndefined(value); // Zero (0) is valid too\n      }\n\n      return !!value;\n    }\n  }]);\n\n  return SmartColumn;\n}(Column);\n\nexport { SmartColumn as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/table/columns/SmartColumn.js"],"names":["Column","LookupCall","LookupRow","scout","SmartField","strings","objects","SmartColumn","codeType","lookupCall","browseHierarchy","browseMaxRowCount","DEFAULT_BROWSE_MAX_COUNT","browseAutoExpandAll","browseLoadIncremental","activeFilterEnabled","_lookupCallBatchContext","model","_setLookupCall","_setCodeType","ensure","session","create","value","nvl","batch","_batchFormatValue","textByKey","key","isNullOrUndefined","$","resolvedPromise","currentBatchContext","batchResult","Deferred","keySet","result","promise","setTimeout","textsByKeys","Object","keys","then","textMap","resolve","catch","e","reject","bind","field","cell","setValue","lookupRow","text","setLookupRow","row","parent","table","on","event","trigger","isNumber"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Column, LookupCall, LookupRow, scout, SmartField, strings} from '../../index';\nimport objects from '../../util/objects';\n\nexport default class SmartColumn extends Column {\n\n  constructor() {\n    super();\n    this.codeType = null;\n    this.lookupCall = null;\n    this.browseHierarchy = false;\n    this.browseMaxRowCount = SmartField.DEFAULT_BROWSE_MAX_COUNT;\n    this.browseAutoExpandAll = true;\n    this.browseLoadIncremental = false;\n    this.activeFilterEnabled = false;\n    this._lookupCallBatchContext = null;\n  }\n\n  /**\n   * @override\n   */\n  _init(model) {\n    super._init(model);\n    this._setLookupCall(this.lookupCall);\n    this._setCodeType(this.codeType);\n  }\n\n  setLookupCall(lookupCall) {\n    if (this.lookupCall === lookupCall) {\n      return;\n    }\n    this._setLookupCall(lookupCall);\n  }\n\n  _setLookupCall(lookupCall) {\n    this.lookupCall = LookupCall.ensure(lookupCall, this.session);\n  }\n\n  setCodeType(codeType) {\n    if (this.codeType === codeType) {\n      return;\n    }\n    this._setCodeType(codeType);\n  }\n\n  _setCodeType(codeType) {\n    this.codeType = codeType;\n    if (!codeType) {\n      return;\n    }\n    this.lookupCall = scout.create('CodeLookupCall', {\n      session: this.session,\n      codeType: codeType\n    });\n  }\n\n  setBrowseHierarchy(browseHierarchy) {\n    this.browseHierarchy = browseHierarchy;\n  }\n\n  setBrowseMaxRowCount(browseMaxRowCount) {\n    this.browseMaxRowCount = browseMaxRowCount;\n  }\n\n  setBrowseAutoExpandAll(browseAutoExpandAll) {\n    this.browseAutoExpandAll = browseAutoExpandAll;\n  }\n\n  setBrowseLoadIncremental(browseLoadIncremental) {\n    this.browseLoadIncremental = browseLoadIncremental;\n  }\n\n  setActiveFilterEnabled(activeFilterEnabled) {\n    this.activeFilterEnabled = activeFilterEnabled;\n  }\n\n  _formatValue(value) {\n    if (!this.lookupCall) {\n      return strings.nvl(value) + '';\n    }\n\n    if (this.lookupCall.batch) {\n      return this._batchFormatValue(value);\n    }\n\n    return this.lookupCall.textByKey(value);\n  }\n\n  /**\n   * Defers all invocations of the lookup call for the duration of the current event handler.\n   * Once the current event handler completes, all lookup calls are resolved in a single batch.\n   */\n  _batchFormatValue(key) {\n    if (objects.isNullOrUndefined(key)) {\n      return $.resolvedPromise('');\n    }\n\n    var currentBatchContext = this._lookupCallBatchContext;\n    if (!currentBatchContext) {\n      // create new batch context for this column\n      var batchResult = $.Deferred();\n      currentBatchContext = {\n        keySet: {},\n        result: batchResult.promise()\n      };\n      this._lookupCallBatchContext = currentBatchContext;\n\n      setTimeout(function() {\n        // reset batch context for next batch run\n        this._lookupCallBatchContext = null;\n\n        // batch lookup texts\n        this.lookupCall.textsByKeys(Object.keys(currentBatchContext.keySet)).then(function(textMap) {\n          // resolve result in current batch context\n          batchResult.resolve(textMap);\n        }).catch(function(e) {\n          batchResult.reject(e);\n        });\n      }.bind(this));\n    }\n\n    // add key to current batch\n    currentBatchContext.keySet[key] = true;\n\n    // return text for current key\n    return currentBatchContext.result.then(function(textMap) {\n      return textMap[key] || '';\n    });\n  }\n\n  /**\n   * Create and set the lookup-row instead of call setValue() as this would execute a lookup by key\n   * which is not necessary, since the cell already contains text and value. This also avoids a problem\n   * with multiple lookups running at once, see ticket 236960.\n   */\n  _initEditorField(field, cell) {\n    if (objects.isNullOrUndefined(cell.value)) {\n      field.setValue(null);\n      return;\n    }\n\n    var lookupRow = new LookupRow();\n    lookupRow.key = cell.value;\n    lookupRow.text = cell.text;\n    field.setLookupRow(lookupRow);\n  }\n\n  _createEditor(row) {\n    var field = scout.create('SmartField', {\n      parent: this.table,\n      codeType: this.codeType,\n      lookupCall: this.lookupCall,\n      browseHierarchy: this.browseHierarchy,\n      browseMaxRowCount: this.browseMaxRowCount,\n      browseAutoExpandAll: this.browseAutoExpandAll,\n      browseLoadIncremental: this.browseLoadIncremental,\n      activeFilterEnabled: this.activeFilterEnabled\n    });\n\n    field.on('prepareLookupCall', function(event) {\n      this.trigger('prepareLookupCall', {\n        lookupCall: event.lookupCall,\n        row: row\n      });\n    }.bind(this));\n    field.on('lookupCallDone', function(event) {\n      this.trigger('lookupCallDone', {\n        result: event.result\n      });\n    }.bind(this));\n\n    return field;\n  }\n\n  /**\n   * Since we don't know the type of the key from the lookup-row we must deal with numeric and string types here.\n   */\n  _hasCellValue(cell) {\n    var value = cell.value;\n    if (objects.isNumber(value)) {\n      return !objects.isNullOrUndefined(value); // Zero (0) is valid too\n    }\n    return !!value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}