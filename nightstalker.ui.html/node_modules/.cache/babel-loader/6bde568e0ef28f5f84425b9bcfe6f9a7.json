{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Dimension, graphics, Insets, NullLayout, scout } from '../index';\nimport $ from 'jquery';\n/**\n * Wrapper for a JQuery selector. Used as replacement for javax.swing.JComponent.\n */\n\nvar HtmlComponent = /*#__PURE__*/function () {\n  function HtmlComponent($comp, session) {\n    _classCallCheck(this, HtmlComponent);\n\n    if (!session) {\n      throw new Error('session must be defined for ' + this.debug());\n    }\n\n    this.$comp = $comp;\n    this.layout = new NullLayout();\n    this.layoutData = null;\n    this.valid = false;\n    this.validateRoot = false;\n    /**\n     * Flag to indicate that the component has been layouted at least once. Invalidation should NOT reset this flag.\n     */\n\n    this.layouted = false;\n    /**\n     * Flag to indicate that the component is being layouted.\n     */\n\n    this.layouting = false;\n    /**\n     * May be set to temporarily disable invalidation (e.g. if the component gets modified during the layouting process)\n     */\n\n    this.suppressInvalidate = false;\n    /**\n     * Set pixelBasedSizing to false if your component automatically adjusts its size,\n     * e.g. by using CSS styling -> setSize won't be called.\n     */\n\n    this.pixelBasedSizing = true;\n    this.sizeCached = null;\n    /**\n     * Object which stores the computed preferred size. Key is a string containing the width and height hints.\n     * @see #computePrefSizeKey(options);\n     */\n\n    this.prefSizeCached = {};\n    this.session = session;\n    this.scrollable = false;\n  }\n  /**\n   * Returns the parent or $comp or null when $comp has no parent.\n   * Creates a new instance of HtmlComponent if the parent DOM element has no linked instance yet.\n   */\n\n\n  _createClass(HtmlComponent, [{\n    key: \"getParent\",\n    value: function getParent() {\n      var $parent = this.$comp.parent();\n\n      if ($parent.length === 0) {\n        return null;\n      }\n\n      return HtmlComponent.optGet($parent);\n    }\n    /**\n     * @returns {boolean} true if the given htmlComponent is an ancestor, false if not\n     */\n\n  }, {\n    key: \"isDescendantOf\",\n    value: function isDescendantOf(htmlComp) {\n      var $parent = this.$comp.parent();\n\n      while ($parent.length > 0) {\n        if (HtmlComponent.optGet($parent) === htmlComp) {\n          return true;\n        }\n\n        $parent = $parent.parent();\n      }\n\n      return false;\n    }\n    /**\n     * Computes the preferred height if the component is scrollable and returns it if it is greater than the actual size.\n     * If it is not scrollable, the actual height is returned.\n     * <p>\n     * The returned size contains insets (padding and border) but no margin. The width is always the actual width because there are no horizontal scrollbars.\n     *\n     * OPTION    DEFAULT VALUE   DESCRIPTION\n     * -------------------------------------\n     * exact     false           When set to true the returned dimensions may contain fractional digits, otherwise the sizes are rounded up.\n     *\n     * @param (options) may contain the options of the above table\n     */\n\n  }, {\n    key: \"availableSize\",\n    value: function availableSize(options) {\n      options = options || {};\n      var size = this.size({\n        exact: options.exact\n      });\n\n      if (this.scrollable) {\n        var prefSize = this.prefSize({\n          widthHint: size.width,\n          removeMarginFromHints: false // Since the width of this component is used as hint, the margin must not be removed\n\n        });\n\n        if (prefSize.height > size.height) {\n          size.height = prefSize.height;\n        }\n      }\n\n      return size;\n    }\n    /**\n     * Invalidates the component (sets the valid property to false and calls layout.invalidate()).\n     * @param {HtmlComponent} [htmlSource] The component the invalidation originated from.\n     *        Is always set if the invalidation is triggered by using invalidateLayoutTree, may be undefined otherwise.\n     */\n\n  }, {\n    key: \"invalidateLayout\",\n    value: function invalidateLayout(htmlSource) {\n      this.valid = false;\n      this.prefSizeCached = {};\n\n      if (this.layout) {\n        this.layout.invalidate(htmlSource);\n      }\n    }\n    /**\n     * Calls the layout of the component to layout its children but only if the component is not valid.\n     * @exception when component has no layout\n     * @return {boolean} true if validation was successful, false if it could not be executed (e.g. because the element is invisible or detached)\n     */\n\n  }, {\n    key: \"validateLayout\",\n    value: function validateLayout() {\n      if (!this.layout) {\n        throw new Error('Called layout() but component has no layout');\n      }\n\n      if (!this.valid) {\n        if (!this._checkValidationPossible()) {\n          return false;\n        }\n\n        this.layouting = true;\n        this.layout.layout(this.$comp);\n        this.layouting = false;\n        this.layouted = true; // Save size for later use (necessary if pixelBasedSizing is set to false)\n\n        this.sizeCached = this.size({\n          exact: true\n        });\n        this.valid = true;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_checkValidationPossible\",\n    value: function _checkValidationPossible() {\n      // Don't layout components which don't exist anymore, are invisible or are detached from the DOM\n      if (!this.isAttachedAndVisible()) {\n        return false;\n      } // Don't layout if component is currently animated\n\n\n      if (this.$comp.hasAnimationClass()) {\n        this._validateLayoutAfterAnimation(this.$comp);\n\n        return false;\n      } // Check the visibility of the parents as well.\n      // Also check if one of the parents is currently being animated.\n      // To improve performance (the check might loop to the top of the DOM tree), the following code is\n      // not executed if the parent already executed it, which is the case if the parent is being layouted.\n\n\n      var parent = this.getParent();\n\n      if (!parent || !parent.layouting) {\n        var everyParentVisible = true;\n        var $animatedParent = null;\n        this.$comp.parents().each(function () {\n          var $parent = $(this);\n\n          if (!$parent.isVisible()) {\n            everyParentVisible = false;\n            return false;\n          }\n\n          if ($parent.hasAnimationClass()) {\n            $animatedParent = $parent;\n            return false;\n          }\n\n          return true; // continue loop\n        });\n\n        if (!everyParentVisible) {\n          return false;\n        }\n\n        if ($animatedParent) {\n          // Postpone the layout if there is a CSS animation in progress on one of the parent containers.\n          // Otherwise, wrong sizes might be measured (depending on the CSS animation, e.g. grow/shrink).\n          this._validateLayoutAfterAnimation($animatedParent);\n\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_validateLayoutAfterAnimation\",\n    value: function _validateLayoutAfterAnimation($animatedElement) {\n      $animatedElement.oneAnimationEnd(this.validateLayout.bind(this));\n    }\n    /**\n     * Performs invalidateLayout() and validateLayout() subsequently.\n     */\n\n  }, {\n    key: \"revalidateLayout\",\n    value: function revalidateLayout() {\n      this.invalidateLayout();\n      this.validateLayout();\n    }\n    /**\n     * Invalidates the component-tree up to the next validate root, but only if invalidateParents is set to true.\n     */\n\n  }, {\n    key: \"invalidateLayoutTree\",\n    value: function invalidateLayoutTree(invalidateParents) {\n      if (this.suppressInvalidate) {\n        return;\n      }\n\n      if (scout.nvl(invalidateParents, true)) {\n        this.session.layoutValidator.invalidateTree(this); // will call invalidateLayout(), which sets this.valid = false\n      } else {\n        this.invalidateLayout();\n        this.session.layoutValidator.invalidate(this);\n      }\n    }\n    /**\n     * Layouts all invalid components\n     */\n\n  }, {\n    key: \"validateLayoutTree\",\n    value: function validateLayoutTree() {\n      this.session.layoutValidator.validate();\n    }\n    /**\n     * Performs invalidateLayoutTree() and validateLayoutTree() subsequently.\n     */\n\n  }, {\n    key: \"revalidateLayoutTree\",\n    value: function revalidateLayoutTree(invalidateParents) {\n      if (this.suppressInvalidate) {\n        return;\n      }\n\n      this.invalidateLayoutTree(invalidateParents);\n      this.validateLayoutTree();\n    }\n    /**\n     * Marks the end of the parent invalidation. <p>\n     * A component is a validate root if its size does not depend on the visibility or bounds of its children.<p>\n     * Example: It is not necessary to relayout the whole form if just the label of a form field gets invisible.\n     * Only the form field container needs to be relayouted. In this case the form field container is the validate root.\n     */\n\n  }, {\n    key: \"isValidateRoot\",\n    value: function isValidateRoot() {\n      if (this.validateRoot) {\n        return true;\n      }\n\n      if (!this.layoutData || !this.layoutData.isValidateRoot) {\n        return false;\n      }\n\n      return this.layoutData.isValidateRoot();\n    }\n    /**\n     * Sets the given layout.\n     */\n\n  }, {\n    key: \"setLayout\",\n    value: function setLayout(layout) {\n      this.layout = layout;\n\n      if (layout.cssClass) {\n        this.$comp.addClass(layout.cssClass);\n      }\n    }\n    /**\n     * Returns the preferred size of the component, insets included, margin excluded.<p>\n     * The preferred size is cached until the component will be invalidated.\n     * Hence, subsequent calls to this function will return the cached preferred size unless the component is invalidated.\n     * <p>\n     *\n     * @param {object|boolean} [options] an optional options object. Short-hand version: If a boolean is passed instead of an object, the value is automatically converted to the option \"includeMargin\".\n     *                  May contain the options described below. All other options are passed as they are to the layout when layout.preferredLayoutSize() is called.\n     *                  Possible options may be found at graphics.prefSize(), but it depends on the actual layout if these options have an effect or not.\n     * @param {boolean|null} [options.includeMargin] Whether to include the margin in the returned size. Default is false.\n     * @param {number} [options.widthHint] When set, horizontal padding, border and margin are removed from it so that the actual layout does not need to take care of it. Default is null.\n     * @param {number} [options.heightHint] When set, vertical padding, border and margin are removed from it so that the actual layout does not need to take care of it. Default is null.\n     * @param {boolean|null} [options.removeMarginFromHints] Whether or not to automatically remove the margin from the hints. Default is true.\n     * @param {boolean|null} [options.removeInsetsFromHints] Whether or not to automatically remove the insets (padding and border) from the hints. Default is true.\n     * @exception When component has no layout\n     */\n\n  }, {\n    key: \"prefSize\",\n    value: function prefSize(options) {\n      if (!this.isVisible()) {\n        return new Dimension(0, 0);\n      }\n\n      if (typeof options === 'boolean') {\n        options = {\n          includeMargin: options\n        };\n      } else {\n        // Create a copy to not modify the original options\n        options = $.extend({}, options);\n      }\n\n      var includeMargin = scout.nvl(options.includeMargin, false);\n      options.includeMargin = null;\n\n      if (!this.layout) {\n        throw new Error('Called prefSize() but component has no layout');\n      }\n\n      var prefSizeCacheKey = this.computePrefSizeKey(options);\n      var prefSizeCached = this.prefSizeCached[prefSizeCacheKey];\n\n      if (!$.isEmptyObject(prefSizeCached)) {\n        $.log.isTraceEnabled() && $.log.trace('(HtmlComponent#prefSize) ' + this.debug() + ' widthHint=' + options.widthHint + ' heightHint=' + options.heightHint + ' prefSizeCached=' + prefSizeCached);\n\n        if (includeMargin) {\n          prefSizeCached = prefSizeCached.add(this.margins());\n        }\n\n        return prefSizeCached.clone();\n      }\n\n      var minSize = graphics.cssMinSize(this.$comp);\n      var maxSize = graphics.cssMaxSize(this.$comp);\n\n      if (options.widthHint || options.heightHint) {\n        this._adjustSizeHintsForPrefSize(options, minSize, maxSize);\n      }\n\n      var prefSize = this.layout.preferredLayoutSize(this.$comp, options);\n\n      this._adjustPrefSizeWithMinMaxSize(prefSize, minSize, maxSize);\n\n      this.prefSizeCached[prefSizeCacheKey] = prefSize;\n      $.log.isTraceEnabled() && $.log.trace('(HtmlComponent#prefSize) ' + this.debug() + ' widthHint=' + options.widthHint + ' heightHint=' + options.heightHint + ' prefSize=' + prefSize);\n\n      if (includeMargin) {\n        prefSize = prefSize.add(this.margins());\n      }\n\n      return prefSize.clone();\n    }\n  }, {\n    key: \"computePrefSizeKey\",\n    value: function computePrefSizeKey(options) {\n      return 'wHint' + scout.nvl(options.widthHint, '-1') + 'hHint' + scout.nvl(options.heightHint, '-1') + 'wOnly' + scout.nvl(options.widthOnly, '-1');\n    }\n    /**\n     * Remove padding, border and margin from the width and heightHint so that the actual layout does not need to take care of it.\n     * Also makes sure the hints consider the min and max size set by CSS.\n     */\n\n  }, {\n    key: \"_adjustSizeHintsForPrefSize\",\n    value: function _adjustSizeHintsForPrefSize(options, minSize, maxSize) {\n      var removeMargins = scout.nvl(options.removeMarginFromHints, true);\n      var removeInsets = scout.nvl(options.removeInsetsFromHints, true);\n      options.removeMarginFromHints = null;\n      options.removeInsetsFromHints = null;\n\n      if (!options.widthHint && !options.heightHint) {\n        return;\n      }\n\n      var margins = removeMargins ? this.margins() : new Insets();\n      var insets = removeInsets ? this.insets() : new Insets();\n\n      if (options.widthHint) {\n        // The order is important! Box-sizing: border-box is expected.\n        options.widthHint -= margins.horizontal();\n        options.widthHint = Math.max(options.widthHint, minSize.width);\n        options.widthHint = Math.min(options.widthHint, maxSize.width);\n        options.widthHint -= insets.horizontal();\n      }\n\n      if (options.heightHint) {\n        // The order is important! Box-sizing: border-box is expected.\n        options.heightHint -= margins.vertical();\n        options.heightHint = Math.max(options.heightHint, minSize.height);\n        options.heightHint = Math.min(options.heightHint, maxSize.height);\n        options.heightHint -= insets.vertical();\n      }\n    }\n    /**\n     * The html element may define a min or max height/height -> adjust the pref size accordingly\n     */\n\n  }, {\n    key: \"_adjustPrefSizeWithMinMaxSize\",\n    value: function _adjustPrefSizeWithMinMaxSize(prefSize, minSize, maxSize) {\n      minSize = minSize || graphics.cssMinSize(this.$comp);\n      maxSize = maxSize || graphics.cssMaxSize(this.$comp);\n      prefSize.height = Math.max(prefSize.height, minSize.height);\n      prefSize.height = Math.min(prefSize.height, maxSize.height);\n      prefSize.width = Math.max(prefSize.width, minSize.width);\n      prefSize.width = Math.min(prefSize.width, maxSize.width);\n    }\n    /**\n     * Returns the inset-dimensions of the component (padding and border, no margin).\n     */\n\n  }, {\n    key: \"insets\",\n    value: function insets(options) {\n      return graphics.insets(this.$comp, options);\n    }\n  }, {\n    key: \"margins\",\n    value: function margins() {\n      return graphics.margins(this.$comp);\n    }\n  }, {\n    key: \"borders\",\n    value: function borders() {\n      return graphics.borders(this.$comp);\n    }\n    /**\n     * Returns the size of the component, insets included.\n     * @param options, see {@link graphics#size} for details.\n     */\n\n  }, {\n    key: \"size\",\n    value: function size(options) {\n      return graphics.size(this.$comp, options);\n    }\n    /**\n     * Sets the size of the component, insets included. Which means: the method subtracts the components insets\n     * from the given size before setting the width/height of the component.\n     *\n     * @param {Dimension} size\n     */\n\n  }, {\n    key: \"setSize\",\n    value: function setSize(size) {\n      if (!this.isAttachedAndVisible()) {\n        // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong\n        return;\n      }\n\n      var oldSize = this.sizeCached;\n\n      if (!size.equals(oldSize)) {\n        this.invalidateLayout();\n      }\n\n      if (this.pixelBasedSizing) {\n        graphics.setSize(this.$comp, size);\n      }\n\n      this.validateLayout();\n    }\n  }, {\n    key: \"bounds\",\n    value: function bounds(options) {\n      return graphics.bounds(this.$comp, options);\n    }\n  }, {\n    key: \"position\",\n    value: function position() {\n      return graphics.position(this.$comp);\n    }\n  }, {\n    key: \"offsetBounds\",\n    value: function offsetBounds(options) {\n      return graphics.offsetBounds(this.$comp, options);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset() {\n      return graphics.offset(this.$comp);\n    }\n    /**\n     * Delegation to graphics.setLocation\n     * @param location Point\n     */\n\n  }, {\n    key: \"setLocation\",\n    value: function setLocation(location) {\n      graphics.setLocation(this.$comp, location);\n    }\n  }, {\n    key: \"location\",\n    value: function location() {\n      return graphics.location(this.$comp);\n    }\n  }, {\n    key: \"setBounds\",\n    value: function setBounds(bounds) {\n      if (!this.isAttachedAndVisible()) {\n        // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong\n        return;\n      }\n\n      var oldSize = this.sizeCached;\n\n      if (!bounds.dimension().equals(oldSize)) {\n        this.invalidateLayout();\n      }\n\n      if (this.pixelBasedSizing) {\n        graphics.setBounds(this.$comp, bounds);\n      }\n\n      this.validateLayout();\n    }\n    /**\n     * Sets the component to its preferred size.\n     */\n\n  }, {\n    key: \"pack\",\n    value: function pack() {\n      var preferredSize = this.prefSize();\n      this.setSize(preferredSize);\n    }\n    /**\n     * Checks whether $comp is in the DOM or has been removed or detached.<br>\n     * Also returns false if the $comp does not belong to a window (defaultView) anymore. This may happen if it belonged to a popup window which is now closed\n     */\n\n  }, {\n    key: \"isAttached\",\n    value: function isAttached() {\n      return this.$comp.isAttached() && this.$comp.window(true);\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return this.$comp.isVisible();\n    }\n  }, {\n    key: \"isAttachedAndVisible\",\n    value: function isAttachedAndVisible() {\n      return this.isAttached() && this.isVisible();\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      return graphics.debugOutput(this.$comp);\n    }\n    /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n    /**\n     * Creates a new HtmlComponent and links it to the given $comp element, so it can be\n     * retrieved again with HtmlComponent.get($comp).\n     *\n     * @memberOf HtmlComponent\n     */\n\n  }], [{\n    key: \"install\",\n    value: function install($comp, session) {\n      if (!$comp) {\n        throw new Error('Missing argument \"$comp\"');\n      }\n\n      if (!session) {\n        throw new Error('Missing argument \"session\"');\n      }\n\n      var htmlComp = new HtmlComponent($comp, session); // link DOM element with the new instance\n\n      $comp.data('htmlComponent', htmlComp);\n      return htmlComp;\n    }\n    /**\n     * Static method to get the HtmlComponent associated with the given DOM $comp.\n     * Throws an error when data 'htmlComponent' is not set.\n     *\n     * @memberOf HtmlComponent\n     */\n\n  }, {\n    key: \"get\",\n    value: function get($comp) {\n      var htmlComp = this.optGet($comp);\n\n      if (!htmlComp) {\n        var details = '';\n\n        if ($comp) {\n          details = '\\nClass: ' + $comp.attr('class');\n          details += '\\nId: ' + $comp.attr('id');\n          details += '\\nAttached: ' + $comp.isAttached();\n        }\n\n        throw new Error('data \"htmlComponent\" is undefined.' + details);\n      }\n\n      return htmlComp;\n    }\n    /**\n     * @memberOf HtmlComponent\n     */\n\n  }, {\n    key: \"optGet\",\n    value: function optGet($comp) {\n      return $comp && $comp.data('htmlComponent');\n    }\n  }]);\n\n  return HtmlComponent;\n}();\n\nexport { HtmlComponent as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/layout/HtmlComponent.js"],"names":["Dimension","graphics","Insets","NullLayout","scout","$","HtmlComponent","$comp","session","Error","debug","layout","layoutData","valid","validateRoot","layouted","layouting","suppressInvalidate","pixelBasedSizing","sizeCached","prefSizeCached","scrollable","$parent","parent","length","optGet","htmlComp","options","size","exact","prefSize","widthHint","width","removeMarginFromHints","height","htmlSource","invalidate","_checkValidationPossible","isAttachedAndVisible","hasAnimationClass","_validateLayoutAfterAnimation","getParent","everyParentVisible","$animatedParent","parents","each","isVisible","$animatedElement","oneAnimationEnd","validateLayout","bind","invalidateLayout","invalidateParents","nvl","layoutValidator","invalidateTree","validate","invalidateLayoutTree","validateLayoutTree","isValidateRoot","cssClass","addClass","includeMargin","extend","prefSizeCacheKey","computePrefSizeKey","isEmptyObject","log","isTraceEnabled","trace","heightHint","add","margins","clone","minSize","cssMinSize","maxSize","cssMaxSize","_adjustSizeHintsForPrefSize","preferredLayoutSize","_adjustPrefSizeWithMinMaxSize","widthOnly","removeMargins","removeInsets","removeInsetsFromHints","insets","horizontal","Math","max","min","vertical","borders","oldSize","equals","setSize","bounds","position","offsetBounds","offset","location","setLocation","dimension","setBounds","preferredSize","isAttached","window","debugOutput","data","details","attr"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Dimension, graphics, Insets, NullLayout, scout} from '../index';\nimport $ from 'jquery';\n\n/**\n * Wrapper for a JQuery selector. Used as replacement for javax.swing.JComponent.\n */\nexport default class HtmlComponent {\n  constructor($comp, session) {\n    if (!session) {\n      throw new Error('session must be defined for ' + this.debug());\n    }\n    this.$comp = $comp;\n    this.layout = new NullLayout();\n    this.layoutData = null;\n    this.valid = false;\n    this.validateRoot = false;\n\n    /**\n     * Flag to indicate that the component has been layouted at least once. Invalidation should NOT reset this flag.\n     */\n    this.layouted = false;\n\n    /**\n     * Flag to indicate that the component is being layouted.\n     */\n    this.layouting = false;\n\n    /**\n     * May be set to temporarily disable invalidation (e.g. if the component gets modified during the layouting process)\n     */\n    this.suppressInvalidate = false;\n\n    /**\n     * Set pixelBasedSizing to false if your component automatically adjusts its size,\n     * e.g. by using CSS styling -> setSize won't be called.\n     */\n    this.pixelBasedSizing = true;\n    this.sizeCached = null;\n\n    /**\n     * Object which stores the computed preferred size. Key is a string containing the width and height hints.\n     * @see #computePrefSizeKey(options);\n     */\n    this.prefSizeCached = {};\n    this.session = session;\n    this.scrollable = false;\n  }\n\n  /**\n   * Returns the parent or $comp or null when $comp has no parent.\n   * Creates a new instance of HtmlComponent if the parent DOM element has no linked instance yet.\n   */\n  getParent() {\n    var $parent = this.$comp.parent();\n    if ($parent.length === 0) {\n      return null;\n    }\n    return HtmlComponent.optGet($parent);\n  }\n\n  /**\n   * @returns {boolean} true if the given htmlComponent is an ancestor, false if not\n   */\n  isDescendantOf(htmlComp) {\n    var $parent = this.$comp.parent();\n    while ($parent.length > 0) {\n      if (HtmlComponent.optGet($parent) === htmlComp) {\n        return true;\n      }\n      $parent = $parent.parent();\n    }\n    return false;\n  }\n\n  /**\n   * Computes the preferred height if the component is scrollable and returns it if it is greater than the actual size.\n   * If it is not scrollable, the actual height is returned.\n   * <p>\n   * The returned size contains insets (padding and border) but no margin. The width is always the actual width because there are no horizontal scrollbars.\n   *\n   * OPTION    DEFAULT VALUE   DESCRIPTION\n   * -------------------------------------\n   * exact     false           When set to true the returned dimensions may contain fractional digits, otherwise the sizes are rounded up.\n   *\n   * @param (options) may contain the options of the above table\n   */\n  availableSize(options) {\n    options = options || {};\n    var size = this.size({\n      exact: options.exact\n    });\n\n    if (this.scrollable) {\n      var prefSize = this.prefSize({\n        widthHint: size.width,\n        removeMarginFromHints: false // Since the width of this component is used as hint, the margin must not be removed\n      });\n      if (prefSize.height > size.height) {\n        size.height = prefSize.height;\n      }\n    }\n\n    return size;\n  }\n\n  /**\n   * Invalidates the component (sets the valid property to false and calls layout.invalidate()).\n   * @param {HtmlComponent} [htmlSource] The component the invalidation originated from.\n   *        Is always set if the invalidation is triggered by using invalidateLayoutTree, may be undefined otherwise.\n   */\n  invalidateLayout(htmlSource) {\n    this.valid = false;\n    this.prefSizeCached = {};\n    if (this.layout) {\n      this.layout.invalidate(htmlSource);\n    }\n  }\n\n  /**\n   * Calls the layout of the component to layout its children but only if the component is not valid.\n   * @exception when component has no layout\n   * @return {boolean} true if validation was successful, false if it could not be executed (e.g. because the element is invisible or detached)\n   */\n  validateLayout() {\n    if (!this.layout) {\n      throw new Error('Called layout() but component has no layout');\n    }\n    if (!this.valid) {\n      if (!this._checkValidationPossible()) {\n        return false;\n      }\n      this.layouting = true;\n      this.layout.layout(this.$comp);\n      this.layouting = false;\n      this.layouted = true;\n      // Save size for later use (necessary if pixelBasedSizing is set to false)\n      this.sizeCached = this.size({exact: true});\n      this.valid = true;\n    }\n    return true;\n  }\n\n  _checkValidationPossible() {\n    // Don't layout components which don't exist anymore, are invisible or are detached from the DOM\n    if (!this.isAttachedAndVisible()) {\n      return false;\n    }\n\n    // Don't layout if component is currently animated\n    if (this.$comp.hasAnimationClass()) {\n      this._validateLayoutAfterAnimation(this.$comp);\n      return false;\n    }\n\n    // Check the visibility of the parents as well.\n    // Also check if one of the parents is currently being animated.\n    // To improve performance (the check might loop to the top of the DOM tree), the following code is\n    // not executed if the parent already executed it, which is the case if the parent is being layouted.\n    var parent = this.getParent();\n    if (!parent || !parent.layouting) {\n      var everyParentVisible = true;\n      var $animatedParent = null;\n      this.$comp.parents().each(function() {\n        var $parent = $(this);\n        if (!$parent.isVisible()) {\n          everyParentVisible = false;\n          return false;\n        }\n        if ($parent.hasAnimationClass()) {\n          $animatedParent = $parent;\n          return false;\n        }\n        return true; // continue loop\n      });\n      if (!everyParentVisible) {\n        return false;\n      }\n      if ($animatedParent) {\n        // Postpone the layout if there is a CSS animation in progress on one of the parent containers.\n        // Otherwise, wrong sizes might be measured (depending on the CSS animation, e.g. grow/shrink).\n        this._validateLayoutAfterAnimation($animatedParent);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  _validateLayoutAfterAnimation($animatedElement) {\n    $animatedElement.oneAnimationEnd(this.validateLayout.bind(this));\n  }\n\n  /**\n   * Performs invalidateLayout() and validateLayout() subsequently.\n   */\n  revalidateLayout() {\n    this.invalidateLayout();\n    this.validateLayout();\n  }\n\n  /**\n   * Invalidates the component-tree up to the next validate root, but only if invalidateParents is set to true.\n   */\n  invalidateLayoutTree(invalidateParents) {\n    if (this.suppressInvalidate) {\n      return;\n    }\n    if (scout.nvl(invalidateParents, true)) {\n      this.session.layoutValidator.invalidateTree(this); // will call invalidateLayout(), which sets this.valid = false\n    } else {\n      this.invalidateLayout();\n      this.session.layoutValidator.invalidate(this);\n    }\n  }\n\n  /**\n   * Layouts all invalid components\n   */\n  validateLayoutTree() {\n    this.session.layoutValidator.validate();\n  }\n\n  /**\n   * Performs invalidateLayoutTree() and validateLayoutTree() subsequently.\n   */\n  revalidateLayoutTree(invalidateParents) {\n    if (this.suppressInvalidate) {\n      return;\n    }\n    this.invalidateLayoutTree(invalidateParents);\n    this.validateLayoutTree();\n  }\n\n  /**\n   * Marks the end of the parent invalidation. <p>\n   * A component is a validate root if its size does not depend on the visibility or bounds of its children.<p>\n   * Example: It is not necessary to relayout the whole form if just the label of a form field gets invisible.\n   * Only the form field container needs to be relayouted. In this case the form field container is the validate root.\n   */\n  isValidateRoot() {\n    if (this.validateRoot) {\n      return true;\n    }\n    if (!this.layoutData || !this.layoutData.isValidateRoot) {\n      return false;\n    }\n    return this.layoutData.isValidateRoot();\n  }\n\n  /**\n   * Sets the given layout.\n   */\n  setLayout(layout) {\n    this.layout = layout;\n    if (layout.cssClass) {\n      this.$comp.addClass(layout.cssClass);\n    }\n  }\n\n  /**\n   * Returns the preferred size of the component, insets included, margin excluded.<p>\n   * The preferred size is cached until the component will be invalidated.\n   * Hence, subsequent calls to this function will return the cached preferred size unless the component is invalidated.\n   * <p>\n   *\n   * @param {object|boolean} [options] an optional options object. Short-hand version: If a boolean is passed instead of an object, the value is automatically converted to the option \"includeMargin\".\n   *                  May contain the options described below. All other options are passed as they are to the layout when layout.preferredLayoutSize() is called.\n   *                  Possible options may be found at graphics.prefSize(), but it depends on the actual layout if these options have an effect or not.\n   * @param {boolean|null} [options.includeMargin] Whether to include the margin in the returned size. Default is false.\n   * @param {number} [options.widthHint] When set, horizontal padding, border and margin are removed from it so that the actual layout does not need to take care of it. Default is null.\n   * @param {number} [options.heightHint] When set, vertical padding, border and margin are removed from it so that the actual layout does not need to take care of it. Default is null.\n   * @param {boolean|null} [options.removeMarginFromHints] Whether or not to automatically remove the margin from the hints. Default is true.\n   * @param {boolean|null} [options.removeInsetsFromHints] Whether or not to automatically remove the insets (padding and border) from the hints. Default is true.\n   * @exception When component has no layout\n   */\n  prefSize(options) {\n    if (!this.isVisible()) {\n      return new Dimension(0, 0);\n    }\n\n    if (typeof options === 'boolean') {\n      options = {\n        includeMargin: options\n      };\n    } else {\n      // Create a copy to not modify the original options\n      options = $.extend({}, options);\n    }\n    var includeMargin = scout.nvl(options.includeMargin, false);\n    options.includeMargin = null;\n    if (!this.layout) {\n      throw new Error('Called prefSize() but component has no layout');\n    }\n\n    var prefSizeCacheKey = this.computePrefSizeKey(options);\n    var prefSizeCached = this.prefSizeCached[prefSizeCacheKey];\n    if (!$.isEmptyObject(prefSizeCached)) {\n      $.log.isTraceEnabled() && $.log.trace('(HtmlComponent#prefSize) ' + this.debug() + ' widthHint=' + options.widthHint + ' heightHint=' + options.heightHint + ' prefSizeCached=' + prefSizeCached);\n      if (includeMargin) {\n        prefSizeCached = prefSizeCached.add(this.margins());\n      }\n      return prefSizeCached.clone();\n    }\n\n    var minSize = graphics.cssMinSize(this.$comp);\n    var maxSize = graphics.cssMaxSize(this.$comp);\n    if (options.widthHint || options.heightHint) {\n      this._adjustSizeHintsForPrefSize(options, minSize, maxSize);\n    }\n\n    var prefSize = this.layout.preferredLayoutSize(this.$comp, options);\n    this._adjustPrefSizeWithMinMaxSize(prefSize, minSize, maxSize);\n    this.prefSizeCached[prefSizeCacheKey] = prefSize;\n\n    $.log.isTraceEnabled() && $.log.trace('(HtmlComponent#prefSize) ' + this.debug() + ' widthHint=' + options.widthHint + ' heightHint=' + options.heightHint + ' prefSize=' + prefSize);\n    if (includeMargin) {\n      prefSize = prefSize.add(this.margins());\n    }\n    return prefSize.clone();\n  }\n\n  computePrefSizeKey(options) {\n    return 'wHint' + scout.nvl(options.widthHint, '-1') + 'hHint' + scout.nvl(options.heightHint, '-1') + 'wOnly' + scout.nvl(options.widthOnly, '-1');\n  }\n\n  /**\n   * Remove padding, border and margin from the width and heightHint so that the actual layout does not need to take care of it.\n   * Also makes sure the hints consider the min and max size set by CSS.\n   */\n  _adjustSizeHintsForPrefSize(options, minSize, maxSize) {\n    var removeMargins = scout.nvl(options.removeMarginFromHints, true);\n    var removeInsets = scout.nvl(options.removeInsetsFromHints, true);\n    options.removeMarginFromHints = null;\n    options.removeInsetsFromHints = null;\n    if (!options.widthHint && !options.heightHint) {\n      return;\n    }\n    var margins = removeMargins ? this.margins() : new Insets();\n    var insets = removeInsets ? this.insets() : new Insets();\n    if (options.widthHint) {\n      // The order is important! Box-sizing: border-box is expected.\n      options.widthHint -= margins.horizontal();\n      options.widthHint = Math.max(options.widthHint, minSize.width);\n      options.widthHint = Math.min(options.widthHint, maxSize.width);\n      options.widthHint -= insets.horizontal();\n    }\n    if (options.heightHint) {\n      // The order is important! Box-sizing: border-box is expected.\n      options.heightHint -= margins.vertical();\n      options.heightHint = Math.max(options.heightHint, minSize.height);\n      options.heightHint = Math.min(options.heightHint, maxSize.height);\n      options.heightHint -= insets.vertical();\n    }\n  }\n\n  /**\n   * The html element may define a min or max height/height -> adjust the pref size accordingly\n   */\n  _adjustPrefSizeWithMinMaxSize(prefSize, minSize, maxSize) {\n    minSize = minSize || graphics.cssMinSize(this.$comp);\n    maxSize = maxSize || graphics.cssMaxSize(this.$comp);\n    prefSize.height = Math.max(prefSize.height, minSize.height);\n    prefSize.height = Math.min(prefSize.height, maxSize.height);\n    prefSize.width = Math.max(prefSize.width, minSize.width);\n    prefSize.width = Math.min(prefSize.width, maxSize.width);\n  }\n\n  /**\n   * Returns the inset-dimensions of the component (padding and border, no margin).\n   */\n  insets(options) {\n    return graphics.insets(this.$comp, options);\n  }\n\n  margins() {\n    return graphics.margins(this.$comp);\n  }\n\n  borders() {\n    return graphics.borders(this.$comp);\n  }\n\n  /**\n   * Returns the size of the component, insets included.\n   * @param options, see {@link graphics#size} for details.\n   */\n  size(options) {\n    return graphics.size(this.$comp, options);\n  }\n\n  /**\n   * Sets the size of the component, insets included. Which means: the method subtracts the components insets\n   * from the given size before setting the width/height of the component.\n   *\n   * @param {Dimension} size\n   */\n  setSize(size) {\n    if (!this.isAttachedAndVisible()) {\n      // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong\n      return;\n    }\n    var oldSize = this.sizeCached;\n    if (!size.equals(oldSize)) {\n      this.invalidateLayout();\n    }\n    if (this.pixelBasedSizing) {\n      graphics.setSize(this.$comp, size);\n    }\n    this.validateLayout();\n  }\n\n  bounds(options) {\n    return graphics.bounds(this.$comp, options);\n  }\n\n  position() {\n    return graphics.position(this.$comp);\n  }\n\n  offsetBounds(options) {\n    return graphics.offsetBounds(this.$comp, options);\n  }\n\n  offset() {\n    return graphics.offset(this.$comp);\n  }\n\n  /**\n   * Delegation to graphics.setLocation\n   * @param location Point\n   */\n  setLocation(location) {\n    graphics.setLocation(this.$comp, location);\n  }\n\n  location() {\n    return graphics.location(this.$comp);\n  }\n\n  setBounds(bounds) {\n    if (!this.isAttachedAndVisible()) {\n      // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong\n      return;\n    }\n    var oldSize = this.sizeCached;\n    if (!bounds.dimension().equals(oldSize)) {\n      this.invalidateLayout();\n    }\n    if (this.pixelBasedSizing) {\n      graphics.setBounds(this.$comp, bounds);\n    }\n    this.validateLayout();\n  }\n\n  /**\n   * Sets the component to its preferred size.\n   */\n  pack() {\n    var preferredSize = this.prefSize();\n    this.setSize(preferredSize);\n  }\n\n  /**\n   * Checks whether $comp is in the DOM or has been removed or detached.<br>\n   * Also returns false if the $comp does not belong to a window (defaultView) anymore. This may happen if it belonged to a popup window which is now closed\n   */\n  isAttached() {\n    return this.$comp.isAttached() && this.$comp.window(true);\n  }\n\n  isVisible() {\n    return this.$comp.isVisible();\n  }\n\n  isAttachedAndVisible() {\n    return this.isAttached() && this.isVisible();\n  }\n\n  debug() {\n    return graphics.debugOutput(this.$comp);\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * Creates a new HtmlComponent and links it to the given $comp element, so it can be\n   * retrieved again with HtmlComponent.get($comp).\n   *\n   * @memberOf HtmlComponent\n   */\n  static install($comp, session) {\n    if (!$comp) {\n      throw new Error('Missing argument \"$comp\"');\n    }\n    if (!session) {\n      throw new Error('Missing argument \"session\"');\n    }\n\n    var htmlComp = new HtmlComponent($comp, session);\n    // link DOM element with the new instance\n    $comp.data('htmlComponent', htmlComp);\n\n    return htmlComp;\n  }\n\n  /**\n   * Static method to get the HtmlComponent associated with the given DOM $comp.\n   * Throws an error when data 'htmlComponent' is not set.\n   *\n   * @memberOf HtmlComponent\n   */\n  static get($comp) {\n    var htmlComp = this.optGet($comp);\n    if (!htmlComp) {\n      var details = '';\n      if ($comp) {\n        details = '\\nClass: ' + $comp.attr('class');\n        details += '\\nId: ' + $comp.attr('id');\n        details += '\\nAttached: ' + $comp.isAttached();\n      }\n      throw new Error('data \"htmlComponent\" is undefined.' + details);\n    }\n    return htmlComp;\n  }\n\n  /**\n   * @memberOf HtmlComponent\n   */\n  static optGet($comp) {\n    return $comp && $comp.data('htmlComponent');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}