{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays } from '../index';\n/**\n * Input is expected to be encoded. Output (toString()) is also encoded.\n * If no URL is passed, 'window.location.href' is used as input.\n */\n\nvar URL = /*#__PURE__*/function () {\n  function URL(url) {\n    _classCallCheck(this, URL);\n\n    if (url === undefined) {\n      url = window.location.href;\n    }\n\n    var urlParts = /^([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$/.exec(url || ''); // encoded\n\n    this.baseUrlRaw = urlParts[1];\n    this.queryPartRaw = urlParts[2];\n    this.hashPartRaw = urlParts[3]; // un-encoded (!)\n\n    this.parameterMap = URL._parse(this.queryPartRaw);\n  }\n  /**\n   * Checks if the given parameter exists, even if value is null or an empty string.\n   *\n   * @param param\n   * @return {boolean}\n   */\n\n\n  _createClass(URL, [{\n    key: \"hasParameter\",\n    value: function hasParameter(param) {\n      return this.parameterMap.hasOwnProperty(param);\n    }\n  }, {\n    key: \"getParameter\",\n    value: function getParameter(param) {\n      if (typeof param !== 'string') {\n        throw new Error('Illegal argument type: ' + param);\n      }\n\n      var value = this.parameterMap[param];\n\n      if (Array.isArray(value)) {\n        return value.sort(URL._sorter);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"removeParameter\",\n    value: function removeParameter(param) {\n      if (typeof param !== 'string') {\n        throw new Error('Illegal argument type: ' + param);\n      }\n\n      delete this.parameterMap[param];\n      return this;\n    }\n  }, {\n    key: \"setParameter\",\n    value: function setParameter(param, value) {\n      if (typeof param !== 'string') {\n        throw new Error('Illegal argument type: ' + param);\n      }\n\n      if (param === '') {\n        // ignore empty keys\n        return;\n      }\n\n      this.parameterMap[param] = value;\n      return this;\n    }\n  }, {\n    key: \"addParameter\",\n    value: function addParameter(param, value) {\n      if (typeof param !== 'string') {\n        throw new Error('Illegal argument type: ' + param);\n      }\n\n      if (param === '') {\n        // ignore empty keys\n        return;\n      }\n\n      URL._addToMap(this.parameterMap, param, value);\n\n      return this;\n    }\n    /**\n     * Options:\n     *\n     *   sorter:\n     *     a function to be used instead of the default lexical ordering\n     *     based function\n     *\n     *   alwaysFirst:\n     *     an array of parameter names that should always be first in the\n     *     resulting string. Among those parameters, the order in the passed\n     *     array is respected.\n     *\n     *   alwaysLast:\n     *     similar to alwaysFirst, but puts the parameters at the end of\n     *     the resulting string.\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(options) {\n      var result = this.baseUrlRaw;\n\n      if (Object.keys(this.parameterMap).length) {\n        options = options || {};\n        var sorter = options.sorter || URL._sorter;\n\n        if (options.alwaysFirst || options.alwaysLast) {\n          options.alwaysFirst = arrays.ensure(options.alwaysFirst);\n          options.alwaysLast = arrays.ensure(options.alwaysLast);\n          var origSorter = sorter;\n\n          sorter = function sorter(a, b) {\n            var firstA = options.alwaysFirst.indexOf(a);\n            var firstB = options.alwaysFirst.indexOf(b);\n            var lastA = options.alwaysLast.indexOf(a);\n            var lastB = options.alwaysLast.indexOf(b); // If A is marked as \"alwaysFirst\", sort them A-B. If B is also marked as \"alwaysFirst\", sort them\n            // by their position in the array. If only B is marked as \"alwaysFirst\", sort them B-A.\n\n            if (firstA !== -1) {\n              return firstB === -1 ? -1 : firstA - firstB;\n            } else if (firstB !== -1) {\n              return 1;\n            } // If A is marked as \"alwaysLast\", sort them B-A. If B is also marked as \"alwaysLast\", sort them\n            // by their position in the array. If only B is marked as \"alwaysLast\", sort them A-B.\n\n\n            if (lastA !== -1) {\n              return lastB === -1 ? 1 : lastA - lastB;\n            } else if (lastB !== -1) {\n              return -1;\n            } // Default order\n\n\n            return origSorter(a, b);\n          };\n        } // Built a sorted string of all formatted parameterMap entries\n\n\n        var reconstructedQueryPart = Object.keys(this.parameterMap).sort(sorter).map(function (key) {\n          var value = this.getParameter(key); // For multiple values, generate a parameter string for each value\n\n          if (Array.isArray(value)) {\n            return value.map(function (innerKey, innerIndex) {\n              return URL._formatQueryParam(key, value[innerIndex]);\n            }).join('&');\n          }\n\n          return URL._formatQueryParam(key, value);\n        }.bind(this)).join('&');\n        result += '?' + reconstructedQueryPart;\n      }\n\n      if (this.hashPartRaw) {\n        result += '#' + this.hashPartRaw;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new URL(this.toString());\n    }\n    /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n    /**\n     * Helper function to sort arrays alphabetically, nulls in front\n     *\n     * @memberOf URL\n     */\n\n  }], [{\n    key: \"_sorter\",\n    value: function _sorter(a, b) {\n      return a === null ? -1 : b === null ? 1 : a.toString().localeCompare(b);\n    }\n    /**\n     * Helper function to build a query parameter with value\n     *\n     * @memberOf URL\n     */\n    //\n\n  }, {\n    key: \"_formatQueryParam\",\n    value: function _formatQueryParam(key, value) {\n      var s = encodeURIComponent(key);\n\n      if (value !== undefined && value !== null) {\n        s += '=' + encodeURIComponent(value);\n      }\n\n      return s;\n    }\n    /**\n     * Helper function to add an key-value pair to a map. If the key is added multiple\n     * times, the value is converted to an array.\n     *\n     * @memberOf URL\n     */\n\n  }, {\n    key: \"_addToMap\",\n    value: function _addToMap(map, key, value) {\n      if (map === undefined) {\n        throw new Error('Argument \\'map\\' must not be null');\n      }\n\n      if (key === undefined) {\n        throw new Error('Argument \\'key\\' must not be null');\n      }\n\n      if (key in map) {\n        var oldValue = map[key];\n\n        if (Array.isArray(oldValue)) {\n          oldValue.push(value);\n        } else {\n          map[key] = [oldValue, value];\n        }\n      } else {\n        map[key] = value;\n      }\n    }\n    /**\n     * Helper function to parse the given (encoded) query string and return\n     * it as (un-encoded) map of key-value pairs.\n     *\n     * @memberOf URL\n     */\n\n  }, {\n    key: \"_parse\",\n    value: function _parse(queryPart) {\n      var queryString = (queryPart || '').replace(/\\+/g, ' '),\n          pattern = /([^&=]+)(=?)([^&]*)/g,\n          map = {},\n          m,\n          key,\n          value;\n\n      while (m = pattern.exec(queryString)) {\n        key = decodeURIComponent(m[1]);\n        value = decodeURIComponent(m[3]);\n\n        if (value === '' && m[2] !== '=') {\n          value = null;\n        }\n\n        URL._addToMap(map, key, value);\n      }\n\n      return map;\n    }\n  }]);\n\n  return URL;\n}();\n\nexport { URL as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/util/URL.js"],"names":["arrays","URL","url","undefined","window","location","href","urlParts","exec","baseUrlRaw","queryPartRaw","hashPartRaw","parameterMap","_parse","param","hasOwnProperty","Error","value","Array","isArray","sort","_sorter","_addToMap","options","result","Object","keys","length","sorter","alwaysFirst","alwaysLast","ensure","origSorter","a","b","firstA","indexOf","firstB","lastA","lastB","reconstructedQueryPart","map","key","getParameter","innerKey","innerIndex","_formatQueryParam","join","bind","toString","localeCompare","s","encodeURIComponent","oldValue","push","queryPart","queryString","replace","pattern","m","decodeURIComponent"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays} from '../index';\n\n/**\n * Input is expected to be encoded. Output (toString()) is also encoded.\n * If no URL is passed, 'window.location.href' is used as input.\n */\nexport default class URL {\n\n  constructor(url) {\n    if (url === undefined) {\n      url = window.location.href;\n    }\n    var urlParts = /^([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$/.exec(url || '');\n    // encoded\n    this.baseUrlRaw = urlParts[1];\n    this.queryPartRaw = urlParts[2];\n    this.hashPartRaw = urlParts[3];\n    // un-encoded (!)\n    this.parameterMap = URL._parse(this.queryPartRaw);\n  }\n\n  /**\n   * Checks if the given parameter exists, even if value is null or an empty string.\n   *\n   * @param param\n   * @return {boolean}\n   */\n  hasParameter(param) {\n    return this.parameterMap.hasOwnProperty(param);\n  }\n\n  getParameter(param) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    var value = this.parameterMap[param];\n    if (Array.isArray(value)) {\n      return value.sort(URL._sorter);\n    }\n    return value;\n  }\n\n  removeParameter(param) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    delete this.parameterMap[param];\n    return this;\n  }\n\n  setParameter(param, value) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    if (param === '') { // ignore empty keys\n      return;\n    }\n    this.parameterMap[param] = value;\n    return this;\n  }\n\n  addParameter(param, value) {\n    if (typeof param !== 'string') {\n      throw new Error('Illegal argument type: ' + param);\n    }\n    if (param === '') { // ignore empty keys\n      return;\n    }\n    URL._addToMap(this.parameterMap, param, value);\n    return this;\n  }\n\n  /**\n   * Options:\n   *\n   *   sorter:\n   *     a function to be used instead of the default lexical ordering\n   *     based function\n   *\n   *   alwaysFirst:\n   *     an array of parameter names that should always be first in the\n   *     resulting string. Among those parameters, the order in the passed\n   *     array is respected.\n   *\n   *   alwaysLast:\n   *     similar to alwaysFirst, but puts the parameters at the end of\n   *     the resulting string.\n   */\n  toString(options) {\n    var result = this.baseUrlRaw;\n\n    if (Object.keys(this.parameterMap).length) {\n      options = options || {};\n      var sorter = options.sorter || URL._sorter;\n      if (options.alwaysFirst || options.alwaysLast) {\n        options.alwaysFirst = arrays.ensure(options.alwaysFirst);\n        options.alwaysLast = arrays.ensure(options.alwaysLast);\n        var origSorter = sorter;\n        sorter = function(a, b) {\n          var firstA = options.alwaysFirst.indexOf(a);\n          var firstB = options.alwaysFirst.indexOf(b);\n          var lastA = options.alwaysLast.indexOf(a);\n          var lastB = options.alwaysLast.indexOf(b);\n          // If A is marked as \"alwaysFirst\", sort them A-B. If B is also marked as \"alwaysFirst\", sort them\n          // by their position in the array. If only B is marked as \"alwaysFirst\", sort them B-A.\n          if (firstA !== -1) {\n            return (firstB === -1 ? -1 : firstA - firstB);\n          } else if (firstB !== -1) {\n            return 1;\n          }\n          // If A is marked as \"alwaysLast\", sort them B-A. If B is also marked as \"alwaysLast\", sort them\n          // by their position in the array. If only B is marked as \"alwaysLast\", sort them A-B.\n          if (lastA !== -1) {\n            return (lastB === -1 ? 1 : lastA - lastB);\n          } else if (lastB !== -1) {\n            return -1;\n          }\n          // Default order\n          return origSorter(a, b);\n        };\n      }\n      // Built a sorted string of all formatted parameterMap entries\n      var reconstructedQueryPart = Object.keys(this.parameterMap).sort(sorter).map(function(key) {\n        var value = this.getParameter(key);\n        // For multiple values, generate a parameter string for each value\n        if (Array.isArray(value)) {\n          return value.map(\n            function(innerKey, innerIndex) {\n              return URL._formatQueryParam(key, value[innerIndex]);\n            }\n          ).join('&');\n        }\n        return URL._formatQueryParam(key, value);\n      }.bind(this)).join('&');\n      result += '?' + reconstructedQueryPart;\n    }\n\n    if (this.hashPartRaw) {\n      result += '#' + this.hashPartRaw;\n    }\n\n    return result;\n  }\n\n  clone() {\n    return new URL(this.toString());\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  /**\n   * Helper function to sort arrays alphabetically, nulls in front\n   *\n   * @memberOf URL\n   */\n  static _sorter(a, b) {\n    return a === null ? -1 : b === null ? 1 : a.toString().localeCompare(b);\n  }\n\n  /**\n   * Helper function to build a query parameter with value\n   *\n   * @memberOf URL\n   */\n  //\n  static _formatQueryParam(key, value) {\n    var s = encodeURIComponent(key);\n    if (value !== undefined && value !== null) {\n      s += '=' + encodeURIComponent(value);\n    }\n    return s;\n  }\n\n  /**\n   * Helper function to add an key-value pair to a map. If the key is added multiple\n   * times, the value is converted to an array.\n   *\n   * @memberOf URL\n   */\n  static _addToMap(map, key, value) {\n    if (map === undefined) {\n      throw new Error('Argument \\'map\\' must not be null');\n    }\n    if (key === undefined) {\n      throw new Error('Argument \\'key\\' must not be null');\n    }\n    if (key in map) {\n      var oldValue = map[key];\n      if (Array.isArray(oldValue)) {\n        oldValue.push(value);\n      } else {\n        map[key] = [oldValue, value];\n      }\n    } else {\n      map[key] = value;\n    }\n  }\n\n  /**\n   * Helper function to parse the given (encoded) query string and return\n   * it as (un-encoded) map of key-value pairs.\n   *\n   * @memberOf URL\n   */\n  static _parse(queryPart) {\n    var queryString = (queryPart || '').replace(/\\+/g, ' '),\n      pattern = /([^&=]+)(=?)([^&]*)/g,\n      map = {},\n      m, key, value;\n\n    while ((m = pattern.exec(queryString))) {\n      key = decodeURIComponent(m[1]);\n      value = decodeURIComponent(m[3]);\n      if (value === '' && m[2] !== '=') {\n        value = null;\n      }\n      URL._addToMap(map, key, value);\n    }\n    return map;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}