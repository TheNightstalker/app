{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { Action, arrays, KeyStroke, keyStrokeModifier, objects, scout } from '../index';\nimport $ from 'jquery';\n\nvar KeyStrokeContext = /*#__PURE__*/function () {\n  function KeyStrokeContext(options) {\n    _classCallCheck(this, KeyStrokeContext);\n\n    /*\n     * Holds the target where to bind this context as keydown listener.\n     * This can either be a static value or a function to resolve the target.\n     */\n    this.$bindTarget = null;\n    /*\n     * Holds the scope of this context and is used to determine the context's accessibility, meaning not covert by a glasspane.\n     * This can either be a static value or a function to resolve the target.\n     */\n\n    this.$scopeTarget = null;\n    /*\n     * Holds the keystrokes registered within this context.\n     */\n\n    this.keyStrokes = [];\n    /*\n     * Array of interceptors to participate in setting 'stop propagation' flags.\n     */\n\n    this.stopPropagationInterceptors = [];\n    /*\n     * Arrays with combinations of keys to prevent from bubbling up in the DOM tree.\n     */\n\n    this._stopPropagationKeys = {};\n    /*\n     * Indicates whether to invoke 'acceptInput' on a currently focused value field prior handling the keystroke.\n     */\n\n    this.invokeAcceptInputOnActiveValueField = false;\n    options = options || {};\n    $.extend(this, options);\n  }\n  /**\n   * Registers the given keys as 'stopPropagation' keys, meaning that any keystroke event with that key and matching the modifier bit mask is prevented from bubbling the DOM tree up.\n   *\n   * @param modifierBitMask bitwise OR'ing together modifier constants to match a keystroke event. (KeyStrokeModifier.js)\n   * @param keys the keys to match a keystroke event.\n   */\n\n\n  _createClass(KeyStrokeContext, [{\n    key: \"registerStopPropagationKeys\",\n    value: function registerStopPropagationKeys(modifierBitMask, keys) {\n      this._stopPropagationKeys[modifierBitMask] = this._stopPropagationKeys[modifierBitMask] || [];\n      arrays.pushAll(this._stopPropagationKeys[modifierBitMask], keys);\n    }\n    /**\n     * Use this method to register an interceptor to set propagation flags on context level.\n     */\n\n  }, {\n    key: \"registerStopPropagationInterceptor\",\n    value: function registerStopPropagationInterceptor(interceptor) {\n      this.stopPropagationInterceptors.push(interceptor);\n    }\n    /**\n     * Returns true if this event is handled by this context, and if so sets the propagation flags accordingly.\n     */\n\n  }, {\n    key: \"accept\",\n    value: function accept(event) {\n      // Check whether this event is accepted.\n      if (!this._accept(event)) {\n        return false;\n      } // Apply propagation flags to the event.\n\n\n      this._applyPropagationFlags(event);\n\n      return true;\n    }\n    /**\n     * Sets the propagation flags to the given event.\n     */\n\n  }, {\n    key: \"_applyPropagationFlags\",\n    value: function _applyPropagationFlags(event) {\n      var modifierBitMask = keyStrokeModifier.toModifierBitMask(event);\n      var keys = this._stopPropagationKeys[modifierBitMask];\n\n      if (keys && scout.isOneOf(event.which, keys)) {\n        event.stopPropagation();\n      } // Let registered interceptors participate.\n\n\n      this.stopPropagationInterceptors.forEach(function (interceptor) {\n        interceptor(event);\n      }, this);\n    }\n  }, {\n    key: \"_accept\",\n    value: function _accept(event) {\n      return true;\n    }\n  }, {\n    key: \"registerKeyStroke\",\n    value: function registerKeyStroke(keyStroke) {\n      this.registerKeyStrokes(keyStroke);\n    }\n    /**\n     * Registers the given keystroke(s) if not installed yet.\n     */\n\n  }, {\n    key: \"registerKeyStrokes\",\n    value: function registerKeyStrokes(keyStrokes) {\n      arrays.ensure(keyStrokes).map(this._resolveKeyStroke, this).filter(function (ks) {\n        return this.keyStrokes.indexOf(ks) === -1; // must not be registered yet\n      }, this).forEach(function (ks) {\n        this.keyStrokes.push(ks); // Registers a destroy listener, so that the keystroke is uninstalled once its field is destroyed.\n\n        if (ks.field && !ks.destroyListener) {\n          ks.destroyListener = function (event) {\n            this.unregisterKeyStroke(ks);\n            ks.destroyListener = null;\n          }.bind(this);\n\n          ks.field.one('destroy', ks.destroyListener);\n        }\n      }, this);\n    }\n    /**\n     * Uninstalls the given keystroke. Has no effect if not installed.\n     */\n\n  }, {\n    key: \"unregisterKeyStroke\",\n    value: function unregisterKeyStroke(keyStroke) {\n      this.unregisterKeyStrokes(keyStroke);\n    }\n  }, {\n    key: \"unregisterKeyStrokes\",\n    value: function unregisterKeyStrokes(keyStrokes) {\n      arrays.ensure(keyStrokes).map(this._resolveKeyStroke, this).forEach(function (ks) {\n        if (arrays.remove(this.keyStrokes, ks) && ks.field && ks.destroyListener) {\n          ks.field.off('destroy', ks.destroyListener);\n          ks.destroyListener = null;\n        }\n      }, this);\n    }\n  }, {\n    key: \"_resolveKeyStroke\",\n    value: function _resolveKeyStroke(keyStroke) {\n      if (keyStroke instanceof KeyStroke) {\n        return keyStroke;\n      } else if (keyStroke instanceof Action) {\n        return keyStroke.actionKeyStroke;\n      }\n\n      throw new Error('unsupported keystroke: ' + keyStroke);\n    }\n    /**\n     * Returns the $target where to bind this context as keydown listener.\n     */\n\n  }, {\n    key: \"$getBindTarget\",\n    value: function $getBindTarget() {\n      return typeof this.$bindTarget === 'function' ? this.$bindTarget() : this.$bindTarget;\n    }\n    /**\n     * Returns the scope of this context and is used to determine the context's accessibility, meaning not covert by a glasspane.\n     */\n\n  }, {\n    key: \"$getScopeTarget\",\n    value: function $getScopeTarget() {\n      return typeof this.$scopeTarget === 'function' ? this.$scopeTarget() : this.$scopeTarget;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new KeyStrokeContext(objects.copyOwnProperties(this, {}));\n    }\n  }]);\n\n  return KeyStrokeContext;\n}();\n\nexport { KeyStrokeContext as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/keystroke/KeyStrokeContext.js"],"names":["Action","arrays","KeyStroke","keyStrokeModifier","objects","scout","$","KeyStrokeContext","options","$bindTarget","$scopeTarget","keyStrokes","stopPropagationInterceptors","_stopPropagationKeys","invokeAcceptInputOnActiveValueField","extend","modifierBitMask","keys","pushAll","interceptor","push","event","_accept","_applyPropagationFlags","toModifierBitMask","isOneOf","which","stopPropagation","forEach","keyStroke","registerKeyStrokes","ensure","map","_resolveKeyStroke","filter","ks","indexOf","field","destroyListener","unregisterKeyStroke","bind","one","unregisterKeyStrokes","remove","off","actionKeyStroke","Error","copyOwnProperties"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {Action, arrays, KeyStroke, keyStrokeModifier, objects, scout} from '../index';\nimport $ from 'jquery';\n\nexport default class KeyStrokeContext {\n\n  constructor(options) {\n    /*\n     * Holds the target where to bind this context as keydown listener.\n     * This can either be a static value or a function to resolve the target.\n     */\n    this.$bindTarget = null;\n    /*\n     * Holds the scope of this context and is used to determine the context's accessibility, meaning not covert by a glasspane.\n     * This can either be a static value or a function to resolve the target.\n     */\n    this.$scopeTarget = null;\n    /*\n     * Holds the keystrokes registered within this context.\n     */\n    this.keyStrokes = [];\n    /*\n     * Array of interceptors to participate in setting 'stop propagation' flags.\n     */\n    this.stopPropagationInterceptors = [];\n\n    /*\n     * Arrays with combinations of keys to prevent from bubbling up in the DOM tree.\n     */\n    this._stopPropagationKeys = {};\n\n    /*\n     * Indicates whether to invoke 'acceptInput' on a currently focused value field prior handling the keystroke.\n     */\n    this.invokeAcceptInputOnActiveValueField = false;\n\n    options = options || {};\n    $.extend(this, options);\n  }\n\n  /**\n   * Registers the given keys as 'stopPropagation' keys, meaning that any keystroke event with that key and matching the modifier bit mask is prevented from bubbling the DOM tree up.\n   *\n   * @param modifierBitMask bitwise OR'ing together modifier constants to match a keystroke event. (KeyStrokeModifier.js)\n   * @param keys the keys to match a keystroke event.\n   */\n  registerStopPropagationKeys(modifierBitMask, keys) {\n    this._stopPropagationKeys[modifierBitMask] = this._stopPropagationKeys[modifierBitMask] || [];\n    arrays.pushAll(this._stopPropagationKeys[modifierBitMask], keys);\n  }\n\n  /**\n   * Use this method to register an interceptor to set propagation flags on context level.\n   */\n  registerStopPropagationInterceptor(interceptor) {\n    this.stopPropagationInterceptors.push(interceptor);\n  }\n\n  /**\n   * Returns true if this event is handled by this context, and if so sets the propagation flags accordingly.\n   */\n  accept(event) {\n    // Check whether this event is accepted.\n    if (!this._accept(event)) {\n      return false;\n    }\n\n    // Apply propagation flags to the event.\n    this._applyPropagationFlags(event);\n\n    return true;\n  }\n\n  /**\n   * Sets the propagation flags to the given event.\n   */\n  _applyPropagationFlags(event) {\n    var modifierBitMask = keyStrokeModifier.toModifierBitMask(event);\n    var keys = this._stopPropagationKeys[modifierBitMask];\n\n    if (keys && scout.isOneOf(event.which, keys)) {\n      event.stopPropagation();\n    }\n\n    // Let registered interceptors participate.\n    this.stopPropagationInterceptors.forEach(function(interceptor) {\n      interceptor(event);\n    }, this);\n  }\n\n  _accept(event) {\n    return true;\n  }\n\n  registerKeyStroke(keyStroke) {\n    this.registerKeyStrokes(keyStroke);\n  }\n\n  /**\n   * Registers the given keystroke(s) if not installed yet.\n   */\n  registerKeyStrokes(keyStrokes) {\n    arrays.ensure(keyStrokes)\n      .map(this._resolveKeyStroke, this)\n      .filter(function(ks) {\n        return this.keyStrokes.indexOf(ks) === -1; // must not be registered yet\n      }, this)\n      .forEach(function(ks) {\n        this.keyStrokes.push(ks);\n\n        // Registers a destroy listener, so that the keystroke is uninstalled once its field is destroyed.\n        if (ks.field && !ks.destroyListener) {\n          ks.destroyListener = function(event) {\n            this.unregisterKeyStroke(ks);\n            ks.destroyListener = null;\n          }.bind(this);\n          ks.field.one('destroy', ks.destroyListener);\n        }\n      }, this);\n  }\n\n  /**\n   * Uninstalls the given keystroke. Has no effect if not installed.\n   */\n  unregisterKeyStroke(keyStroke) {\n    this.unregisterKeyStrokes(keyStroke);\n  }\n\n  unregisterKeyStrokes(keyStrokes) {\n    arrays.ensure(keyStrokes)\n      .map(this._resolveKeyStroke, this)\n      .forEach(function(ks) {\n        if (arrays.remove(this.keyStrokes, ks) && ks.field && ks.destroyListener) {\n          ks.field.off('destroy', ks.destroyListener);\n          ks.destroyListener = null;\n        }\n      }, this);\n  }\n\n  _resolveKeyStroke(keyStroke) {\n    if (keyStroke instanceof KeyStroke) {\n      return keyStroke;\n    } else if (keyStroke instanceof Action) {\n      return keyStroke.actionKeyStroke;\n    }\n    throw new Error('unsupported keystroke: ' + keyStroke);\n  }\n\n  /**\n   * Returns the $target where to bind this context as keydown listener.\n   */\n  $getBindTarget() {\n    return (typeof this.$bindTarget === 'function' ? this.$bindTarget() : this.$bindTarget);\n  }\n\n  /**\n   * Returns the scope of this context and is used to determine the context's accessibility, meaning not covert by a glasspane.\n   */\n  $getScopeTarget() {\n    return (typeof this.$scopeTarget === 'function' ? this.$scopeTarget() : this.$scopeTarget);\n  }\n\n  clone() {\n    return new KeyStrokeContext(objects.copyOwnProperties(this, {}));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}