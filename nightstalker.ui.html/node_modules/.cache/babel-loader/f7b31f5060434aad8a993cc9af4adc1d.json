{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { AbstractLayout, graphics, menus } from '../../index';\n\nvar MenuBoxLayout = /*#__PURE__*/function (_AbstractLayout) {\n  _inherits(MenuBoxLayout, _AbstractLayout);\n\n  var _super = _createSuper(MenuBoxLayout);\n\n  function MenuBoxLayout(menuBox) {\n    var _this;\n\n    _classCallCheck(this, MenuBoxLayout);\n\n    _this = _super.call(this);\n    _this.menuBox = menuBox; // References to prevent too many DOM updates\n\n    _this.firstMenu = null;\n    _this.lastMenu = null;\n    return _this;\n  }\n  /**\n   * @override AbstractLayout.js\n   */\n\n\n  _createClass(MenuBoxLayout, [{\n    key: \"layout\",\n    value: function layout($container) {\n      var htmlContainer = this.menuBox.htmlComp,\n          containerSize = htmlContainer.size(),\n          menus = this.visibleMenus(),\n          menusWidth = 0; // Make sure open popups are at the correct position after layouting\n\n      this.menuBox.session.layoutValidator.schedulePostValidateFunction(function () {\n        menus.forEach(function (menu) {\n          if (menu.popup) {\n            menu.popup.position();\n          }\n        });\n      });\n      this.updateFirstAndLastMenuMarker(menus);\n      this.undoCollapse(menus);\n      this.undoCompact(menus);\n      this.undoShrink(menus);\n      menusWidth = this.actualPrefSize(menus).width;\n\n      if (menusWidth <= containerSize.width) {\n        // OK, every menu fits into container\n        return;\n      } // Menus don't fit\n      // First approach: Set menuBox into compact mode\n\n\n      this.compact(menus);\n      menusWidth = this.actualPrefSize(menus).width;\n\n      if (menusWidth <= containerSize.width) {\n        // OK, every menu fits into container\n        return;\n      } // Second approach: Make text invisible and only show the icon (if available)\n\n\n      this.shrink(menus);\n      menusWidth = this.actualPrefSize(menus).width;\n\n      if (menusWidth <= containerSize.width) {\n        // OK, every menu fits into container\n        return;\n      } // Third approach: Create ellipsis and move overflown menus into it\n\n\n      this.collapse(menus, containerSize, menusWidth);\n    }\n  }, {\n    key: \"preferredLayoutSize\",\n    value: function preferredLayoutSize($container) {\n      var menus = this.visibleMenus();\n      this.updateFirstAndLastMenuMarker(menus);\n      this.undoCollapse(menus);\n      this.undoCompact(menus);\n      this.undoShrink(menus);\n      return this.actualPrefSize();\n    }\n  }, {\n    key: \"compact\",\n    value: function compact(argMenus) {\n      if (this.menuBox.compactOrig === undefined) {\n        this.menuBox.compactOrig = this.menuBox.compact;\n        this.menuBox.htmlComp.suppressInvalidate = true;\n        this.menuBox.setCompact(true);\n        this.menuBox.htmlComp.suppressInvalidate = false;\n      }\n\n      this.compactMenus(argMenus);\n    }\n  }, {\n    key: \"undoCompact\",\n    value: function undoCompact(argMenus) {\n      if (this.menuBox.compactOrig !== undefined) {\n        this.menuBox.htmlComp.suppressInvalidate = true;\n        this.menuBox.setCompact(this.menuBox.compactOrig);\n        this.menuBox.htmlComp.suppressInvalidate = false;\n        this.menuBox.compactOrig = undefined;\n      }\n\n      this.undoCompactMenus(argMenus);\n    }\n    /**\n     * Sets all menus into compact mode.\n     */\n\n  }, {\n    key: \"compactMenus\",\n    value: function compactMenus(argMenus) {\n      argMenus = argMenus || this.visibleMenus();\n      argMenus.forEach(function (menu) {\n        if (menu.compactOrig !== undefined) {\n          // already done\n          return;\n        }\n\n        menu.compactOrig = menu.compact;\n        menu.htmlComp.suppressInvalidate = true;\n        menu.setCompact(true);\n        menu.htmlComp.suppressInvalidate = false;\n      }, this);\n\n      if (this._ellipsis) {\n        this._ellipsis.setCompact(true);\n      }\n    }\n    /**\n     * Restores to the previous state of the compact property.\n     */\n\n  }, {\n    key: \"undoCompactMenus\",\n    value: function undoCompactMenus(argMenus) {\n      argMenus = argMenus || this.visibleMenus();\n      argMenus.forEach(function (menu) {\n        if (menu.compactOrig === undefined) {\n          return;\n        } // Restore old compact state\n\n\n        menu.htmlComp.suppressInvalidate = true;\n        menu.setCompact(menu.compactOrig);\n        menu.htmlComp.suppressInvalidate = false;\n        menu.compactOrig = undefined;\n      }, this);\n\n      if (this._ellipsis) {\n        this._ellipsis.setCompact(false);\n      }\n    }\n  }, {\n    key: \"shrink\",\n    value: function shrink(argMenus) {\n      this.shrinkMenus(argMenus);\n    }\n    /**\n     * Makes the text invisible of all menus with an icon.\n     */\n\n  }, {\n    key: \"shrinkMenus\",\n    value: function shrinkMenus(argMenus) {\n      argMenus = argMenus || this.visibleMenus();\n      argMenus.forEach(function (menu) {\n        if (menu.textVisibleOrig !== undefined) {\n          // already done\n          return;\n        }\n\n        if (menu.iconId) {\n          menu.textVisibleOrig = menu.textVisible;\n          menu.htmlComp.suppressInvalidate = true;\n          menu.setTextVisible(false);\n          menu.htmlComp.suppressInvalidate = false;\n        }\n      }, this);\n    }\n  }, {\n    key: \"undoShrink\",\n    value: function undoShrink(argMenus) {\n      this.undoShrinkMenus(argMenus);\n    }\n  }, {\n    key: \"undoShrinkMenus\",\n    value: function undoShrinkMenus(argMenus) {\n      argMenus = argMenus || this.visibleMenus();\n      argMenus.forEach(function (menu) {\n        if (menu.textVisibleOrig === undefined) {\n          return;\n        } // Restore old text visible state\n\n\n        menu.htmlComp.suppressInvalidate = true;\n        menu.setTextVisible(menu.textVisibleOrig);\n        menu.htmlComp.suppressInvalidate = false;\n        menu.textVisibleOrig = undefined;\n      }, this);\n    }\n  }, {\n    key: \"collapse\",\n    value: function collapse(argMenus, containerSize, menusWidth) {\n      this._createAndRenderEllipsis(this.menuBox.$container);\n\n      var collapsedMenus = this._moveOverflowMenusIntoEllipsis(containerSize, menusWidth);\n\n      this.updateFirstAndLastMenuMarker(collapsedMenus);\n    }\n    /**\n     * Undoes the collapsing by removing ellipsis and rendering non rendered menus.\n     */\n\n  }, {\n    key: \"undoCollapse\",\n    value: function undoCollapse(argMenus) {\n      argMenus = argMenus || this.visibleMenus();\n\n      this._destroyEllipsis();\n\n      this._removeMenusFromEllipsis(argMenus);\n    }\n  }, {\n    key: \"_createAndRenderEllipsis\",\n    value: function _createAndRenderEllipsis($container) {\n      var ellipsis = menus.createEllipsisMenu({\n        parent: this.menuBox,\n        horizontalAlignment: 1,\n        compact: this.menuBox.compact\n      });\n      ellipsis.uiCssClass = this.menuBox.uiMenuCssClass;\n      ellipsis.render($container);\n      this._ellipsis = ellipsis;\n    }\n  }, {\n    key: \"_destroyEllipsis\",\n    value: function _destroyEllipsis() {\n      if (this._ellipsis) {\n        this._ellipsis.destroy();\n\n        this._ellipsis = null;\n      }\n    }\n    /**\n     * Moves every menu which doesn't fit into the container into the ellipsis menu.\n     * Returns the list of \"surviving\" menus (with the ellipsis menu being the last element).\n     */\n\n  }, {\n    key: \"_moveOverflowMenusIntoEllipsis\",\n    value: function _moveOverflowMenusIntoEllipsis(containerSize, menusWidth) {\n      var collapsedMenus = [this._ellipsis];\n      var ellipsisSize = graphics.size(this._ellipsis.$container, true);\n      menusWidth += ellipsisSize.width;\n      this.visibleMenus().slice().reverse().forEach(function (menu) {\n        var menuSize;\n\n        if (menusWidth > containerSize.width) {\n          // Menu does not fit -> move to ellipsis menu\n          menuSize = graphics.size(menu.$container, true);\n          menusWidth -= menuSize.width;\n          menus.moveMenuIntoEllipsis(menu, this._ellipsis);\n        } else {\n          collapsedMenus.unshift(menu); // add as first element\n        }\n      }, this);\n      return collapsedMenus;\n    }\n  }, {\n    key: \"_removeMenusFromEllipsis\",\n    value: function _removeMenusFromEllipsis(argMenus) {\n      argMenus = argMenus || this.visibleMenus();\n      argMenus.forEach(function (menu) {\n        menus.removeMenuFromEllipsis(menu, this.menuBox.$container);\n      }, this);\n    }\n  }, {\n    key: \"actualPrefSize\",\n    value: function actualPrefSize(argMenus) {\n      var menusWidth, prefSize;\n      argMenus = argMenus || this.visibleMenus();\n      menusWidth = this._menusWidth(argMenus);\n      prefSize = graphics.prefSize(this.menuBox.$container, {\n        includeMargin: true,\n        useCssSize: true\n      });\n      prefSize.width = menusWidth + this.menuBox.htmlComp.insets().horizontal();\n      return prefSize;\n    }\n    /**\n     * @return the current width of all menus incl. the ellipsis\n     */\n\n  }, {\n    key: \"_menusWidth\",\n    value: function _menusWidth(argMenus) {\n      var menusWidth = 0;\n      argMenus = argMenus || this.visibleMenus();\n      argMenus.forEach(function (menu) {\n        if (menu.rendered) {\n          menusWidth += menu.$container.outerWidth(true);\n        }\n      }, this);\n\n      if (this._ellipsis) {\n        menusWidth += this._ellipsis.$container.outerWidth(true);\n      }\n\n      return menusWidth;\n    }\n  }, {\n    key: \"compactPrefSize\",\n    value: function compactPrefSize(argMenus) {\n      argMenus = argMenus || this.visibleMenus();\n      this.updateFirstAndLastMenuMarker(argMenus);\n      this.undoCollapse(argMenus);\n      this.undoShrink(argMenus);\n      this.compact(argMenus);\n      return this.actualPrefSize();\n    }\n  }, {\n    key: \"shrinkPrefSize\",\n    value: function shrinkPrefSize(argMenus) {\n      argMenus = argMenus || this.visibleMenus();\n      this.updateFirstAndLastMenuMarker(argMenus);\n      this.undoCollapse(argMenus);\n      this.compact(argMenus);\n      this.shrink(argMenus);\n      return this.actualPrefSize();\n    }\n  }, {\n    key: \"visibleMenus\",\n    value: function visibleMenus() {\n      return this.menuBox.menus.filter(function (menu) {\n        return menu.visible;\n      }, this);\n    }\n  }, {\n    key: \"updateFirstAndLastMenuMarker\",\n    value: function updateFirstAndLastMenuMarker(argMenus) {\n      // Find first and last rendered menu\n      var firstMenu = null;\n      var lastMenu = null;\n      (argMenus || []).forEach(function (menu) {\n        if (menu.rendered) {\n          if (!firstMenu) {\n            firstMenu = menu;\n          }\n\n          lastMenu = menu;\n        }\n      }); // Check if first or last menu has changed (prevents unnecessary DOM updates)\n\n      if (firstMenu !== this.firstMenu || lastMenu !== this.lastMenu) {\n        // Remove existing markers\n        if (this.firstMenu && this.firstMenu.rendered) {\n          this.firstMenu.$container.removeClass('first');\n        }\n\n        if (this.lastMenu && this.lastMenu.rendered) {\n          this.lastMenu.$container.removeClass('last');\n        } // Remember found menus\n\n\n        this.firstMenu = firstMenu;\n        this.lastMenu = lastMenu; // Add markers to found menus\n\n        if (this.firstMenu) {\n          this.firstMenu.$container.addClass('first');\n        }\n\n        if (this.lastMenu) {\n          this.lastMenu.$container.addClass('last');\n        }\n      }\n    }\n  }]);\n\n  return MenuBoxLayout;\n}(AbstractLayout);\n\nexport { MenuBoxLayout as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/menu/menubox/MenuBoxLayout.js"],"names":["AbstractLayout","graphics","menus","MenuBoxLayout","menuBox","firstMenu","lastMenu","$container","htmlContainer","htmlComp","containerSize","size","visibleMenus","menusWidth","session","layoutValidator","schedulePostValidateFunction","forEach","menu","popup","position","updateFirstAndLastMenuMarker","undoCollapse","undoCompact","undoShrink","actualPrefSize","width","compact","shrink","collapse","argMenus","compactOrig","undefined","suppressInvalidate","setCompact","compactMenus","undoCompactMenus","_ellipsis","shrinkMenus","textVisibleOrig","iconId","textVisible","setTextVisible","undoShrinkMenus","_createAndRenderEllipsis","collapsedMenus","_moveOverflowMenusIntoEllipsis","_destroyEllipsis","_removeMenusFromEllipsis","ellipsis","createEllipsisMenu","parent","horizontalAlignment","uiCssClass","uiMenuCssClass","render","destroy","ellipsisSize","slice","reverse","menuSize","moveMenuIntoEllipsis","unshift","removeMenuFromEllipsis","prefSize","_menusWidth","includeMargin","useCssSize","insets","horizontal","rendered","outerWidth","filter","visible","removeClass","addClass"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {AbstractLayout, graphics, menus} from '../../index';\n\nexport default class MenuBoxLayout extends AbstractLayout {\n\n  constructor(menuBox) {\n    super();\n    this.menuBox = menuBox;\n    // References to prevent too many DOM updates\n    this.firstMenu = null;\n    this.lastMenu = null;\n  }\n\n  /**\n   * @override AbstractLayout.js\n   */\n  layout($container) {\n    var htmlContainer = this.menuBox.htmlComp,\n      containerSize = htmlContainer.size(),\n      menus = this.visibleMenus(),\n      menusWidth = 0;\n\n    // Make sure open popups are at the correct position after layouting\n    this.menuBox.session.layoutValidator.schedulePostValidateFunction(function() {\n      menus.forEach(function(menu) {\n        if (menu.popup) {\n          menu.popup.position();\n        }\n      });\n    });\n\n    this.updateFirstAndLastMenuMarker(menus);\n    this.undoCollapse(menus);\n    this.undoCompact(menus);\n    this.undoShrink(menus);\n    menusWidth = this.actualPrefSize(menus).width;\n    if (menusWidth <= containerSize.width) {\n      // OK, every menu fits into container\n      return;\n    }\n\n    // Menus don't fit\n\n    // First approach: Set menuBox into compact mode\n    this.compact(menus);\n    menusWidth = this.actualPrefSize(menus).width;\n    if (menusWidth <= containerSize.width) {\n      // OK, every menu fits into container\n      return;\n    }\n\n    // Second approach: Make text invisible and only show the icon (if available)\n    this.shrink(menus);\n    menusWidth = this.actualPrefSize(menus).width;\n    if (menusWidth <= containerSize.width) {\n      // OK, every menu fits into container\n      return;\n    }\n\n    // Third approach: Create ellipsis and move overflown menus into it\n    this.collapse(menus, containerSize, menusWidth);\n  }\n\n  preferredLayoutSize($container) {\n    var menus = this.visibleMenus();\n\n    this.updateFirstAndLastMenuMarker(menus);\n    this.undoCollapse(menus);\n    this.undoCompact(menus);\n    this.undoShrink(menus);\n\n    return this.actualPrefSize();\n  }\n\n  compact(argMenus) {\n    if (this.menuBox.compactOrig === undefined) {\n      this.menuBox.compactOrig = this.menuBox.compact;\n      this.menuBox.htmlComp.suppressInvalidate = true;\n      this.menuBox.setCompact(true);\n      this.menuBox.htmlComp.suppressInvalidate = false;\n    }\n\n    this.compactMenus(argMenus);\n  }\n\n  undoCompact(argMenus) {\n    if (this.menuBox.compactOrig !== undefined) {\n      this.menuBox.htmlComp.suppressInvalidate = true;\n      this.menuBox.setCompact(this.menuBox.compactOrig);\n      this.menuBox.htmlComp.suppressInvalidate = false;\n      this.menuBox.compactOrig = undefined;\n    }\n\n    this.undoCompactMenus(argMenus);\n  }\n\n  /**\n   * Sets all menus into compact mode.\n   */\n  compactMenus(argMenus) {\n    argMenus = argMenus || this.visibleMenus();\n    argMenus.forEach(function(menu) {\n      if (menu.compactOrig !== undefined) {\n        // already done\n        return;\n      }\n      menu.compactOrig = menu.compact;\n      menu.htmlComp.suppressInvalidate = true;\n      menu.setCompact(true);\n      menu.htmlComp.suppressInvalidate = false;\n    }, this);\n\n    if (this._ellipsis) {\n      this._ellipsis.setCompact(true);\n    }\n  }\n\n  /**\n   * Restores to the previous state of the compact property.\n   */\n  undoCompactMenus(argMenus) {\n    argMenus = argMenus || this.visibleMenus();\n    argMenus.forEach(function(menu) {\n      if (menu.compactOrig === undefined) {\n        return;\n      }\n      // Restore old compact state\n      menu.htmlComp.suppressInvalidate = true;\n      menu.setCompact(menu.compactOrig);\n      menu.htmlComp.suppressInvalidate = false;\n      menu.compactOrig = undefined;\n    }, this);\n\n    if (this._ellipsis) {\n      this._ellipsis.setCompact(false);\n    }\n  }\n\n  shrink(argMenus) {\n    this.shrinkMenus(argMenus);\n  }\n\n  /**\n   * Makes the text invisible of all menus with an icon.\n   */\n  shrinkMenus(argMenus) {\n    argMenus = argMenus || this.visibleMenus();\n    argMenus.forEach(function(menu) {\n      if (menu.textVisibleOrig !== undefined) {\n        // already done\n        return;\n      }\n      if (menu.iconId) {\n        menu.textVisibleOrig = menu.textVisible;\n        menu.htmlComp.suppressInvalidate = true;\n        menu.setTextVisible(false);\n        menu.htmlComp.suppressInvalidate = false;\n      }\n    }, this);\n  }\n\n  undoShrink(argMenus) {\n    this.undoShrinkMenus(argMenus);\n  }\n\n  undoShrinkMenus(argMenus) {\n    argMenus = argMenus || this.visibleMenus();\n    argMenus.forEach(function(menu) {\n      if (menu.textVisibleOrig === undefined) {\n        return;\n      }\n      // Restore old text visible state\n      menu.htmlComp.suppressInvalidate = true;\n      menu.setTextVisible(menu.textVisibleOrig);\n      menu.htmlComp.suppressInvalidate = false;\n      menu.textVisibleOrig = undefined;\n    }, this);\n  }\n\n  collapse(argMenus, containerSize, menusWidth) {\n    this._createAndRenderEllipsis(this.menuBox.$container);\n    var collapsedMenus = this._moveOverflowMenusIntoEllipsis(containerSize, menusWidth);\n    this.updateFirstAndLastMenuMarker(collapsedMenus);\n  }\n\n  /**\n   * Undoes the collapsing by removing ellipsis and rendering non rendered menus.\n   */\n  undoCollapse(argMenus) {\n    argMenus = argMenus || this.visibleMenus();\n    this._destroyEllipsis();\n    this._removeMenusFromEllipsis(argMenus);\n  }\n\n  _createAndRenderEllipsis($container) {\n    var ellipsis = menus.createEllipsisMenu({\n      parent: this.menuBox,\n      horizontalAlignment: 1,\n      compact: this.menuBox.compact\n    });\n    ellipsis.uiCssClass = this.menuBox.uiMenuCssClass;\n    ellipsis.render($container);\n    this._ellipsis = ellipsis;\n  }\n\n  _destroyEllipsis() {\n    if (this._ellipsis) {\n      this._ellipsis.destroy();\n      this._ellipsis = null;\n    }\n  }\n\n  /**\n   * Moves every menu which doesn't fit into the container into the ellipsis menu.\n   * Returns the list of \"surviving\" menus (with the ellipsis menu being the last element).\n   */\n  _moveOverflowMenusIntoEllipsis(containerSize, menusWidth) {\n    var collapsedMenus = [this._ellipsis];\n    var ellipsisSize = graphics.size(this._ellipsis.$container, true);\n    menusWidth += ellipsisSize.width;\n    this.visibleMenus().slice().reverse().forEach(function(menu) {\n      var menuSize;\n      if (menusWidth > containerSize.width) {\n        // Menu does not fit -> move to ellipsis menu\n        menuSize = graphics.size(menu.$container, true);\n        menusWidth -= menuSize.width;\n        menus.moveMenuIntoEllipsis(menu, this._ellipsis);\n      } else {\n        collapsedMenus.unshift(menu); // add as first element\n      }\n    }, this);\n    return collapsedMenus;\n  }\n\n  _removeMenusFromEllipsis(argMenus) {\n    argMenus = argMenus || this.visibleMenus();\n    argMenus.forEach(function(menu) {\n      menus.removeMenuFromEllipsis(menu, this.menuBox.$container);\n    }, this);\n  }\n\n  actualPrefSize(argMenus) {\n    var menusWidth, prefSize;\n\n    argMenus = argMenus || this.visibleMenus();\n    menusWidth = this._menusWidth(argMenus);\n    prefSize = graphics.prefSize(this.menuBox.$container, {\n      includeMargin: true,\n      useCssSize: true\n    });\n    prefSize.width = menusWidth + this.menuBox.htmlComp.insets().horizontal();\n\n    return prefSize;\n  }\n\n  /**\n   * @return the current width of all menus incl. the ellipsis\n   */\n  _menusWidth(argMenus) {\n    var menusWidth = 0;\n    argMenus = argMenus || this.visibleMenus();\n    argMenus.forEach(function(menu) {\n      if (menu.rendered) {\n        menusWidth += menu.$container.outerWidth(true);\n      }\n    }, this);\n    if (this._ellipsis) {\n      menusWidth += this._ellipsis.$container.outerWidth(true);\n    }\n    return menusWidth;\n  }\n\n  compactPrefSize(argMenus) {\n    argMenus = argMenus || this.visibleMenus();\n\n    this.updateFirstAndLastMenuMarker(argMenus);\n    this.undoCollapse(argMenus);\n    this.undoShrink(argMenus);\n    this.compact(argMenus);\n\n    return this.actualPrefSize();\n  }\n\n  shrinkPrefSize(argMenus) {\n    argMenus = argMenus || this.visibleMenus();\n\n    this.updateFirstAndLastMenuMarker(argMenus);\n    this.undoCollapse(argMenus);\n    this.compact(argMenus);\n    this.shrink(argMenus);\n\n    return this.actualPrefSize();\n  }\n\n  visibleMenus() {\n    return this.menuBox.menus.filter(function(menu) {\n      return menu.visible;\n    }, this);\n  }\n\n  updateFirstAndLastMenuMarker(argMenus) {\n    // Find first and last rendered menu\n    var firstMenu = null;\n    var lastMenu = null;\n    (argMenus || []).forEach(function(menu) {\n      if (menu.rendered) {\n        if (!firstMenu) {\n          firstMenu = menu;\n        }\n        lastMenu = menu;\n      }\n    });\n\n    // Check if first or last menu has changed (prevents unnecessary DOM updates)\n    if (firstMenu !== this.firstMenu || lastMenu !== this.lastMenu) {\n      // Remove existing markers\n      if (this.firstMenu && this.firstMenu.rendered) {\n        this.firstMenu.$container.removeClass('first');\n      }\n      if (this.lastMenu && this.lastMenu.rendered) {\n        this.lastMenu.$container.removeClass('last');\n      }\n      // Remember found menus\n      this.firstMenu = firstMenu;\n      this.lastMenu = lastMenu;\n      // Add markers to found menus\n      if (this.firstMenu) {\n        this.firstMenu.$container.addClass('first');\n      }\n      if (this.lastMenu) {\n        this.lastMenu.$container.addClass('last');\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}