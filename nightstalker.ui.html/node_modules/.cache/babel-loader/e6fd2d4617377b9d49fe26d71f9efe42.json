{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Device, fields, FormField, InputFieldKeyStrokeContext, keys, LookupCall, objects, QueryBy, scout, SimpleLoadingSupport, SmartFieldCancelKeyStroke, SmartFieldLayout, Status, strings, ValueField } from '../../../index';\nimport $ from 'jquery';\n\nvar SmartField = /*#__PURE__*/function (_ValueField) {\n  _inherits(SmartField, _ValueField);\n\n  var _super = _createSuper(SmartField);\n\n  function SmartField() {\n    var _this;\n\n    _classCallCheck(this, SmartField);\n\n    _this = _super.call(this);\n    _this.popup = null;\n    _this.lookupCall = null;\n    _this.codeType = null;\n    _this._pendingLookup = null;\n    _this._pendingOpenPopup = false;\n    _this._tabPrevented = null;\n    _this.lookupRow = null;\n    _this.browseHierarchy = false;\n    _this.browseMaxRowCount = SmartField.DEFAULT_BROWSE_MAX_COUNT;\n    _this.browseAutoExpandAll = true;\n    _this.browseLoadIncremental = false;\n    _this.searchRequired = false;\n    _this.activeFilterEnabled = false;\n    _this.activeFilter = null;\n    _this.activeFilterLabels = [];\n    _this.columnDescriptors = null;\n    _this.displayStyle = SmartField.DisplayStyle.DEFAULT;\n    _this.touchMode = false;\n    _this.embedded = false;\n    _this._userWasTyping = false; // used to detect whether the last thing the user did was typing (a proposal) or something else, like selecting a proposal row\n\n    _this._acceptInputEnabled = true; // used to prevent multiple execution of blur/acceptInput\n\n    _this._acceptInputDeferred = $.Deferred();\n    _this._notUnique = false; // used to store the error state 'not unique' which must not be showed while typing, but when the field loses focus\n\n    _this._lastSearchText = null;\n    _this.lookupStatus = null;\n    _this._currentLookupCall = null; // should only be accessed on the original widget since the adapter accesses it\n\n    _this.lookupSeqNo = 0; // used to detect if the proposal chooser contains the results of the latest lookup, or an out-dated result.\n    // only when the result is up-to-date, we can use the selected lookup row\n\n    _this.initActiveFilter = null;\n    _this.disabledCopyOverlay = true;\n\n    _this._addCloneProperties(['lookupRow', 'codeType', 'lookupCall', 'activeFilter', 'activeFilterEnabled', 'activeFilterLabels', 'browseHierarchy', 'browseMaxRowCount', 'browseAutoExpandAll', 'browseLoadIncremental', 'searchRequired', 'columnDescriptors', 'displayStyle']);\n\n    return _this;\n  }\n\n  _createClass(SmartField, [{\n    key: \"_init\",\n    value: function _init(model) {\n      _get(_getPrototypeOf(SmartField.prototype), \"_init\", this).call(this, model);\n\n      if (this.activeFilterLabels.length === 0) {\n        this.activeFilterLabels = [this.session.text('ui.All'), this.session.text('ui.Inactive'), this.session.text('ui.Active')];\n      }\n\n      fields.initTouch(this, model);\n    }\n    /**\n     * Initializes lookup call and code type before calling set value.\n     * This cannot be done in _init because the value field would call _setValue first\n     */\n\n  }, {\n    key: \"_initValue\",\n    value: function _initValue(value) {\n      this._setLookupCall(this.lookupCall);\n\n      this._setCodeType(this.codeType);\n\n      this._setLookupRow(this.lookupRow);\n\n      _get(_getPrototypeOf(SmartField.prototype), \"_initValue\", this).call(this, value);\n    }\n  }, {\n    key: \"markAsSaved\",\n    value: function markAsSaved() {\n      _get(_getPrototypeOf(SmartField.prototype), \"markAsSaved\", this).call(this);\n\n      this.setInitActiveFilter(this.activeFilter);\n    }\n  }, {\n    key: \"resetValue\",\n    value: function resetValue() {\n      _get(_getPrototypeOf(SmartField.prototype), \"resetValue\", this).call(this);\n\n      this.setActiveFilter(this.initActiveFilter);\n    }\n  }, {\n    key: \"_createKeyStrokeContext\",\n    value: function _createKeyStrokeContext() {\n      return new InputFieldKeyStrokeContext();\n    }\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      _get(_getPrototypeOf(SmartField.prototype), \"_initKeyStrokeContext\", this).call(this);\n\n      this.keyStrokeContext.registerKeyStroke(new SmartFieldCancelKeyStroke(this));\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      this.addContainer(this.$parent, 'has-icon ' + this.cssClassName(), new SmartFieldLayout(this));\n      this.addLabel();\n      var fieldFunc = this.isDropdown() ? fields.makeInputDiv : fields.makeInputOrDiv;\n      var $field = fieldFunc.call(scout.fields, this).on('mousedown', this._onFieldMouseDown.bind(this));\n\n      if (!this.touchMode) {\n        $field.keyup(this._onFieldKeyUp.bind(this)).keydown(this._onFieldKeyDown.bind(this)).on('input', this._onFieldInput.bind(this));\n      }\n\n      this.addField($field);\n\n      if (!this.embedded) {\n        this.addMandatoryIndicator();\n      }\n\n      this.addIcon();\n      this.$icon.addClass('needsclick');\n      this.addStatus();\n    }\n  }, {\n    key: \"_renderGridData\",\n    value: function _renderGridData() {\n      _get(_getPrototypeOf(SmartField.prototype), \"_renderGridData\", this).call(this);\n\n      this.updateInnerAlignment({\n        useHorizontalAlignment: this.browseHierarchy ? false : true\n      });\n    }\n  }, {\n    key: \"_renderGridDataHints\",\n    value: function _renderGridDataHints() {\n      _get(_getPrototypeOf(SmartField.prototype), \"_renderGridDataHints\", this).call(this);\n\n      this.updateInnerAlignment({\n        useHorizontalAlignment: this.browseHierarchy ? false : true\n      });\n    }\n  }, {\n    key: \"cssClassName\",\n    value: function cssClassName() {\n      var prefix = this.displayStyle;\n\n      if (this.displayStyle === SmartField.DisplayStyle.DEFAULT) {\n        prefix = 'smart';\n      }\n\n      return prefix + '-field';\n    }\n  }, {\n    key: \"_readSearchText\",\n    value: function _readSearchText() {\n      var fieldText = this._readDisplayText(),\n          displayText = scout.nvl(this.displayText, ''),\n          textLines = displayText.split('\\n');\n\n      if (textLines.length === 1 || strings.empty(fieldText)) {\n        return fieldText;\n      }\n\n      textLines.shift(); // remove first line\n\n      arrays.insert(textLines, fieldText, 0);\n      return strings.join('\\n', textLines);\n    }\n  }, {\n    key: \"_readDisplayText\",\n    value: function _readDisplayText() {\n      return fields.valOrText(this.$field);\n    }\n  }, {\n    key: \"_renderDisplayText\",\n    value: function _renderDisplayText() {\n      var displayText = scout.nvl(this.displayText, ''),\n          textLines = displayText.split('\\n');\n\n      if (textLines.length) {\n        displayText = textLines[0];\n      }\n\n      fields.valOrText(this.$field, displayText);\n\n      _get(_getPrototypeOf(SmartField.prototype), \"_renderDisplayText\", this).call(this);\n    }\n    /**\n     * Accepts the selected lookup row and sets its id as value.\n     * This function is called on blur, by a keystroke or programmatically at any time.\n     *\n     * @param [sync] optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search\n     */\n\n  }, {\n    key: \"acceptInput\",\n    value: function acceptInput(sync) {\n      if (!this._acceptInputEnabled) {\n        $.log.isTraceEnabled() && $.log.trace('(SmartField#acceptInput) Skipped acceptInput because _acceptInputEnabled=false');\n        return this._acceptInputDeferred.promise();\n      } // Use a timeout to prevent multiple execution within the same user action\n\n\n      this._acceptInputEnabled = false;\n      setTimeout(function () {\n        this._acceptInputEnabled = true;\n      }.bind(this));\n\n      var searchText = this._readSearchText(),\n          searchTextEmpty = strings.empty(searchText),\n          searchTextChanged = this._checkSearchTextChanged(searchText),\n          selectedLookupRow = this._getSelectedLookupRow(searchTextChanged);\n\n      this._setProperty('displayText', searchText);\n\n      this._acceptInputDeferred = $.Deferred();\n\n      this._flushLookupStatus();\n\n      this._clearPendingLookup();\n\n      if (this.touchMode) {\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#acceptInput) Always send acceptInput for touch field');\n\n        this._inputAccepted();\n\n        return;\n      }\n\n      return this._acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow);\n    }\n    /**\n     * This function is used to determine if the currently selected lookup row can be\n     * used when acceptInput is called. Basically we don't want to use the row in case\n     * the result is out-dated.\n     */\n\n  }, {\n    key: \"_getSelectedLookupRow\",\n    value: function _getSelectedLookupRow(searchTextChanged) {\n      // don't use selected lookup row if...\n      if (!this.isPopupOpen() || // 1. popup has been closed\n      searchTextChanged && this._userWasTyping) {\n        // 2. search text has changed and user was typing\n        return null;\n      } // 3. if the result row is from an out-dated result\n\n\n      return this.lookupSeqNo === this.popup.lookupResult.seqNo ? this.popup.getSelectedLookupRow() : null;\n    }\n  }, {\n    key: \"_checkSearchTextChanged\",\n    value: function _checkSearchTextChanged(searchText) {\n      if (this.isDropdown() || !this._userWasTyping) {\n        return false; // search text cannot change in drop-down fields\n      } // check if search text has changed since the last search, when it has changed\n      // we cannot use the currently selected lookup row, because these proposals are\n      // out-dated.\n\n\n      return !this._searchTextEquals(searchText, this._lastSearchText);\n    }\n  }, {\n    key: \"_searchTextEquals\",\n    value: function _searchTextEquals(searchText, lastSearchText) {\n      var a = strings.nullIfEmpty(this._firstTextLine(searchText));\n      var b = strings.nullIfEmpty(lastSearchText);\n      return strings.equalsIgnoreCase(a, b);\n    }\n  }, {\n    key: \"_clearPendingLookup\",\n    value: function _clearPendingLookup() {\n      if (this._pendingLookup) {\n        clearTimeout(this._pendingLookup);\n        this._pendingLookup = null;\n      }\n    }\n    /**\n     * This function is intended to be overridden. Proposal field has another behavior than the smart field.\n     *\n     * @param [sync] optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search\n     */\n\n  }, {\n    key: \"_acceptInput\",\n    value: function _acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow) {\n      // Do nothing when search text is equals to the text of the current lookup row\n      if (!selectedLookupRow && this.lookupRow) {\n        var lookupRowText = strings.nvl(this.lookupRow.text);\n\n        if (lookupRowText === searchText) {\n          $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) unchanged: text is equals. Close popup');\n\n          this._clearLookupStatus();\n\n          this._inputAccepted(false);\n\n          return;\n        }\n      } // Don't show the not-unique error when the search-text becomes empty while typing (see ticket #229775)\n\n\n      if (this._notUnique && !searchTextEmpty) {\n        this._setNotUniqueError(searchText);\n      } // Do nothing when we don't have a current lookup row and search text is empty\n      // trigger event when search text has changed. This is required for the case where\n      // a field is cleared, and the remote model must be updated (value=null)\n\n\n      if (!selectedLookupRow && !this.lookupRow && searchTextEmpty) {\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) unchanged: text is empty. Close popup');\n\n        this._clearLookupStatus();\n\n        if (this.errorStatus && this.errorStatus.code === SmartField.ErrorCode.NO_RESULTS) {\n          // clear the error status from previous search which did not find any results. This error status is no longer valid as we accept the null content here.\n          this.clearErrorStatus();\n        }\n\n        this._inputAccepted(searchTextChanged || this._userWasTyping);\n\n        return;\n      } // 1.) when search text is empty and no lookup-row is selected, simply set the value to null\n      // Note: here we assume that a current lookup row is set.\n\n\n      if (!selectedLookupRow && searchTextEmpty) {\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) empty. Set lookup-row to null, close popup');\n\n        this._clearLookupStatus();\n\n        this.setLookupRow(null);\n\n        this._inputAccepted();\n\n        return;\n      } // 2.) proposal chooser is open -> use the selected row as value\n\n\n      if (selectedLookupRow) {\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) lookup-row selected. Set lookup-row, close popup lookupRow=', selectedLookupRow.toString());\n\n        this._clearLookupStatus();\n\n        this.setLookupRow(selectedLookupRow);\n\n        this._inputAccepted();\n\n        return;\n      } // 3.) proposal chooser is not open -> try to accept the current display text\n      // this causes a lookup which may fail and open a new proposal chooser (property\n      // change for 'result').\n\n\n      if (searchTextChanged || this._userWasTyping) {\n        this._acceptByText(sync, this._firstTextLine(searchText));\n      } else if (!this._hasUiError()) {\n        this._inputAccepted(false);\n      } else if (this._hasNotUniqueError() && this.popup) {\n        // popup has been opened (again) with errorStatus NOT_UNIQUE, and search text is still the same\n        this.popup.selectFirstLookupRow();\n      } else {\n        // even though there's nothing to do, someone could wait for our promise to be resolved\n        this._acceptInputDeferred.resolve();\n      }\n\n      return this._acceptInputDeferred.promise();\n    }\n    /**\n     * Required for multiline smart-field. Only use first line of search text for accept by text.\n     * Note: for the regular lookup by text, we use the readDisplayText() function which always\n     * returns a single line. But in acceptInput we need the full search text (=display text + additional\n     * lines) in order to check whether or not the display text has changed, compared to the current\n     * lookup row. That's why we must extract the first line here.\n     */\n\n  }, {\n    key: \"_firstTextLine\",\n    value: function _firstTextLine(text) {\n      if (strings.empty(text)) {\n        return text;\n      }\n\n      return text.split('\\n')[0];\n    }\n    /**\n     * This function is intended to be overridden. Proposal field has another behavior than the smart field.\n     *\n     * @param sync when set to true it's not allowed to start an asynchronous lookup to search by text, the\n     *     current search text is discarded. The flag is set to true in case we click on another field, where\n     *     we must make sure the order of (browser) events is not changed by the lookup that would return _after_\n     *     the events for the clicked field are handled.\n     */\n\n  }, {\n    key: \"_acceptByText\",\n    value: function _acceptByText(sync, searchText) {\n      sync = scout.nvl(sync, false);\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptByText) sync=' + sync + ' searchText=', searchText);\n\n      if (sync) {\n        this._acceptByTextSync(searchText);\n      } else {\n        this._acceptByTextAsync(searchText);\n      }\n    }\n  }, {\n    key: \"_acceptByTextSync\",\n    value: function _acceptByTextSync(searchText) {\n      this._lastSearchText = null;\n\n      this._inputAccepted();\n\n      if (!this._hasUiError()) {\n        this.resetDisplayText();\n      }\n    }\n  }, {\n    key: \"_acceptByTextAsync\",\n    value: function _acceptByTextAsync(searchText) {\n      this._lastSearchText = searchText;\n\n      this._executeLookup(this.lookupCall.cloneForText(searchText), true).done(this._acceptByTextDone.bind(this)).done(this._triggerLookupCallDone.bind(this));\n\n      this._triggerAcceptByText(searchText);\n    }\n  }, {\n    key: \"_inputAccepted\",\n    value: function _inputAccepted(triggerEvent, acceptByLookupRow) {\n      triggerEvent = scout.nvl(triggerEvent, true);\n      acceptByLookupRow = scout.nvl(acceptByLookupRow, true); // don't close when shown in touch popup (also called when clear() is executed)\n\n      if (!this.embedded) {\n        this.closePopup();\n      }\n\n      this._userWasTyping = false;\n\n      if (triggerEvent) {\n        this._triggerAcceptInput(acceptByLookupRow);\n      }\n\n      this._focusNextTabbable();\n\n      this._acceptInputDeferred.resolve();\n    }\n  }, {\n    key: \"_focusNextTabbable\",\n    value: function _focusNextTabbable() {\n      if (this._tabPrevented) {\n        var $tabElements = this.entryPoint().find(':tabbable'),\n            direction = this._tabPrevented.shiftKey ? -1 : 1,\n            fieldIndex = $tabElements.index(this.$field),\n            nextIndex = fieldIndex + direction;\n\n        if (nextIndex < 0) {\n          nextIndex = $tabElements.length - 1;\n        } else if (nextIndex >= $tabElements.length) {\n          nextIndex = 0;\n        }\n\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_inputAccepted) tab-index=' + fieldIndex + ' next tab-index=' + nextIndex);\n        var $nextElement = $tabElements.eq(nextIndex).focus();\n\n        if (objects.isFunction($nextElement[0].select)) {\n          $nextElement[0].select();\n        }\n\n        this._tabPrevented = null;\n      }\n    }\n  }, {\n    key: \"_acceptByTextDone\",\n    value: function _acceptByTextDone(result) {\n      this._userWasTyping = false;\n\n      this._extendResult(result);\n\n      this._notUnique = result.numLookupRows > 1; // when there's exactly one result, we accept that lookup row\n\n      if (result.uniqueMatch) {\n        var lookupRow = result.uniqueMatch;\n\n        if (this._isLookupRowActive(lookupRow)) {\n          this.setLookupRow(lookupRow);\n\n          this._inputAccepted();\n        } else {\n          this.setErrorStatus(Status.error({\n            message: this.session.text('SmartFieldInactiveRow', result.text)\n          }));\n        }\n\n        return;\n      }\n\n      this._acceptInputFail(result);\n    }\n    /**\n     * Extends the properties 'uniqueMatch' and 'numLookupRows' on the given result object.\n     * The implementation is different depending on the browseHierarchy property.\n     */\n\n  }, {\n    key: \"_extendResult\",\n    value: function _extendResult(result) {\n      result.seqNo = this.lookupSeqNo;\n      result.uniqueMatch = null; // Set query type on result, e.g. 'byAll'\n\n      var propertyName = 'by' + strings.toUpperCaseFirstLetter(result.queryBy.toLowerCase());\n      result[propertyName] = true;\n\n      if (this.browseHierarchy) {\n        // tree (hierarchical)\n        var proposalChooser = scout.create('TreeProposalChooser', {\n          parent: this,\n          smartField: this\n        });\n        proposalChooser.setLookupResult(result);\n        var leafs = proposalChooser.findLeafs();\n        result.numLookupRows = leafs.length;\n\n        if (result.numLookupRows === 1) {\n          result.uniqueMatch = leafs[0].lookupRow;\n        }\n      } else {\n        // table\n        result.numLookupRows = result.lookupRows.length;\n\n        if (result.numLookupRows === 1) {\n          result.uniqueMatch = result.lookupRows[0];\n        }\n      }\n\n      result.empty = result.numLookupRows === 0;\n    }\n  }, {\n    key: \"_acceptInputFail\",\n    value: function _acceptInputFail(result) {\n      var searchText = result.text; // in any other case something went wrong\n\n      if (result.empty) {\n        if (!this.embedded) {\n          this.closePopup();\n        }\n\n        this.setValue(null);\n        this.setDisplayText(searchText);\n        this.setErrorStatus(Status.error({\n          message: this.session.text('SmartFieldCannotComplete', searchText),\n          code: SmartField.ErrorCode.NO_RESULTS\n        }));\n      }\n\n      if (result.numLookupRows > 1) {\n        this.setValue(null);\n        this.setDisplayText(searchText);\n\n        this._setNotUniqueError(searchText);\n\n        if (this.isPopupOpen()) {\n          this.popup.setLookupResult(result);\n        } else {\n          this._lookupByTextOrAllDone(result);\n        } // check again if popup is open yet (might have been opened by _lookupByTextOrAllDone)\n\n\n        if (this.isPopupOpen()) {\n          this.popup.selectFirstLookupRow();\n        }\n      }\n\n      this._acceptInputDeferred.resolve();\n\n      this._triggerAcceptInputFail();\n    }\n  }, {\n    key: \"lookupByRec\",\n    value: function lookupByRec(rec) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#lookupByRec) rec=', rec);\n      this._lastSearchText = null;\n      return this._executeLookup(this.lookupCall.cloneForRec(rec)).then(function (result) {\n        // Since this function is only used for hierarchical trees we\n        // can simply set the appendResult flag always to true here\n        result.appendResult = true;\n        result.rec = rec;\n\n        if (this.isPopupOpen()) {\n          this.popup.setLookupResult(result);\n        }\n      }.bind(this)).then(this._triggerLookupCallDone.bind(this));\n    }\n    /**\n     * Validates the given lookup row is enabled and matches the current activeFilter settings.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"_isLookupRowActive\",\n    value: function _isLookupRowActive(lookupRow) {\n      if (!lookupRow.enabled) {\n        return false;\n      }\n\n      if (!this.activeFilterEnabled) {\n        return true;\n      }\n\n      if (this.activeFilter === 'TRUE') {\n        return lookupRow.active;\n      }\n\n      if (this.activeFilter === 'FALSE') {\n        return !lookupRow.active;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_renderEnabled\",\n    value: function _renderEnabled() {\n      _get(_getPrototypeOf(SmartField.prototype), \"_renderEnabled\", this).call(this);\n\n      this.$field.setTabbable(this.enabledComputed);\n    }\n  }, {\n    key: \"setLookupCall\",\n    value: function setLookupCall(lookupCall) {\n      this.setProperty('lookupCall', lookupCall);\n    }\n  }, {\n    key: \"_setLookupCall\",\n    value: function _setLookupCall(lookupCall) {\n      this._setProperty('lookupCall', LookupCall.ensure(lookupCall, this.session));\n    }\n  }, {\n    key: \"_setCodeType\",\n    value: function _setCodeType(codeType) {\n      this._setProperty('codeType', codeType);\n\n      if (!codeType) {\n        return;\n      }\n\n      var lookupCall = scout.create('CodeLookupCall', {\n        session: this.session,\n        codeType: codeType\n      });\n      this.setProperty('lookupCall', lookupCall);\n    }\n  }, {\n    key: \"_formatValue\",\n    value: function _formatValue(value) {\n      if (objects.isNullOrUndefined(value)) {\n        return '';\n      } // we already have a lookup row - Note: in Scout Classic (remote case)\n      // we always end here and don't need to perform a getByKey lookup.\n\n\n      if (this.lookupRow) {\n        return this._formatLookupRow(this.lookupRow);\n      } // we must do a lookup first to get the display text\n      // Note: this has a side-effect as it sets the property lookupRow on the smart field\n\n\n      this._lastSearchText = null;\n      return this._executeLookup(this.lookupCall.cloneForKey(value), true).then(this._lookupByKeyDone.bind(this)).then(this._triggerLookupCallDone.bind(this));\n    }\n  }, {\n    key: \"_lookupByKeyDone\",\n    value: function _lookupByKeyDone(result) {\n      this._notUnique = false;\n      var lookupRow = LookupCall.firstLookupRow(result);\n      this.setLookupRow(lookupRow);\n      return this._formatLookupRow(lookupRow);\n    }\n    /**\n     * This function is called when we need to format a display text from a given lookup\n     * row. By default the property 'text' is used for that purpose. Override this function\n     * if you need to format different properties from the lookupRow.\n     */\n\n  }, {\n    key: \"_formatLookupRow\",\n    value: function _formatLookupRow(lookupRow) {\n      return lookupRow ? lookupRow.text : '';\n    }\n    /**\n     * @param {boolean} [browse] whether or not the lookup call should execute getAll() or getByText() with the current display text.\n     *     if browse is undefined, browse is set to true automatically if search text is empty\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"openPopup\",\n    value: function openPopup(browse) {\n      // In case searchRequired is set to true, we always start a new search with the text from the field as query\n      var searchText = this._readDisplayText(),\n          searchAlways = this.searchRequired ? true : null;\n\n      $.log.isInfoEnabled() && $.log.info('SmartField#openPopup browse=' + browse + ' searchText=' + searchText + ' popup=' + this.popup + ' pendingOpenPopup=' + this._pendingOpenPopup); // Reset scheduled focus next tabbable when user clicks on the smartfield while a lookup is resolved.\n\n      this._tabPrevented = null;\n      this._pendingOpenPopup = true;\n\n      if (strings.empty(searchText)) {\n        // if search text is empty - always do 'browse', no matter what the error code is\n        browse = true;\n      } else if (this.errorStatus) {\n        // In case the search yields a not-unique error, we always want to start a lookup\n        // with the current display text in every other case we better do browse again\n        if (this._hasNotUniqueError()) {\n          searchAlways = true;\n          browse = false;\n        } else if (!this.searchRequired) {\n          browse = true;\n        }\n      }\n\n      return this._lookupByTextOrAll(browse, searchText, searchAlways);\n    }\n  }, {\n    key: \"_hasUiError\",\n    value: function _hasUiError(codes) {\n      var status = this._errorStatus();\n\n      if (!status) {\n        return false;\n      }\n\n      if (codes) {\n        codes = arrays.ensure(codes);\n      } else {\n        codes = [SmartField.ErrorCode.NO_RESULTS, SmartField.ErrorCode.NOT_UNIQUE];\n      } // collect codes from the status hierarchy\n\n\n      var statusList = Status.asFlatList(status);\n      var foundCodes = statusList.reduce(function (list, status) {\n        if (status.code && list.indexOf(status.code) === -1) {\n          list.push(status.code);\n        }\n\n        return list;\n      }, []); // if one of the requested codes exist in the list of found codes\n\n      return codes.some(function (code) {\n        return foundCodes.indexOf(code) > -1;\n      });\n    }\n    /**\n     * @param browse [boolean] optional, whether to perform a lookupByAll (=browse) or a lookupByText.\n     *        By default the param is set to <code>true</code> if the search-text is not empty\n     * @param searchText [String] optional, when not set the search-text from the smart-field is used\n     * @param searchAlways [boolean] optional, only used when browse=false. When set to true the search\n     *        is always performed, event when the search-text has not changed. By default the param is\n     *        set to <code>false</code>.\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_lookupByTextOrAll\",\n    value: function _lookupByTextOrAll(browse, searchText, searchAlways) {\n      // default values\n      searchText = scout.nvl(searchText, this._readDisplayText());\n      browse = scout.nvl(browse, strings.empty(searchText));\n      searchAlways = scout.nvl(searchAlways, false); // never do a text-lookup if field has dropdown style\n\n      if (this.isDropdown()) {\n        browse = true;\n      } // this avoids unnecessary lookup-calls when a keyboard event has triggered\n      // the lookupByTextOrAll function but the search-text has not changed #226643.\n\n\n      if (!browse && !searchAlways) {\n        var lastSearchText = null;\n\n        if (this._lastSearchText) {\n          lastSearchText = this._lastSearchText;\n        } else {\n          lastSearchText = this._getLastSearchText();\n        }\n\n        if (this._searchTextEquals(searchText, lastSearchText)) {\n          this._pendingOpenPopup = false;\n          $.log.debug('(SmartField#_lookupByTextOrAll) searchText is equals -> skip lookup');\n          return;\n        }\n      }\n\n      this._clearPendingLookup();\n\n      var deferred = $.Deferred();\n\n      var doneHandler = function (result) {\n        this._lookupByTextOrAllDone(result);\n\n        deferred.resolve(result);\n      }.bind(this); // execute lookup byAll immediately\n\n\n      if (browse) {\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_lookupByTextOrAll) lookup byAll (searchText empty)');\n        this._lastSearchText = null;\n\n        if (this.searchRequired) {\n          doneHandler({\n            queryBy: QueryBy.TEXT,\n            lookupRows: []\n          });\n          this.setLookupStatus(Status.warning({\n            message: this.session.text('TooManyRows'),\n            code: SmartField.ErrorCode.SEARCH_REQUIRED\n          }));\n        } else {\n          this._executeLookup(this.lookupCall.cloneForAll(), true).done(doneHandler).done(this._triggerLookupCallDone.bind(this));\n        }\n      } else {\n        // execute lookup byText with a debounce/delay\n        this._pendingLookup = setTimeout(function () {\n          $.log.isDebugEnabled() && $.log.debug('(SmartField#_lookupByTextOrAll) lookup byText searchText=' + searchText);\n          this._lastSearchText = searchText;\n\n          this._executeLookup(this.lookupCall.cloneForText(searchText), true).done(doneHandler).done(this._triggerLookupCallDone.bind(this));\n        }.bind(this), SmartField.DEBOUNCE_DELAY);\n      }\n\n      return deferred.promise();\n    }\n    /**\n     * Returns the text used to store the 'last search-text'. The implementation differs between SmartField and ProposalField.\n     */\n\n  }, {\n    key: \"_getLastSearchText\",\n    value: function _getLastSearchText() {\n      return objects.optProperty(this.lookupRow, 'text');\n    }\n  }, {\n    key: \"_lookupByTextOrAllDone\",\n    value: function _lookupByTextOrAllDone(result) {\n      this._extendResult(result);\n\n      this._notUnique = !result.byAll && result.numLookupRows > 1;\n\n      if (this._handleException(result)) {\n        return;\n      } // In cases where the user has tabbed to the next field, while results for the previous\n      // smart-field are still loading: don't show the proposal popup. In the case of a cell-editor\n      // it's also possible that the smart-field is not rendered anymore when the lookup is done\n\n\n      if (!this.rendered || !this.isFocused() && !this.isTouchable()) {\n        this.closePopup();\n        return;\n      } // 'No data' case\n\n\n      if (result.empty && result.byAll) {\n        // When active filter is enabled we must always show the popup, because the user\n        // must be able to switch the filter properties. Otherwise a user could set the filter\n        // to 'inactive', and receives an empty result for that query, the popup is closed\n        // and the user can not switch the filter back to 'active' again because the filter\n        // control is not visible.\n        if (this.activeFilterEnabled) {\n          this._ensurePopup(result);\n        } else {\n          this.closePopup();\n        }\n\n        this.setLookupStatus(Status.warning({\n          message: this.session.text('SmartFieldNoDataFound'),\n          code: SmartField.ErrorCode.NO_DATA\n        }));\n        return;\n      }\n\n      if (result.empty) {\n        this._handleEmptyResult();\n\n        this.setLookupStatus(Status.warning({\n          message: this.session.text('SmartFieldCannotComplete', result.text),\n          code: SmartField.ErrorCode.NO_RESULTS\n        }));\n        return;\n      }\n\n      var popupStatus = null;\n\n      if (result.numLookupRows > this.browseMaxRowCount) {\n        // Info: we limit the lookup rows here, but this is more a last line of defense\n        // limit should be always performed on the server, so we don't have to transfer\n        // unnecessary lookup rows over the slow network. Make sure your Scout lookup call\n        // or REST service impl. respects the max. row count property.\n        result.lookupRows = result.lookupRows.slice(0, this.browseMaxRowCount);\n        popupStatus = Status.info({\n          message: this.session.text('SmartFieldMoreThanXRows', this.browseMaxRowCount)\n        });\n      } // Render popup, if not yet rendered and set results\n\n\n      this._ensurePopup(result, popupStatus);\n    }\n  }, {\n    key: \"_ensurePopup\",\n    value: function _ensurePopup(result, status) {\n      if (this.popup) {\n        this.popup.setLookupResult(result);\n        this.popup.setStatus(status);\n      } else {\n        this._renderPopup(result, status);\n      }\n    }\n  }, {\n    key: \"_handleException\",\n    value: function _handleException(result) {\n      // Oops! Something went wrong while the lookup has been processed.\n      if (result.exception) {\n        this.setErrorStatus(Status.error({\n          message: result.exception\n        }));\n        this.closePopup();\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_handleEmptyResult\",\n    value: function _handleEmptyResult() {\n      if (this.touchMode || this.activeFilterEnabled) {\n        // In mobile mode we always open the popup, event if we don't have a result\n        // Otherwise it would be impossible to enter text in a proposal field with\n        // an empty proposal list. The same goes for activeFilterEnabled state -\n        // a filter can lead to an empty result (for instance when there are no\n        // inactive proposals), and it's hard to switch to another filter value\n        // when the popup does not show up at all.\n        var emptyResult = {\n          lookupRows: []\n        };\n\n        this._ensurePopup(emptyResult);\n      } else if (this.embedded) {\n        this.popup.clearLookupRows();\n      } else {\n        this.closePopup();\n      }\n    }\n  }, {\n    key: \"_renderPopup\",\n    value: function _renderPopup(result, status) {\n      // On touch devices the field does not get the focus.\n      // But it should look focused when the popup is open.\n      this.$field.addClass('focused');\n      this.$container.addClass('popup-open');\n      var useTouch = this.touchMode && !this.isDropdown();\n      var popupType = useTouch ? 'SmartFieldTouchPopup' : 'SmartFieldPopup';\n      this._pendingOpenPopup = false;\n      this.popup = scout.create(popupType, {\n        parent: this,\n        $anchor: this.$field,\n        boundToAnchor: !useTouch,\n        closeOnAnchorMouseDown: false,\n        field: this,\n        lookupResult: result,\n        status: status\n      });\n      this.popup.open();\n      /* This variable is required to route events to the right field:\n       * - in normal mode popup events should be processed by the normal smart-field\n       * - in touch mode, the field flagged with the 'touch' property should process no\n       *   events at all, instead the field flagged with the 'embedded' property should\n       *   process these events.\n       *\n       * (*1) because the lookup is processed by the field flagged with 'touch' we must\n       *      set the activeFilter on that field too, because the java-model on the server\n       *      is stateful. The java field always passes the activeFilter property to the\n       *      lookup call.\n       */\n\n      var fieldForPopup = useTouch ? this.popup._field : this;\n      this.popup.on('lookupRowSelected', fieldForPopup._onLookupRowSelected.bind(fieldForPopup));\n      this.popup.on('activeFilterSelected', this._onActiveFilterSelected.bind(this)); // intentionally use this instead of fieldForPopup *1\n\n      this.popup.one('remove', function () {\n        this.popup = null;\n\n        if (this.rendered) {\n          this.$container.removeClass('popup-open');\n          this.$field.removeClass('focused');\n\n          this._renderErrorStatus();\n        }\n      }.bind(this));\n    }\n  }, {\n    key: \"closePopup\",\n    value: function closePopup() {\n      this._pendingOpenPopup = false;\n\n      if (this.popup) {\n        this.popup.close();\n      }\n    }\n    /**\n     * Calls acceptInput if mouse down happens outside of the field or popup\n     * @override\n     */\n\n  }, {\n    key: \"aboutToBlurByMouseDown\",\n    value: function aboutToBlurByMouseDown(target) {\n      if (this.touchMode) {\n        return false;\n      }\n\n      if (fields.eventOutsideProposalField(this, target)) {\n        this.acceptInput(true);\n      }\n    }\n  }, {\n    key: \"_onFieldMouseDown\",\n    value: function _onFieldMouseDown(event) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_onFieldMouseDown)');\n      this.activate(true);\n    }\n  }, {\n    key: \"activate\",\n    value: function activate(onField) {\n      if (!this.enabledComputed || !this.rendered) {\n        return;\n      }\n\n      if (!this.isDropdown() && !fields.handleOnClick(this)) {\n        if (this.popup && this.popup.removalPending) {\n          // If smart field is activated while it is closing (during remove animation), wait for the animation to finish and activate it afterwards\n          this.popup.one('remove', function () {\n            if (this.rendered) {\n              this.activate(onField);\n            }\n          }.bind(this));\n        }\n\n        return;\n      } // Don't focus on desktop devices when click is on field #217192\n      // Also required for touch case where field is a DIV and not an INPUT field\n\n\n      if (!onField || Device.get().supportsOnlyTouch()) {\n        this.$field.focus();\n      }\n\n      this.togglePopup();\n    }\n  }, {\n    key: \"_onIconMouseDown\",\n    value: function _onIconMouseDown(event) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_onIconMouseDown)');\n\n      if (!this.enabledComputed) {\n        return;\n      }\n\n      event.preventDefault();\n      this.$field.focus();\n\n      if (!this.embedded) {\n        if (this.isDropdown()) {\n          this.togglePopup();\n        } else if (!this.popup) {\n          this.openPopup(!this.searchRequired);\n        }\n      }\n    }\n  }, {\n    key: \"_onClearIconMouseDown\",\n    value: function _onClearIconMouseDown(event) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_onClearIconMouseDown)');\n\n      if (!this.enabledComputed) {\n        return;\n      }\n\n      event.preventDefault();\n      this.$field.focus();\n      this.clear();\n    }\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      // don't tab next field when user clicks on clear icon (acceptInput is called later)\n      this._tabPrevented = null; // the state of these two flags is important. See #_checkSearchTextChanged\n\n      this._lastSearchText = this._readDisplayText();\n      this._userWasTyping = true;\n      fields.valOrText(this.$field, '');\n\n      if (this.touchMode) {\n        // There is actually no \"x\" the user can press in touch mode, but if the developer calls clear() manually, it should work too.\n        // Because accept input works differently in touch mode we need to explicitly set the value to null\n        this.setValue(null);\n      }\n\n      if (this.isPopupOpen()) {\n        // When cleared, browse by all again, need to do it in setTimeout because sending acceptInput and lookupAll at the same time does not seem to work\n        setTimeout(this._lookupByTextOrAll.bind(this, true));\n      }\n\n      this._updateHasText();\n    }\n  }, {\n    key: \"togglePopup\",\n    value: function togglePopup() {\n      $.log.isInfoEnabled() && $.log.info('(SmartField#togglePopup) popupOpen=', this.isPopupOpen());\n\n      if (this.isPopupOpen()) {\n        this.closePopup();\n      } else {\n        this.openPopup(!this.searchRequired);\n      }\n    }\n  }, {\n    key: \"_onFieldBlur\",\n    value: function _onFieldBlur(event) {\n      this.setFocused(false);\n      this.setLoading(false);\n\n      if (this.isTouchable()) {\n        return;\n      }\n\n      this.acceptInput(false);\n      this.closePopup();\n    }\n    /**\n     * @returns {boolean} true if the field is either 'embedded' or in 'touchMode'.\n     */\n\n  }, {\n    key: \"isTouchable\",\n    value: function isTouchable() {\n      return this.embedded || this.touchMode;\n    }\n  }, {\n    key: \"_onFieldKeyUp\",\n    value: function _onFieldKeyUp(event) {\n      // Escape\n      if (event.which === keys.ESC) {\n        return;\n      } // Pop-ups shouldn't open when one of the following keys is pressed\n\n\n      var w = event.which;\n      var isPaste = (event.ctrlKey || event.metaKey) && w === keys.V || event.shiftKey && w === keys.INSERT;\n      var isCut = (event.ctrlKey || event.metaKey) && w === keys.X || event.shiftKey && w === keys.DELETE;\n      var isCutOrPaste = (isPaste || isCut) && !this.isDropdown();\n\n      if (!isCutOrPaste && (event.ctrlKey || event.altKey || event.metaKey || w === keys.ENTER || w === keys.TAB || w === keys.SHIFT || w === keys.CTRL || w === keys.ALT || w === keys.HOME || w === keys.END || w === keys.LEFT || w === keys.RIGHT || w === keys.WIN_LEFT || w === keys.WIN_RIGHT || w === keys.SELECT || w === keys.NUM_LOCK || w === keys.CAPS_LOCK || w === keys.SCROLL_LOCK || w === keys.PAUSE || w === keys.PRINT_SCREEN || this._isNavigationKey(event) || this._isFunctionKey(event))) {\n        return;\n      } // The typed character is not available until the keyUp event happens\n      // That's why we must deal with that event here (and not in keyDown)\n      // We don't use _displayText() here because we always want the text the\n      // user has typed.\n\n\n      this._handleInput();\n    }\n  }, {\n    key: \"_handleInput\",\n    value: function _handleInput() {\n      if (this._pendingOpenPopup || this.isPopupOpen()) {\n        if (!this.isDropdown()) {\n          this._lookupByTextOrAll();\n        }\n      } else if (!this._pendingOpenPopup) {\n        this.openPopup();\n      }\n    }\n  }, {\n    key: \"isPopupOpen\",\n    value: function isPopupOpen() {\n      return !!(this.popup && !this.popup.removalPending);\n    }\n  }, {\n    key: \"_onFieldKeyDown\",\n    value: function _onFieldKeyDown(event) {\n      this._updateUserWasTyping(event); // We must prevent default focus handling\n\n\n      if (event.which === keys.TAB) {\n        if (this.mode === FormField.Mode.DEFAULT) {\n          event.preventDefault(); // prevent browser default TAB behavior\n\n          event.stopPropagation(); // prevent FocusContext#._onKeyDown\n\n          $.log.isDebugEnabled() && $.log.debug('(SmartField#_onFieldKeyDown) set _tabPrevented');\n          this._tabPrevented = {\n            shiftKey: event.shiftKey\n          };\n        }\n\n        this.acceptInput();\n        return;\n      }\n\n      if (event.which === keys.ENTER) {\n        this._handleEnterKey(event);\n\n        return;\n      } // For dropdowns, not only navigation keys trigger the popup (see code below).\n      // However, there are still some exceptions that should be ignored:\n\n\n      var w = event.which;\n\n      if (this.isDropdown() && (event.ctrlKey || event.altKey || event.metaKey || w === keys.ESC || w === keys.SHIFT || w === keys.CTRL || w === keys.ALT || w === keys.WIN_LEFT || w === keys.WIN_RIGHT || w === keys.SELECT || w === keys.NUM_LOCK || w === keys.CAPS_LOCK || w === keys.SCROLL_LOCK || w === keys.PAUSE || w === keys.PRINT_SCREEN || this._isFunctionKey(event))) {\n        return;\n      } // If field has dropdown style, we open the popup immediately\n      // because we must not wait until text has been typed\n\n\n      if (this._isNavigationKey(event) || this.isDropdown()) {\n        if (this.isPopupOpen()) {\n          this.popup.delegateKeyEvent(event);\n        } else if (!this._pendingOpenPopup) {\n          this.openPopup(!this.searchRequired);\n        }\n\n        event.stopPropagation(); // key has been handled (popup open). do not allow propagation to other listeners because this could remove tooltips\n\n        event.preventDefault(); // prevent scrolling of container\n      }\n    }\n  }, {\n    key: \"_onFieldInput\",\n    value: function _onFieldInput() {\n      this._updateHasText(); // Handling for undo/redo events which can affect this field, even tough the focus is on another field\n      // we must have the focus, because otherwise acceptInput would be skipped, which could cause the smart-field\n      // to have an invalid displayText which does not reflect the current value. #246765\n      //\n      // We cannot fix this problem on IE 11, because IE 11 triggers the INPUT event by error when DOM attributes\n      // like 'placeholder' change. Since we have no way to detect these false events, we must skip the undo/redo\n      // handling. See: https://github.com/vuejs/vue/issues/7138\n\n\n      if (Device.get().isInternetExplorer()) {\n        return;\n      }\n\n      if (!this._userWasTyping) {\n        if (!this.isFocused()) {\n          this.focus();\n        }\n\n        this._handleInput();\n      }\n    }\n  }, {\n    key: \"_updateUserWasTyping\",\n    value: function _updateUserWasTyping(event) {\n      var w = event.which;\n      var isPaste = (event.ctrlKey || event.metaKey) && w === keys.V || event.shiftKey && w === keys.INSERT;\n      var isCut = (event.ctrlKey || event.metaKey) && w === keys.X || event.shiftKey && w === keys.DELETE;\n      var isCutOrPaste = (isPaste || isCut) && !this.isDropdown();\n\n      if (!isCutOrPaste && (event.ctrlKey || event.altKey || event.metaKey || w === keys.ESC || w === keys.TAB || w === keys.SHIFT || w === keys.CTRL || w === keys.ALT || w === keys.HOME || w === keys.END || w === keys.LEFT || w === keys.RIGHT || w === keys.WIN_LEFT || w === keys.WIN_RIGHT || w === keys.SELECT || w === keys.NUM_LOCK || w === keys.CAPS_LOCK || w === keys.SCROLL_LOCK || w === keys.PAUSE || w === keys.PRINT_SCREEN || this._isFunctionKey(event))) {\n        // neutral, don't change flag\n        return;\n      }\n\n      this._userWasTyping = !(this._isNavigationKey(event) || w === keys.ENTER);\n    }\n  }, {\n    key: \"_isNavigationKey\",\n    value: function _isNavigationKey(event) {\n      var navigationKeys = [keys.PAGE_UP, keys.PAGE_DOWN, keys.UP, keys.DOWN];\n\n      if (this.isDropdown()) {\n        navigationKeys.push(keys.HOME);\n        navigationKeys.push(keys.END);\n      }\n\n      return scout.isOneOf(event.which, navigationKeys);\n    }\n  }, {\n    key: \"_handleEnterKey\",\n    value: function _handleEnterKey(event) {\n      if (this.isPopupOpen()) {\n        this.popup.selectLookupRow();\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"_isFunctionKey\",\n    value: function _isFunctionKey(event) {\n      return event.which >= keys.F1 && event.which <= keys.F12;\n    }\n  }, {\n    key: \"_onLookupRowSelected\",\n    value: function _onLookupRowSelected(event) {\n      // When a row has been selected in the proposal chooser, cancel all\n      // pending and running lookup-calls. This avoids situations where the\n      // lookup-call returns with results after the user has pressed the\n      // enter key in order to select a result (see ticket #229775).\n      this._clearPendingLookup();\n\n      var currentLookupCall = this.original()._currentLookupCall;\n\n      if (currentLookupCall) {\n        currentLookupCall.abort();\n        this.original()._currentLookupCall = null;\n        this.setLoading(false);\n      }\n\n      this.setLookupRow(event.lookupRow);\n\n      this._inputAccepted();\n\n      this.closePopup();\n    }\n    /**\n     * When the user changes the active-filter we must always perform a new search. When the user has typed a searchText\n     * we must perform a lookupByText. When the searchText is empty or different from the text of the selected lookup-row\n     * we are in browse mode where we use the default given by the 'searchRequired' property. See: #237229.\n     */\n\n  }, {\n    key: \"_onActiveFilterSelected\",\n    value: function _onActiveFilterSelected(event) {\n      this.setActiveFilter(event.activeFilter);\n      var browse = !this.searchRequired;\n\n      var searchText = this._readSearchText();\n\n      if (this.lookupRow) {\n        if (this.lookupRow.text !== searchText) {\n          browse = false;\n        }\n      } else if (strings.hasText(searchText)) {\n        browse = false;\n      }\n\n      this._lookupByTextOrAll(browse, searchText, true);\n    }\n  }, {\n    key: \"setBrowseMaxRowCount\",\n    value: function setBrowseMaxRowCount(browseMaxRowCount) {\n      this.setProperty('browseMaxRowCount', browseMaxRowCount);\n    }\n  }, {\n    key: \"setBrowseAutoExpandAll\",\n    value: function setBrowseAutoExpandAll(browseAutoExpandAll) {\n      this.setProperty('browseAutoExpandAll', browseAutoExpandAll);\n    }\n  }, {\n    key: \"setBrowseLoadIncremental\",\n    value: function setBrowseLoadIncremental(browseLoadIncremental) {\n      this.setProperty('browseLoadIncremental', browseLoadIncremental);\n\n      if (this.lookupCall) {\n        // change template here. Will be used on the next clone\n        this.lookupCall.setLoadIncremental(browseLoadIncremental);\n      }\n    }\n  }, {\n    key: \"setActiveFilter\",\n    value: function setActiveFilter(activeFilter) {\n      this.setProperty('activeFilter', this.activeFilterEnabled ? activeFilter : null);\n    }\n  }, {\n    key: \"setActiveFilterEnabled\",\n    value: function setActiveFilterEnabled(activeFilterEnabled) {\n      this.setProperty('activeFilterEnabled', activeFilterEnabled);\n    }\n  }, {\n    key: \"setInitActiveFilter\",\n    value: function setInitActiveFilter(initActiveFilter) {\n      this.setProperty('initActiveFilter', initActiveFilter);\n    }\n  }, {\n    key: \"setSearchRequired\",\n    value: function setSearchRequired(searchRequired) {\n      this.setProperty('searchRequired', searchRequired);\n    }\n    /**\n     * A wrapper function around lookup calls used to display the state in the UI.\n     */\n\n  }, {\n    key: \"_executeLookup\",\n    value: function _executeLookup(lookupCall, abortExisting) {\n      this.lookupSeqNo++;\n      this.setLoading(true);\n\n      var currentLookupCall = this.original()._currentLookupCall;\n\n      if (abortExisting && currentLookupCall) {\n        currentLookupCall.abort();\n      }\n\n      this.original()._currentLookupCall = lookupCall;\n      this.trigger('prepareLookupCall', {\n        lookupCall: lookupCall\n      });\n      return lookupCall.execute().always(function () {\n        this.original()._currentLookupCall = null;\n        this.setLoading(false);\n\n        this._clearLookupStatus();\n\n        this._clearNoResultsErrorStatus();\n      }.bind(this));\n    }\n    /**\n     * Reset error status NO_RESULTS when a lookup is performed, otherwise it would interfere with the\n     * temporary lookupStatus and we'd see an out-dated error-status message while the user is typing.\n     */\n\n  }, {\n    key: \"_clearNoResultsErrorStatus\",\n    value: function _clearNoResultsErrorStatus() {\n      if (this.isTouchable()) {\n        return;\n      }\n\n      if (this._userWasTyping && this.errorStatus && this.errorStatus.code === SmartField.ErrorCode.NO_RESULTS) {\n        this.setErrorStatus(null);\n      }\n    }\n    /**\n     * Returns true if the smart-field lookup returns a lot of rows. In that case\n     * the proposal chooser must create a table with virtual scrolling, which means\n     * only the rows visible in the UI are rendered in the DOM. By default we render\n     * all rows, since this avoids problems with layout-invalidation with rows\n     * that have a bitmap-image (PNG) which is loaded asynchronously.\n     */\n\n  }, {\n    key: \"virtual\",\n    value: function virtual() {\n      return this.browseMaxRowCount > SmartField.DEFAULT_BROWSE_MAX_COUNT;\n    }\n  }, {\n    key: \"isDropdown\",\n    value: function isDropdown() {\n      return this.displayStyle === SmartField.DisplayStyle.DROPDOWN;\n    }\n  }, {\n    key: \"_setLookupRow\",\n    value: function _setLookupRow(lookupRow) {\n      // remove css classes from old lookup-row\n      if (this.lookupRow) {\n        this.removeCssClass(this.lookupRow.cssClass);\n      }\n\n      this._setProperty('lookupRow', lookupRow); // add css classes from new lookup-row\n\n\n      if (lookupRow) {\n        this.addCssClass(lookupRow.cssClass);\n      }\n    }\n  }, {\n    key: \"setLookupRow\",\n    value: function setLookupRow(lookupRow) {\n      if (this.lookupRow === lookupRow) {\n        return;\n      }\n\n      this._notUnique = false;\n      this.clearErrorStatus();\n\n      this._setLookupRow(lookupRow); // this flag is required so lookup row is not changed again, when _setValue is called\n\n\n      this._lockLookupRow = true;\n\n      if (lookupRow) {\n        this.setValue(this._getValueFromLookupRow(lookupRow));\n      } else {\n        this.setValue(null);\n      }\n\n      this._lockLookupRow = false; // In case we have a value X set, start to type search text, and then choose the lookup\n      // row from the proposal with exactly the same value X, setValue() does nothing because\n      // the value has not changed (even though the display text has) thus _formatValue is\n      // never called. That's why we always reset the display text to make sure the display\n      // text is correct.\n\n      this.resetDisplayText();\n    }\n  }, {\n    key: \"setDisplayText\",\n    value: function setDisplayText(displayText) {\n      _get(_getPrototypeOf(SmartField.prototype), \"setDisplayText\", this).call(this, displayText);\n\n      this._userWasTyping = false;\n    }\n  }, {\n    key: \"resetDisplayText\",\n    value: function resetDisplayText() {\n      var returned = this.formatValue(this.value);\n\n      if (returned && $.isFunction(returned.promise)) {\n        // Promise is returned -> set display text later\n        returned.done(this._setAndRenderDisplayText.bind(this)).fail(function () {\n          $.log.isInfoEnabled() && $.log.info('Could not resolve display text for value: ' + this.value);\n        }.bind(this));\n      } else {\n        this._setAndRenderDisplayText(returned);\n      }\n    }\n    /**\n     * This method is very similar to setDisplayText(), but does _not_ check for equality with\n     * the current value. The property is always set and (if the field is rendered) the given\n     * display text is always rendered. This is important when resetting the display text,\n     * because the visible text in the input field may differ from the \"displayText\" property\n     * value. If setDisplayText() was used, the visible text would not always be reset.\n     */\n\n  }, {\n    key: \"_setAndRenderDisplayText\",\n    value: function _setAndRenderDisplayText(displayText) {\n      this._setProperty('displayText', displayText);\n\n      if (this.rendered) {\n        this._renderDisplayText();\n      }\n    }\n  }, {\n    key: \"_getValueFromLookupRow\",\n    value: function _getValueFromLookupRow(lookupRow) {\n      return lookupRow.key;\n    }\n  }, {\n    key: \"_setValue\",\n    value: function _setValue(value) {\n      // set the cached lookup row to null. Keep in mind that the lookup row is set async in a timeout\n      // must of the time. Thus we must remove the reference to the old lookup row as early as possible\n      if (!this._lockLookupRow) {\n        if (objects.isNullOrUndefined(value)) {\n          // when value is set to null, we must also reset the cached lookup row\n          this._setLookupRow(null);\n        } else {\n          // when a value is set, we only keep the cached lookup row when the key of the lookup row is equals to the value\n          if (this._checkResetLookupRow(value)) {\n            this._setLookupRow(null);\n          }\n        }\n      }\n\n      _get(_getPrototypeOf(SmartField.prototype), \"_setValue\", this).call(this, value);\n\n      this._notUnique = false;\n    }\n    /**\n     * Sub-classes like the proposal field may override this function to implement a different behavior.\n     */\n\n  }, {\n    key: \"_checkResetLookupRow\",\n    value: function _checkResetLookupRow(value) {\n      return this.lookupRow && this.lookupRow.key !== value;\n    }\n    /**\n     * This function may be overridden to return another value than this.value.\n     * For instance the proposal field does'nt use the value but the key from the\n     * lookup row for comparison.\n     *\n     * @returns {*} the value used to find the selected element in a proposal chooser.\n     */\n\n  }, {\n    key: \"getValueForSelection\",\n    value: function getValueForSelection() {\n      return this._showSelection() ? this.value : null;\n    }\n  }, {\n    key: \"_showSelection\",\n    value: function _showSelection() {\n      if (objects.isNullOrUndefined(this.value) || objects.isNullOrUndefined(this.lookupRow)) {\n        return false;\n      }\n\n      var text;\n\n      if (this.rendered) {\n        // check if text matches (deal with multi-line)\n        text = this._readDisplayText();\n        var additionalLines = this.additionalLines();\n\n        if (additionalLines) {\n          text = [text].concat(additionalLines).join('\\n');\n        }\n      } else {\n        text = this.displayText;\n      }\n\n      return text === this.lookupRow.text;\n    }\n    /**\n     * override to ensure dropdown fields and touch mode smart fields does not have a clear icon.\n     */\n\n  }, {\n    key: \"isClearable\",\n    value: function isClearable() {\n      return _get(_getPrototypeOf(SmartField.prototype), \"isClearable\", this).call(this) && !this.isDropdown() && !this.touchMode;\n    }\n  }, {\n    key: \"_triggerLookupCallDone\",\n    value: function _triggerLookupCallDone(result) {\n      this.trigger('lookupCallDone', {\n        result: result\n      });\n      return result;\n    }\n  }, {\n    key: \"_triggerAcceptInputFail\",\n    value: function _triggerAcceptInputFail() {\n      this._triggerAcceptInput(false, true);\n    }\n  }, {\n    key: \"_triggerAcceptInput\",\n    value: function _triggerAcceptInput(acceptByLookupRow, failure) {\n      this.trigger('acceptInput', {\n        displayText: this.displayText,\n        errorStatus: this.errorStatus,\n        value: this.value,\n        lookupRow: this.lookupRow,\n        acceptByLookupRow: scout.nvl(acceptByLookupRow, true),\n        failure: scout.nvl(failure, false)\n      });\n    }\n  }, {\n    key: \"_triggerAcceptByText\",\n    value: function _triggerAcceptByText(searchText) {\n      this.trigger('acceptByText', {\n        searchText: searchText,\n        errorStatus: this.errorStatus\n      });\n    }\n    /**\n     * Function invoked if being rendered within a cell-editor (mode='scout.FormField.Mode.CELLEDITOR'), and once the editor finished its rendering.\n     */\n\n  }, {\n    key: \"onCellEditorRendered\",\n    value: function onCellEditorRendered(options) {\n      if (options.openFieldPopup) {\n        this._cellEditorPopup = options.cellEditorPopup;\n        this.openPopup(!this.searchRequired);\n      }\n    }\n  }, {\n    key: \"additionalLines\",\n    value: function additionalLines() {\n      var text = scout.nvl(this.displayText, ''),\n          textLines = text.split('\\n');\n\n      if (textLines.length > 1) {\n        textLines.shift();\n        return textLines;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_createLoadingSupport\",\n    value: function _createLoadingSupport() {\n      return new SimpleLoadingSupport({\n        widget: this,\n        loadingIndicatorDelay: 400 // ms\n\n      });\n    }\n    /**\n     * @override FormField.js\n     */\n\n  }, {\n    key: \"_isInitialShowStatus\",\n    value: function _isInitialShowStatus() {\n      if (this.touchMode && (this._pendingOpenPopup || this.isPopupOpen())) {\n        // Do not display a tooltip if the touch popup is open, the tooltip will be displayed there\n        return false;\n      }\n\n      return _get(_getPrototypeOf(SmartField.prototype), \"_isInitialShowStatus\", this).call(this);\n    }\n    /**\n     * In touch mode, we must close the cell editor popup explicitly, because the touch-popup and its glasspane\n     * prevents the cell editor popup from receiving mouse down events.\n     */\n\n  }, {\n    key: \"acceptInputFromField\",\n    value: function acceptInputFromField(otherField) {\n      this._copyValuesFromField(otherField);\n\n      if (this._cellEditorPopup) {\n        // this will call acceptInput on the touch smart-field (== this)\n        this._cellEditorPopup.completeEdit();\n\n        this._cellEditorPopup = null;\n      } else {\n        this.acceptInput();\n      }\n    }\n    /**\n     * This function is overridden by ProposalField because it has a different behavior than the smart-field.\n     */\n\n  }, {\n    key: \"_copyValuesFromField\",\n    value: function _copyValuesFromField(otherField) {\n      if (this.lookupRow !== otherField.lookupRow) {\n        this.setLookupRow(otherField.lookupRow);\n      }\n\n      this.setErrorStatus(otherField.errorStatus);\n      this.setDisplayText(otherField.displayText);\n    }\n  }, {\n    key: \"_setNotUniqueError\",\n    value: function _setNotUniqueError(searchText) {\n      this.setErrorStatus(Status.error({\n        message: this.session.text('SmartFieldNotUnique', searchText),\n        code: SmartField.ErrorCode.NOT_UNIQUE\n      }));\n    }\n  }, {\n    key: \"_hasNotUniqueError\",\n    value: function _hasNotUniqueError(searchText) {\n      return this._notUnique || this._hasUiError(SmartField.ErrorCode.NOT_UNIQUE);\n    }\n  }, {\n    key: \"_errorStatus\",\n    value: function _errorStatus() {\n      return this.lookupStatus || this.errorStatus;\n    }\n  }, {\n    key: \"setLookupStatus\",\n    value: function setLookupStatus(lookupStatus) {\n      this.setProperty('lookupStatus', lookupStatus);\n\n      if (this.rendered) {\n        this._renderErrorStatus();\n      }\n    }\n  }, {\n    key: \"clearErrorStatus\",\n    value: function clearErrorStatus() {\n      this.setErrorStatus(null);\n\n      this._clearLookupStatus();\n    }\n  }, {\n    key: \"_clearLookupStatus\",\n    value: function _clearLookupStatus() {\n      this.setLookupStatus(null);\n    }\n    /**\n     * Checks if there is a lookup status that needs to be set as error status\n     * before we leave the smart-field. The lookup status is set to null, because\n     * it is a temporary state that is only important while the user executes a lookup.\n     */\n\n  }, {\n    key: \"_flushLookupStatus\",\n    value: function _flushLookupStatus() {\n      if (!this.lookupStatus) {\n        return;\n      }\n\n      if (this.lookupStatus.code === SmartField.ErrorCode.NO_RESULTS || this.lookupStatus.code === SmartField.ErrorCode.NOT_UNIQUE) {\n        var errorStatus = this.lookupStatus.clone();\n        errorStatus.severity = Status.Severity.ERROR;\n        this.setErrorStatus(errorStatus);\n      }\n\n      this._clearLookupStatus();\n    }\n  }, {\n    key: \"requestInput\",\n    value: function requestInput() {\n      if (this.enabledComputed && this.rendered) {\n        this.focus();\n        this.openPopup(!this.searchRequired);\n      }\n    }\n  }]);\n\n  return SmartField;\n}(ValueField);\n\n_defineProperty(SmartField, \"DisplayStyle\", {\n  DEFAULT: 'default',\n  DROPDOWN: 'dropdown'\n});\n\n_defineProperty(SmartField, \"ErrorCode\", {\n  NOT_UNIQUE: 1,\n  NO_RESULTS: 2,\n  NO_DATA: 3,\n  SEARCH_REQUIRED: 4\n});\n\n_defineProperty(SmartField, \"DEBOUNCE_DELAY\", 200);\n\n_defineProperty(SmartField, \"DEFAULT_BROWSE_MAX_COUNT\", 100);\n\n_defineProperty(SmartField, \"ACTIVE_FILTER_VALUES\", ['UNDEFINED', 'FALSE', 'TRUE']);\n\nexport { SmartField as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/form/fields/smartfield/SmartField.js"],"names":["arrays","Device","fields","FormField","InputFieldKeyStrokeContext","keys","LookupCall","objects","QueryBy","scout","SimpleLoadingSupport","SmartFieldCancelKeyStroke","SmartFieldLayout","Status","strings","ValueField","$","SmartField","popup","lookupCall","codeType","_pendingLookup","_pendingOpenPopup","_tabPrevented","lookupRow","browseHierarchy","browseMaxRowCount","DEFAULT_BROWSE_MAX_COUNT","browseAutoExpandAll","browseLoadIncremental","searchRequired","activeFilterEnabled","activeFilter","activeFilterLabels","columnDescriptors","displayStyle","DisplayStyle","DEFAULT","touchMode","embedded","_userWasTyping","_acceptInputEnabled","_acceptInputDeferred","Deferred","_notUnique","_lastSearchText","lookupStatus","_currentLookupCall","lookupSeqNo","initActiveFilter","disabledCopyOverlay","_addCloneProperties","model","length","session","text","initTouch","value","_setLookupCall","_setCodeType","_setLookupRow","setInitActiveFilter","setActiveFilter","keyStrokeContext","registerKeyStroke","addContainer","$parent","cssClassName","addLabel","fieldFunc","isDropdown","makeInputDiv","makeInputOrDiv","$field","call","on","_onFieldMouseDown","bind","keyup","_onFieldKeyUp","keydown","_onFieldKeyDown","_onFieldInput","addField","addMandatoryIndicator","addIcon","$icon","addClass","addStatus","updateInnerAlignment","useHorizontalAlignment","prefix","fieldText","_readDisplayText","displayText","nvl","textLines","split","empty","shift","insert","join","valOrText","sync","log","isTraceEnabled","trace","promise","setTimeout","searchText","_readSearchText","searchTextEmpty","searchTextChanged","_checkSearchTextChanged","selectedLookupRow","_getSelectedLookupRow","_setProperty","_flushLookupStatus","_clearPendingLookup","isDebugEnabled","debug","_inputAccepted","_acceptInput","isPopupOpen","lookupResult","seqNo","getSelectedLookupRow","_searchTextEquals","lastSearchText","a","nullIfEmpty","_firstTextLine","b","equalsIgnoreCase","clearTimeout","lookupRowText","_clearLookupStatus","_setNotUniqueError","errorStatus","code","ErrorCode","NO_RESULTS","clearErrorStatus","setLookupRow","toString","_acceptByText","_hasUiError","_hasNotUniqueError","selectFirstLookupRow","resolve","_acceptByTextSync","_acceptByTextAsync","resetDisplayText","_executeLookup","cloneForText","done","_acceptByTextDone","_triggerLookupCallDone","_triggerAcceptByText","triggerEvent","acceptByLookupRow","closePopup","_triggerAcceptInput","_focusNextTabbable","$tabElements","entryPoint","find","direction","shiftKey","fieldIndex","index","nextIndex","$nextElement","eq","focus","isFunction","select","result","_extendResult","numLookupRows","uniqueMatch","_isLookupRowActive","setErrorStatus","error","message","_acceptInputFail","propertyName","toUpperCaseFirstLetter","queryBy","toLowerCase","proposalChooser","create","parent","smartField","setLookupResult","leafs","findLeafs","lookupRows","setValue","setDisplayText","_lookupByTextOrAllDone","_triggerAcceptInputFail","rec","cloneForRec","then","appendResult","enabled","active","setTabbable","enabledComputed","setProperty","ensure","isNullOrUndefined","_formatLookupRow","cloneForKey","_lookupByKeyDone","firstLookupRow","browse","searchAlways","isInfoEnabled","info","_lookupByTextOrAll","codes","status","_errorStatus","NOT_UNIQUE","statusList","asFlatList","foundCodes","reduce","list","indexOf","push","some","_getLastSearchText","deferred","doneHandler","TEXT","setLookupStatus","warning","SEARCH_REQUIRED","cloneForAll","DEBOUNCE_DELAY","optProperty","byAll","_handleException","rendered","isFocused","isTouchable","_ensurePopup","NO_DATA","_handleEmptyResult","popupStatus","slice","setStatus","_renderPopup","exception","emptyResult","clearLookupRows","$container","useTouch","popupType","$anchor","boundToAnchor","closeOnAnchorMouseDown","field","open","fieldForPopup","_field","_onLookupRowSelected","_onActiveFilterSelected","one","removeClass","_renderErrorStatus","close","target","eventOutsideProposalField","acceptInput","event","activate","onField","handleOnClick","removalPending","get","supportsOnlyTouch","togglePopup","preventDefault","openPopup","clear","_updateHasText","setFocused","setLoading","which","ESC","w","isPaste","ctrlKey","metaKey","V","INSERT","isCut","X","DELETE","isCutOrPaste","altKey","ENTER","TAB","SHIFT","CTRL","ALT","HOME","END","LEFT","RIGHT","WIN_LEFT","WIN_RIGHT","SELECT","NUM_LOCK","CAPS_LOCK","SCROLL_LOCK","PAUSE","PRINT_SCREEN","_isNavigationKey","_isFunctionKey","_handleInput","_updateUserWasTyping","mode","Mode","stopPropagation","_handleEnterKey","delegateKeyEvent","isInternetExplorer","navigationKeys","PAGE_UP","PAGE_DOWN","UP","DOWN","isOneOf","selectLookupRow","F1","F12","currentLookupCall","original","abort","hasText","setLoadIncremental","abortExisting","trigger","execute","always","_clearNoResultsErrorStatus","DROPDOWN","removeCssClass","cssClass","addCssClass","_lockLookupRow","_getValueFromLookupRow","returned","formatValue","_setAndRenderDisplayText","fail","_renderDisplayText","key","_checkResetLookupRow","_showSelection","additionalLines","concat","failure","options","openFieldPopup","_cellEditorPopup","cellEditorPopup","widget","loadingIndicatorDelay","otherField","_copyValuesFromField","completeEdit","clone","severity","Severity","ERROR"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  arrays,\n  Device,\n  fields,\n  FormField,\n  InputFieldKeyStrokeContext,\n  keys,\n  LookupCall,\n  objects,\n  QueryBy,\n  scout,\n  SimpleLoadingSupport,\n  SmartFieldCancelKeyStroke,\n  SmartFieldLayout,\n  Status,\n  strings,\n  ValueField\n} from '../../../index';\nimport $ from 'jquery';\n\nexport default class SmartField extends ValueField {\n\n  constructor() {\n    super();\n\n    this.popup = null;\n    this.lookupCall = null;\n    this.codeType = null;\n    this._pendingLookup = null;\n    this._pendingOpenPopup = false;\n    this._tabPrevented = null;\n    this.lookupRow = null;\n    this.browseHierarchy = false;\n    this.browseMaxRowCount = SmartField.DEFAULT_BROWSE_MAX_COUNT;\n    this.browseAutoExpandAll = true;\n    this.browseLoadIncremental = false;\n    this.searchRequired = false;\n    this.activeFilterEnabled = false;\n    this.activeFilter = null;\n    this.activeFilterLabels = [];\n    this.columnDescriptors = null;\n    this.displayStyle = SmartField.DisplayStyle.DEFAULT;\n    this.touchMode = false;\n    this.embedded = false;\n    this._userWasTyping = false; // used to detect whether the last thing the user did was typing (a proposal) or something else, like selecting a proposal row\n    this._acceptInputEnabled = true; // used to prevent multiple execution of blur/acceptInput\n    this._acceptInputDeferred = $.Deferred();\n    this._notUnique = false; // used to store the error state 'not unique' which must not be showed while typing, but when the field loses focus\n    this._lastSearchText = null;\n    this.lookupStatus = null;\n    this._currentLookupCall = null; // should only be accessed on the original widget since the adapter accesses it\n    this.lookupSeqNo = 0; // used to detect if the proposal chooser contains the results of the latest lookup, or an out-dated result.\n    // only when the result is up-to-date, we can use the selected lookup row\n    this.initActiveFilter = null;\n    this.disabledCopyOverlay = true;\n\n    this._addCloneProperties(['lookupRow', 'codeType', 'lookupCall', 'activeFilter', 'activeFilterEnabled', 'activeFilterLabels',\n      'browseHierarchy', 'browseMaxRowCount', 'browseAutoExpandAll', 'browseLoadIncremental', 'searchRequired', 'columnDescriptors',\n      'displayStyle'\n    ]);\n  }\n\n  static DisplayStyle = {\n    DEFAULT: 'default',\n    DROPDOWN: 'dropdown'\n  };\n\n  static ErrorCode = {\n    NOT_UNIQUE: 1,\n    NO_RESULTS: 2,\n    NO_DATA: 3,\n    SEARCH_REQUIRED: 4\n  };\n\n  static DEBOUNCE_DELAY = 200;\n\n  static DEFAULT_BROWSE_MAX_COUNT = 100;\n\n  /**\n   * @see \"IContentAssistField#getActiveFilterLabels()\" - should have the same order.\n   */\n  static ACTIVE_FILTER_VALUES = ['UNDEFINED', 'FALSE', 'TRUE'];\n\n  _init(model) {\n    super._init(model);\n\n    if (this.activeFilterLabels.length === 0) {\n      this.activeFilterLabels = [\n        this.session.text('ui.All'),\n        this.session.text('ui.Inactive'),\n        this.session.text('ui.Active')\n      ];\n    }\n\n    fields.initTouch(this, model);\n  }\n\n  /**\n   * Initializes lookup call and code type before calling set value.\n   * This cannot be done in _init because the value field would call _setValue first\n   */\n  _initValue(value) {\n    this._setLookupCall(this.lookupCall);\n    this._setCodeType(this.codeType);\n    this._setLookupRow(this.lookupRow);\n    super._initValue(value);\n  }\n\n  markAsSaved() {\n    super.markAsSaved();\n    this.setInitActiveFilter(this.activeFilter);\n  }\n\n  resetValue() {\n    super.resetValue();\n    this.setActiveFilter(this.initActiveFilter);\n  }\n\n  _createKeyStrokeContext() {\n    return new InputFieldKeyStrokeContext();\n  }\n\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n    this.keyStrokeContext.registerKeyStroke(new SmartFieldCancelKeyStroke(this));\n  }\n\n  _render() {\n    this.addContainer(this.$parent, 'has-icon ' + this.cssClassName(), new SmartFieldLayout(this));\n    this.addLabel();\n\n    var fieldFunc = this.isDropdown() ? fields.makeInputDiv : fields.makeInputOrDiv;\n    var $field = fieldFunc.call(scout.fields, this)\n      .on('mousedown', this._onFieldMouseDown.bind(this));\n\n    if (!this.touchMode) {\n      $field\n        .keyup(this._onFieldKeyUp.bind(this))\n        .keydown(this._onFieldKeyDown.bind(this))\n        .on('input', this._onFieldInput.bind(this));\n    }\n    this.addField($field);\n\n    if (!this.embedded) {\n      this.addMandatoryIndicator();\n    }\n    this.addIcon();\n    this.$icon.addClass('needsclick');\n    this.addStatus();\n  }\n\n  _renderGridData() {\n    super._renderGridData();\n    this.updateInnerAlignment({\n      useHorizontalAlignment: (this.browseHierarchy ? false : true)\n    });\n  }\n\n  _renderGridDataHints() {\n    super._renderGridDataHints();\n    this.updateInnerAlignment({\n      useHorizontalAlignment: (this.browseHierarchy ? false : true)\n    });\n  }\n\n  cssClassName() {\n    var prefix = this.displayStyle;\n    if (this.displayStyle === SmartField.DisplayStyle.DEFAULT) {\n      prefix = 'smart';\n    }\n    return prefix + '-field';\n  }\n\n  _readSearchText() {\n    var fieldText = this._readDisplayText(),\n      displayText = scout.nvl(this.displayText, ''),\n      textLines = displayText.split('\\n');\n\n    if (textLines.length === 1 || strings.empty(fieldText)) {\n      return fieldText;\n    }\n    textLines.shift(); // remove first line\n    arrays.insert(textLines, fieldText, 0);\n    return strings.join('\\n', textLines);\n  }\n\n  _readDisplayText() {\n    return fields.valOrText(this.$field);\n  }\n\n  _renderDisplayText() {\n    var displayText = scout.nvl(this.displayText, ''),\n      textLines = displayText.split('\\n');\n    if (textLines.length) {\n      displayText = textLines[0];\n    }\n    fields.valOrText(this.$field, displayText);\n    super._renderDisplayText();\n  }\n\n  /**\n   * Accepts the selected lookup row and sets its id as value.\n   * This function is called on blur, by a keystroke or programmatically at any time.\n   *\n   * @param [sync] optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search\n   */\n  acceptInput(sync) {\n    if (!this._acceptInputEnabled) {\n      $.log.isTraceEnabled() && $.log.trace('(SmartField#acceptInput) Skipped acceptInput because _acceptInputEnabled=false');\n      return this._acceptInputDeferred.promise();\n    }\n\n    // Use a timeout to prevent multiple execution within the same user action\n    this._acceptInputEnabled = false;\n    setTimeout(function() {\n      this._acceptInputEnabled = true;\n    }.bind(this));\n\n    var\n      searchText = this._readSearchText(),\n      searchTextEmpty = strings.empty(searchText),\n      searchTextChanged = this._checkSearchTextChanged(searchText),\n      selectedLookupRow = this._getSelectedLookupRow(searchTextChanged);\n\n    this._setProperty('displayText', searchText);\n    this._acceptInputDeferred = $.Deferred();\n    this._flushLookupStatus();\n    this._clearPendingLookup();\n\n    if (this.touchMode) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#acceptInput) Always send acceptInput for touch field');\n      this._inputAccepted();\n      return;\n    }\n\n    return this._acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow);\n  }\n\n  /**\n   * This function is used to determine if the currently selected lookup row can be\n   * used when acceptInput is called. Basically we don't want to use the row in case\n   * the result is out-dated.\n   */\n  _getSelectedLookupRow(searchTextChanged) {\n    // don't use selected lookup row if...\n    if (!this.isPopupOpen() || // 1. popup has been closed\n      (searchTextChanged && this._userWasTyping)) { // 2. search text has changed and user was typing\n      return null;\n    }\n    // 3. if the result row is from an out-dated result\n    return this.lookupSeqNo === this.popup.lookupResult.seqNo ?\n      this.popup.getSelectedLookupRow() : null;\n  }\n\n  _checkSearchTextChanged(searchText) {\n    if (this.isDropdown() || !this._userWasTyping) {\n      return false; // search text cannot change in drop-down fields\n    }\n\n    // check if search text has changed since the last search, when it has changed\n    // we cannot use the currently selected lookup row, because these proposals are\n    // out-dated.\n    return !this._searchTextEquals(searchText, this._lastSearchText);\n  }\n\n  _searchTextEquals(searchText, lastSearchText) {\n    var a = strings.nullIfEmpty(this._firstTextLine(searchText));\n    var b = strings.nullIfEmpty(lastSearchText);\n    return strings.equalsIgnoreCase(a, b);\n  }\n\n  _clearPendingLookup() {\n    if (this._pendingLookup) {\n      clearTimeout(this._pendingLookup);\n      this._pendingLookup = null;\n    }\n  }\n\n  /**\n   * This function is intended to be overridden. Proposal field has another behavior than the smart field.\n   *\n   * @param [sync] optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search\n   */\n  _acceptInput(sync, searchText, searchTextEmpty, searchTextChanged, selectedLookupRow) {\n\n    // Do nothing when search text is equals to the text of the current lookup row\n    if (!selectedLookupRow && this.lookupRow) {\n      var lookupRowText = strings.nvl(this.lookupRow.text);\n      if (lookupRowText === searchText) {\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) unchanged: text is equals. Close popup');\n        this._clearLookupStatus();\n        this._inputAccepted(false);\n        return;\n      }\n    }\n\n    // Don't show the not-unique error when the search-text becomes empty while typing (see ticket #229775)\n    if (this._notUnique && !searchTextEmpty) {\n      this._setNotUniqueError(searchText);\n    }\n\n    // Do nothing when we don't have a current lookup row and search text is empty\n    // trigger event when search text has changed. This is required for the case where\n    // a field is cleared, and the remote model must be updated (value=null)\n    if (!selectedLookupRow && !this.lookupRow && searchTextEmpty) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) unchanged: text is empty. Close popup');\n      this._clearLookupStatus();\n      if (this.errorStatus && this.errorStatus.code === SmartField.ErrorCode.NO_RESULTS) {\n        // clear the error status from previous search which did not find any results. This error status is no longer valid as we accept the null content here.\n        this.clearErrorStatus();\n      }\n      this._inputAccepted(searchTextChanged || this._userWasTyping);\n      return;\n    }\n\n    // 1.) when search text is empty and no lookup-row is selected, simply set the value to null\n    // Note: here we assume that a current lookup row is set.\n    if (!selectedLookupRow && searchTextEmpty) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) empty. Set lookup-row to null, close popup');\n      this._clearLookupStatus();\n      this.setLookupRow(null);\n      this._inputAccepted();\n      return;\n    }\n\n    // 2.) proposal chooser is open -> use the selected row as value\n    if (selectedLookupRow) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptInput) lookup-row selected. Set lookup-row, close popup lookupRow=', selectedLookupRow.toString());\n      this._clearLookupStatus();\n      this.setLookupRow(selectedLookupRow);\n      this._inputAccepted();\n      return;\n    }\n\n    // 3.) proposal chooser is not open -> try to accept the current display text\n    // this causes a lookup which may fail and open a new proposal chooser (property\n    // change for 'result').\n    if (searchTextChanged || this._userWasTyping) {\n      this._acceptByText(sync, this._firstTextLine(searchText));\n    } else if (!this._hasUiError()) {\n      this._inputAccepted(false);\n    } else if (this._hasNotUniqueError() && this.popup) {\n      // popup has been opened (again) with errorStatus NOT_UNIQUE, and search text is still the same\n      this.popup.selectFirstLookupRow();\n    } else {\n      // even though there's nothing to do, someone could wait for our promise to be resolved\n      this._acceptInputDeferred.resolve();\n    }\n\n    return this._acceptInputDeferred.promise();\n  }\n\n  /**\n   * Required for multiline smart-field. Only use first line of search text for accept by text.\n   * Note: for the regular lookup by text, we use the readDisplayText() function which always\n   * returns a single line. But in acceptInput we need the full search text (=display text + additional\n   * lines) in order to check whether or not the display text has changed, compared to the current\n   * lookup row. That's why we must extract the first line here.\n   */\n  _firstTextLine(text) {\n    if (strings.empty(text)) {\n      return text;\n    }\n    return text.split('\\n')[0];\n  }\n\n  /**\n   * This function is intended to be overridden. Proposal field has another behavior than the smart field.\n   *\n   * @param sync when set to true it's not allowed to start an asynchronous lookup to search by text, the\n   *     current search text is discarded. The flag is set to true in case we click on another field, where\n   *     we must make sure the order of (browser) events is not changed by the lookup that would return _after_\n   *     the events for the clicked field are handled.\n   */\n  _acceptByText(sync, searchText) {\n    sync = scout.nvl(sync, false);\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_acceptByText) sync=' + sync + ' searchText=', searchText);\n\n    if (sync) {\n      this._acceptByTextSync(searchText);\n    } else {\n      this._acceptByTextAsync(searchText);\n    }\n  }\n\n  _acceptByTextSync(searchText) {\n    this._lastSearchText = null;\n    this._inputAccepted();\n    if (!this._hasUiError()) {\n      this.resetDisplayText();\n    }\n  }\n\n  _acceptByTextAsync(searchText) {\n    this._lastSearchText = searchText;\n    this._executeLookup(this.lookupCall.cloneForText(searchText), true)\n      .done(this._acceptByTextDone.bind(this))\n      .done(this._triggerLookupCallDone.bind(this));\n    this._triggerAcceptByText(searchText);\n  }\n\n  _inputAccepted(triggerEvent, acceptByLookupRow) {\n    triggerEvent = scout.nvl(triggerEvent, true);\n    acceptByLookupRow = scout.nvl(acceptByLookupRow, true);\n    // don't close when shown in touch popup (also called when clear() is executed)\n    if (!this.embedded) {\n      this.closePopup();\n    }\n    this._userWasTyping = false;\n    if (triggerEvent) {\n      this._triggerAcceptInput(acceptByLookupRow);\n    }\n    this._focusNextTabbable();\n    this._acceptInputDeferred.resolve();\n  }\n\n  _focusNextTabbable() {\n    if (this._tabPrevented) {\n      var $tabElements = this.entryPoint().find(':tabbable'),\n        direction = this._tabPrevented.shiftKey ? -1 : 1,\n        fieldIndex = $tabElements.index(this.$field),\n        nextIndex = fieldIndex + direction;\n\n      if (nextIndex < 0) {\n        nextIndex = $tabElements.length - 1;\n      } else if (nextIndex >= $tabElements.length) {\n        nextIndex = 0;\n      }\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_inputAccepted) tab-index=' + fieldIndex + ' next tab-index=' + nextIndex);\n      var $nextElement = $tabElements.eq(nextIndex).focus();\n      if (objects.isFunction($nextElement[0].select)) {\n        $nextElement[0].select();\n      }\n      this._tabPrevented = null;\n    }\n  }\n\n  _acceptByTextDone(result) {\n    this._userWasTyping = false;\n    this._extendResult(result);\n    this._notUnique = result.numLookupRows > 1;\n\n    // when there's exactly one result, we accept that lookup row\n    if (result.uniqueMatch) {\n      var lookupRow = result.uniqueMatch;\n      if (this._isLookupRowActive(lookupRow)) {\n        this.setLookupRow(lookupRow);\n        this._inputAccepted();\n      } else {\n        this.setErrorStatus(Status.error({\n          message: this.session.text('SmartFieldInactiveRow', result.text)\n        }));\n      }\n      return;\n    }\n\n    this._acceptInputFail(result);\n  }\n\n  /**\n   * Extends the properties 'uniqueMatch' and 'numLookupRows' on the given result object.\n   * The implementation is different depending on the browseHierarchy property.\n   */\n  _extendResult(result) {\n    result.seqNo = this.lookupSeqNo;\n    result.uniqueMatch = null;\n\n    // Set query type on result, e.g. 'byAll'\n    var propertyName = 'by' + strings.toUpperCaseFirstLetter(result.queryBy.toLowerCase());\n    result[propertyName] = true;\n\n    if (this.browseHierarchy) {\n      // tree (hierarchical)\n      var proposalChooser = scout.create('TreeProposalChooser', {\n        parent: this,\n        smartField: this\n      });\n      proposalChooser.setLookupResult(result);\n      var leafs = proposalChooser.findLeafs();\n      result.numLookupRows = leafs.length;\n      if (result.numLookupRows === 1) {\n        result.uniqueMatch = leafs[0].lookupRow;\n      }\n    } else {\n      // table\n      result.numLookupRows = result.lookupRows.length;\n      if (result.numLookupRows === 1) {\n        result.uniqueMatch = result.lookupRows[0];\n      }\n    }\n\n    result.empty = (result.numLookupRows === 0);\n  }\n\n  _acceptInputFail(result) {\n    var searchText = result.text;\n\n    // in any other case something went wrong\n    if (result.empty) {\n      if (!this.embedded) {\n        this.closePopup();\n      }\n      this.setValue(null);\n      this.setDisplayText(searchText);\n      this.setErrorStatus(Status.error({\n        message: this.session.text('SmartFieldCannotComplete', searchText),\n        code: SmartField.ErrorCode.NO_RESULTS\n      }));\n    }\n\n    if (result.numLookupRows > 1) {\n      this.setValue(null);\n      this.setDisplayText(searchText);\n      this._setNotUniqueError(searchText);\n      if (this.isPopupOpen()) {\n        this.popup.setLookupResult(result);\n      } else {\n        this._lookupByTextOrAllDone(result);\n      }\n      // check again if popup is open yet (might have been opened by _lookupByTextOrAllDone)\n      if (this.isPopupOpen()) {\n        this.popup.selectFirstLookupRow();\n      }\n    }\n\n    this._acceptInputDeferred.resolve();\n    this._triggerAcceptInputFail();\n  }\n\n  lookupByRec(rec) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#lookupByRec) rec=', rec);\n    this._lastSearchText = null;\n    return this._executeLookup(this.lookupCall.cloneForRec(rec))\n      .then(function(result) {\n\n        // Since this function is only used for hierarchical trees we\n        // can simply set the appendResult flag always to true here\n        result.appendResult = true;\n        result.rec = rec;\n\n        if (this.isPopupOpen()) {\n          this.popup.setLookupResult(result);\n        }\n      }.bind(this))\n      .then(this._triggerLookupCallDone.bind(this));\n  }\n\n  /**\n   * Validates the given lookup row is enabled and matches the current activeFilter settings.\n   *\n   * @returns {boolean}\n   */\n  _isLookupRowActive(lookupRow) {\n    if (!lookupRow.enabled) {\n      return false;\n    }\n    if (!this.activeFilterEnabled) {\n      return true;\n    }\n    if (this.activeFilter === 'TRUE') {\n      return lookupRow.active;\n    }\n    if (this.activeFilter === 'FALSE') {\n      return !lookupRow.active;\n    }\n    return true;\n  }\n\n  _renderEnabled() {\n    super._renderEnabled();\n    this.$field.setTabbable(this.enabledComputed);\n  }\n\n  setLookupCall(lookupCall) {\n    this.setProperty('lookupCall', lookupCall);\n  }\n\n  _setLookupCall(lookupCall) {\n    this._setProperty('lookupCall', LookupCall.ensure(lookupCall, this.session));\n  }\n\n  _setCodeType(codeType) {\n    this._setProperty('codeType', codeType);\n    if (!codeType) {\n      return;\n    }\n    var lookupCall = scout.create('CodeLookupCall', {\n      session: this.session,\n      codeType: codeType\n    });\n    this.setProperty('lookupCall', lookupCall);\n  }\n\n  _formatValue(value) {\n    if (objects.isNullOrUndefined(value)) {\n      return '';\n    }\n\n    // we already have a lookup row - Note: in Scout Classic (remote case)\n    // we always end here and don't need to perform a getByKey lookup.\n    if (this.lookupRow) {\n      return this._formatLookupRow(this.lookupRow);\n    }\n\n    // we must do a lookup first to get the display text\n    // Note: this has a side-effect as it sets the property lookupRow on the smart field\n    this._lastSearchText = null;\n    return this._executeLookup(this.lookupCall.cloneForKey(value), true)\n      .then(this._lookupByKeyDone.bind(this))\n      .then(this._triggerLookupCallDone.bind(this));\n  }\n\n  _lookupByKeyDone(result) {\n    this._notUnique = false;\n    var lookupRow = LookupCall.firstLookupRow(result);\n    this.setLookupRow(lookupRow);\n    return this._formatLookupRow(lookupRow);\n  }\n\n  /**\n   * This function is called when we need to format a display text from a given lookup\n   * row. By default the property 'text' is used for that purpose. Override this function\n   * if you need to format different properties from the lookupRow.\n   */\n  _formatLookupRow(lookupRow) {\n    return lookupRow ? lookupRow.text : '';\n  }\n\n  /**\n   * @param {boolean} [browse] whether or not the lookup call should execute getAll() or getByText() with the current display text.\n   *     if browse is undefined, browse is set to true automatically if search text is empty\n   * @returns {Promise}\n   */\n  openPopup(browse) {\n    // In case searchRequired is set to true, we always start a new search with the text from the field as query\n    var searchText = this._readDisplayText(),\n      searchAlways = this.searchRequired ? true : null;\n    $.log.isInfoEnabled() && $.log.info('SmartField#openPopup browse=' + browse + ' searchText=' + searchText +\n      ' popup=' + this.popup + ' pendingOpenPopup=' + this._pendingOpenPopup);\n\n    // Reset scheduled focus next tabbable when user clicks on the smartfield while a lookup is resolved.\n    this._tabPrevented = null;\n    this._pendingOpenPopup = true;\n\n    if (strings.empty(searchText)) {\n      // if search text is empty - always do 'browse', no matter what the error code is\n      browse = true;\n    } else if (this.errorStatus) {\n      // In case the search yields a not-unique error, we always want to start a lookup\n      // with the current display text in every other case we better do browse again\n      if (this._hasNotUniqueError()) {\n        searchAlways = true;\n        browse = false;\n      } else if (!this.searchRequired) {\n        browse = true;\n      }\n    }\n\n    return this._lookupByTextOrAll(browse, searchText, searchAlways);\n  }\n\n  _hasUiError(codes) {\n    var status = this._errorStatus();\n\n    if (!status) {\n      return false;\n    }\n\n    if (codes) {\n      codes = arrays.ensure(codes);\n    } else {\n      codes = [SmartField.ErrorCode.NO_RESULTS, SmartField.ErrorCode.NOT_UNIQUE];\n    }\n\n    // collect codes from the status hierarchy\n    var statusList = Status.asFlatList(status);\n    var foundCodes = statusList.reduce(function(list, status) {\n      if (status.code && list.indexOf(status.code) === -1) {\n        list.push(status.code);\n      }\n      return list;\n    }, []);\n\n    // if one of the requested codes exist in the list of found codes\n    return codes.some(function(code) {\n      return foundCodes.indexOf(code) > -1;\n    });\n  }\n\n  /**\n   * @param browse [boolean] optional, whether to perform a lookupByAll (=browse) or a lookupByText.\n   *        By default the param is set to <code>true</code> if the search-text is not empty\n   * @param searchText [String] optional, when not set the search-text from the smart-field is used\n   * @param searchAlways [boolean] optional, only used when browse=false. When set to true the search\n   *        is always performed, event when the search-text has not changed. By default the param is\n   *        set to <code>false</code>.\n   * @returns {Promise}\n   */\n  _lookupByTextOrAll(browse, searchText, searchAlways) {\n    // default values\n    searchText = scout.nvl(searchText, this._readDisplayText());\n    browse = scout.nvl(browse, strings.empty(searchText));\n    searchAlways = scout.nvl(searchAlways, false);\n\n    // never do a text-lookup if field has dropdown style\n    if (this.isDropdown()) {\n      browse = true;\n    }\n\n    // this avoids unnecessary lookup-calls when a keyboard event has triggered\n    // the lookupByTextOrAll function but the search-text has not changed #226643.\n    if (!browse && !searchAlways) {\n      var lastSearchText = null;\n      if (this._lastSearchText) {\n        lastSearchText = this._lastSearchText;\n      } else {\n        lastSearchText = this._getLastSearchText();\n      }\n      if (this._searchTextEquals(searchText, lastSearchText)) {\n        this._pendingOpenPopup = false;\n        $.log.debug('(SmartField#_lookupByTextOrAll) searchText is equals -> skip lookup');\n        return;\n      }\n    }\n\n    this._clearPendingLookup();\n\n    var deferred = $.Deferred();\n    var doneHandler = function(result) {\n      this._lookupByTextOrAllDone(result);\n      deferred.resolve(result);\n    }.bind(this);\n\n    // execute lookup byAll immediately\n    if (browse) {\n      $.log.isDebugEnabled() && $.log.debug('(SmartField#_lookupByTextOrAll) lookup byAll (searchText empty)');\n      this._lastSearchText = null;\n      if (this.searchRequired) {\n        doneHandler({\n          queryBy: QueryBy.TEXT,\n          lookupRows: []\n        });\n        this.setLookupStatus(Status.warning({\n          message: this.session.text('TooManyRows'),\n          code: SmartField.ErrorCode.SEARCH_REQUIRED\n        }));\n      } else {\n        this._executeLookup(this.lookupCall.cloneForAll(), true)\n          .done(doneHandler)\n          .done(this._triggerLookupCallDone.bind(this));\n      }\n    } else {\n      // execute lookup byText with a debounce/delay\n      this._pendingLookup = setTimeout(function() {\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_lookupByTextOrAll) lookup byText searchText=' + searchText);\n        this._lastSearchText = searchText;\n        this._executeLookup(this.lookupCall.cloneForText(searchText), true)\n          .done(doneHandler)\n          .done(this._triggerLookupCallDone.bind(this));\n      }.bind(this), SmartField.DEBOUNCE_DELAY);\n    }\n\n    return deferred.promise();\n  }\n\n  /**\n   * Returns the text used to store the 'last search-text'. The implementation differs between SmartField and ProposalField.\n   */\n  _getLastSearchText() {\n    return objects.optProperty(this.lookupRow, 'text');\n  }\n\n  _lookupByTextOrAllDone(result) {\n    this._extendResult(result);\n    this._notUnique = !result.byAll && result.numLookupRows > 1;\n\n    if (this._handleException(result)) {\n      return;\n    }\n\n    // In cases where the user has tabbed to the next field, while results for the previous\n    // smart-field are still loading: don't show the proposal popup. In the case of a cell-editor\n    // it's also possible that the smart-field is not rendered anymore when the lookup is done\n    if (!this.rendered ||\n      !this.isFocused() && !this.isTouchable()) {\n      this.closePopup();\n      return;\n    }\n\n    // 'No data' case\n    if (result.empty && result.byAll) {\n      // When active filter is enabled we must always show the popup, because the user\n      // must be able to switch the filter properties. Otherwise a user could set the filter\n      // to 'inactive', and receives an empty result for that query, the popup is closed\n      // and the user can not switch the filter back to 'active' again because the filter\n      // control is not visible.\n      if (this.activeFilterEnabled) {\n        this._ensurePopup(result);\n      } else {\n        this.closePopup();\n      }\n\n      this.setLookupStatus(Status.warning({\n        message: this.session.text('SmartFieldNoDataFound'),\n        code: SmartField.ErrorCode.NO_DATA\n      }));\n      return;\n    }\n\n    if (result.empty) {\n      this._handleEmptyResult();\n      this.setLookupStatus(Status.warning({\n        message: this.session.text('SmartFieldCannotComplete', result.text),\n        code: SmartField.ErrorCode.NO_RESULTS\n      }));\n      return;\n    }\n\n    var popupStatus = null;\n    if (result.numLookupRows > this.browseMaxRowCount) {\n      // Info: we limit the lookup rows here, but this is more a last line of defense\n      // limit should be always performed on the server, so we don't have to transfer\n      // unnecessary lookup rows over the slow network. Make sure your Scout lookup call\n      // or REST service impl. respects the max. row count property.\n      result.lookupRows = result.lookupRows.slice(0, this.browseMaxRowCount);\n      popupStatus = Status.info({\n        message: this.session.text('SmartFieldMoreThanXRows', this.browseMaxRowCount)\n      });\n    }\n\n    // Render popup, if not yet rendered and set results\n    this._ensurePopup(result, popupStatus);\n  }\n\n  _ensurePopup(result, status) {\n    if (this.popup) {\n      this.popup.setLookupResult(result);\n      this.popup.setStatus(status);\n    } else {\n      this._renderPopup(result, status);\n    }\n  }\n\n  _handleException(result) {\n    // Oops! Something went wrong while the lookup has been processed.\n    if (result.exception) {\n      this.setErrorStatus(Status.error({\n        message: result.exception\n      }));\n      this.closePopup();\n      return true;\n    }\n    return false;\n  }\n\n  _handleEmptyResult() {\n    if (this.touchMode || this.activeFilterEnabled) {\n      // In mobile mode we always open the popup, event if we don't have a result\n      // Otherwise it would be impossible to enter text in a proposal field with\n      // an empty proposal list. The same goes for activeFilterEnabled state -\n      // a filter can lead to an empty result (for instance when there are no\n      // inactive proposals), and it's hard to switch to another filter value\n      // when the popup does not show up at all.\n      var emptyResult = {\n        lookupRows: []\n      };\n      this._ensurePopup(emptyResult);\n    } else if (this.embedded) {\n      this.popup.clearLookupRows();\n    } else {\n      this.closePopup();\n    }\n  }\n\n  _renderPopup(result, status) {\n    // On touch devices the field does not get the focus.\n    // But it should look focused when the popup is open.\n    this.$field.addClass('focused');\n    this.$container.addClass('popup-open');\n\n    var useTouch = this.touchMode && !this.isDropdown();\n    var popupType = useTouch ? 'SmartFieldTouchPopup' : 'SmartFieldPopup';\n    this._pendingOpenPopup = false;\n    this.popup = scout.create(popupType, {\n      parent: this,\n      $anchor: this.$field,\n      boundToAnchor: !useTouch,\n      closeOnAnchorMouseDown: false,\n      field: this,\n      lookupResult: result,\n      status: status\n    });\n\n    this.popup.open();\n\n    /* This variable is required to route events to the right field:\n     * - in normal mode popup events should be processed by the normal smart-field\n     * - in touch mode, the field flagged with the 'touch' property should process no\n     *   events at all, instead the field flagged with the 'embedded' property should\n     *   process these events.\n     *\n     * (*1) because the lookup is processed by the field flagged with 'touch' we must\n     *      set the activeFilter on that field too, because the java-model on the server\n     *      is stateful. The java field always passes the activeFilter property to the\n     *      lookup call.\n     */\n    var fieldForPopup = useTouch ? this.popup._field : this;\n    this.popup.on('lookupRowSelected', fieldForPopup._onLookupRowSelected.bind(fieldForPopup));\n    this.popup.on('activeFilterSelected', this._onActiveFilterSelected.bind(this)); // intentionally use this instead of fieldForPopup *1\n    this.popup.one('remove', function() {\n      this.popup = null;\n      if (this.rendered) {\n        this.$container.removeClass('popup-open');\n        this.$field.removeClass('focused');\n        this._renderErrorStatus();\n      }\n    }.bind(this));\n  }\n\n  closePopup() {\n    this._pendingOpenPopup = false;\n    if (this.popup) {\n      this.popup.close();\n    }\n  }\n\n  /**\n   * Calls acceptInput if mouse down happens outside of the field or popup\n   * @override\n   */\n  aboutToBlurByMouseDown(target) {\n    if (this.touchMode) {\n      return false;\n    }\n    if (fields.eventOutsideProposalField(this, target)) {\n      this.acceptInput(true);\n    }\n  }\n\n  _onFieldMouseDown(event) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_onFieldMouseDown)');\n    this.activate(true);\n  }\n\n  activate(onField) {\n    if (!this.enabledComputed || !this.rendered) {\n      return;\n    }\n    if (!this.isDropdown() && !fields.handleOnClick(this)) {\n      if (this.popup && this.popup.removalPending) {\n        // If smart field is activated while it is closing (during remove animation), wait for the animation to finish and activate it afterwards\n        this.popup.one('remove', function() {\n          if (this.rendered) {\n            this.activate(onField);\n          }\n        }.bind(this));\n      }\n      return;\n    }\n    // Don't focus on desktop devices when click is on field #217192\n    // Also required for touch case where field is a DIV and not an INPUT field\n    if (!onField || Device.get().supportsOnlyTouch()) {\n      this.$field.focus();\n    }\n    this.togglePopup();\n  }\n\n  _onIconMouseDown(event) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_onIconMouseDown)');\n    if (!this.enabledComputed) {\n      return;\n    }\n    event.preventDefault();\n    this.$field.focus();\n    if (!this.embedded) {\n      if (this.isDropdown()) {\n        this.togglePopup();\n      } else if (!this.popup) {\n        this.openPopup(!this.searchRequired);\n      }\n    }\n  }\n\n  _onClearIconMouseDown(event) {\n    $.log.isDebugEnabled() && $.log.debug('(SmartField#_onClearIconMouseDown)');\n    if (!this.enabledComputed) {\n      return;\n    }\n    event.preventDefault();\n    this.$field.focus();\n    this.clear();\n  }\n\n  _clear() {\n    // don't tab next field when user clicks on clear icon (acceptInput is called later)\n    this._tabPrevented = null;\n    // the state of these two flags is important. See #_checkSearchTextChanged\n    this._lastSearchText = this._readDisplayText();\n    this._userWasTyping = true;\n    fields.valOrText(this.$field, '');\n    if (this.touchMode) {\n      // There is actually no \"x\" the user can press in touch mode, but if the developer calls clear() manually, it should work too.\n      // Because accept input works differently in touch mode we need to explicitly set the value to null\n      this.setValue(null);\n    }\n    if (this.isPopupOpen()) {\n      // When cleared, browse by all again, need to do it in setTimeout because sending acceptInput and lookupAll at the same time does not seem to work\n      setTimeout(this._lookupByTextOrAll.bind(this, true));\n    }\n    this._updateHasText();\n  }\n\n  togglePopup() {\n    $.log.isInfoEnabled() && $.log.info('(SmartField#togglePopup) popupOpen=', this.isPopupOpen());\n    if (this.isPopupOpen()) {\n      this.closePopup();\n    } else {\n      this.openPopup(!this.searchRequired);\n    }\n  }\n\n  _onFieldBlur(event) {\n    this.setFocused(false);\n    this.setLoading(false);\n    if (this.isTouchable()) {\n      return;\n    }\n    this.acceptInput(false);\n    this.closePopup();\n  }\n\n  /**\n   * @returns {boolean} true if the field is either 'embedded' or in 'touchMode'.\n   */\n  isTouchable() {\n    return this.embedded || this.touchMode;\n  }\n\n  _onFieldKeyUp(event) {\n    // Escape\n    if (event.which === keys.ESC) {\n      return;\n    }\n\n    // Pop-ups shouldn't open when one of the following keys is pressed\n    var w = event.which;\n    var isPaste = ((event.ctrlKey || event.metaKey) && w === keys.V) || (event.shiftKey && w === keys.INSERT);\n    var isCut = ((event.ctrlKey || event.metaKey) && w === keys.X) || (event.shiftKey && w === keys.DELETE);\n    var isCutOrPaste = (isPaste || isCut) && !this.isDropdown();\n\n    if (!isCutOrPaste && (\n      event.ctrlKey ||\n      event.altKey ||\n      event.metaKey ||\n      w === keys.ENTER ||\n      w === keys.TAB ||\n      w === keys.SHIFT ||\n      w === keys.CTRL ||\n      w === keys.ALT ||\n      w === keys.HOME ||\n      w === keys.END ||\n      w === keys.LEFT ||\n      w === keys.RIGHT ||\n      w === keys.WIN_LEFT ||\n      w === keys.WIN_RIGHT ||\n      w === keys.SELECT ||\n      w === keys.NUM_LOCK ||\n      w === keys.CAPS_LOCK ||\n      w === keys.SCROLL_LOCK ||\n      w === keys.PAUSE ||\n      w === keys.PRINT_SCREEN ||\n      this._isNavigationKey(event) ||\n      this._isFunctionKey(event)\n    )) {\n      return;\n    }\n\n    // The typed character is not available until the keyUp event happens\n    // That's why we must deal with that event here (and not in keyDown)\n    // We don't use _displayText() here because we always want the text the\n    // user has typed.\n    this._handleInput();\n  }\n\n  _handleInput() {\n    if (this._pendingOpenPopup || this.isPopupOpen()) {\n      if (!this.isDropdown()) {\n        this._lookupByTextOrAll();\n      }\n    } else if (!this._pendingOpenPopup) {\n      this.openPopup();\n    }\n  }\n\n  isPopupOpen() {\n    return !!(this.popup && !this.popup.removalPending);\n  }\n\n  _onFieldKeyDown(event) {\n    this._updateUserWasTyping(event);\n\n    // We must prevent default focus handling\n    if (event.which === keys.TAB) {\n      if (this.mode === FormField.Mode.DEFAULT) {\n        event.preventDefault(); // prevent browser default TAB behavior\n        event.stopPropagation(); // prevent FocusContext#._onKeyDown\n        $.log.isDebugEnabled() && $.log.debug('(SmartField#_onFieldKeyDown) set _tabPrevented');\n        this._tabPrevented = {\n          shiftKey: event.shiftKey\n        };\n      }\n      this.acceptInput();\n      return;\n    }\n\n    if (event.which === keys.ENTER) {\n      this._handleEnterKey(event);\n      return;\n    }\n\n    // For dropdowns, not only navigation keys trigger the popup (see code below).\n    // However, there are still some exceptions that should be ignored:\n    var w = event.which;\n    if (this.isDropdown() && (\n      event.ctrlKey ||\n      event.altKey ||\n      event.metaKey ||\n      w === keys.ESC ||\n      w === keys.SHIFT ||\n      w === keys.CTRL ||\n      w === keys.ALT ||\n      w === keys.WIN_LEFT ||\n      w === keys.WIN_RIGHT ||\n      w === keys.SELECT ||\n      w === keys.NUM_LOCK ||\n      w === keys.CAPS_LOCK ||\n      w === keys.SCROLL_LOCK ||\n      w === keys.PAUSE ||\n      w === keys.PRINT_SCREEN ||\n      this._isFunctionKey(event)\n    )) {\n      return;\n    }\n\n    // If field has dropdown style, we open the popup immediately\n    // because we must not wait until text has been typed\n    if (this._isNavigationKey(event) || this.isDropdown()) {\n      if (this.isPopupOpen()) {\n        this.popup.delegateKeyEvent(event);\n      } else if (!this._pendingOpenPopup) {\n        this.openPopup(!this.searchRequired);\n      }\n      event.stopPropagation(); // key has been handled (popup open). do not allow propagation to other listeners because this could remove tooltips\n      event.preventDefault(); // prevent scrolling of container\n    }\n  }\n\n  _onFieldInput() {\n    this._updateHasText();\n\n    // Handling for undo/redo events which can affect this field, even tough the focus is on another field\n    // we must have the focus, because otherwise acceptInput would be skipped, which could cause the smart-field\n    // to have an invalid displayText which does not reflect the current value. #246765\n    //\n    // We cannot fix this problem on IE 11, because IE 11 triggers the INPUT event by error when DOM attributes\n    // like 'placeholder' change. Since we have no way to detect these false events, we must skip the undo/redo\n    // handling. See: https://github.com/vuejs/vue/issues/7138\n    if (Device.get().isInternetExplorer()) {\n      return;\n    }\n    if (!this._userWasTyping) {\n      if (!this.isFocused()) {\n        this.focus();\n      }\n      this._handleInput();\n    }\n  }\n\n  _updateUserWasTyping(event) {\n    var w = event.which;\n    var isPaste = ((event.ctrlKey || event.metaKey) && w === keys.V) || (event.shiftKey && w === keys.INSERT);\n    var isCut = ((event.ctrlKey || event.metaKey) && w === keys.X) || (event.shiftKey && w === keys.DELETE);\n    var isCutOrPaste = (isPaste || isCut) && !this.isDropdown();\n\n    if (!isCutOrPaste && (\n      event.ctrlKey ||\n      event.altKey ||\n      event.metaKey ||\n      w === keys.ESC ||\n      w === keys.TAB ||\n      w === keys.SHIFT ||\n      w === keys.CTRL ||\n      w === keys.ALT ||\n      w === keys.HOME ||\n      w === keys.END ||\n      w === keys.LEFT ||\n      w === keys.RIGHT ||\n      w === keys.WIN_LEFT ||\n      w === keys.WIN_RIGHT ||\n      w === keys.SELECT ||\n      w === keys.NUM_LOCK ||\n      w === keys.CAPS_LOCK ||\n      w === keys.SCROLL_LOCK ||\n      w === keys.PAUSE ||\n      w === keys.PRINT_SCREEN ||\n      this._isFunctionKey(event)\n    )) {\n      // neutral, don't change flag\n      return;\n    }\n\n    this._userWasTyping = !(this._isNavigationKey(event) || w === keys.ENTER);\n  }\n\n  _isNavigationKey(event) {\n    var navigationKeys = [\n      keys.PAGE_UP,\n      keys.PAGE_DOWN,\n      keys.UP,\n      keys.DOWN\n    ];\n\n    if (this.isDropdown()) {\n      navigationKeys.push(keys.HOME);\n      navigationKeys.push(keys.END);\n    }\n\n    return scout.isOneOf(event.which, navigationKeys);\n  }\n\n  _handleEnterKey(event) {\n    if (this.isPopupOpen()) {\n      this.popup.selectLookupRow();\n      event.stopPropagation();\n    }\n  }\n\n  _isFunctionKey(event) {\n    return event.which >= keys.F1 && event.which <= keys.F12;\n  }\n\n  _onLookupRowSelected(event) {\n    // When a row has been selected in the proposal chooser, cancel all\n    // pending and running lookup-calls. This avoids situations where the\n    // lookup-call returns with results after the user has pressed the\n    // enter key in order to select a result (see ticket #229775).\n    this._clearPendingLookup();\n\n    var currentLookupCall = this.original()._currentLookupCall;\n\n    if (currentLookupCall) {\n      currentLookupCall.abort();\n      this.original()._currentLookupCall = null;\n      this.setLoading(false);\n    }\n\n    this.setLookupRow(event.lookupRow);\n    this._inputAccepted();\n    this.closePopup();\n  }\n\n  /**\n   * When the user changes the active-filter we must always perform a new search. When the user has typed a searchText\n   * we must perform a lookupByText. When the searchText is empty or different from the text of the selected lookup-row\n   * we are in browse mode where we use the default given by the 'searchRequired' property. See: #237229.\n   */\n  _onActiveFilterSelected(event) {\n    this.setActiveFilter(event.activeFilter);\n    var browse = !this.searchRequired;\n    var searchText = this._readSearchText();\n    if (this.lookupRow) {\n      if (this.lookupRow.text !== searchText) {\n        browse = false;\n      }\n    } else if (strings.hasText(searchText)) {\n      browse = false;\n    }\n    this._lookupByTextOrAll(browse, searchText, true);\n  }\n\n  setBrowseMaxRowCount(browseMaxRowCount) {\n    this.setProperty('browseMaxRowCount', browseMaxRowCount);\n  }\n\n  setBrowseAutoExpandAll(browseAutoExpandAll) {\n    this.setProperty('browseAutoExpandAll', browseAutoExpandAll);\n  }\n\n  setBrowseLoadIncremental(browseLoadIncremental) {\n    this.setProperty('browseLoadIncremental', browseLoadIncremental);\n    if (this.lookupCall) {\n      // change template here. Will be used on the next clone\n      this.lookupCall.setLoadIncremental(browseLoadIncremental);\n    }\n  }\n\n  setActiveFilter(activeFilter) {\n    this.setProperty('activeFilter', this.activeFilterEnabled ? activeFilter : null);\n  }\n\n  setActiveFilterEnabled(activeFilterEnabled) {\n    this.setProperty('activeFilterEnabled', activeFilterEnabled);\n  }\n\n  setInitActiveFilter(initActiveFilter) {\n    this.setProperty('initActiveFilter', initActiveFilter);\n  }\n\n  setSearchRequired(searchRequired) {\n    this.setProperty('searchRequired', searchRequired);\n  }\n\n  /**\n   * A wrapper function around lookup calls used to display the state in the UI.\n   */\n  _executeLookup(lookupCall, abortExisting) {\n    this.lookupSeqNo++;\n    this.setLoading(true);\n\n    var currentLookupCall = this.original()._currentLookupCall;\n\n    if (abortExisting && currentLookupCall) {\n      currentLookupCall.abort();\n    }\n    this.original()._currentLookupCall = lookupCall;\n    this.trigger('prepareLookupCall', {\n      lookupCall: lookupCall\n    });\n\n    return lookupCall\n      .execute()\n      .always(function() {\n        this.original()._currentLookupCall = null;\n        this.setLoading(false);\n        this._clearLookupStatus();\n        this._clearNoResultsErrorStatus();\n      }.bind(this));\n  }\n\n  /**\n   * Reset error status NO_RESULTS when a lookup is performed, otherwise it would interfere with the\n   * temporary lookupStatus and we'd see an out-dated error-status message while the user is typing.\n   */\n  _clearNoResultsErrorStatus() {\n    if (this.isTouchable()) {\n      return;\n    }\n    if (this._userWasTyping && this.errorStatus && this.errorStatus.code === SmartField.ErrorCode.NO_RESULTS) {\n      this.setErrorStatus(null);\n    }\n  }\n\n  /**\n   * Returns true if the smart-field lookup returns a lot of rows. In that case\n   * the proposal chooser must create a table with virtual scrolling, which means\n   * only the rows visible in the UI are rendered in the DOM. By default we render\n   * all rows, since this avoids problems with layout-invalidation with rows\n   * that have a bitmap-image (PNG) which is loaded asynchronously.\n   */\n  virtual() {\n    return this.browseMaxRowCount > SmartField.DEFAULT_BROWSE_MAX_COUNT;\n  }\n\n  isDropdown() {\n    return this.displayStyle === SmartField.DisplayStyle.DROPDOWN;\n  }\n\n  _setLookupRow(lookupRow) {\n    // remove css classes from old lookup-row\n    if (this.lookupRow) {\n      this.removeCssClass(this.lookupRow.cssClass);\n    }\n\n    this._setProperty('lookupRow', lookupRow);\n\n    // add css classes from new lookup-row\n    if (lookupRow) {\n      this.addCssClass(lookupRow.cssClass);\n    }\n  }\n\n  setLookupRow(lookupRow) {\n    if (this.lookupRow === lookupRow) {\n      return;\n    }\n    this._notUnique = false;\n    this.clearErrorStatus();\n    this._setLookupRow(lookupRow);\n    // this flag is required so lookup row is not changed again, when _setValue is called\n    this._lockLookupRow = true;\n    if (lookupRow) {\n      this.setValue(this._getValueFromLookupRow(lookupRow));\n    } else {\n      this.setValue(null);\n    }\n    this._lockLookupRow = false;\n\n    // In case we have a value X set, start to type search text, and then choose the lookup\n    // row from the proposal with exactly the same value X, setValue() does nothing because\n    // the value has not changed (even though the display text has) thus _formatValue is\n    // never called. That's why we always reset the display text to make sure the display\n    // text is correct.\n    this.resetDisplayText();\n  }\n\n  setDisplayText(displayText) {\n    super.setDisplayText(displayText);\n    this._userWasTyping = false;\n  }\n\n  resetDisplayText() {\n    var returned = this.formatValue(this.value);\n    if (returned && $.isFunction(returned.promise)) {\n      // Promise is returned -> set display text later\n      returned\n        .done(this._setAndRenderDisplayText.bind(this))\n        .fail(function() {\n          $.log.isInfoEnabled() && $.log.info('Could not resolve display text for value: ' + this.value);\n        }.bind(this));\n    } else {\n      this._setAndRenderDisplayText(returned);\n    }\n  }\n\n  /**\n   * This method is very similar to setDisplayText(), but does _not_ check for equality with\n   * the current value. The property is always set and (if the field is rendered) the given\n   * display text is always rendered. This is important when resetting the display text,\n   * because the visible text in the input field may differ from the \"displayText\" property\n   * value. If setDisplayText() was used, the visible text would not always be reset.\n   */\n  _setAndRenderDisplayText(displayText) {\n    this._setProperty('displayText', displayText);\n    if (this.rendered) {\n      this._renderDisplayText();\n    }\n  }\n\n  _getValueFromLookupRow(lookupRow) {\n    return lookupRow.key;\n  }\n\n  _setValue(value) {\n    // set the cached lookup row to null. Keep in mind that the lookup row is set async in a timeout\n    // must of the time. Thus we must remove the reference to the old lookup row as early as possible\n    if (!this._lockLookupRow) {\n      if (objects.isNullOrUndefined(value)) {\n        // when value is set to null, we must also reset the cached lookup row\n        this._setLookupRow(null);\n      } else {\n        // when a value is set, we only keep the cached lookup row when the key of the lookup row is equals to the value\n        if (this._checkResetLookupRow(value)) {\n          this._setLookupRow(null);\n        }\n      }\n    }\n    super._setValue(value);\n    this._notUnique = false;\n  }\n\n  /**\n   * Sub-classes like the proposal field may override this function to implement a different behavior.\n   */\n  _checkResetLookupRow(value) {\n    return this.lookupRow && this.lookupRow.key !== value;\n  }\n\n  /**\n   * This function may be overridden to return another value than this.value.\n   * For instance the proposal field does'nt use the value but the key from the\n   * lookup row for comparison.\n   *\n   * @returns {*} the value used to find the selected element in a proposal chooser.\n   */\n  getValueForSelection() {\n    return this._showSelection() ? this.value : null;\n  }\n\n  _showSelection() {\n    if (objects.isNullOrUndefined(this.value) ||\n      objects.isNullOrUndefined(this.lookupRow)) {\n      return false;\n    }\n\n    var text;\n    if (this.rendered) {\n      // check if text matches (deal with multi-line)\n      text = this._readDisplayText();\n      var additionalLines = this.additionalLines();\n      if (additionalLines) {\n        text = [text].concat(additionalLines).join('\\n');\n      }\n    } else {\n      text = this.displayText;\n    }\n\n    return text === this.lookupRow.text;\n  }\n\n  /**\n   * override to ensure dropdown fields and touch mode smart fields does not have a clear icon.\n   */\n  isClearable() {\n    return super.isClearable() && !this.isDropdown() && !this.touchMode;\n  }\n\n  _triggerLookupCallDone(result) {\n    this.trigger('lookupCallDone', {\n      result: result\n    });\n    return result;\n  }\n\n  _triggerAcceptInputFail() {\n    this._triggerAcceptInput(false, true);\n  }\n\n  _triggerAcceptInput(acceptByLookupRow, failure) {\n    this.trigger('acceptInput', {\n      displayText: this.displayText,\n      errorStatus: this.errorStatus,\n      value: this.value,\n      lookupRow: this.lookupRow,\n      acceptByLookupRow: scout.nvl(acceptByLookupRow, true),\n      failure: scout.nvl(failure, false)\n    });\n  }\n\n  _triggerAcceptByText(searchText) {\n    this.trigger('acceptByText', {\n      searchText: searchText,\n      errorStatus: this.errorStatus\n    });\n  }\n\n  /**\n   * Function invoked if being rendered within a cell-editor (mode='scout.FormField.Mode.CELLEDITOR'), and once the editor finished its rendering.\n   */\n  onCellEditorRendered(options) {\n    if (options.openFieldPopup) {\n      this._cellEditorPopup = options.cellEditorPopup;\n      this.openPopup(!this.searchRequired);\n    }\n  }\n\n  additionalLines() {\n    var text = scout.nvl(this.displayText, ''),\n      textLines = text.split('\\n');\n    if (textLines.length > 1) {\n      textLines.shift();\n      return textLines;\n    }\n    return null;\n\n  }\n\n  _createLoadingSupport() {\n    return new SimpleLoadingSupport({\n      widget: this,\n      loadingIndicatorDelay: 400 // ms\n    });\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _isInitialShowStatus() {\n    if (this.touchMode && (this._pendingOpenPopup || this.isPopupOpen())) {\n      // Do not display a tooltip if the touch popup is open, the tooltip will be displayed there\n      return false;\n    }\n    return super._isInitialShowStatus();\n  }\n\n  /**\n   * In touch mode, we must close the cell editor popup explicitly, because the touch-popup and its glasspane\n   * prevents the cell editor popup from receiving mouse down events.\n   */\n  acceptInputFromField(otherField) {\n    this._copyValuesFromField(otherField);\n\n    if (this._cellEditorPopup) {\n      // this will call acceptInput on the touch smart-field (== this)\n      this._cellEditorPopup.completeEdit();\n      this._cellEditorPopup = null;\n    } else {\n      this.acceptInput();\n    }\n  }\n\n  /**\n   * This function is overridden by ProposalField because it has a different behavior than the smart-field.\n   */\n  _copyValuesFromField(otherField) {\n    if (this.lookupRow !== otherField.lookupRow) {\n      this.setLookupRow(otherField.lookupRow);\n    }\n    this.setErrorStatus(otherField.errorStatus);\n    this.setDisplayText(otherField.displayText);\n  }\n\n  _setNotUniqueError(searchText) {\n    this.setErrorStatus(Status.error({\n      message: this.session.text('SmartFieldNotUnique', searchText),\n      code: SmartField.ErrorCode.NOT_UNIQUE\n    }));\n  }\n\n  _hasNotUniqueError(searchText) {\n    return this._notUnique || this._hasUiError(SmartField.ErrorCode.NOT_UNIQUE);\n  }\n\n  _errorStatus() {\n    return this.lookupStatus || this.errorStatus;\n  }\n\n  setLookupStatus(lookupStatus) {\n    this.setProperty('lookupStatus', lookupStatus);\n    if (this.rendered) {\n      this._renderErrorStatus();\n    }\n  }\n\n  clearErrorStatus() {\n    this.setErrorStatus(null);\n    this._clearLookupStatus();\n  }\n\n  _clearLookupStatus() {\n    this.setLookupStatus(null);\n  }\n\n  /**\n   * Checks if there is a lookup status that needs to be set as error status\n   * before we leave the smart-field. The lookup status is set to null, because\n   * it is a temporary state that is only important while the user executes a lookup.\n   */\n  _flushLookupStatus() {\n    if (!this.lookupStatus) {\n      return;\n    }\n\n    if (this.lookupStatus.code === SmartField.ErrorCode.NO_RESULTS ||\n      this.lookupStatus.code === SmartField.ErrorCode.NOT_UNIQUE) {\n      var errorStatus = this.lookupStatus.clone();\n      errorStatus.severity = Status.Severity.ERROR;\n      this.setErrorStatus(errorStatus);\n    }\n\n    this._clearLookupStatus();\n  }\n\n  requestInput() {\n    if (this.enabledComputed && this.rendered) {\n      this.focus();\n      this.openPopup(!this.searchRequired);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}