{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays } from '../index';\n\nvar LayoutValidator = /*#__PURE__*/function () {\n  function LayoutValidator() {\n    _classCallCheck(this, LayoutValidator);\n\n    this._invalidComponents = [];\n    this._validateTimeoutId = null;\n    this._postValidateFunctions = [];\n  }\n\n  _createClass(LayoutValidator, [{\n    key: \"invalidateTree\",\n    value: function invalidateTree(htmlComp) {\n      var validateRoot,\n          htmlParent = htmlComp,\n          htmlSource = htmlComp; // Mark every parent as invalid until validate root\n\n      while (htmlParent) {\n        htmlComp = htmlParent;\n        htmlComp.invalidateLayout(htmlSource);\n\n        if (htmlComp.isValidateRoot()) {\n          validateRoot = htmlComp;\n          break;\n        }\n\n        htmlParent = htmlComp.getParent();\n      }\n\n      if (!htmlParent) {\n        validateRoot = htmlComp;\n      }\n\n      this.invalidate(validateRoot);\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(htmlComp) {\n      var position = 0; // Don't insert if already inserted...\n      // Info: when component is already in list but no one triggers validation,\n      // validation is never scheduled that's why we call scheduleValidation here.\n\n      if (this._invalidComponents.indexOf(htmlComp) >= 0) {\n        this._scheduleValidation(); // ... but schedule validation\n\n\n        return;\n      } // Make sure it will be inserted before any descendant\n      // This prevents multiple layouting of the descendant\n\n\n      this._invalidComponents.forEach(function (invalidComponent, i) {\n        if (invalidComponent.isDescendantOf(htmlComp)) {\n          return;\n        }\n\n        position++;\n      }, this); // Add validate root to list of invalid components. These are the starting point for a subsequent call to validate().\n\n\n      arrays.insert(this._invalidComponents, htmlComp, position);\n\n      this._scheduleValidation();\n    }\n  }, {\n    key: \"_scheduleValidation\",\n    value: function _scheduleValidation() {\n      if (this._validateTimeoutId === null) {\n        this._validateTimeoutId = setTimeout(function () {\n          this.validate();\n        }.bind(this));\n      }\n    }\n    /**\n     * Layouts all invalid components (as long as they haven't been removed).\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      clearTimeout(this._validateTimeoutId);\n      this._validateTimeoutId = null;\n\n      this._invalidComponents.slice().forEach(function (comp) {\n        if (comp.validateLayout()) {\n          arrays.remove(this._invalidComponents, comp);\n        }\n      }, this);\n\n      this._postValidateFunctions.slice().forEach(function (func) {\n        func();\n        arrays.remove(this._postValidateFunctions, func);\n      }, this);\n    }\n    /**\n     * Removes those components from this._invalidComponents which have the given container as ancestor.\n     * The idea is to remove all components whose ancestor is about to be removed from the DOM.\n     */\n\n  }, {\n    key: \"cleanupInvalidComponents\",\n    value: function cleanupInvalidComponents($parentContainer) {\n      this._invalidComponents.slice().forEach(function (comp) {\n        if (comp.$comp.closest($parentContainer).length > 0) {\n          arrays.remove(this._invalidComponents, comp);\n        }\n      }, this);\n    }\n    /**\n     * Runs the given function at the end of validate().\n     */\n\n  }, {\n    key: \"schedulePostValidateFunction\",\n    value: function schedulePostValidateFunction(func) {\n      if (func) {\n        this._postValidateFunctions.push(func);\n      }\n    }\n  }]);\n\n  return LayoutValidator;\n}();\n\nexport { LayoutValidator as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/layout/LayoutValidator.js"],"names":["arrays","LayoutValidator","_invalidComponents","_validateTimeoutId","_postValidateFunctions","htmlComp","validateRoot","htmlParent","htmlSource","invalidateLayout","isValidateRoot","getParent","invalidate","position","indexOf","_scheduleValidation","forEach","invalidComponent","i","isDescendantOf","insert","setTimeout","validate","bind","clearTimeout","slice","comp","validateLayout","remove","func","$parentContainer","$comp","closest","length","push"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays} from '../index';\n\nexport default class LayoutValidator {\n\n  constructor() {\n    this._invalidComponents = [];\n    this._validateTimeoutId = null;\n    this._postValidateFunctions = [];\n  }\n\n  invalidateTree(htmlComp) {\n    var validateRoot,\n      htmlParent = htmlComp,\n      htmlSource = htmlComp;\n\n    // Mark every parent as invalid until validate root\n    while (htmlParent) {\n      htmlComp = htmlParent;\n      htmlComp.invalidateLayout(htmlSource);\n      if (htmlComp.isValidateRoot()) {\n        validateRoot = htmlComp;\n        break;\n      }\n      htmlParent = htmlComp.getParent();\n    }\n\n    if (!htmlParent) {\n      validateRoot = htmlComp;\n    }\n\n    this.invalidate(validateRoot);\n  }\n\n  invalidate(htmlComp) {\n    var position = 0;\n    // Don't insert if already inserted...\n    // Info: when component is already in list but no one triggers validation,\n    // validation is never scheduled that's why we call scheduleValidation here.\n    if (this._invalidComponents.indexOf(htmlComp) >= 0) {\n      this._scheduleValidation(); // ... but schedule validation\n      return;\n    }\n\n    // Make sure it will be inserted before any descendant\n    // This prevents multiple layouting of the descendant\n    this._invalidComponents.forEach(function(invalidComponent, i) {\n      if (invalidComponent.isDescendantOf(htmlComp)) {\n        return;\n      }\n      position++;\n    }, this);\n\n    // Add validate root to list of invalid components. These are the starting point for a subsequent call to validate().\n    arrays.insert(this._invalidComponents, htmlComp, position);\n\n    this._scheduleValidation();\n  }\n\n  _scheduleValidation() {\n    if (this._validateTimeoutId === null) {\n      this._validateTimeoutId = setTimeout(function() {\n        this.validate();\n      }.bind(this));\n    }\n  }\n\n  /**\n   * Layouts all invalid components (as long as they haven't been removed).\n   */\n  validate() {\n    clearTimeout(this._validateTimeoutId);\n    this._validateTimeoutId = null;\n    this._invalidComponents.slice().forEach(function(comp) {\n      if (comp.validateLayout()) {\n        arrays.remove(this._invalidComponents, comp);\n      }\n    }, this);\n    this._postValidateFunctions.slice().forEach(function(func) {\n      func();\n      arrays.remove(this._postValidateFunctions, func);\n    }, this);\n  }\n\n  /**\n   * Removes those components from this._invalidComponents which have the given container as ancestor.\n   * The idea is to remove all components whose ancestor is about to be removed from the DOM.\n   */\n  cleanupInvalidComponents($parentContainer) {\n    this._invalidComponents.slice().forEach(function(comp) {\n      if (comp.$comp.closest($parentContainer).length > 0) {\n        arrays.remove(this._invalidComponents, comp);\n      }\n    }, this);\n  }\n\n  /**\n   * Runs the given function at the end of validate().\n   */\n  schedulePostValidateFunction(func) {\n    if (func) {\n      this._postValidateFunctions.push(func);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}