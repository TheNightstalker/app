{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { AggregateTableControl, AppLinkKeyStroke, arrays, BooleanColumn, clipboard, Column, ContextMenuKeyStroke, ContextMenuPopup, Device, DoubleClickSupport, dragAndDrop, Event, graphics, HtmlComponent, keys, KeyStrokeContext, LoadingSupport, MenuBar, MenuDestinations, MenuItemsOrder, menus, NumberColumn, objects, Range, scout, scrollbars, Status, strings, styles, TableCopyKeyStroke, TableFocusFilterFieldKeyStroke, TableLayout, TableNavigationCollapseKeyStroke, TableNavigationDownKeyStroke, TableNavigationEndKeyStroke, TableNavigationExpandKeyStroke, TableNavigationHomeKeyStroke, TableNavigationPageDownKeyStroke, TableNavigationPageUpKeyStroke, TableNavigationUpKeyStroke, TableRefreshKeyStroke, TableRow, TableSelectAllKeyStroke, TableSelectionHandler, TableStartCellEditKeyStroke, TableToggleRowKeyStroke, TableUpdateBuffer, TableUserFilter, tooltips as tooltips_1, Widget } from '../index';\nimport $ from 'jquery';\n\nvar Table = /*#__PURE__*/function (_Widget) {\n  _inherits(Table, _Widget);\n\n  var _super = _createSuper(Table);\n\n  function Table() {\n    var _this;\n\n    _classCallCheck(this, Table);\n\n    _this = _super.call(this);\n    _this.autoResizeColumns = false;\n    _this.columnAddable = false;\n    _this.columnLayoutDirty = false;\n    _this.columns = [];\n    _this.contextColumn = null;\n    _this.checkable = false;\n    _this.checkableStyle = Table.CheckableStyle.CHECKBOX;\n    _this.dropType = 0;\n    _this.dropMaximumSize = dragAndDrop.DEFAULT_DROP_MAXIMUM_SIZE;\n    _this.groupingStyle = Table.GroupingStyle.BOTTOM;\n    _this.header = null;\n    _this.headerEnabled = true;\n    _this.headerVisible = true;\n    _this.headerMenusEnabled = true;\n    _this.hasReloadHandler = false;\n    _this.hierarchical = false;\n    _this.hierarchicalStyle = Table.HierarchicalStyle.DEFAULT;\n    _this.keyStrokes = [];\n    _this.keyboardNavigation = true;\n    _this.menus = [];\n    _this.menuBar = null;\n    _this.menuBarVisible = true;\n    _this.contextMenu = null;\n    _this.multiCheck = true;\n    _this.multiSelect = true;\n    _this.multilineText = false;\n    _this.scrollToSelection = false;\n    _this.scrollTop = 0;\n    _this.selectedRows = [];\n    _this.sortEnabled = true;\n    _this.tableControls = [];\n    _this.tableStatusVisible = false;\n    _this.tableTileGridMediator = null;\n    _this.tileMode = false;\n    _this.tileTableHeader = null;\n    _this.footer = null;\n    _this.footerVisible = false;\n    _this.filters = [];\n    _this.rows = [];\n    _this.rootRows = [];\n    _this.visibleRows = [];\n    _this.estimatedRowCount = 0;\n    _this.maxRowCount = 0;\n    _this.truncatedCellTooltipEnabled = null;\n    _this.visibleRowsMap = {}; // visible rows by id\n\n    _this.rowLevelPadding = 0;\n    _this.rowsMap = {}; // rows by id\n\n    _this.rowHeight = 0;\n    _this.rowWidth = 0;\n    _this.rowBorderWidth = 0; // read-only, set by _calculateRowBorderWidth(), also used in TableLayout.js\n\n    _this.rowBorderLeftWidth = 0; // read-only, set by _calculateRowBorderWidth(), also used in TableHeader.js\n\n    _this.rowBorderRightWidth = 0; // read-only, set by _calculateRowBorderWidth(), also used in TableHeader.js\n\n    _this.rowIconVisible = false;\n    _this.rowIconColumnWidth = Column.NARROW_MIN_WIDTH;\n    _this.staticMenus = [];\n    _this.selectionHandler = new TableSelectionHandler(_assertThisInitialized(_this));\n    _this.tooltips = [];\n    _this._filterMap = {};\n    _this._filteredRows = [];\n    _this.tableNodeColumn = null;\n    _this._maxLevel = 0;\n    _this._aggregateRows = [];\n    _this._animationRowLimit = 25;\n    _this._blockLoadThreshold = 25;\n    _this.updateBuffer = new TableUpdateBuffer(_assertThisInitialized(_this)); // Initial value must be > 0 to make prefSize work (if it is 0, no filler will be generated).\n    // If rows have a variable height, prefSize is only correct for 10 rows.\n    // Layout will adjust this value depending on the view port size.\n\n    _this.viewRangeSize = 10;\n    _this.viewRangeDirty = false;\n    _this.viewRangeRendered = new Range(0, 0);\n    _this.virtual = true;\n    _this._doubleClickSupport = new DoubleClickSupport();\n    _this._permanentHeadSortColumns = [];\n    _this._permanentTailSortColumns = [];\n    _this._filterMenusHandler = _this._filterMenus.bind(_assertThisInitialized(_this));\n    _this._popupOpenHandler = _this._onDesktopPopupOpen.bind(_assertThisInitialized(_this));\n    _this._rerenderViewPortAfterAttach = false;\n    _this._renderViewPortAfterAttach = false;\n    _this._desktopPropertyChangeHandler = _this._onDesktopPropertyChange.bind(_assertThisInitialized(_this));\n\n    _this._addWidgetProperties(['tableControls', 'menus', 'keyStrokes', 'staticMenus', 'tileTableHeader', 'tableTileGridMediator']);\n\n    _this.$data = null;\n    _this.$emptyData = null;\n    _this.$fillBefore = null;\n    _this.$fillAfter = null;\n    return _this;\n  } // TODO [7.0] cgu create StringColumn.js incl. defaultValues from defaultValues.json\n\n\n  _createClass(Table, [{\n    key: \"_init\",\n    value: function _init(model) {\n      _get(_getPrototypeOf(Table.prototype), \"_init\", this).call(this, model);\n\n      this.resolveConsts([{\n        property: 'hierarchicalStyle',\n        constType: Table.HierarchicalStyle\n      }, {\n        property: 'checkableStyle',\n        constType: Table.CheckableStyle\n      }, {\n        property: 'groupingStyle',\n        constType: Table.GroupingStyle\n      }]);\n\n      this._initColumns();\n\n      this.rows.forEach(function (row, i) {\n        this.rows[i] = this._initRow(row);\n      }, this);\n      this.setFilters(this.filters);\n\n      this._updateRowStructure({\n        updateTree: true\n      });\n\n      this.menuBar = this._createMenuBar();\n\n      this._setSelectedRows(this.selectedRows);\n\n      this._setKeyStrokes(this.keyStrokes);\n\n      this._setMenus(this.menus);\n\n      this._setTableControls(this.tableControls);\n\n      this._setTableStatus(this.tableStatus);\n\n      this._calculateValuesForBackgroundEffect();\n\n      this._group();\n\n      this._setTileMode(this.tileMode);\n\n      this._setTileTableHeader(this.tileTableHeader);\n    }\n  }, {\n    key: \"_initRow\",\n    value: function _initRow(row) {\n      if (!(row instanceof TableRow)) {\n        row.parent = this;\n        row = scout.create('TableRow', row);\n      }\n\n      this.rowsMap[row.id] = row;\n      this.trigger('rowInit', {\n        row: row\n      });\n      return row;\n    }\n  }, {\n    key: \"_initColumns\",\n    value: function _initColumns() {\n      this.columns = this.columns.map(function (colModel, index) {\n        var column = colModel;\n        column.session = this.session;\n\n        if (column instanceof Column) {\n          column._setTable(this);\n        } else {\n          column.table = this;\n          column = scout.create(column);\n        }\n\n        if (column.index < 0) {\n          column.index = index;\n        }\n\n        if (column.checkable) {\n          // set checkable column if this column is the checkable one\n          this.checkableColumn = column;\n        }\n\n        return column;\n      }, this); // Add gui only checkbox column at the beginning\n\n      this._setCheckable(this.checkable); // Add gui only row icon column at the beginning\n\n\n      if (this.rowIconVisible) {\n        this._insertRowIconColumn();\n      }\n\n      this._calculateTableNodeColumn(); // Sync head and tail sort columns\n\n\n      this._setHeadAndTailSortColumns();\n\n      this.columnLayoutDirty = true;\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this._destroyColumns();\n\n      _get(_getPrototypeOf(Table.prototype), \"_destroy\", this).call(this);\n    }\n  }, {\n    key: \"_destroyColumns\",\n    value: function _destroyColumns() {\n      this.columns.forEach(function (column) {\n        column.destroy();\n      });\n      this.checkableColumn = null;\n      this.columns = [];\n    }\n  }, {\n    key: \"_calculateTableNodeColumn\",\n    value: function _calculateTableNodeColumn() {\n      var candidateColumns = this.visibleColumns().filter(function (column) {\n        return column.nodeColumnCandidate;\n      });\n      var tableNodeColumn = arrays.first(candidateColumns);\n\n      if (this.tableNodeColumn && this.tableNodeColumn !== tableNodeColumn) {\n        // restore\n        this.tableNodeColumn.minWidth = this.tableNodeColumn._initialMinWidth;\n      }\n\n      this.tableNodeColumn = tableNodeColumn;\n\n      if (this.tableNodeColumn) {\n        this.tableNodeColumn._initialMinWidth = this.tableNodeColumn.minWidth;\n        this.tableNodeColumn.minWidth = this.rowLevelPadding * this._maxLevel + this.tableNodeColumn.tableNodeLevel0CellPadding + 8;\n\n        if (this.tableNodeColumn.minWidth > this.tableNodeColumn.width) {\n          if (this._isDataRendered()) {\n            this.resizeColumn(this.tableNodeColumn, this.tableNodeColumn.minWidth);\n          } else {\n            this.tableNodeColumn.width = this.tableNodeColumn.minWidth;\n          }\n        }\n      }\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_createLoadingSupport\",\n    value: function _createLoadingSupport() {\n      // noinspection JSCheckFunctionSignatures\n      return new LoadingSupport({\n        widget: this,\n        $container: function () {\n          return this.$data;\n        }.bind(this)\n      });\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_createKeyStrokeContext\",\n    value: function _createKeyStrokeContext() {\n      return new KeyStrokeContext();\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      _get(_getPrototypeOf(Table.prototype), \"_initKeyStrokeContext\", this).call(this);\n\n      this._initTableKeyStrokeContext();\n    }\n  }, {\n    key: \"_initTableKeyStrokeContext\",\n    value: function _initTableKeyStrokeContext() {\n      this.keyStrokeContext.registerKeyStroke([new TableNavigationUpKeyStroke(this), new TableNavigationDownKeyStroke(this), new TableNavigationPageUpKeyStroke(this), new TableNavigationPageDownKeyStroke(this), new TableNavigationHomeKeyStroke(this), new TableNavigationEndKeyStroke(this), new TableNavigationCollapseKeyStroke(this), new TableNavigationExpandKeyStroke(this), new TableFocusFilterFieldKeyStroke(this), new TableStartCellEditKeyStroke(this), new TableSelectAllKeyStroke(this), new TableRefreshKeyStroke(this), new TableToggleRowKeyStroke(this), new TableCopyKeyStroke(this), new ContextMenuKeyStroke(this, this.showContextMenu, this), new AppLinkKeyStroke(this, this.handleAppLinkAction)]); // Prevent default action and do not propagate ↓ or ↑ keys if ctrl- or alt-modifier is not pressed.\n      // Otherwise, an '↑-event' on the first row, or an '↓-event' on the last row will bubble up (because not consumed by table navigation keystrokes) and cause a superior table to move its selection.\n      // Use case: - outline page table with search form that contains a table field;\n      //           - shift + '↑-event'/'↓-event' are not consumed by a single selection table, and would propagate otherwise;\n      //           - preventDefault because of smartfield, so that the cursor is not moved on first or last row;\n\n      this.keyStrokeContext.registerStopPropagationInterceptor(function (event) {\n        if (!event.ctrlKey && !event.altKey && scout.isOneOf(event.which, keys.UP, keys.DOWN)) {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n      });\n    }\n  }, {\n    key: \"_insertBooleanColumn\",\n    value: function _insertBooleanColumn() {\n      // don't add checkbox column when we're in checkableStyle mode\n      if (this.checkableStyle === Table.CheckableStyle.TABLE_ROW) {\n        return;\n      }\n\n      var column = scout.create('BooleanColumn', {\n        session: this.session,\n        fixedWidth: true,\n        fixedPosition: true,\n        guiOnly: true,\n        nodeColumnCandidate: false,\n        headerMenuEnabled: false,\n        showSeparator: false,\n        width: Column.NARROW_MIN_WIDTH,\n        table: this\n      });\n      arrays.insert(this.columns, column, 0);\n      this.checkableColumn = column;\n    }\n  }, {\n    key: \"_insertRowIconColumn\",\n    value: function _insertRowIconColumn() {\n      var position = 0,\n          column = scout.create('IconColumn', {\n        session: this.session,\n        fixedWidth: true,\n        fixedPosition: true,\n        guiOnly: true,\n        nodeColumnCandidate: false,\n        headerMenuEnabled: false,\n        showSeparator: false,\n        width: this.rowIconColumnWidth,\n        table: this\n      });\n\n      if (this.columns[0] === this.checkableColumn) {\n        position = 1;\n      }\n\n      arrays.insert(this.columns, column, position);\n      this.rowIconColumn = column;\n    }\n  }, {\n    key: \"handleAppLinkAction\",\n    value: function handleAppLinkAction(event) {\n      var $appLink = $(event.target);\n\n      var column = this._columnAtX($appLink.offset().left);\n\n      this._triggerAppLinkAction(column, $appLink.data('ref'));\n    }\n  }, {\n    key: \"_isDataRendered\",\n    value: function _isDataRendered() {\n      return this.rendered && this.$data !== null;\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      this.$container = this.$parent.appendDiv('table').addDeviceClass();\n      this.htmlComp = HtmlComponent.install(this.$container, this.session);\n      this.htmlComp.setLayout(new TableLayout(this));\n\n      if (this.uiCssClass) {\n        this.$container.addClass(this.uiCssClass);\n      }\n\n      if (this.tileMode) {\n        this._renderTileMode();\n      } else {\n        this._renderData();\n      }\n\n      this.session.desktop.on('popupOpen', this._popupOpenHandler);\n      this.session.desktop.on('propertyChange', this._desktopPropertyChangeHandler);\n    }\n  }, {\n    key: \"_renderData\",\n    value: function _renderData() {\n      this.$data = this.$container.appendDiv('table-data');\n      this.$data.on('mousedown', '.table-row', this._onRowMouseDown.bind(this)).on('mouseup', '.table-row', this._onRowMouseUp.bind(this)).on('dblclick', '.table-row', this._onRowDoubleClick.bind(this)).on('contextmenu', function (event) {\n        event.preventDefault();\n      });\n\n      this._installScrollbars({\n        axis: 'both'\n      });\n\n      this._installImageListeners();\n\n      this._installCellTooltipSupport();\n\n      this._calculateRowBorderWidth();\n\n      this._updateRowWidth();\n\n      this._updateRowHeight();\n\n      this._renderViewport();\n\n      if (this.scrollToSelection) {\n        this.revealSelection();\n      }\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      _get(_getPrototypeOf(Table.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderTableHeader();\n\n      this._renderMenuBarVisible();\n\n      this._renderFooterVisible();\n\n      this._renderDropType();\n\n      this._renderCheckableStyle();\n\n      this._renderHierarchicalStyle();\n    }\n  }, {\n    key: \"_setCssClass\",\n    value: function _setCssClass(cssClass) {\n      _get(_getPrototypeOf(Table.prototype), \"_setCssClass\", this).call(this, cssClass); // calculate row level padding\n\n\n      var paddingClasses = ['table-row-level-padding'];\n\n      if (this.cssClass) {\n        paddingClasses.push(this.cssClass);\n      }\n\n      this.setRowLevelPadding(styles.getSize(paddingClasses.reduce(function (acc, cssClass) {\n        return acc + ' ' + cssClass;\n      }, ''), 'width', 'width', 15));\n    }\n  }, {\n    key: \"_removeData\",\n    value: function _removeData() {\n      this._destroyCellEditorPopup();\n\n      this._removeAggregateRows();\n\n      this._uninstallImageListeners();\n\n      this._uninstallCellTooltipSupport();\n\n      this._uninstallScrollbars();\n\n      this._removeRows();\n\n      this.$fillBefore = null;\n      this.$fillAfter = null;\n      this.$data.remove();\n      this.$data = null;\n      this.$emptyData = null;\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      this.session.desktop.off('propertyChange', this._desktopPropertyChangeHandler);\n      this.session.desktop.off('popupOpen', this._popupOpenHandler);\n\n      this._uninstallDragAndDropHandler(); // TODO [7.0] cgu do not delete header, implement according to footer\n\n\n      this.header = null;\n\n      if (this.$data) {\n        this._removeData();\n      }\n\n      _get(_getPrototypeOf(Table.prototype), \"_remove\", this).call(this);\n    }\n  }, {\n    key: \"setRowLevelPadding\",\n    value: function setRowLevelPadding(rowLevelPadding) {\n      this.setProperty('rowLevelPadding', rowLevelPadding);\n    }\n  }, {\n    key: \"_renderRowLevelPadding\",\n    value: function _renderRowLevelPadding() {\n      this._rerenderViewport();\n    }\n  }, {\n    key: \"setTableControls\",\n    value: function setTableControls(controls) {\n      this.setProperty('tableControls', controls);\n    }\n  }, {\n    key: \"_renderTableControls\",\n    value: function _renderTableControls() {\n      if (this.footer) {\n        this.footer._renderControls();\n      }\n    }\n  }, {\n    key: \"_setTableControls\",\n    value: function _setTableControls(controls) {\n      var i;\n\n      for (i = 0; i < this.tableControls.length; i++) {\n        this.keyStrokeContext.unregisterKeyStroke(this.tableControls[i]);\n      }\n\n      this._setProperty('tableControls', controls);\n\n      for (i = 0; i < this.tableControls.length; i++) {\n        this.keyStrokeContext.registerKeyStroke(this.tableControls[i]);\n      }\n\n      this._updateFooterVisibility();\n\n      this.tableControls.forEach(function (control) {\n        control.tableFooter = this.footer;\n      }, this);\n    }\n    /**\n     * When an IMG has been loaded we must update the stored height in the model-row.\n     * Note: we don't change the width of the row or table.\n     */\n\n  }, {\n    key: \"_onImageLoadOrError\",\n    value: function _onImageLoadOrError(event) {\n      var $target = $(event.target);\n\n      if ($target.data('measure') === 'in-progress') {\n        // Ignore events created by autoOptimizeWidth measurement (see ColumnOptimalWidthMeasurer)\n        // Using event.stopPropagation() is not possible because the image load event does not bubble\n        return;\n      }\n\n      var $row = $target.closest('.table-row');\n      var row = $row.data('row');\n\n      if (!row) {\n        return; // row was removed while loading the image\n      }\n\n      var oldRowHeight = row.height;\n      row.height = $row.outerHeight(true);\n\n      if (oldRowHeight !== row.height) {\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_onRowMouseDown\",\n    value: function _onRowMouseDown(event) {\n      this._doubleClickSupport.mousedown(event);\n\n      this._$mouseDownRow = $(event.currentTarget);\n      this._mouseDownRowId = this._$mouseDownRow.data('row').id;\n      this._mouseDownColumn = this._columnAtX(event.pageX);\n\n      this._$mouseDownRow.window().one('mouseup', function () {\n        this._$mouseDownRow = null;\n        this._mouseDownRowId = null;\n        this._mouseDownColumn = null;\n      }.bind(this));\n\n      this.setContextColumn(this._columnAtX(event.pageX));\n      this.selectionHandler.onMouseDown(event);\n      var isRightClick = event.which === 3;\n\n      var row = this._$mouseDownRow.data('row');\n\n      var $target = $(event.target); // handle expansion\n\n      if (this._isRowControl($target)) {\n        if (row.expanded) {\n          this.collapseRow(row);\n        } else {\n          this.expandRow(row);\n        }\n      } // For checkableStyle TABLE_ROW & CHECKBOX_TABLE_ROW only: check row if left click OR clicked row was not checked yet\n\n\n      if (scout.isOneOf(this.checkableStyle, Table.CheckableStyle.TABLE_ROW, Table.CheckableStyle.CHECKBOX_TABLE_ROW) && (!isRightClick || !row.checked) && !$(event.target).is('.table-row-control') && // Click on BooleanColumns should not trigger a row check. The only exception is if the BooleanColumn is the checkableColumn of this table (handled in BooleanColumn.js)\n      !($target.hasClass('checkable') || $target.parent().hasClass('checkable'))) {\n        this.checkRow(row, !row.checked);\n      }\n\n      if (isRightClick) {\n        this.showContextMenu({\n          pageX: event.pageX,\n          pageY: event.pageY\n        });\n        return false;\n      }\n    }\n  }, {\n    key: \"_isRowControl\",\n    value: function _isRowControl($target) {\n      return $target.hasClass('table-row-control') || $target.parent().hasClass('table-row-control');\n    }\n  }, {\n    key: \"_onRowMouseUp\",\n    value: function _onRowMouseUp(event) {\n      var $row,\n          $mouseUpRow,\n          column,\n          $appLink,\n          mouseButton = event.which;\n\n      if (this._doubleClickSupport.doubleClicked()) {\n        // Don't execute on double click events\n        return;\n      }\n\n      $mouseUpRow = $(event.currentTarget);\n      this.selectionHandler.onMouseUp(event, $mouseUpRow);\n\n      if (!this._$mouseDownRow || this._mouseDownRowId !== $mouseUpRow.data('row').id) {\n        // Don't accept if mouse up happens on another row than mouse down, or mousedown didn't happen on a row at all\n        return;\n      }\n\n      $row = $mouseUpRow;\n      column = this._columnAtX(event.pageX);\n\n      if (column !== this._mouseDownColumn) {\n        // Don't execute click / appLinks when the mouse gets pressed and moved outside of a cell\n        return;\n      }\n\n      var $target = $(event.target);\n\n      if (this._isRowControl($target)) {\n        // Don't start cell editor or trigger click if row control was clicked (expansion itself is handled by the mouse down handler)\n        return;\n      }\n\n      if (mouseButton === 1) {\n        column.onMouseUp(event, $row);\n        $appLink = this._find$AppLink(event);\n      }\n\n      if ($appLink) {\n        this._triggerAppLinkAction(column, $appLink.data('ref'));\n      } else {\n        var row = $row.data('row');\n\n        this._triggerRowClick(row, mouseButton);\n      }\n    }\n  }, {\n    key: \"_onRowDoubleClick\",\n    value: function _onRowDoubleClick(event) {\n      var $row = $(event.currentTarget),\n          column = this._columnAtX(event.pageX);\n\n      this.doRowAction($row.data('row'), column);\n    }\n  }, {\n    key: \"showContextMenu\",\n    value: function showContextMenu(options) {\n      this.session.onRequestsDone(this._showContextMenu.bind(this, options));\n    }\n  }, {\n    key: \"_showContextMenu\",\n    value: function _showContextMenu(options) {\n      options = options || {};\n\n      if (!this._isDataRendered() || !this.attached) {\n        // check needed because function is called asynchronously\n        return;\n      }\n\n      if (this.selectedRows.length === 0) {\n        return;\n      }\n\n      var menuItems = this._filterMenusForContextMenu();\n\n      if (menuItems.length === 0) {\n        return;\n      }\n\n      var pageX = scout.nvl(options.pageX, null);\n      var pageY = scout.nvl(options.pageY, null);\n\n      if (pageX === null || pageY === null) {\n        var rowToDisplay = this.isRowSelectedAndVisible(this.selectionHandler.lastActionRow) ? this.selectionHandler.lastActionRow : this.getLastSelectedAndVisibleRow();\n\n        if (rowToDisplay !== null) {\n          var $rowToDisplay = rowToDisplay.$row;\n          var offset = $rowToDisplay.offset();\n          var dataOffsetBounds = graphics.offsetBounds(this.$data);\n          offset.left += this.$data.scrollLeft();\n          pageX = offset.left + 10;\n          pageY = offset.top + $rowToDisplay.outerHeight() / 2;\n          pageY = Math.min(Math.max(pageY, dataOffsetBounds.y + 1), dataOffsetBounds.bottom() - 1);\n        } else {\n          pageX = this.$data.offset().left + 10;\n          pageY = this.$data.offset().top + 10;\n        }\n      } // Prevent firing of 'onClose'-handler during contextMenu.open()\n      // (Can lead to null-access when adding a new handler to this.contextMenu)\n\n\n      if (this.contextMenu) {\n        this.contextMenu.close();\n      }\n\n      this.contextMenu = scout.create('ContextMenuPopup', {\n        parent: this,\n        menuItems: menuItems,\n        location: {\n          x: pageX,\n          y: pageY\n        },\n        $anchor: this.$data,\n        menuFilter: this._filterMenusHandler\n      });\n      this.contextMenu.open();\n    }\n  }, {\n    key: \"isRowSelectedAndVisible\",\n    value: function isRowSelectedAndVisible(row) {\n      if (!this.isRowSelected(row) || !row.$row) {\n        return false;\n      }\n\n      return graphics.offsetBounds(row.$row).intersects(graphics.offsetBounds(this.$data));\n    }\n  }, {\n    key: \"getLastSelectedAndVisibleRow\",\n    value: function getLastSelectedAndVisibleRow() {\n      for (var i = this.viewRangeRendered.to; i >= this.viewRangeRendered.from; i--) {\n        if (this.isRowSelectedAndVisible(this.rows[i])) {\n          return this.rows[i];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"onColumnVisibilityChanged\",\n    value: function onColumnVisibilityChanged(column) {\n      this.columnLayoutDirty = true;\n\n      if (this._isDataRendered()) {\n        this._updateRowWidth();\n\n        this._redraw();\n\n        this.invalidateLayoutTree();\n      }\n\n      this.trigger('columnStructureChanged');\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll() {\n      var scrollTop = this.$data[0].scrollTop;\n      var scrollLeft = this.$data[0].scrollLeft;\n\n      if (this.scrollTop !== scrollTop) {\n        this._renderViewport();\n      }\n\n      this.scrollTop = scrollTop;\n      this.scrollLeft = scrollLeft;\n    }\n  }, {\n    key: \"_renderTableStatus\",\n    value: function _renderTableStatus() {\n      this.trigger('statusChanged');\n    }\n  }, {\n    key: \"setContextColumn\",\n    value: function setContextColumn(contextColumn) {\n      this.setProperty('contextColumn', contextColumn);\n    }\n  }, {\n    key: \"_hasVisibleTableControls\",\n    value: function _hasVisibleTableControls() {\n      return this.tableControls.some(function (control) {\n        return control.visible;\n      });\n    }\n  }, {\n    key: \"hasAggregateTableControl\",\n    value: function hasAggregateTableControl() {\n      return this.tableControls.some(function (control) {\n        return control instanceof AggregateTableControl;\n      });\n    }\n  }, {\n    key: \"_createHeader\",\n    value: function _createHeader() {\n      return scout.create('TableHeader', {\n        parent: this,\n        table: this,\n        enabled: this.headerEnabled,\n        headerMenusEnabled: this.headerMenusEnabled\n      });\n    }\n  }, {\n    key: \"_createFooter\",\n    value: function _createFooter() {\n      return scout.create('TableFooter', {\n        parent: this,\n        table: this\n      });\n    }\n  }, {\n    key: \"_installCellTooltipSupport\",\n    value: function _installCellTooltipSupport() {\n      tooltips_1.install(this.$data, {\n        parent: this,\n        selector: '.table-cell',\n        text: this._cellTooltipText.bind(this),\n        htmlEnabled: this._isAggregatedTooltip.bind(this),\n        arrowPosition: 50,\n        arrowPositionUnit: '%',\n        nativeTooltip: !Device.get().isCustomEllipsisTooltipPossible()\n      });\n    }\n  }, {\n    key: \"_uninstallCellTooltipSupport\",\n    value: function _uninstallCellTooltipSupport() {\n      tooltips_1.uninstall(this.$data);\n    }\n  }, {\n    key: \"_cellTooltipText\",\n    value: function _cellTooltipText($cell) {\n      var cell,\n          tooltipText,\n          $row = $cell.parent(),\n          column = this.columnFor$Cell($cell, $row),\n          row = $row.data('row');\n\n      if (row) {\n        cell = this.cell(column, row);\n        tooltipText = cell.tooltipText;\n      }\n\n      if (tooltipText) {\n        return tooltipText;\n      } else if ($row.data('aggregateRow') && $cell.text().trim() && ($cell.isContentTruncated() || $cell.children('.table-cell-icon').length && !$cell.children('.table-cell-icon').isVisible())) {\n        $cell = $cell.clone();\n        $cell.children('.table-cell-icon').setVisible(true);\n        return $cell.html();\n      } else if (this._isTruncatedCellTooltipEnabled(column) && $cell.isContentTruncated()) {\n        return strings.plainText($cell.html(), {\n          trim: true\n        });\n      }\n    }\n  }, {\n    key: \"setTruncatedCellTooltipEnabled\",\n    value: function setTruncatedCellTooltipEnabled(truncatedCellTooltipEnabled) {\n      this.setProperty('truncatedCellTooltipEnabled', truncatedCellTooltipEnabled);\n    }\n    /**\n     * Decides if a cell tooltip should be shown for a truncated cell.\n     */\n\n  }, {\n    key: \"_isTruncatedCellTooltipEnabled\",\n    value: function _isTruncatedCellTooltipEnabled(column) {\n      if (this.truncatedCellTooltipEnabled === null) {\n        // Show cell tooltip only if it is not possible to resize the column.\n        return !this.headerVisible || !this.headerEnabled || column.fixedWidth;\n      }\n\n      return this.truncatedCellTooltipEnabled;\n    }\n  }, {\n    key: \"_isAggregatedTooltip\",\n    value: function _isAggregatedTooltip($cell) {\n      var $row = $cell.parent();\n\n      if ($row.data('aggregateRow')) {\n        return true;\n      }\n    }\n  }, {\n    key: \"reload\",\n    value: function reload(reloadReason) {\n      if (!this.hasReloadHandler) {\n        return;\n      }\n\n      this._removeRows();\n\n      if (this._isDataRendered()) {\n        this._removeAggregateRows();\n\n        this._renderFiller();\n      }\n\n      this._triggerReload(reloadReason);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"setLoading\",\n    value: function setLoading(loading) {\n      if (!loading && this.updateBuffer.isBuffering()) {\n        // Don't abort loading while buffering, the buffer will do it at the end\n        return;\n      }\n\n      _get(_getPrototypeOf(Table.prototype), \"setLoading\", this).call(this, loading);\n    }\n  }, {\n    key: \"exportToClipboard\",\n    value: function exportToClipboard() {\n      this._triggerClipboardExport();\n    }\n    /**\n     * JS implementation of AbstractTable.execCopy(rows)\n     */\n\n  }, {\n    key: \"_exportToClipboard\",\n    value: function _exportToClipboard() {\n      clipboard.copyText({\n        parent: this,\n        text: this._selectedRowsToText()\n      });\n    }\n  }, {\n    key: \"_selectedRowsToText\",\n    value: function _selectedRowsToText() {\n      var _this2 = this;\n\n      var columns = this.visibleColumns();\n      return this.selectedRows.map(function (row) {\n        return columns.map(function (column) {\n          var cell = column.cell(row);\n          var text;\n\n          if (column instanceof BooleanColumn) {\n            text = cell.value ? 'X' : '';\n          } else if (cell.htmlEnabled) {\n            text = strings.plainText(cell.text);\n          } else {\n            text = cell.text;\n          } // unwrap\n\n\n          return _this2._unwrapText(text);\n        }).join('\\t');\n      }).join('\\n');\n    }\n  }, {\n    key: \"_unwrapText\",\n    value: function _unwrapText(text) {\n      // Same implementation as in AbstractTable#unwrapText(String)\n      return strings.nvl(text).split(/[\\n\\r]/).map(function (line) {\n        return line.replace(/\\t/g, ' ');\n      }).map(function (line) {\n        return line.trim();\n      }).filter(function (line) {\n        return !!line.length;\n      }).join(' ');\n    }\n  }, {\n    key: \"setMultiSelect\",\n    value: function setMultiSelect(multiSelect) {\n      this.setProperty('multiSelect', multiSelect);\n    }\n  }, {\n    key: \"toggleSelection\",\n    value: function toggleSelection() {\n      if (this.selectedRows.length === this.visibleRows.length) {\n        this.deselectAll();\n      } else {\n        this.selectAll();\n      }\n    }\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      this.selectRows(this.visibleRows);\n    }\n  }, {\n    key: \"deselectAll\",\n    value: function deselectAll() {\n      this.selectRows([]);\n    }\n  }, {\n    key: \"checkAll\",\n    value: function checkAll(checked, options) {\n      var opts = $.extend(options, {\n        checked: checked\n      });\n      this.checkRows(this.visibleRows, opts);\n    }\n  }, {\n    key: \"uncheckAll\",\n    value: function uncheckAll(options) {\n      this.checkAll(false, options);\n    }\n  }, {\n    key: \"updateScrollbars\",\n    value: function updateScrollbars() {\n      scrollbars.update(this.$data);\n    }\n  }, {\n    key: \"_sort\",\n    value: function _sort(animateAggregateRows) {\n      var sortColumns = this._sortColumns(); // Initialize comparators\n\n\n      if (!this._isSortingPossible(sortColumns)) {\n        return false;\n      }\n\n      this.clearAggregateRows(animateAggregateRows);\n\n      if (!sortColumns.length) {\n        // no sort column defined.\n        return true;\n      } // add all visible columns as fallback sorting to guarantee same sorting as in Java.\n\n\n      sortColumns = arrays.union(sortColumns, this.columns);\n\n      this._sortImpl(sortColumns);\n\n      this._triggerRowOrderChanged();\n\n      if (this._isDataRendered()) {\n        this._renderRowOrderChanges();\n      } // Do it after row order has been rendered, because renderRowOrderChanges rerenders the whole viewport which would destroy the animation\n\n\n      this._group(animateAggregateRows); // Sort was possible -> return true\n\n\n      return true;\n    }\n    /**\n     * @returns whether or not sorting is possible. Asks each column to answer this question by calling Column#isSortingPossible.\n     */\n\n  }, {\n    key: \"_isSortingPossible\",\n    value: function _isSortingPossible(sortColumns) {\n      return sortColumns.every(function (column) {\n        return column.isSortingPossible();\n      });\n    }\n  }, {\n    key: \"_sortColumns\",\n    value: function _sortColumns() {\n      var sortColumns = [];\n\n      for (var c = 0; c < this.columns.length; c++) {\n        var column = this.columns[c];\n        var sortIndex = column.sortIndex;\n\n        if (sortIndex >= 0) {\n          sortColumns[sortIndex] = column;\n        }\n      }\n\n      return sortColumns;\n    }\n  }, {\n    key: \"_sortImpl\",\n    value: function _sortImpl(sortColumns) {\n      var sortFunction = function sortFunction(row1, row2) {\n        for (var s = 0; s < sortColumns.length; s++) {\n          var column = sortColumns[s];\n          var result = column.compare(row1, row2);\n\n          if (column.sortActive && !column.sortAscending) {\n            // only consider sortAscending flag when sort is active\n            // columns with !sortActive are always sorted ascending (sortAscending represents last state for those, thus not considered)\n            result = -result;\n          }\n\n          if (result !== 0) {\n            return result;\n          }\n        }\n\n        return 0;\n      };\n\n      if (this.hierarchical) {\n        // sort tree and set flat row array afterwards.\n        this._sortHierarchical(sortFunction);\n\n        var sortedFlatRows = [];\n        this.visitRows(function (row) {\n          sortedFlatRows.push(row);\n        });\n        this.rows = sortedFlatRows;\n      } else {\n        // sort the flat rows and set the rootRows afterwards.\n        this.rows.sort(sortFunction);\n        this.rootRows = this.rows;\n      }\n\n      this._updateRowStructure({\n        filteredRows: true,\n        applyFilters: false,\n        visibleRows: true\n      });\n    }\n    /**\n     * Pre-order (top-down) traversal of all rows in this table (if hierarchical).\n     */\n\n  }, {\n    key: \"visitRows\",\n    value: function visitRows(visitFunc, rows, level) {\n      level = scout.nvl(level, 0);\n      rows = rows || this.rootRows;\n      rows.forEach(function (row) {\n        visitFunc(row, level);\n        this.visitRows(visitFunc, row.childRows, level + 1);\n      }, this);\n    }\n  }, {\n    key: \"_sortHierarchical\",\n    value: function _sortHierarchical(sortFunc, rows) {\n      rows = rows || this.rootRows;\n      rows.sort(sortFunc);\n      rows.forEach(function (row) {\n        this._sortHierarchical(sortFunc, row.childRows);\n      }, this);\n    }\n  }, {\n    key: \"_renderRowOrderChanges\",\n    value: function _renderRowOrderChanges() {\n      var animate,\n          $rows = this.$rows(),\n          oldRowPositions = {}; // store old position\n      // animate only if every row is rendered, otherwise some rows would be animated and some not\n\n      if ($rows.length === this.visibleRows.length) {\n        $rows.each(function (index, elem) {\n          var rowWasInserted = false,\n              $row = $(elem),\n              row = $row.data('row'); // Prevent the order animation for newly inserted rows (to not confuse the user)\n\n          if (this._insertedRows) {\n            for (var i = 0; i < this._insertedRows.length; i++) {\n              if (this._insertedRows[i].id === row.id) {\n                rowWasInserted = true;\n                break;\n              }\n            }\n          }\n\n          if (!rowWasInserted) {\n            animate = true;\n            oldRowPositions[row.id] = $row.offset().top;\n          }\n        }.bind(this));\n      }\n\n      this._rerenderViewport(); // If aggregate rows are being removed by animation, rerenderViewport does not delete them -> reorder\n      // This may happen if grouping gets deactivated and another column will get the new first sort column\n\n\n      this._order$AggregateRows(); // Ensure selected row is visible after ordering\n\n\n      if (this.scrollToSelection) {\n        this.revealSelection();\n      } // for less than animationRowLimit rows: move to old position and then animate\n\n\n      if (animate) {\n        $rows = this.$rows();\n        $rows.each(function (index, elem) {\n          var $row = $(elem),\n              row = $row.data('row'),\n              oldTop = oldRowPositions[row.id];\n\n          if (oldTop !== undefined) {\n            $row.css('top', oldTop - $row.offset().top).animate({\n              top: 0\n            }, {\n              progress: function () {\n                this._triggerRowOrderChanged(row, true);\n\n                this.updateScrollbars();\n              }.bind(this)\n            });\n          }\n        }.bind(this));\n      }\n    }\n  }, {\n    key: \"setSortEnabled\",\n    value: function setSortEnabled(sortEnabled) {\n      this.setProperty('sortEnabled', sortEnabled);\n    }\n    /**\n     * @param multiSort true to add the column to list of sorted columns. False to use this column exclusively as sort column (reset other columns)\n     * @param remove true to remove the column from the sort columns\n     */\n\n  }, {\n    key: \"sort\",\n    value: function sort(column, direction, multiSort, remove) {\n      var data, sorted, animateAggregateRows;\n      multiSort = scout.nvl(multiSort, false);\n      remove = scout.nvl(remove, false); // Animate if sort removes aggregate rows\n\n      animateAggregateRows = !multiSort;\n\n      if (remove) {\n        this._removeSortColumn(column);\n      } else {\n        this._addSortColumn(column, direction, multiSort);\n      }\n\n      if (this.header) {\n        this.header.onSortingChanged();\n      }\n\n      sorted = this._sort(animateAggregateRows);\n      data = {\n        column: column,\n        sortAscending: column.sortAscending\n      };\n\n      if (remove) {\n        data.sortingRemoved = true;\n      }\n\n      if (multiSort) {\n        data.multiSort = true;\n      }\n\n      if (!sorted) {\n        // Delegate sorting to server when it is not possible on client side\n        data.sortingRequested = true; // hint to animate the aggregate after the row order changed event\n\n        this._animateAggregateRows = animateAggregateRows;\n      }\n\n      this.trigger('sort', data);\n    }\n  }, {\n    key: \"_addSortColumn\",\n    value: function _addSortColumn(column, direction, multiSort) {\n      var groupColCount, sortColCount;\n      direction = scout.nvl(direction, column.sortAscending ? 'asc' : 'desc');\n      multiSort = scout.nvl(multiSort, true);\n\n      this._updateSortIndexForColumn(column, multiSort); // Reset grouped flag if column should be sorted exclusively\n\n\n      if (!multiSort) {\n        groupColCount = this._groupedColumns().length;\n        sortColCount = this._sortColumns().length;\n\n        if (sortColCount === 1 && groupColCount === 1) {// special case: if it is the only sort column and also grouped, do not remove grouped property.\n        } else {\n          column.grouped = false;\n        }\n      }\n\n      column.sortAscending = direction === 'asc';\n      column.sortActive = true;\n    }\n    /**\n     * Intended to be called for new sort columns.\n     * Sets the sortIndex of the given column and its siblings.\n     */\n\n  }, {\n    key: \"_updateSortIndexForColumn\",\n    value: function _updateSortIndexForColumn(column, multiSort) {\n      var deviation,\n          sortIndex = -1;\n\n      if (multiSort) {\n        // if not already sorted set the appropriate sort index (check for sortIndex necessary if called by _onColumnHeadersUpdated)\n        if (!column.sortActive || column.sortIndex === -1) {\n          sortIndex = Math.max(-1, arrays.max(this.columns.map(function (c) {\n            return c.sortIndex === undefined || c.initialAlwaysIncludeSortAtEnd ? -1 : c.sortIndex;\n          })));\n          column.sortIndex = sortIndex + 1; // increase sortIndex for all permanent tail columns (a column has been added in front of them)\n\n          this._permanentTailSortColumns.forEach(function (c) {\n            c.sortIndex++;\n          });\n        }\n      } else {\n        // do not update sort index for permanent head/tail sort columns, their order is fixed (see ColumnSet.java)\n        if (!(column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd)) {\n          column.sortIndex = this._permanentHeadSortColumns.length;\n        } // remove sort index for siblings (ignore permanent head/tail columns, only if not multi sort)\n\n\n        arrays.eachSibling(this.columns, column, function (siblingColumn) {\n          if (siblingColumn.sortActive) {\n            this._removeSortColumnInternal(siblingColumn);\n          }\n        }.bind(this)); // set correct sort index for all permanent tail sort columns\n\n        deviation = column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd ? 0 : 1;\n\n        this._permanentTailSortColumns.forEach(function (c, index) {\n          c.sortIndex = this._permanentHeadSortColumns.length + deviation + index;\n        }, this);\n      }\n    }\n  }, {\n    key: \"_removeSortColumn\",\n    value: function _removeSortColumn(column) {\n      if (column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd) {\n        return;\n      } // Adjust sibling columns with higher index\n\n\n      arrays.eachSibling(this.columns, column, function (siblingColumn) {\n        if (siblingColumn.sortIndex > column.sortIndex) {\n          siblingColumn.sortIndex = siblingColumn.sortIndex - 1;\n        }\n      });\n\n      this._removeSortColumnInternal(column);\n    }\n  }, {\n    key: \"_removeSortColumnInternal\",\n    value: function _removeSortColumnInternal(column) {\n      if (column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd) {\n        return;\n      }\n\n      column.sortActive = false;\n      column.grouped = false;\n      column.sortIndex = -1;\n    }\n  }, {\n    key: \"isGroupingPossible\",\n    value: function isGroupingPossible(column) {\n      var possible = true;\n\n      if (this.hierarchical) {\n        return false;\n      }\n\n      if (!this.sortEnabled) {\n        // grouping without sorting is not possible\n        return false;\n      }\n\n      if (this._permanentHeadSortColumns && this._permanentHeadSortColumns.length === 0) {\n        // no permanent head sort columns. grouping ok.\n        return true;\n      }\n\n      if (column.initialAlwaysIncludeSortAtBegin) {\n        possible = true;\n        arrays.eachSibling(this._permanentHeadSortColumns, column, function (c) {\n          if (c.sortIndex < column.sortIndex) {\n            possible = possible && c.grouped;\n          }\n        });\n        return possible;\n      }\n\n      if (column.initialAlwaysIncludeSortAtEnd) {\n        // it is a tail sort column. Grouping does not make sense.\n        return false;\n      } // column itself is not a head or tail sort column. Therefore, all head sort columns must be grouped.\n\n\n      this._permanentHeadSortColumns.forEach(function (c) {\n        possible = possible && c.grouped;\n      });\n\n      return possible;\n    }\n  }, {\n    key: \"isAggregationPossible\",\n    value: function isAggregationPossible(column) {\n      if (!(column instanceof NumberColumn)) {\n        return false;\n      }\n\n      if (column.grouped) {\n        // Aggregation is not possible if column is grouped\n        return false;\n      }\n\n      if (!column.allowedAggregationFunctions || column.allowedAggregationFunctions.length <= 1) {\n        // Aggregation is not possible if no aggregation functions are allowed or only exactly one aggregation is pre-defined.\n        return false;\n      } // Aggregation is possible if it is grouped by another column or aggregation control is available\n\n\n      return this.isGrouped() || this.hasAggregateTableControl();\n    }\n  }, {\n    key: \"changeAggregation\",\n    value: function changeAggregation(column, func) {\n      this.changeAggregations([column], [func]);\n    }\n  }, {\n    key: \"changeAggregations\",\n    value: function changeAggregations(columns, functions) {\n      columns.forEach(function (column, i) {\n        var func = functions[i];\n\n        if (column.aggregationFunction !== func) {\n          column.setAggregationFunction(func);\n\n          this._triggerAggregationFunctionChanged(column);\n        }\n      }, this);\n\n      this._group();\n    }\n  }, {\n    key: \"_addGroupColumn\",\n    value: function _addGroupColumn(column, direction, multiGroup) {\n      var sortIndex = -1;\n\n      if (!this.isGroupingPossible(column)) {\n        return;\n      }\n\n      direction = scout.nvl(direction, column.sortAscending ? 'asc' : 'desc');\n      multiGroup = scout.nvl(multiGroup, true);\n\n      if (!(column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd)) {\n        // do not update sort index for permanent head/tail sort columns, their order is fixed (see ColumnSet.java)\n        if (multiGroup) {\n          sortIndex = Math.max(-1, arrays.max(this.columns.map(function (c) {\n            return c.sortIndex === undefined || c.initialAlwaysIncludeSortAtEnd || !c.grouped ? -1 : c.sortIndex;\n          })));\n\n          if (!column.sortActive) {\n            // column was not yet present: insert at determined position\n            // and move all subsequent nodes by one.\n            // add just after all other grouping columns in column set.\n            column.sortIndex = sortIndex + 1;\n            arrays.eachSibling(this.columns, column, function (siblingColumn) {\n              if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex > sortIndex) {\n                siblingColumn.sortIndex++;\n              }\n            }); // increase sortIndex for all permanent tail columns (a column has been added in front of them)\n\n            this._permanentTailSortColumns.forEach(function (c) {\n              c.sortIndex++;\n            });\n          } else {\n            // column already sorted, update position:\n            // move all sort columns between the newly determined sortindex and the old sortindex by one.\n            arrays.eachSibling(this.columns, column, function (siblingColumn) {\n              if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex > sortIndex && siblingColumn.sortIndex < column.sortIndex) {\n                siblingColumn.sortIndex++;\n              }\n            });\n            column.sortIndex = sortIndex + 1;\n          }\n        } else {\n          // no multigroup:\n          sortIndex = this._permanentHeadSortColumns.length;\n\n          if (column.sortActive) {\n            // column already sorted, update position:\n            // move all sort columns between the newly determined sortindex and the old sortindex by one.\n            arrays.eachSibling(this.columns, column, function (siblingColumn) {\n              if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex >= sortIndex && siblingColumn.sortIndex < column.sortIndex) {\n                siblingColumn.sortIndex++;\n              }\n            });\n            column.sortIndex = sortIndex;\n          } else {\n            // not sorted yet\n            arrays.eachSibling(this.columns, column, function (siblingColumn) {\n              if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex >= sortIndex) {\n                siblingColumn.sortIndex++;\n              }\n            });\n            column.sortIndex = sortIndex; // increase sortIndex for all permanent tail columns (a column has been added in front of them)\n\n            this._permanentTailSortColumns.forEach(function (c) {\n              c.sortIndex++;\n            });\n          } // remove all other grouped properties:\n\n\n          arrays.eachSibling(this.columns, column, function (siblingColumn) {\n            if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex >= sortIndex) {\n              siblingColumn.grouped = false;\n            }\n          });\n        }\n\n        column.sortAscending = direction === 'asc';\n        column.sortActive = true;\n      } else if (column.initialAlwaysIncludeSortAtBegin) {\n        // do not change order or direction. just set grouped to true.\n        column.grouped = true;\n      }\n\n      column.grouped = true;\n    }\n  }, {\n    key: \"_removeGroupColumn\",\n    value: function _removeGroupColumn(column) {\n      column.grouped = false;\n\n      if (column.initialAlwaysIncludeSortAtBegin) {\n        // head sort case: remove all groupings after this column.\n        this.columns.forEach(function (c) {\n          if (c.sortIndex >= column.sortIndex) {\n            c.grouped = false;\n          }\n        });\n      }\n\n      this._removeSortColumn(column);\n    }\n  }, {\n    key: \"_buildRowDiv\",\n    value: function _buildRowDiv(row) {\n      var rowWidth = this.rowWidth;\n      var rowClass = 'table-row';\n\n      if (row.cssClass) {\n        rowClass += ' ' + row.cssClass;\n      }\n\n      if (!row.enabled) {\n        rowClass += ' disabled';\n      }\n\n      if (row.checked && this.checkableStyle === Table.CheckableStyle.TABLE_ROW) {\n        rowClass += ' checked';\n      } // if a row is not filterAccepted it must be visible since any of its child rows are filter accepted.\n\n\n      if (!row.filterAccepted) {\n        rowClass += ' filter-not-accepted';\n      }\n\n      if (arrays.empty(row.childRows)) {\n        rowClass += ' leaf';\n      }\n\n      var i,\n          column,\n          rowDiv = '<div class=\"' + rowClass + '\" style=\"width: ' + rowWidth + 'px\">';\n\n      for (i = 0; i < this.columns.length; i++) {\n        column = this.columns[i];\n\n        if (column.isVisible()) {\n          rowDiv += column.buildCellForRow(row);\n        }\n      }\n\n      rowDiv += '</div>';\n      return rowDiv;\n    }\n  }, {\n    key: \"_calculateRowBorderWidth\",\n    value: function _calculateRowBorderWidth() {\n      var $tableRowDummy = this.$data.appendDiv('table-row');\n      this.rowBorderLeftWidth = $tableRowDummy.cssBorderLeftWidth();\n      this.rowBorderRightWidth = $tableRowDummy.cssBorderRightWidth();\n      this.rowBorderWidth = this.rowBorderLeftWidth + this.rowBorderRightWidth;\n      $tableRowDummy.remove();\n    }\n  }, {\n    key: \"_updateRowWidth\",\n    value: function _updateRowWidth() {\n      this.rowWidth = this.visibleColumns().reduce(function (sum, column) {\n        if (this.autoResizeColumns) {\n          return sum + column.width;\n        } // Ensure the row is as long as all cells. Only necessary to use the _realWidth if the device.hasTableCellZoomBug().\n        // If autoResizeColumns is enabled, it is not possible to do a proper calculation with this bug\n        // -> Use regular width and live with the consequence that the last cell of a table with many columns is not fully visible\n\n\n        return sum + column._realWidthIfAvailable();\n      }.bind(this), this.rowBorderWidth);\n    }\n    /**\n     * A html element with display: table-cell gets the wrong width in Chrome when zoom is enabled, see\n     * https://bugs.chromium.org/p/chromium/issues/detail?id=740502.\n     * Because the table header items don't use display: table-cell, theirs width is correct.\n     * -> Header items and table cells are not in sync which is normally not a big deal but gets visible very well with a lot of columns.\n     * This method reads the real width and stores it on the column so that the header can use it when setting the header item's size.\n     * It is also necessary to update the row width accordingly otherwise it would be cut at the very right.\n     */\n\n  }, {\n    key: \"_updateRealColumnWidths\",\n    value: function _updateRealColumnWidths($row) {\n      if (!Device.get().hasTableCellZoomBug()) {\n        return false;\n      }\n\n      var changed = false;\n      $row = $row || this.$rows().eq(0);\n      this.visibleColumns().forEach(function (column, colIndex) {\n        if (this._updateRealColumnWidth(column, colIndex, $row)) {\n          changed = true;\n        }\n      }, this);\n      return changed;\n    }\n  }, {\n    key: \"_updateRealColumnWidth\",\n    value: function _updateRealColumnWidth(column, colIndex, $row) {\n      if (!Device.get().hasTableCellZoomBug()) {\n        return false;\n      }\n\n      $row = $row || this.$rows().eq(0);\n      var $cell = this.$cell(scout.nvl(colIndex, column), $row);\n\n      if ($cell.length === 0 && column._realWidth !== null) {\n        column._realWidth = null;\n        return true;\n      }\n\n      var realWidth = graphics.size($cell, {\n        exact: true\n      }).width;\n\n      if (realWidth !== column._realWidth) {\n        column._realWidth = realWidth;\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_updateRowHeight\",\n    value: function _updateRowHeight() {\n      var $emptyRow = this.$data.appendDiv('table-row');\n      var $emptyAggrRow = this.$data.appendDiv('table-aggregate-row');\n      $emptyRow.appendDiv('table-cell').html('&nbsp;');\n      $emptyAggrRow.appendDiv('table-cell').html('&nbsp;');\n      this.rowHeight = $emptyRow.outerHeight(true);\n      this.aggregateRowHeight = $emptyAggrRow.outerHeight(true);\n      $emptyRow.remove();\n      $emptyAggrRow.remove();\n    }\n    /**\n     * Updates the row heights for every visible row and aggregate row and clears the height of the others\n     */\n\n  }, {\n    key: \"_updateRowHeights\",\n    value: function _updateRowHeights() {\n      this.rows.forEach(function (row) {\n        if (!row.$row) {\n          row.height = null;\n        } else {\n          row.height = row.$row.outerHeight(true);\n        }\n      });\n\n      this._aggregateRows.forEach(function (aggregateRow) {\n        if (!aggregateRow.$row) {\n          aggregateRow.height = null;\n        } else {\n          aggregateRow.height = aggregateRow.$row.outerHeight(true);\n        }\n      });\n    }\n  }, {\n    key: \"_renderRowsInRange\",\n    value: function _renderRowsInRange(range) {\n      var $rows,\n          rowString = '',\n          numRowsRendered = 0,\n          prepend = false;\n      var rows = this.visibleRows;\n\n      if (rows.length === 0) {\n        return;\n      }\n\n      var maxRange = new Range(0, this.rows.length);\n      range = maxRange.intersect(range);\n\n      if (this.viewRangeRendered.size() > 0 && !range.intersect(this.viewRangeRendered).equals(new Range(0, 0))) {\n        throw new Error('New range must not intersect with existing.');\n      }\n\n      if (range.to <= this.viewRangeRendered.from) {\n        prepend = true;\n      }\n\n      var newRange = this.viewRangeRendered.union(range);\n\n      if (newRange.length === 2) {\n        throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n      }\n\n      this.viewRangeRendered = newRange[0];\n\n      this._removeEmptyData(); // Build $rows (as string instead of jQuery objects due to efficiency reasons)\n\n\n      for (var r = range.from; r < range.to; r++) {\n        var row = rows[r];\n        rowString += this._buildRowDiv(row);\n        numRowsRendered++;\n      } // append block of rows\n\n\n      $rows = this.$data.makeElement(rowString);\n\n      if (prepend) {\n        if (this.$fillBefore) {\n          $rows = $rows.insertAfter(this.$fillBefore);\n        } else {\n          $rows = $rows.prependTo(this.$data);\n        }\n      } else if (this.$fillAfter) {\n        $rows = $rows.insertBefore(this.$fillAfter);\n      } else {\n        $rows = $rows.appendTo(this.$data);\n      }\n\n      $rows.each(function (index, rowObject) {\n        var $row = $(rowObject); // Workaround for Chrome bug, see _updateRealColumnWidths\n        // Can be removed when Chrome bug is resolved.\n        // This is only necessary once (when the first row is rendered)\n\n        if (this.viewRangeRendered.size() === numRowsRendered && this._updateRealColumnWidths($row)) {\n          this._updateRowWidth();\n\n          if (this.header && this.header.rendered) {\n            this.header.resizeHeaderItems();\n          }\n        }\n\n        $row.cssWidth(this.rowWidth); // End workaround\n\n        var row = rows[range.from + index];\n        Table.linkRowToDiv(row, $row);\n\n        this._installRow(row);\n      }.bind(this));\n\n      if ($.log.isTraceEnabled()) {\n        $.log.trace(numRowsRendered + ' new rows rendered from ' + range);\n        $.log.trace(this._rowsRenderedInfo());\n      }\n    }\n  }, {\n    key: \"_rowsRenderedInfo\",\n    value: function _rowsRenderedInfo() {\n      var numRenderedRows = this.$rows().length,\n          renderedRowsRange = '(' + this.viewRangeRendered + ')';\n      return numRenderedRows + ' rows rendered ' + renderedRowsRange;\n    }\n    /**\n     * Moves the row to the top.\n     */\n\n  }, {\n    key: \"moveRowToTop\",\n    value: function moveRowToTop(row) {\n      var rowIndex = this.rows.indexOf(row);\n      this.moveRow(rowIndex, 0);\n    }\n    /**\n     * Moves the row to the bottom.\n     */\n\n  }, {\n    key: \"moveRowToBottom\",\n    value: function moveRowToBottom(row) {\n      var rowIndex = this.rows.indexOf(row);\n      this.moveRow(rowIndex, this.rows.length - 1);\n    }\n    /**\n     * Moves the row one up, disregarding filtered rows.\n     */\n\n  }, {\n    key: \"moveRowUp\",\n    value: function moveRowUp(row) {\n      var rowIndex = this.rows.indexOf(row),\n          targetIndex = rowIndex - 1;\n\n      if (this.hierarchical) {\n        // find index with same parent\n        var siblings = this.rows.filter(function (candidate) {\n          return row.parentRow === candidate.parentRow;\n        }, this),\n            rowIndexSiblings = siblings.indexOf(row),\n            sibling = siblings[rowIndexSiblings - 1];\n\n        if (sibling) {\n          targetIndex = this.rows.indexOf(sibling);\n        } else {\n          targetIndex = 0;\n        }\n      }\n\n      this.moveRow(rowIndex, targetIndex);\n    }\n    /**\n     * Moves the row one down, disregarding filtered rows.\n     */\n\n  }, {\n    key: \"moveRowDown\",\n    value: function moveRowDown(row) {\n      var rowIndex = this.rows.indexOf(row),\n          targetIndex = rowIndex + 1;\n\n      if (this.hierarchical) {\n        // find index with same parent\n        var siblings = this.rows.filter(function (candidate) {\n          return row.parentRow === candidate.parentRow;\n        }, this),\n            rowIndexSiblings = siblings.indexOf(row),\n            sibling = siblings[rowIndexSiblings + 1];\n\n        if (sibling) {\n          targetIndex = this.rows.indexOf(sibling);\n        } else {\n          targetIndex = this.rows.length;\n        }\n      }\n\n      this.moveRow(rowIndex, targetIndex);\n    }\n    /**\n     * Moves the row one up with respected to filtered rows. Row must be one of the filtered rows.\n     * @deprecated use moveVisibleRowUp instead\n     */\n\n  }, {\n    key: \"moveFilteredRowUp\",\n    value: function moveFilteredRowUp(row) {\n      this.moveVisibleRowUp(row);\n    }\n  }, {\n    key: \"moveVisibleRowUp\",\n    value: function moveVisibleRowUp(row) {\n      var rowIndex = this.rows.indexOf(row),\n          visibleIndex = this.visibleRows.indexOf(row),\n          sibling,\n          targetIndex;\n\n      if (this.hierarchical) {\n        var siblings = this.visibleRows.filter(function (candidate) {\n          return row.parentRow === candidate.parentRow;\n        }, this);\n        sibling = siblings[siblings.indexOf(row) - 1];\n\n        if (sibling) {\n          targetIndex = this.rows.indexOf(sibling);\n        } else {\n          // no previous sibling\n          return;\n        }\n      } else {\n        sibling = this.visibleRows[visibleIndex - 1];\n\n        if (!sibling) {\n          // no previous sibling\n          return;\n        }\n\n        targetIndex = this.rows.indexOf(sibling);\n      }\n\n      this.moveRow(rowIndex, targetIndex);\n    }\n    /**\n     * Moves the row one down with respected to filtered rows. Row must be one of the filtered rows.\n     * @deprecated use moveVisibleRowDown instead\n     */\n\n  }, {\n    key: \"moveFilteredRowDown\",\n    value: function moveFilteredRowDown(row) {\n      this.moveVisibleRowDown(row);\n    }\n  }, {\n    key: \"moveVisibleRowDown\",\n    value: function moveVisibleRowDown(row) {\n      var rowIndex = this.rows.indexOf(row),\n          visibleIndex = this.visibleRows.indexOf(row),\n          sibling,\n          targetIndex;\n\n      if (this.hierarchical) {\n        var siblings = this.visibleRows.filter(function (candidate) {\n          return row.parentRow === candidate.parentRow;\n        }, this);\n        sibling = siblings[siblings.indexOf(row) + 1];\n\n        if (sibling) {\n          targetIndex = this.rows.indexOf(sibling);\n        } else {\n          // no following sibling\n          return;\n        }\n      } else {\n        sibling = this.visibleRows[visibleIndex + 1];\n\n        if (!sibling) {\n          // no following sibling\n          return;\n        }\n\n        targetIndex = this.rows.indexOf(sibling);\n      }\n\n      this.moveRow(rowIndex, targetIndex);\n    }\n  }, {\n    key: \"moveRow\",\n    value: function moveRow(sourceIndex, targetIndex) {\n      var rowCount = this.rows.length;\n      sourceIndex = Math.max(sourceIndex, 0);\n      sourceIndex = Math.min(sourceIndex, rowCount - 1);\n      targetIndex = Math.max(targetIndex, 0);\n      targetIndex = Math.min(targetIndex, rowCount - 1);\n\n      if (sourceIndex === targetIndex) {\n        return;\n      }\n\n      arrays.move(this.rows, sourceIndex, targetIndex);\n      this.updateRowOrder(this.rows);\n    }\n  }, {\n    key: \"_removeRowsInRange\",\n    value: function _removeRowsInRange(range) {\n      var row,\n          i,\n          numRowsRemoved = 0,\n          rows = this.visibleRows;\n      var maxRange = new Range(0, rows.length);\n      range = maxRange.intersect(range);\n      var newRange = this.viewRangeRendered.subtract(range);\n\n      if (newRange.length === 2) {\n        throw new Error('Can only remove rows at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n      }\n\n      this.viewRangeRendered = newRange[0];\n\n      for (i = range.from; i < range.to; i++) {\n        row = rows[i];\n\n        this._removeRow(row);\n\n        numRowsRemoved++;\n      }\n\n      if ($.log.isTraceEnabled()) {\n        $.log.trace(numRowsRemoved + ' rows removed from ' + range + '.');\n        $.log.trace(this._rowsRenderedInfo());\n      }\n    }\n  }, {\n    key: \"removeAllRows\",\n    value: function removeAllRows() {\n      if (this._isDataRendered()) {\n        this.$rows().each(function (i, elem) {\n          var $row = $(elem),\n              row = $row.data('row');\n\n          if ($row.hasClass('hiding')) {\n            // Do not remove rows which are removed using an animation\n            // row.$row may already point to a new row -> don't call removeRow to not accidentally remove the new row\n            return;\n          }\n\n          this._removeRow(row);\n        }.bind(this));\n      }\n\n      this.viewRangeRendered = new Range(0, 0);\n    }\n    /**\n     *\n     * @param rows if undefined, all rows are removed\n     */\n\n  }, {\n    key: \"_removeRows\",\n    value: function _removeRows(rows) {\n      if (!rows) {\n        this.removeAllRows();\n        return;\n      }\n\n      var tableAttached = this.isAttachedAndRendered();\n      rows = arrays.ensure(rows);\n      rows.forEach(function (row) {\n        var rowIndex = this.visibleRows.indexOf(row);\n\n        if (rowIndex === -1) {\n          // row is not visible\n          return;\n        }\n\n        var rowRendered = Boolean(row.$row);\n        var rowInViewRange = this.viewRangeRendered.contains(rowIndex); // Note: these checks can only be done, when table is rendered _and_ attached. When the table is detached it can\n        // still add rows, but these new rows are not rendered while the table is detached. Thus this check would fail,\n        // when a row that has been added in detached state is removed again while table is still detached.\n\n        if (tableAttached) {\n          // if row is not rendered but its row-index is inside the view range -> inconsistency\n          if (!rowRendered && rowInViewRange) {\n            throw new Error('Inconsistency found while removing row. Row is undefined but inside rendered view range. RowIndex: ' + rowIndex);\n          } // if row is rendered but its row-index is not inside the view range -> inconsistency\n\n\n          if (rowRendered && !rowInViewRange) {\n            throw new Error('Inconsistency found while removing row. Row is rendered but not inside rendered view range. RowIndex: ' + rowIndex);\n          }\n        }\n\n        this._removeRow(row); // Adjust view range if row is inside or before range\n\n\n        if (rowInViewRange || rowIndex < this.viewRangeRendered.from) {\n          if (rowIndex < this.viewRangeRendered.from) {\n            this.viewRangeRendered.from--;\n            this.viewRangeRendered.to--;\n          } else if (rowIndex <= this.viewRangeRendered.to) {\n            this.viewRangeRendered.to--;\n          }\n        }\n      }.bind(this));\n    }\n    /**\n     * Just removes the row, does NOT adjust this.viewRangeRendered\n     */\n\n  }, {\n    key: \"_removeRow\",\n    value: function _removeRow(row) {\n      var $row = row.$row;\n\n      if (!$row) {\n        return;\n      }\n\n      this._destroyTooltipsForRow(row);\n\n      this._removeCellEditorForRow(row); // Do not remove rows which are removed using an animation\n\n\n      if (!$row.hasClass('hiding')) {\n        $row.remove();\n        row.$row = null;\n      }\n    }\n    /**\n     * Animates the rendering of a row by setting it to invisible before doing a slideDown animation. The row needs to already be rendered.\n     */\n\n  }, {\n    key: \"_showRow\",\n    value: function _showRow(row) {\n      var $row = row.$row;\n\n      if (!$row) {\n        return;\n      }\n\n      if ($row.is('.showing')) {\n        return;\n      }\n\n      $row.hide(); // intentionally don't use setVisible(false) here\n\n      $row.addClass('showing');\n      $row.removeClass('hiding');\n      $row.stop().slideDown({\n        duration: 250,\n        complete: function () {\n          $row.removeClass('showing');\n          this.updateScrollbars();\n        }.bind(this)\n      });\n    }\n    /**\n     * Animates the removal of a row by doing a slideUp animation. The row will be removed after the animation finishes.\n     */\n\n  }, {\n    key: \"_hideRow\",\n    value: function _hideRow(row) {\n      var $row = row.$row;\n\n      if (!$row) {\n        return;\n      }\n\n      if ($row.is('.hiding')) {\n        return;\n      }\n\n      $row.addClass('hiding');\n      $row.removeClass('showing');\n      $row.stop().slideUp({\n        duration: 250,\n        complete: function () {\n          if (!row.$row) {\n            // ignore already removed rows\n            return;\n          }\n\n          $row.remove();\n\n          if ($row[0] === row.$row[0]) {\n            // Only set to null if row still is linked to to original $row\n            // If row got rendered again while the animation is still running, row.$row points to the new $row\n            row.$row = null;\n          }\n\n          this.updateScrollbars();\n        }.bind(this)\n      });\n    }\n    /**\n     * This method should be used after a row is added to the DOM (new rows, updated rows). The 'row'\n     * is expected to be linked with the corresponding '$row' (row.$row and $row.data('row')).\n     */\n\n  }, {\n    key: \"_installRow\",\n    value: function _installRow(row) {\n      row.height = row.$row.outerHeight(true);\n\n      if (row.hasError) {\n        this._showCellErrorForRow(row);\n      } // Reopen editor popup (closed when row was removed)\n\n\n      if (this.cellEditorPopup && !this.cellEditorPopup.rendered && this.cellEditorPopup.row.id === row.id) {\n        var editorField = this.cellEditorPopup.cell.field;\n        this.startCellEdit(this.cellEditorPopup.column, row, editorField);\n      }\n    }\n  }, {\n    key: \"_calcRowLevelPadding\",\n    value: function _calcRowLevelPadding(row) {\n      if (!row) {\n        return -this.rowLevelPadding;\n      }\n\n      return this._calcRowLevelPadding(row.parentRow) + this.rowLevelPadding;\n    }\n  }, {\n    key: \"_showCellErrorForRow\",\n    value: function _showCellErrorForRow(row) {\n      var $cells = this.$cellsForRow(row.$row),\n          that = this;\n      $cells.each(function (index) {\n        var $cell = $(this);\n        var cell = that.cellByCellIndex(index, row);\n\n        if (cell.errorStatus) {\n          that._showCellError(row, $cell, cell.errorStatus);\n        }\n      });\n    }\n  }, {\n    key: \"_showCellError\",\n    value: function _showCellError(row, $cell, errorStatus) {\n      var tooltip,\n          opts,\n          text = errorStatus.message;\n      opts = {\n        parent: this,\n        text: text,\n        autoRemove: false,\n        $anchor: $cell,\n        table: this\n      };\n      tooltip = scout.create('TableTooltip', opts);\n      tooltip.render(); // link to be able to remove it when row gets deleted\n\n      tooltip.row = row;\n      this.tooltips.push(tooltip);\n    }\n    /**\n     * @returns {Column} the column at position x (e.g. from event.pageX)\n     */\n\n  }, {\n    key: \"_columnAtX\",\n    value: function _columnAtX(x) {\n      var columnOffsetRight = 0,\n          columnOffsetLeft = this.$data.offset().left + this.rowBorderLeftWidth,\n          scrollLeft = this.$data.scrollLeft();\n\n      if (x < columnOffsetLeft) {\n        // Clicked left of first column (on selection border) --> return first column\n        return this.columns[0];\n      }\n\n      columnOffsetLeft -= scrollLeft;\n      var visibleColumns = this.visibleColumns();\n      var column = arrays.find(visibleColumns, function (column) {\n        columnOffsetRight = columnOffsetLeft + column.width;\n\n        if (x >= columnOffsetLeft && x < columnOffsetRight) {\n          return true;\n        }\n\n        columnOffsetLeft = columnOffsetRight;\n      });\n\n      if (!column) {\n        // No column found (clicked right of last column, on selection border) --> return last column\n        column = visibleColumns[visibleColumns.length - 1];\n      }\n\n      return column;\n    }\n  }, {\n    key: \"_find$AppLink\",\n    value: function _find$AppLink(event) {\n      // bubble up from target to delegateTarget\n      var $elem = $(event.target);\n      var $stop = $(event.delegateTarget);\n\n      while ($elem.length > 0) {\n        if ($elem.hasClass('app-link')) {\n          return $elem;\n        }\n\n        if ($elem[0] === $stop[0]) {\n          return null;\n        }\n\n        $elem = $elem.parent();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_filterMenus\",\n    value: function _filterMenus(menuItems, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {\n      return menus.filterAccordingToSelection('Table', this.selectedRows.length, menuItems, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes);\n    }\n  }, {\n    key: \"_filterMenusForContextMenu\",\n    value: function _filterMenusForContextMenu() {\n      return this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true, false, ['Header']);\n    }\n  }, {\n    key: \"setStaticMenus\",\n    value: function setStaticMenus(staticMenus) {\n      this.setProperty('staticMenus', staticMenus);\n\n      this._updateMenuBar();\n    }\n  }, {\n    key: \"_removeMenus\",\n    value: function _removeMenus() {// menubar takes care about removal\n    }\n  }, {\n    key: \"notifyRowSelectionFinished\",\n    value: function notifyRowSelectionFinished() {\n      if (this._triggerRowsSelectedPending) {\n        this._triggerRowsSelected();\n\n        this._triggerRowsSelectedPending = false;\n      }\n\n      this.session.onRequestsDone(this._updateMenuBar.bind(this));\n    }\n  }, {\n    key: \"_triggerRowClick\",\n    value: function _triggerRowClick(row, mouseButton, column) {\n      var event = {\n        row: row,\n        mouseButton: mouseButton\n      };\n      this.trigger('rowClick', event);\n    }\n  }, {\n    key: \"_triggerRowAction\",\n    value: function _triggerRowAction(row, column) {\n      this.trigger('rowAction', {\n        row: row,\n        column: column\n      });\n    }\n    /**\n     * This functions starts the cell editor for the given row and column. Prepare must wait until\n     * a pending completeCellEdit operation is resolved.\n     */\n\n  }, {\n    key: \"prepareCellEdit\",\n    value: function prepareCellEdit(column, row, openFieldPopupOnCellEdit) {\n      var promise = $.resolvedPromise();\n\n      if (this.cellEditorPopup) {\n        promise = this.cellEditorPopup.waitForCompleteCellEdit();\n      }\n\n      promise.then(this.prepareCellEditInternal.bind(this, column, row, openFieldPopupOnCellEdit));\n    }\n    /**\n     * @param openFieldPopupOnCellEdit when this parameter is set to true, the CellEditorPopup sets an\n     *    additional property 'cellEditor' on the editor-field. The field instance may use this property\n     *    to decide whether or not it should open a popup immediately after it is rendered. This is used\n     *    for Smart- and DateFields.\n     */\n\n  }, {\n    key: \"prepareCellEditInternal\",\n    value: function prepareCellEditInternal(column, row, openFieldPopupOnCellEdit) {\n      var event = new Event({\n        column: column,\n        row: row\n      });\n      this.openFieldPopupOnCellEdit = scout.nvl(openFieldPopupOnCellEdit, false);\n      this.trigger('prepareCellEdit', event);\n\n      if (!event.defaultPrevented) {\n        var field = column.createEditor(row);\n        this.startCellEdit(column, row, field);\n      }\n    }\n    /**\n     * @returns {Cell} a cell for the given column and row. Row Icon column and cell icon column don't not have cells --> generate one.\n     */\n\n  }, {\n    key: \"cell\",\n    value: function cell(column, row) {\n      if (column === this.rowIconColumn) {\n        return scout.create('Cell', {\n          iconId: row.iconId,\n          cssClass: strings.join(' ', 'row-icon-cell', row.cssClass)\n        });\n      }\n\n      if (column === this.checkableColumn) {\n        return scout.create('Cell', {\n          value: row.checked,\n          editable: true,\n          cssClass: row.cssClass\n        });\n      }\n\n      return row.cells[column.index];\n    }\n  }, {\n    key: \"cellByCellIndex\",\n    value: function cellByCellIndex(cellIndex, row) {\n      return this.cell(this.columns[cellIndex], row);\n    }\n  }, {\n    key: \"cellValue\",\n    value: function cellValue(column, row) {\n      var cell = this.cell(column, row);\n\n      if (!cell) {\n        return cell;\n      }\n\n      if (cell.value !== undefined) {\n        return cell.value;\n      }\n\n      return '';\n    }\n  }, {\n    key: \"cellText\",\n    value: function cellText(column, row) {\n      var cell = this.cell(column, row);\n\n      if (!cell) {\n        return '';\n      }\n\n      return cell.text || '';\n    }\n    /**\n     *\n     * @returns {object} the next editable position in the table, starting from the cell at (currentColumn / currentRow).\n     * A position is an object containing row and column (cell has no reference to a row or column due to memory reasons).\n     */\n\n  }, {\n    key: \"nextEditableCellPos\",\n    value: function nextEditableCellPos(currentColumn, currentRow, reverse) {\n      var pos,\n          startColumnIndex,\n          rowIndex,\n          startRowIndex,\n          predicate,\n          colIndex = this.columns.indexOf(currentColumn);\n      startColumnIndex = colIndex + 1;\n\n      if (reverse) {\n        startColumnIndex = colIndex - 1;\n      }\n\n      pos = this.nextEditableCellPosForRow(startColumnIndex, currentRow, reverse);\n\n      if (pos) {\n        return pos;\n      }\n\n      predicate = function (row) {\n        if (!row.$row) {\n          return false;\n        }\n\n        startColumnIndex = 0;\n\n        if (reverse) {\n          startColumnIndex = this.columns.length - 1;\n        }\n\n        pos = this.nextEditableCellPosForRow(startColumnIndex, row, reverse);\n\n        if (pos) {\n          return true;\n        }\n      }.bind(this);\n\n      rowIndex = this.rows.indexOf(currentRow);\n      startRowIndex = rowIndex + 1;\n\n      if (reverse) {\n        startRowIndex = rowIndex - 1;\n      }\n\n      arrays.findFrom(this.rows, startRowIndex, predicate, reverse);\n      return pos;\n    }\n  }, {\n    key: \"nextEditableCellPosForRow\",\n    value: function nextEditableCellPosForRow(startColumnIndex, row, reverse) {\n      var cell, column, predicate;\n\n      predicate = function (column) {\n        if (column.guiOnly) {\n          // does not support tabbing\n          return false;\n        }\n\n        cell = this.cell(column, row);\n        return this.enabledComputed && row.enabled && cell.editable;\n      }.bind(this);\n\n      column = arrays.findFrom(this.columns, startColumnIndex, predicate, reverse);\n\n      if (column) {\n        return {\n          column: column,\n          row: row\n        };\n      }\n    }\n  }, {\n    key: \"clearAggregateRows\",\n    value: function clearAggregateRows(animate) {\n      // Remove \"hasAggregateRow\" markers from real rows\n      this._aggregateRows.forEach(function (aggregateRow) {\n        if (aggregateRow.prevRow) {\n          aggregateRow.prevRow.aggregateRowAfter = null;\n        }\n\n        if (aggregateRow.nextRow) {\n          aggregateRow.nextRow.aggregateRowBefore = null;\n        }\n      }, this);\n\n      if (this._isDataRendered()) {\n        this._removeAggregateRows(animate);\n\n        this._renderSelection(); // fix selection borders\n\n      }\n\n      this._aggregateRows = [];\n    }\n    /**\n     * Executes the aggregate function with the given funcName for each visible column, but only if the Column\n     * has that function, which is currently only the case for NumberColumns.\n     *\n     * @param states is a reference to an Array containing the results for each column.\n     * @param row (optional) if set, an additional cell-value parameter is passed to the aggregate function\n     */\n\n  }, {\n    key: \"_forEachVisibleColumn\",\n    value: function _forEachVisibleColumn(funcName, states, row) {\n      var value;\n      this.visibleColumns().forEach(function (column, i) {\n        if (column[funcName]) {\n          if (row) {\n            value = column.cellValueOrTextForCalculation(row);\n          }\n\n          states[i] = column[funcName](states[i], value);\n        } else {\n          states[i] = undefined;\n        }\n      });\n    }\n  }, {\n    key: \"_group\",\n    value: function _group(animate) {\n      var rows,\n          nextRow,\n          newGroup,\n          firstRow,\n          lastRow,\n          groupColumns = this._groupedColumns(),\n          onTop = this.groupingStyle === Table.GroupingStyle.TOP,\n          states = [];\n\n      this.clearAggregateRows();\n\n      if (!groupColumns.length) {\n        return;\n      }\n\n      rows = this.visibleRows;\n\n      this._forEachVisibleColumn('aggrStart', states);\n\n      rows.forEach(function (row, r) {\n        if (!firstRow) {\n          firstRow = row;\n        }\n\n        this._forEachVisibleColumn('aggrStep', states, row); // test if sum should be shown, if yes: reset sum-array\n\n\n        nextRow = rows[r + 1]; // test if group is finished\n\n        newGroup = r === rows.length - 1 || this._isNewGroup(groupColumns, row, nextRow); // if group is finished: add group row\n\n        if (newGroup) {\n          // finish aggregation\n          this._forEachVisibleColumn('aggrFinish', states); // append sum row\n\n\n          this._addAggregateRow(states, onTop ? lastRow : row, onTop ? firstRow : nextRow); // reset after group\n\n\n          this._forEachVisibleColumn('aggrStart', states);\n\n          firstRow = null;\n          lastRow = row;\n        }\n      }.bind(this));\n\n      if (this._isDataRendered()) {\n        this._renderAggregateRows(animate);\n\n        this._renderSelection(); // fix selection borders\n\n      }\n    }\n  }, {\n    key: \"_isNewGroup\",\n    value: function _isNewGroup(groupedColumns, row, nextRow) {\n      var i,\n          col,\n          newRow = false,\n          hasCellTextForGroupingFunction;\n\n      if (!nextRow) {\n        return true; // row is last row\n      }\n\n      for (i = 0; i < groupedColumns.length; i++) {\n        col = groupedColumns[i];\n        hasCellTextForGroupingFunction = col && col.cellTextForGrouping && typeof col.cellTextForGrouping === 'function';\n        newRow = newRow || hasCellTextForGroupingFunction && col.cellTextForGrouping(row) !== col.cellTextForGrouping(nextRow); // NOSONAR\n\n        newRow = newRow || !hasCellTextForGroupingFunction && this.cellText(col, row) !== this.cellText(col, nextRow);\n\n        if (newRow) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_groupedColumns\",\n    value: function _groupedColumns() {\n      return this.columns.filter(function (col) {\n        return col.grouped;\n      });\n    }\n    /**\n     * Inserts a new aggregation row between 'prevRow' and 'nextRow'.\n     *\n     * @param contents cells of the new aggregate row\n     * @param prevRow row _before_ the new aggregate row\n     * @param nextRow row _after_ the new aggregate row\n     */\n\n  }, {\n    key: \"_addAggregateRow\",\n    value: function _addAggregateRow(contents, prevRow, nextRow) {\n      var aggregateRow = {\n        contents: contents.slice(),\n        prevRow: prevRow,\n        nextRow: nextRow\n      };\n\n      this._aggregateRows.push(aggregateRow);\n\n      if (prevRow) {\n        prevRow.aggregateRowAfter = aggregateRow;\n      }\n\n      if (nextRow) {\n        nextRow.aggregateRowBefore = aggregateRow;\n      }\n    }\n  }, {\n    key: \"_removeAggregateRows\",\n    value: function _removeAggregateRows(animate) {\n      if (this._aggregateRows.length === 0) {\n        return;\n      }\n\n      animate = scout.nvl(animate, false);\n\n      if (!animate) {\n        this._aggregateRows.forEach(function (aggregateRow) {\n          this._removeRow(aggregateRow);\n        }, this);\n\n        this.updateScrollbars();\n      } else {\n        this._aggregateRows.forEach(function (aggregateRow, i) {\n          this._hideRow(aggregateRow);\n        }, this);\n      }\n    }\n  }, {\n    key: \"_renderAggregateRows\",\n    value: function _renderAggregateRows(animate) {\n      var onTop = this.groupingStyle === Table.GroupingStyle.TOP,\n          insertFunc = onTop ? 'insertBefore' : 'insertAfter';\n      animate = scout.nvl(animate, false);\n\n      this._aggregateRows.forEach(function (aggregateRow, r) {\n        var refRow, $cell, $aggregateRow;\n\n        if (aggregateRow.$row) {\n          // already rendered, no need to update again (necessary for subsequent renderAggregateRows calls (e.g. in insertRows -> renderRows)\n          return;\n        }\n\n        refRow = onTop ? aggregateRow.nextRow : aggregateRow.prevRow;\n\n        if (!refRow || !refRow.$row) {\n          return;\n        }\n\n        $aggregateRow = this.$container.makeDiv('table-aggregate-row').data('aggregateRow', aggregateRow);\n        $aggregateRow[insertFunc](refRow.$row).width(this.rowWidth);\n        this.visibleColumns().forEach(function (column) {\n          $cell = $(column.buildCellForAggregateRow(aggregateRow));\n          $cell.appendTo($aggregateRow);\n\n          this._resizeCell($cell);\n        }, this);\n        aggregateRow.height = $aggregateRow.outerHeight(true);\n        aggregateRow.$row = $aggregateRow;\n\n        if (animate) {\n          this._showRow(aggregateRow);\n        }\n      }, this);\n    }\n  }, {\n    key: \"groupColumn\",\n    value: function groupColumn(column, multiGroup, direction, remove) {\n      var data, sorted;\n      multiGroup = scout.nvl(multiGroup, false);\n      remove = scout.nvl(remove, false);\n\n      if (remove) {\n        this._removeGroupColumn(column);\n      }\n\n      if (!this.isGroupingPossible(column)) {\n        return;\n      }\n\n      if (!remove) {\n        this._addGroupColumn(column, direction, multiGroup);\n      }\n\n      if (this.header) {\n        this.header.onSortingChanged();\n      }\n\n      sorted = this._sort(true);\n      data = {\n        column: column,\n        groupAscending: column.sortAscending\n      };\n\n      if (remove) {\n        data.groupingRemoved = true;\n      }\n\n      if (multiGroup) {\n        data.multiGroup = true;\n      }\n\n      if (!sorted) {\n        // Delegate sorting to server when it is not possible on client side\n        data.groupingRequested = true; // hint to animate the aggregate after the row order changed event\n\n        this._animateAggregateRows = true;\n      }\n\n      this.trigger('group', data);\n    }\n  }, {\n    key: \"removeColumnGrouping\",\n    value: function removeColumnGrouping(column) {\n      if (column) {\n        this.groupColumn(column, false, 'asc', true);\n      }\n    }\n  }, {\n    key: \"removeAllColumnGroupings\",\n    value: function removeAllColumnGroupings() {\n      this.columns.filter(function (column) {\n        return column.grouped;\n      }).forEach(this.removeColumnGrouping.bind(this));\n    }\n    /**\n     * @returns {boolean} true if at least one column has grouped=true\n     */\n\n  }, {\n    key: \"isGrouped\",\n    value: function isGrouped() {\n      return this.columns.some(function (column) {\n        return column.grouped;\n      });\n    }\n  }, {\n    key: \"setColumnBackgroundEffect\",\n    value: function setColumnBackgroundEffect(column, effect) {\n      column.setBackgroundEffect(effect);\n    }\n    /**\n     * Updates the background effect of every column, if column.backgroundEffect is set.\n     * Meaning: Recalculates the min / max values and renders the background effect again.\n     */\n\n  }, {\n    key: \"_updateBackgroundEffect\",\n    value: function _updateBackgroundEffect() {\n      this.columns.forEach(function (column) {\n        if (!column.backgroundEffect) {\n          return;\n        }\n\n        column.updateBackgroundEffect();\n      }, this);\n    }\n    /**\n     * Recalculates the values necessary for the background effect of every column, if column.backgroundEffect is set\n     */\n\n  }, {\n    key: \"_calculateValuesForBackgroundEffect\",\n    value: function _calculateValuesForBackgroundEffect() {\n      this.columns.forEach(function (column) {\n        if (!column.backgroundEffect) {\n          return;\n        }\n\n        column.calculateMinMaxValues();\n      }, this);\n    }\n  }, {\n    key: \"_markAutoOptimizeWidthColumnsAsDirty\",\n    value: function _markAutoOptimizeWidthColumnsAsDirty() {\n      this.columns.forEach(function (column) {\n        column.autoOptimizeWidthRequired = true;\n      });\n    }\n  }, {\n    key: \"_markAutoOptimizeWidthColumnsAsDirtyIfNeeded\",\n    value: function _markAutoOptimizeWidthColumnsAsDirtyIfNeeded(autoOptimizeWidthColumns, oldRow, newRow) {\n      var i,\n          marked = false;\n\n      for (i = autoOptimizeWidthColumns.length - 1; i >= 0; i--) {\n        var column = autoOptimizeWidthColumns[i];\n\n        if (this.cellValue(column, oldRow) !== this.cellValue(column, newRow)) {\n          column.autoOptimizeWidthRequired = true; // Remove column from list since it is now marked and does not have to be processed next time\n\n          autoOptimizeWidthColumns.splice(i, 1);\n          marked = true;\n        }\n      }\n\n      return marked;\n    }\n  }, {\n    key: \"setMultiCheck\",\n    value: function setMultiCheck(multiCheck) {\n      this.setProperty('multiCheck', multiCheck);\n    }\n  }, {\n    key: \"checkedRows\",\n    value: function checkedRows() {\n      return this.rows.filter(function (row) {\n        return row.checked;\n      });\n    }\n  }, {\n    key: \"checkRow\",\n    value: function checkRow(row, checked, options) {\n      var opts = $.extend(options, {\n        checked: checked\n      });\n      this.checkRows([row], opts);\n    }\n  }, {\n    key: \"checkRows\",\n    value: function checkRows(rows, options) {\n      var opts = $.extend({\n        checked: true,\n        checkOnlyEnabled: true\n      }, options);\n      var checkedRows = []; // use enabled computed because when the parent of the table is disabled, it should not be allowed to check rows\n\n      if (!this.checkable || !this.enabledComputed && opts.checkOnlyEnabled) {\n        return;\n      }\n\n      rows = arrays.ensure(rows);\n      rows.forEach(function (row) {\n        if (!row.enabled && opts.checkOnlyEnabled || row.checked === opts.checked) {\n          return;\n        }\n\n        if (!this.multiCheck && opts.checked) {\n          for (var i = 0; i < this.rows.length; i++) {\n            if (this.rows[i].checked) {\n              this.rows[i].checked = false;\n              checkedRows.push(this.rows[i]);\n            }\n          }\n        }\n\n        row.checked = opts.checked;\n        checkedRows.push(row);\n      }, this);\n\n      if (this._isDataRendered()) {\n        checkedRows.forEach(function (row) {\n          this._renderRowChecked(row);\n        }, this);\n      }\n\n      this._triggerRowsChecked(checkedRows);\n    }\n  }, {\n    key: \"uncheckRow\",\n    value: function uncheckRow(row, options) {\n      this.uncheckRows([row], options);\n    }\n  }, {\n    key: \"uncheckRows\",\n    value: function uncheckRows(rows, options) {\n      var opts = $.extend({\n        checked: false\n      }, options);\n      this.checkRows(rows, opts);\n    }\n  }, {\n    key: \"isTableNodeColumn\",\n    value: function isTableNodeColumn(column) {\n      return this.hierarchical && this.tableNodeColumn === column;\n    }\n  }, {\n    key: \"collapseRow\",\n    value: function collapseRow(row) {\n      this.collapseRows(arrays.ensure(row));\n    }\n  }, {\n    key: \"collapseAll\",\n    value: function collapseAll() {\n      this.expandRowsInternal(this.rootRows, false, true);\n    }\n  }, {\n    key: \"expandAll\",\n    value: function expandAll() {\n      this.expandRowsInternal(this.rootRows, true, true);\n    }\n  }, {\n    key: \"collapseRows\",\n    value: function collapseRows(rows, recursive) {\n      this.expandRowsInternal(rows, false, recursive);\n    }\n  }, {\n    key: \"expandRow\",\n    value: function expandRow(row, recursive) {\n      this.expandRows(arrays.ensure(row));\n    }\n  }, {\n    key: \"expandRows\",\n    value: function expandRows(rows, recursive) {\n      this.expandRowsInternal(rows, true, recursive);\n    }\n  }, {\n    key: \"expandRowsInternal\",\n    value: function expandRowsInternal(rows, expanded, recursive) {\n      var changedRows = [],\n          rowsForAnimation = [];\n      rows = rows || this.rootRows;\n      expanded = scout.nvl(expanded, true);\n      recursive = scout.nvl(recursive, false);\n\n      if (recursive) {\n        // collect rows\n        this.visitRows(function (row) {\n          var changed = row.expanded !== expanded;\n\n          if (changed) {\n            row.expanded = expanded;\n            changedRows.push(row);\n\n            if (row.$row) {\n              rowsForAnimation.push(row);\n            }\n          }\n        }, rows);\n      } else {\n        changedRows = rows.filter(function (row) {\n          var changed = row.expanded !== expanded;\n\n          if (changed && row.$row) {\n            rowsForAnimation.push(row);\n          }\n\n          row.expanded = expanded;\n          return changed;\n        });\n      }\n\n      if (changedRows.length === 0) {\n        return;\n      }\n\n      this._updateRowStructure({\n        visibleRows: true\n      });\n\n      this._triggerRowsExpanded(changedRows);\n\n      if (this._isDataRendered()) {\n        this._renderRowDelta();\n\n        rowsForAnimation.forEach(function (row) {\n          row.animateExpansion();\n        });\n\n        if (rows[0].$row) {\n          scrollbars.ensureExpansionVisible({\n            element: rows[0],\n            $element: rows[0].$row,\n            $scrollable: this.get$Scrollable(),\n            isExpanded: function isExpanded(element) {\n              return element.expanded;\n            },\n            getChildren: function getChildren(parent) {\n              return parent.childRows;\n            },\n            defaultChildHeight: this.rowHeight\n          });\n        }\n      }\n    }\n  }, {\n    key: \"doRowAction\",\n    value: function doRowAction(row, column) {\n      if (this.selectedRows.length !== 1 || this.selectedRows[0] !== row) {\n        // Only allow row action if the selected row was double clicked because the handler of the event expects a selected row.\n        // This may happen if the user modifies the selection using ctrl or shift while double clicking.\n        return;\n      }\n\n      column = column || this.columns[0];\n\n      if (column && column.guiOnly) {\n        column = arrays.find(this.columns, function (col) {\n          return !col.guiOnly;\n        });\n      }\n\n      if (!row || !column) {\n        return;\n      }\n\n      this._triggerRowAction(row, column);\n    }\n  }, {\n    key: \"insertRow\",\n    value: function insertRow(row) {\n      this.insertRows([row]);\n    }\n  }, {\n    key: \"insertRows\",\n    value: function insertRows(rows) {\n      var wasEmpty = this.rows.length === 0; // Update model\n\n      rows.forEach(function (row, i) {\n        row = this._initRow(row);\n        row.status = TableRow.Status.INSERTED;\n        rows[i] = row; // Always insert new rows at the end, if the order is wrong a rowOrderChanged event will follow\n\n        this.rows.push(row);\n      }, this);\n      var filterAcceptedRows = rows.filter(function (row) {\n        this._applyFiltersForRow(row);\n\n        return row.filterAccepted;\n      }, this);\n\n      this._updateRowStructure({\n        updateTree: true,\n        filteredRows: true,\n        applyFilters: false,\n        visibleRows: true\n      }); // Notify changed filter if there are user filters and at least one of the new rows is accepted by them\n\n\n      if (this._filterCount() > 0 && filterAcceptedRows.length > 0) {\n        this._triggerFilter();\n      }\n\n      this._calculateValuesForBackgroundEffect();\n\n      this._markAutoOptimizeWidthColumnsAsDirty(); // this event should be triggered before the rowOrderChanged event (triggered by the _sort function).\n\n\n      this._triggerRowsInserted(rows);\n\n      this._sortAfterInsert(wasEmpty); // Update HTML\n\n\n      if (this._isDataRendered()) {\n        if (this.hierarchical) {\n          this._renderRowOrderChanges();\n        } // Remember inserted rows for future events like rowOrderChanged\n\n\n        if (!this._insertedRows) {\n          this._insertedRows = rows;\n          setTimeout(function () {\n            this._insertedRows = null;\n          }.bind(this), 0);\n        } else {\n          arrays.pushAll(this._insertedRows, rows);\n        }\n\n        this.viewRangeDirty = true;\n\n        this._renderViewport();\n\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_sortAfterInsert\",\n    value: function _sortAfterInsert(wasEmpty) {\n      this._sort();\n    }\n  }, {\n    key: \"deleteRow\",\n    value: function deleteRow(row) {\n      this.deleteRows([row]);\n    }\n  }, {\n    key: \"deleteRows\",\n    value: function deleteRows(rows) {\n      var invalidate,\n          filterChanged,\n          removedRows = [];\n      this.visitRows(function (row) {\n        if (!this.rowsMap[row.id]) {\n          return;\n        }\n\n        removedRows.push(row); // Update HTML\n\n        if (this._isDataRendered()) {\n          // Cancel cell editing if cell editor belongs to a cell of the deleted row\n          if (this.cellEditorPopup && this.cellEditorPopup.row.id === row.id) {\n            this.cellEditorPopup.cancelEdit();\n          }\n\n          this._removeRows(row);\n\n          invalidate = true;\n        } // Update model\n\n\n        arrays.remove(this.rows, row);\n        arrays.remove(this.visibleRows, row);\n\n        if (this._filterCount() > 0 && arrays.remove(this._filteredRows, row)) {\n          filterChanged = true;\n        }\n\n        delete this.rowsMap[row.id];\n\n        if (this.selectionHandler.lastActionRow === row) {\n          this.selectionHandler.clearLastSelectedRowMarker();\n        }\n      }.bind(this), rows);\n      this.deselectRows(removedRows);\n\n      this._updateRowStructure({\n        updateTree: true,\n        filteredRows: true,\n        applyFilters: false,\n        visibleRows: true\n      });\n\n      if (filterChanged) {\n        this._triggerFilter();\n      }\n\n      this._group();\n\n      this._updateBackgroundEffect();\n\n      this._markAutoOptimizeWidthColumnsAsDirty();\n\n      this._triggerRowsDeleted(rows);\n\n      if (invalidate) {\n        this._renderViewport(); // Update markers and filler because row may be removed by removeRows. RenderViewport doesn't do it if view range is already correctly rendered.\n\n\n        this._renderRangeMarkers();\n\n        this._renderFiller();\n\n        this._renderEmptyData();\n\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"deleteAllRows\",\n    value: function deleteAllRows() {\n      var filterChanged = this._filterCount() > 0 && this._filteredRows.length > 0,\n          rows = this.rows; // Update HTML\n\n      if (this._isDataRendered()) {\n        // Cancel cell editing\n        if (this.cellEditorPopup) {\n          this.cellEditorPopup.cancelEdit();\n        }\n\n        this.selectionHandler.clearLastSelectedRowMarker();\n\n        this._removeRows();\n      } // Update model\n\n\n      this.rows = [];\n      this.rowsMap = {};\n      this._filteredRows = [];\n      this.deselectAll();\n\n      this._updateRowStructure({\n        updateTree: true,\n        filteredRows: true,\n        applyFilters: false,\n        visibleRows: true\n      });\n\n      if (filterChanged) {\n        this._triggerFilter();\n      }\n\n      this._markAutoOptimizeWidthColumnsAsDirty();\n\n      this._group();\n\n      this._updateBackgroundEffect();\n\n      this._triggerAllRowsDeleted(rows); // Update HTML\n\n\n      if (this._isDataRendered()) {\n        this._renderFiller();\n\n        this._renderViewport();\n\n        this._renderEmptyData();\n\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"updateRow\",\n    value: function updateRow(row) {\n      this.updateRows([row]);\n    }\n  }, {\n    key: \"updateRows\",\n    value: function updateRows(rows) {\n      if (this.updateBuffer.isBuffering()) {\n        this.updateBuffer.buffer(rows);\n        return;\n      }\n\n      var filterChanged, expansionChanged, autoOptimizeWidthColumnsDirty;\n      var autoOptimizeWidthColumns = this.columns.filter(function (column) {\n        return column.autoOptimizeWidth && !column.autoOptimizeWidthRequired;\n      });\n      var rowsToIndex = {};\n      this.rows.forEach(function (row, index) {\n        rowsToIndex[row.id] = index;\n      }, this);\n      var oldRowsMap = {};\n      var structureChanged = false;\n      rows = rows.map(function (row) {\n        var parentRowId = row.parentRow,\n            oldRow = this.rowsMap[row.id]; // collect old rows\n\n        oldRowsMap[row.id] = oldRow;\n\n        if (!oldRow) {\n          throw new Error('Update event received for non existing row. RowId: ' + row.id);\n        } // check structure changes\n\n\n        if (row.parentRow && !objects.isNullOrUndefined(row.parentRow.id)) {\n          parentRowId = row.parentRow.id;\n        }\n\n        structureChanged = structureChanged || scout.nvl(oldRow._parentRowId, null) !== scout.nvl(parentRowId, null);\n        expansionChanged = expansionChanged || oldRow.expanded !== scout.nvl(row.expanded, false);\n        row = this._initRow(row); // Check if cell values have changed\n\n        if (row.status === TableRow.Status.NON_CHANGED) {\n          row.cells.some(function (cell, i) {\n            var oldCell = oldRow.cells[i];\n\n            if (!oldCell || oldCell.value !== cell.value) {\n              row.status = TableRow.Status.UPDATED;\n              return true; // break \"some()\" loop\n            }\n\n            return false;\n          });\n        } // selection\n\n\n        if (this.selectionHandler.lastActionRow === oldRow) {\n          this.selectionHandler.lastActionRow = row;\n        }\n\n        arrays.replace(this.selectedRows, oldRow, row); // replace row use index lookup for performance reasons\n\n        this.rows[rowsToIndex[row.id]] = row; // filter\n\n        row.filterAccepted = oldRow.filterAccepted;\n\n        if (this._filterCount() > 0) {\n          filterChanged = this._applyFiltersForRow(row) || filterChanged;\n        } // Check if cell content changed and if yes mark auto optimize width column as dirty\n\n\n        autoOptimizeWidthColumnsDirty = this._markAutoOptimizeWidthColumnsAsDirtyIfNeeded(autoOptimizeWidthColumns, oldRow, row);\n        return row;\n      }, this);\n\n      this._updateRowStructure({\n        updateTree: true,\n        filteredRows: true,\n        applyFilters: false,\n        visibleRows: true\n      });\n\n      this._triggerRowsUpdated(rows);\n\n      if (this._isDataRendered()) {\n        this._renderUpdateRows(rows, oldRowsMap);\n\n        if (structureChanged) {\n          this._renderRowOrderChanges();\n        }\n      }\n\n      if (filterChanged) {\n        this._triggerFilter();\n      }\n\n      if (filterChanged || expansionChanged) {\n        this._renderRowDelta();\n      }\n\n      this._sortAfterUpdate();\n\n      this._updateBackgroundEffect();\n\n      this.invalidateLayoutTree(); // this will also update the scroll-bars\n    }\n  }, {\n    key: \"_renderUpdateRows\",\n    value: function _renderUpdateRows(rows, oldRowsMap) {\n      // render row and replace div in DOM\n      rows.forEach(function (row) {\n        var oldRow = oldRowsMap[row.id],\n            $updatedRow;\n\n        if (!oldRow.$row || oldRow.$row.hasClass('hiding')) {\n          // If row is not rendered or being removed by an animation, don't try to update it.\n          // If it were updated during animated removal, the new row would immediately be inserted again, so the removal would not work.\n          return;\n        }\n\n        $updatedRow = $(this._buildRowDiv(row));\n        $updatedRow.copyCssClasses(oldRow.$row, Table.SELECTION_CLASSES + ' first last');\n        oldRow.$row.replaceWith($updatedRow);\n        Table.linkRowToDiv(row, $updatedRow);\n\n        this._destroyTooltipsForRow(row);\n\n        this._removeCellEditorForRow(row);\n\n        this._installRow(row);\n\n        if (oldRow.$row.hasClass('showing') && oldRow.$row.outerHeight() < row.$row.outerHeight() / 3) {\n          // If the row was being shown by an animation, start the animation again for the new row, otherwise row would immediately appear without animation.\n          // Do it only, if the current running time of the animation does not exceed 33% (this won't be correct if the height of the new and old rows differ).\n          // Goal: if the update happens immediately after the animation started, the new row will be animated nicely. If the update happens later, don't start the animation again from the start.\n          this._showRow(row);\n        }\n      }, this);\n    }\n  }, {\n    key: \"_sortAfterUpdate\",\n    value: function _sortAfterUpdate() {\n      this._sort();\n    }\n  }, {\n    key: \"isHierarchical\",\n    value: function isHierarchical() {\n      return this.hierarchical;\n    }\n  }, {\n    key: \"_setHierarchical\",\n    value: function _setHierarchical(hierarchical) {\n      if (this.hierarchical === hierarchical) {\n        return;\n      } // Has to be called before the property is set! Otherwise the grouping will not completely removed,\n      // since isGroupingPossible() will return false.\n\n\n      if (hierarchical) {\n        this.removeAllColumnGroupings();\n      }\n\n      this._setProperty('hierarchical', hierarchical);\n    }\n    /**\n     * The given rows must be rows of this table in desired order.\n     * @param {TableRow[]} rows\n     */\n\n  }, {\n    key: \"updateRowOrder\",\n    value: function updateRowOrder(rows) {\n      rows = arrays.ensure(rows);\n\n      if (rows.length !== this.rows.length) {\n        throw new Error('Row order may not be updated because lengths of the arrays differ.');\n      } // update model (make a copy so that original array stays untouched)\n\n\n      this.rows = rows.slice();\n\n      this._updateRowStructure({\n        updateTree: true,\n        filteredRows: true,\n        applyFilters: false,\n        visibleRows: true\n      });\n\n      this.clearAggregateRows(this._animateAggregateRows);\n\n      if (this._isDataRendered()) {\n        this._renderRowOrderChanges();\n      }\n\n      this._triggerRowOrderChanged();\n\n      this._group(this._animateAggregateRows);\n\n      this._animateAggregateRows = false;\n    }\n  }, {\n    key: \"_destroyTooltipsForRow\",\n    value: function _destroyTooltipsForRow(row) {\n      for (var i = this.tooltips.length - 1; i >= 0; i--) {\n        if (this.tooltips[i].row.id === row.id) {\n          this.tooltips[i].destroy();\n          this.tooltips.splice(i, 1);\n        }\n      }\n    }\n  }, {\n    key: \"_removeCellEditorForRow\",\n    value: function _removeCellEditorForRow(row) {\n      if (this.cellEditorPopup && this.cellEditorPopup.rendered && this.cellEditorPopup.row.id === row.id) {\n        this.cellEditorPopup.remove();\n      }\n    }\n  }, {\n    key: \"startCellEdit\",\n    value: function startCellEdit(column, row, field) {\n      if (!this._isDataRendered() || !this.isAttachedAndRendered()) {\n        this._postRenderActions.push(this.startCellEdit.bind(this, column, row, field));\n\n        return;\n      }\n\n      this.trigger('startCellEdit', {\n        column: column,\n        row: row,\n        field: field\n      });\n      this.ensureRowRendered(row);\n      var popup = column.startCellEdit(row, field);\n      this.cellEditorPopup = popup;\n      return popup;\n    }\n    /**\n     * @param saveEditorValue when this parameter is set to true, the value of the editor field is set as\n     *    new value on the edited cell. In remote case this parameter is always false, because the cell\n     *    value is updated by an updateRow event instead.\n     */\n\n  }, {\n    key: \"endCellEdit\",\n    value: function endCellEdit(field, saveEditorValue) {\n      if (!this._isDataRendered() || !this.isAttachedAndRendered()) {\n        this._postRenderActions.push(this.endCellEdit.bind(this, field, saveEditorValue));\n\n        return;\n      } // the cellEditorPopup could already be removed by scrolling (out of view range) or be removed by update rows\n\n\n      if (this.cellEditorPopup) {\n        var context = this.cellEditorPopup; // Remove the cell-editor popup prior destroying the field, so that the 'cell-editor-popup's focus context is\n        // uninstalled first and the focus can be restored onto the last focused element of the surrounding focus context.\n        // Otherwise, if the currently focused field is removed from DOM, the $entryPoint would be focused first, which can\n        // be avoided if removing the popup first.\n\n        this._destroyCellEditorPopup(); // Must store context in a local variable and call setCellValue _after_ cellEditorPopup is set to null\n        // because in updateRows we check if the popup is still there and start cell editing mode again.\n\n\n        saveEditorValue = scout.nvl(saveEditorValue, false);\n\n        if (saveEditorValue) {\n          var column = context.column;\n          var row = context.row;\n          this.setCellErrorStatus(column, row, field.errorStatus); // always get the errorStatus from the editor\n\n          if (field.errorStatus) {\n            // if there is an error from the editor, the displayText of the cell has to be updated\n            this.setCellText(column, row, field.displayText);\n          } else {\n            this.setCellValue(column, row, field.value);\n          }\n        }\n      }\n\n      field.destroy();\n    }\n  }, {\n    key: \"completeCellEdit\",\n    value: function completeCellEdit() {\n      var field = this.cellEditorPopup.cell.field;\n      var event = new Event({\n        field: field,\n        row: this.cellEditorPopup.row,\n        column: this.cellEditorPopup.column,\n        cell: this.cellEditorPopup.cell\n      });\n      this.trigger('completeCellEdit', event);\n\n      if (!event.defaultPrevented) {\n        return this.endCellEdit(field, true);\n      }\n    }\n  }, {\n    key: \"cancelCellEdit\",\n    value: function cancelCellEdit() {\n      var field = this.cellEditorPopup.cell.field;\n      var event = new Event({\n        field: field,\n        row: this.cellEditorPopup.row,\n        column: this.cellEditorPopup.column,\n        cell: this.cellEditorPopup.cell\n      });\n      this.trigger('cancelCellEdit', event);\n\n      if (!event.defaultPrevented) {\n        this.endCellEdit(field);\n      }\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(row, options) {\n      if (this.viewRangeRendered.size() === 0) {\n        // Cannot scroll to a row no row is rendered\n        return;\n      }\n\n      this.ensureRowRendered(row);\n\n      if (!row.$row) {\n        // Row may not be visible due to the filter -> don't try to scroll because it would fail\n        return;\n      }\n\n      scrollbars.scrollTo(this.$data, row.$row, options);\n    }\n  }, {\n    key: \"scrollPageUp\",\n    value: function scrollPageUp() {\n      var newScrollTop = Math.max(0, this.$data[0].scrollTop - this.$data.height());\n      this.setScrollTop(newScrollTop);\n    }\n  }, {\n    key: \"scrollPageDown\",\n    value: function scrollPageDown() {\n      var newScrollTop = Math.min(this.$data[0].scrollHeight, this.$data[0].scrollTop + this.$data.height());\n      this.setScrollTop(newScrollTop);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"setScrollTop\",\n    value: function setScrollTop(scrollTop) {\n      this.setProperty('scrollTop', scrollTop); // call _renderViewport to make sure rows are rendered immediately. The browser fires the scroll event handled by onDataScroll delayed\n\n      if (this._isDataRendered()) {\n        this._renderViewport();\n      }\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_renderScrollTop\",\n    value: function _renderScrollTop() {\n      if (this.rendering) {\n        // Not necessary to do it while rendering since it will be done by the layout\n        return;\n      }\n\n      scrollbars.scrollTop(this.get$Scrollable(), this.scrollTop);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"get$Scrollable\",\n    value: function get$Scrollable() {\n      if (this.$data) {\n        return this.$data;\n      }\n\n      return this.$container;\n    }\n  }, {\n    key: \"setScrollToSelection\",\n    value: function setScrollToSelection(scrollToSelection) {\n      this.setProperty('scrollToSelection', scrollToSelection);\n    }\n  }, {\n    key: \"revealSelection\",\n    value: function revealSelection() {\n      if (!this._isDataRendered()) {\n        // Execute delayed because table may be not layouted yet\n        this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n        return;\n      }\n\n      if (this.selectedRows.length > 0) {\n        this.scrollTo(this.selectedRows[0]);\n      }\n    }\n  }, {\n    key: \"revealChecked\",\n    value: function revealChecked() {\n      var firstCheckedRow = arrays.find(this.rows, function (row) {\n        return row.checked === true;\n      });\n\n      if (firstCheckedRow) {\n        this.scrollTo(firstCheckedRow);\n      }\n    }\n  }, {\n    key: \"_rowById\",\n    value: function _rowById(id) {\n      return this.rowsMap[id];\n    }\n  }, {\n    key: \"_rowsByIds\",\n    value: function _rowsByIds(ids) {\n      return ids.map(this._rowById.bind(this));\n    }\n  }, {\n    key: \"_rowsToIds\",\n    value: function _rowsToIds(rows) {\n      return rows.map(function (row) {\n        return row.id;\n      });\n    }\n    /**\n     * Checks whether the given row is contained in the table. Uses the id of the row for the lookup.\n     */\n\n  }, {\n    key: \"hasRow\",\n    value: function hasRow(row) {\n      return Boolean(this.rowsMap[row.id]);\n    }\n    /**\n     * render borders and selection of row. default select if no argument or false is passed in deselect\n     * model has to be updated before calling this method.\n     */\n\n  }, {\n    key: \"_renderSelection\",\n    value: function _renderSelection(rows) {\n      rows = arrays.ensure(rows || this.selectedRows); // helper function adds/removes a class for a row only if necessary, return true if classes have been changed\n\n      var addOrRemoveClassIfNeededFunc = function addOrRemoveClassIfNeededFunc($row, condition, classname) {\n        var hasClass = $row.hasClass(classname);\n\n        if (condition && !hasClass) {\n          $row.addClass(classname);\n          return true;\n        } else if (!condition && hasClass) {\n          $row.removeClass(classname);\n          return true;\n        }\n\n        return false;\n      };\n\n      for (var i = 0; i < rows.length; i++) {\n        // traditional for loop, elements might be added during loop\n        var row = rows[i];\n\n        if (!row.$row) {\n          continue;\n        }\n\n        var thisRowSelected = this.selectedRows.indexOf(row) !== -1,\n            visibleRows = this.visibleRows,\n            previousIndex = visibleRows.indexOf(row) - 1,\n            previousRowSelected = previousIndex >= 0 && this.selectedRows.indexOf(visibleRows[previousIndex]) !== -1,\n            followingIndex = visibleRows.indexOf(row) + 1,\n            followingRowSelected = followingIndex < visibleRows.length && this.selectedRows.indexOf(visibleRows[followingIndex]) !== -1; // Don't collapse selection borders if two consecutively selected (real) rows are separated by an aggregation row\n\n        if (thisRowSelected && previousRowSelected && row.aggregateRowBefore) {\n          previousRowSelected = false;\n        }\n\n        if (thisRowSelected && followingRowSelected && row.aggregateRowAfter) {\n          followingRowSelected = false;\n        } // Note: We deliberately use the '+' operator on booleans here! That way, _all_ methods are executed (boolean\n        // operators might stop in between) and the variable classChanged contains a number > 1 (which is truthy) when\n        // at least one method call returned true.\n\n\n        var classChanged = 0 + addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected, 'selected') + addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && !previousRowSelected && followingRowSelected, 'select-top') + addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && previousRowSelected && !followingRowSelected, 'select-bottom') + addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && !previousRowSelected && !followingRowSelected, 'select-single') + addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && previousRowSelected && followingRowSelected, 'select-middle');\n\n        if (classChanged && previousRowSelected && rows.indexOf(visibleRows[previousIndex]) === -1) {\n          rows.push(visibleRows[previousIndex]);\n        }\n\n        if (classChanged && followingRowSelected && rows.indexOf(visibleRows[followingIndex]) === -1) {\n          rows.push(visibleRows[followingIndex]);\n        }\n      } // Make sure the cell editor popup is correctly layouted because selection changes the cell bounds\n\n\n      if (this.cellEditorPopup && this.cellEditorPopup.rendered && this.selectedRows.indexOf(this.cellEditorPopup.row) > -1) {\n        this.cellEditorPopup.position();\n        this.cellEditorPopup.pack();\n      }\n    }\n  }, {\n    key: \"_removeSelection\",\n    value: function _removeSelection() {\n      this.selectedRows.forEach(function (row) {\n        if (!row.$row) {\n          return;\n        }\n\n        row.$row.select(false);\n        row.$row.toggleClass(Table.SELECTION_CLASSES, false);\n      }, this);\n    }\n  }, {\n    key: \"addRowToSelection\",\n    value: function addRowToSelection(row, ongoingSelection) {\n      if (this.selectedRows.indexOf(row) > -1) {\n        return;\n      }\n\n      ongoingSelection = ongoingSelection !== undefined ? ongoingSelection : true;\n      this.selectedRows.push(row);\n\n      if (row.$row && this._isDataRendered()) {\n        row.$row.select(true);\n\n        this._renderSelection(row);\n\n        if (this.scrollToSelection) {\n          this.revealSelection();\n        }\n      }\n\n      this._triggerRowsSelectedPending = true;\n\n      if (!ongoingSelection) {\n        this.notifyRowSelectionFinished();\n      }\n    }\n  }, {\n    key: \"removeRowFromSelection\",\n    value: function removeRowFromSelection(row, ongoingSelection) {\n      ongoingSelection = ongoingSelection !== undefined ? ongoingSelection : true;\n\n      if (arrays.remove(this.selectedRows, row)) {\n        if (this._isDataRendered()) {\n          this._renderSelection(row);\n        }\n\n        if (!ongoingSelection) {\n          this._triggerRowsSelected();\n        } else {\n          this._triggerRowsSelectedPending = true;\n        }\n      }\n    }\n  }, {\n    key: \"selectRow\",\n    value: function selectRow(row, debounceSend) {\n      this.selectRows(row, debounceSend);\n    }\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(rows, debounceSend) {\n      // Exclude rows that are currently not visible because of a filter (they cannot be selected)\n      rows = arrays.ensure(rows).filter(function (row) {\n        return Boolean(this.visibleRowsMap[row.id]);\n      }, this);\n      var selectedEqualRows = arrays.equalsIgnoreOrder(rows, this.selectedRows); // TODO [7.0] cgu: maybe make sure selectedRows are in correct order, this would make logic in AbstractTableNavigationKeyStroke or renderSelection easier\n      // but requires some effort (remember rowIndex, keep array in order after sort, ... see java Table)\n\n      if (selectedEqualRows) {\n        return;\n      }\n\n      if (this._isDataRendered()) {\n        this._removeSelection();\n      }\n\n      if (!this.multiSelect && rows.length > 1) {\n        rows = [rows[0]];\n      }\n\n      this.selectedRows = rows; // (Note: direct assignment is safe because the initial filtering created a copy of the original array)\n\n      this._triggerRowsSelected(debounceSend);\n\n      this._updateMenuBar();\n\n      if (this._isDataRendered()) {\n        this._renderSelection();\n\n        if (this.scrollToSelection) {\n          this.revealSelection();\n        }\n      }\n    }\n  }, {\n    key: \"deselectRow\",\n    value: function deselectRow(row) {\n      this.deselectRows(row);\n    }\n  }, {\n    key: \"deselectRows\",\n    value: function deselectRows(rows) {\n      rows = arrays.ensure(rows);\n      var selectedRows = this.selectedRows.slice(); // copy\n\n      if (arrays.removeAll(selectedRows, rows)) {\n        this.selectRows(selectedRows);\n      }\n    }\n  }, {\n    key: \"isRowSelected\",\n    value: function isRowSelected(row) {\n      return this.selectedRows.indexOf(row) > -1;\n    }\n  }, {\n    key: \"_filterCount\",\n    value: function _filterCount() {\n      return Object.keys(this._filterMap).length;\n    }\n  }, {\n    key: \"filteredRows\",\n    value: function filteredRows() {\n      return this._filteredRows;\n    }\n  }, {\n    key: \"$rows\",\n    value: function $rows(includeAggrRows) {\n      var selector = '.table-row';\n\n      if (includeAggrRows) {\n        selector += ', .table-aggregate-row';\n      }\n\n      return this.$data.find(selector);\n    }\n  }, {\n    key: \"$aggregateRows\",\n    value: function $aggregateRows() {\n      return this.$data.find('.table-aggregate-row');\n    }\n    /**\n     * @returns {TableRow} the first selected row of this table or null when no row is selected\n     */\n\n  }, {\n    key: \"selectedRow\",\n    value: function selectedRow() {\n      if (this.selectedRows.length > 0) {\n        return this.selectedRows[0];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"$selectedRows\",\n    value: function $selectedRows() {\n      if (!this.$data) {\n        return $();\n      }\n\n      return this.$data.find('.selected');\n    }\n  }, {\n    key: \"$cellsForColIndex\",\n    value: function $cellsForColIndex(colIndex, includeAggrRows) {\n      var selector = '.table-row > div:nth-of-type(' + colIndex + ')';\n\n      if (includeAggrRows) {\n        selector += ', .table-aggregate-row > div:nth-of-type(' + colIndex + ')';\n      }\n\n      return this.$data.find(selector);\n    }\n  }, {\n    key: \"$cellsForColIndexWidthFix\",\n    value: function $cellsForColIndexWidthFix(colIndex, includeAggrRows) {\n      var selector = '.table-row > div:nth-of-type(' + colIndex + ') > .width-fix ';\n\n      if (includeAggrRows) {\n        selector += ', .table-aggregate-row > div:nth-of-type(' + colIndex + ') > .width-fix';\n      }\n\n      return this.$data.find(selector);\n    }\n  }, {\n    key: \"$cellsForRow\",\n    value: function $cellsForRow($row) {\n      return $row.children('.table-cell');\n    }\n    /**\n     * @param {Column|number} column or columnIndex\n     * @returns {$}\n     */\n\n  }, {\n    key: \"$cell\",\n    value: function $cell(column, $row) {\n      var columnIndex = column;\n\n      if (typeof column !== 'number') {\n        columnIndex = this.visibleColumns().indexOf(column);\n      }\n\n      return $row.children('.table-cell').eq(columnIndex);\n    }\n  }, {\n    key: \"columnById\",\n    value: function columnById(columnId) {\n      return arrays.find(this.columns, function (column) {\n        return column.id === columnId;\n      });\n    }\n    /**\n     * @param {$} $cell the $cell to get the column for\n     * @param {$} [$row] the $row which contains the $cell. If not passed it will be determined automatically\n     * @returns {Column} the column for the given $cell\n     */\n\n  }, {\n    key: \"columnFor$Cell\",\n    value: function columnFor$Cell($cell, $row) {\n      $row = $row || $cell.closest('.table-row');\n      var cellIndex = this.$cellsForRow($row).index($cell);\n      return this.visibleColumns()[cellIndex];\n    }\n  }, {\n    key: \"columnsByIds\",\n    value: function columnsByIds(columnIds) {\n      return columnIds.map(this.columnById.bind(this));\n    }\n  }, {\n    key: \"getVisibleRows\",\n    value: function getVisibleRows() {\n      return this.visibleRows;\n    }\n  }, {\n    key: \"_updateRowStructure\",\n    value: function _updateRowStructure(options) {\n      var updateTree = scout.nvl(options.updateTree, false),\n          updateFilteredRows = scout.nvl(options.filteredRows, updateTree),\n          applyFilters = scout.nvl(options.applyFilters, updateFilteredRows),\n          updateVisibleRows = scout.nvl(options.visibleRows, updateFilteredRows);\n\n      if (updateTree) {\n        this._rebuildTreeStructure();\n      }\n\n      if (updateFilteredRows) {\n        this._updateFilteredRows(applyFilters);\n      }\n\n      if (updateVisibleRows) {\n        this._updateVisibleRows();\n      }\n    }\n  }, {\n    key: \"_rebuildTreeStructure\",\n    value: function _rebuildTreeStructure() {\n      var hierarchical = false;\n      this.rows.forEach(function (row) {\n        row.childRows = [];\n        hierarchical = hierarchical || !objects.isNullOrUndefined(row.parentRow);\n      }, this);\n\n      if (!hierarchical) {\n        this.rootRows = this.rows;\n\n        this._setHierarchical(hierarchical);\n\n        return;\n      }\n\n      this._setHierarchical(hierarchical);\n\n      this.rootRows = [];\n      this.rows.forEach(function (row) {\n        var parentRow;\n\n        if (objects.isNullOrUndefined(row.parentRow)) {\n          // root row\n          row.parentRow = null;\n          row._parentRowId = null;\n          this.rootRows.push(row);\n          return;\n        }\n\n        if (!objects.isNullOrUndefined(row.parentRow.id)) {\n          parentRow = this.rowsMap[row.parentRow.id];\n        } else {\n          // expect id\n          parentRow = this.rowsMap[row.parentRow];\n        }\n\n        if (parentRow) {\n          row.parentRow = parentRow;\n          row._parentRowId = parentRow.id;\n          parentRow.childRows.push(row);\n        } else {\n          // do not allow unresolvable parent rows.\n          throw new Error('Parent row of ' + row + ' can not be resolved.');\n        }\n      }, this); // traverse row tree to have minimal order of rows.\n\n      this._maxLevel = 0;\n      this.rows = [];\n      this.visitRows(function (row, level) {\n        row._hierarchyLevel = level;\n        this._maxLevel = Math.max(level, this._maxLevel);\n        this.rows.push(row);\n      }.bind(this));\n\n      this._calculateTableNodeColumn();\n    }\n  }, {\n    key: \"_updateFilteredRows\",\n    value: function _updateFilteredRows(applyFilters, changed) {\n      changed = Boolean(changed);\n      applyFilters = scout.nvl(applyFilters, true);\n      this._filteredRows = this.rows.filter(function (row) {\n        if (applyFilters) {\n          changed = this._applyFiltersForRow(row) || changed;\n        }\n\n        return row.filterAccepted;\n      }, this);\n\n      if (changed) {\n        this._triggerFilter();\n      }\n    }\n  }, {\n    key: \"_updateVisibleRows\",\n    value: function _updateVisibleRows() {\n      this.visibleRows = this._computeVisibleRows(); // rebuild the rows by id map of visible rows\n\n      this.visibleRowsMap = this.visibleRows.reduce(function (map, row) {\n        map[row.id] = row;\n        return map;\n      }, {});\n\n      if (this.initialized) {\n        // deselect not visible rows\n        this.deselectRows(this.selectedRows.filter(function (selectedRow) {\n          return !this.visibleRowsMap[selectedRow.id];\n        }, this));\n      }\n    }\n  }, {\n    key: \"_computeVisibleRows\",\n    value: function _computeVisibleRows(rows) {\n      var visibleRows = [];\n      rows = rows || this.rootRows;\n      rows.forEach(function (row) {\n        var visibleChildRows = this._computeVisibleRows(row.childRows);\n\n        if (row.filterAccepted) {\n          visibleRows.push(row);\n        } else if (visibleChildRows.length > 0) {\n          visibleRows.push(row);\n        }\n\n        row._expandable = visibleChildRows.length > 0;\n\n        if (row.expanded) {\n          visibleRows = visibleRows.concat(visibleChildRows);\n        }\n      }, this);\n      return visibleRows;\n    }\n  }, {\n    key: \"visibleChildRows\",\n    value: function visibleChildRows(row) {\n      return row.childRows.filter(function (child) {\n        return Boolean(this.visibleRowsMap[child.id]);\n      }, this);\n    }\n  }, {\n    key: \"_renderRowDelta\",\n    value: function _renderRowDelta() {\n      if (!this._isDataRendered()) {\n        return;\n      }\n\n      var renderedRows = [];\n      var rowsToHide = [];\n      this.$rows().each(function (i, elem) {\n        var $row = $(elem),\n            row = $row.data('row');\n\n        if (this.visibleRows.indexOf(row) < 0) {\n          // remember for remove animated\n          row.$row.detach();\n          rowsToHide.push(row);\n        } else {\n          renderedRows.push(row);\n        }\n      }.bind(this));\n\n      this._rerenderViewport(); // insert rows to remove animated\n\n\n      rowsToHide.forEach(function (row) {\n        row.$row.insertAfter(this.$fillBefore);\n      }, this); // Rows removed by an animation are still there, new rows were appended -> reset correct row order\n\n      this._order$Rows().insertAfter(this.$fillBefore); // Also make sure aggregate rows are at the correct position (_renderAggregateRows does nothing because they are already rendered)\n\n\n      this._order$AggregateRows();\n\n      rowsToHide.forEach(function (row) {\n        // remove animated\n        this._hideRow(row);\n      }, this);\n      this.$rows().each(function (i, elem) {\n        var $row = $(elem),\n            row = $row.data('row');\n\n        if ($row.hasClass('hiding')) {\n          // Do not remove rows which are removed using an animation\n          // row.$row may already point to a new row -> don't call removeRow to not accidentally remove the new row\n          return;\n        }\n\n        if (renderedRows.indexOf(row) < 0) {\n          this._showRow(row);\n        }\n      }.bind(this));\n\n      this._renderScrollTop();\n\n      this._renderEmptyData();\n    }\n  }, {\n    key: \"filter\",\n    value: function filter() {\n      this._updateRowStructure({\n        filteredRows: true\n      });\n\n      this._renderRowDelta();\n\n      this._group();\n\n      this.revealSelection();\n    }\n    /**\n     * Sorts the given $rows according to the row index\n     */\n\n  }, {\n    key: \"_order$Rows\",\n    value: function _order$Rows($rows) {\n      // Find rows using jquery because\n      // this.filteredRows() may be empty but there may be $rows which are getting removed by animation\n      $rows = $rows || this.$rows();\n      return $rows.sort(function (elem1, elem2) {\n        var $row1 = $(elem1),\n            $row2 = $(elem2),\n            row1 = $row1.data('row'),\n            row2 = $row2.data('row');\n        return this.rows.indexOf(row1) - this.rows.indexOf(row2);\n      }.bind(this));\n    }\n  }, {\n    key: \"_order$AggregateRows\",\n    value: function _order$AggregateRows($rows) {\n      // Find aggregate rows using jquery because\n      // this._aggregateRows may be empty but there may be $aggregateRows which are getting removed by animation\n      $rows = $rows || this.$aggregateRows();\n      $rows.each(function (i, elem) {\n        var $aggrRow = $(elem),\n            aggregateRow = $aggrRow.data('aggregateRow');\n\n        if (!aggregateRow || !aggregateRow.prevRow) {\n          return;\n        }\n\n        $aggrRow.insertAfter(aggregateRow.prevRow.$row);\n      });\n    }\n  }, {\n    key: \"_rowAcceptedByFilters\",\n    value: function _rowAcceptedByFilters(row) {\n      for (var key in this._filterMap) {\n        // NOSONAR\n        var filter = this._filterMap[key];\n\n        if (!filter.accept(row)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * @returns {Boolean} true if row state has changed, false if not\n     */\n\n  }, {\n    key: \"_applyFiltersForRow\",\n    value: function _applyFiltersForRow(row) {\n      if (this._rowAcceptedByFilters(row)) {\n        if (!row.filterAccepted) {\n          row.filterAccepted = true;\n          return true;\n        }\n      } else if (row.filterAccepted) {\n        row.filterAccepted = false;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @returns {String[]} labels of the currently active Filters that provide a createLabel() function\n     */\n\n  }, {\n    key: \"filteredBy\",\n    value: function filteredBy() {\n      var filteredBy = [];\n\n      for (var key in this._filterMap) {\n        // NOSONAR\n        var filter = this._filterMap[key]; // check if filter supports label\n\n        if (typeof filter.createLabel === 'function') {\n          filteredBy.push(filter.createLabel());\n        }\n      }\n\n      return filteredBy;\n    }\n  }, {\n    key: \"resetUserFilter\",\n    value: function resetUserFilter() {\n      var filter;\n\n      for (var key in this._filterMap) {\n        // NOSONAR\n        filter = this._filterMap[key];\n\n        if (filter instanceof TableUserFilter) {\n          this.removeFilterByKey(key);\n        }\n      } // reset rows\n\n\n      this.filter();\n\n      this._triggerFilterReset();\n    }\n  }, {\n    key: \"hasUserFilter\",\n    value: function hasUserFilter() {\n      return objects.values(this._filterMap).filter(function (filter) {\n        return filter instanceof TableUserFilter;\n      }).length > 0;\n    }\n  }, {\n    key: \"resizeToFit\",\n    value: function resizeToFit(column, maxWidth) {\n      if (column.fixedWidth) {\n        return;\n      }\n\n      var returnValue = column.calculateOptimalWidth();\n\n      if (objects.isPlainObject(returnValue)) {\n        // Function returned a promise -> delay resizing\n        returnValue.always(this._resizeToFit.bind(this, column, maxWidth));\n      } else {\n        this._resizeToFit(column, maxWidth, returnValue);\n      }\n    }\n  }, {\n    key: \"_resizeToFit\",\n    value: function _resizeToFit(column, maxWidth, calculatedSize) {\n      if (calculatedSize === -1) {\n        // Calculation has been aborted -> don't resize\n        return;\n      }\n\n      if (maxWidth && maxWidth > 0 && calculatedSize > maxWidth) {\n        calculatedSize = maxWidth;\n      }\n\n      if (Device.get().isInternetExplorer() && calculatedSize !== column.minWidth) {\n        calculatedSize++;\n      }\n\n      if (column.width !== calculatedSize) {\n        this.resizeColumn(column, calculatedSize);\n      }\n\n      column.autoOptimizeWidthRequired = false;\n\n      this._triggerColumnResizedToFit();\n    }\n    /**\n     * @param filter object with createKey() and accept()\n     */\n\n  }, {\n    key: \"addFilter\",\n    value: function addFilter(filter) {\n      var key = filter.createKey();\n\n      if (!key) {\n        throw new Error('key has to be defined');\n      }\n\n      this._filterMap[key] = filter;\n      this.trigger('filterAdded', {\n        filter: filter\n      });\n    }\n  }, {\n    key: \"removeFilter\",\n    value: function removeFilter(filter) {\n      this.removeFilterByKey(filter.createKey());\n    }\n  }, {\n    key: \"removeFilterByKey\",\n    value: function removeFilterByKey(key) {\n      if (!key) {\n        throw new Error('key has to be defined');\n      }\n\n      var filter = this._filterMap[key];\n\n      if (!filter) {\n        return;\n      }\n\n      delete this._filterMap[key];\n      this.trigger('filterRemoved', {\n        filter: filter\n      });\n    }\n  }, {\n    key: \"getFilter\",\n    value: function getFilter(key) {\n      if (!key) {\n        throw new Error('key has to be defined');\n      }\n\n      return this._filterMap[key];\n    }\n    /**\n     * Resizes the given column to the new size.\n     *\n     * @param column\n     *          column to resize\n     * @param width\n     *          new column size\n     */\n\n  }, {\n    key: \"resizeColumn\",\n    value: function resizeColumn(column, width) {\n      if (column.fixedWidth) {\n        return;\n      }\n\n      width = Math.floor(width);\n      column.width = width;\n      var visibleColumnIndex = this.visibleColumns().indexOf(column);\n\n      if (visibleColumnIndex !== -1) {\n        var colNum = visibleColumnIndex + 1;\n        this.$cellsForColIndex(colNum, true).css('min-width', width).css('max-width', width);\n\n        this._updateRealColumnWidth(column);\n\n        this._updateRowWidth();\n\n        this.$rows(true).css('width', this.rowWidth); // If resized column contains cells with wrapped text, view port needs to be updated\n        // Remove row height for non rendered rows because it may have changed due to resizing (wrap text)\n\n        this._updateRowHeights();\n\n        this._renderFiller();\n\n        this._renderViewport();\n\n        this.updateScrollbars();\n\n        this._renderEmptyData();\n      }\n\n      this._aggregateRows.forEach(function (aggregateRow) {\n        if (aggregateRow.$row) {\n          this._resizeCell(this.$cell(column, aggregateRow.$row));\n        }\n      }, this);\n\n      this._triggerColumnResized(column);\n    }\n  }, {\n    key: \"_resizeCell\",\n    value: function _resizeCell($cell) {\n      var $cellIcon = $cell.children('.table-cell-icon');\n      $cellIcon.setVisible(true);\n\n      if ($cell.isContentTruncated()) {\n        $cellIcon.setVisible(false);\n      }\n    }\n  }, {\n    key: \"moveColumn\",\n    value: function moveColumn(column, visibleOldPos, visibleNewPos, dragged) {\n      // If there are fixed columns, don't allow moving the column onto the other side of the fixed columns\n      visibleNewPos = this._considerFixedPositionColumns(visibleOldPos, visibleNewPos); // Translate position of 'visible columns' array to position in 'all columns' array\n\n      var visibleColumns = this.visibleColumns();\n      var newColumn = visibleColumns[visibleNewPos];\n      var newPos = this.columns.indexOf(newColumn);\n      arrays.remove(this.columns, column);\n      arrays.insert(this.columns, column, newPos);\n      visibleColumns = this.visibleColumns();\n      visibleNewPos = visibleColumns.indexOf(column); // we must re-evaluate visible columns\n\n      this._calculateTableNodeColumn();\n\n      this._triggerColumnMoved(column, visibleOldPos, visibleNewPos, dragged); // move aggregated rows\n\n\n      this._aggregateRows.forEach(function (aggregateRow) {\n        arrays.move(aggregateRow.contents, visibleOldPos, visibleNewPos);\n      }); // move cells\n\n\n      if (this._isDataRendered()) {\n        this._rerenderViewport();\n      }\n    }\n    /**\n     * Ensures the given newPos does not pass a fixed column boundary (necessary when moving columns)\n     */\n\n  }, {\n    key: \"_considerFixedPositionColumns\",\n    value: function _considerFixedPositionColumns(visibleOldPos, visibleNewPos) {\n      var fixedColumnIndex = -1;\n\n      if (visibleNewPos > visibleOldPos) {\n        // move to right\n        fixedColumnIndex = arrays.findIndexFrom(this.visibleColumns(), visibleOldPos, function (col) {\n          return col.fixedPosition;\n        });\n\n        if (fixedColumnIndex > -1) {\n          visibleNewPos = Math.min(visibleNewPos, fixedColumnIndex - 1);\n        }\n      } else {\n        // move to left\n        fixedColumnIndex = arrays.findIndexFromReverse(this.visibleColumns(), visibleOldPos, function (col) {\n          return col.fixedPosition;\n        });\n\n        if (fixedColumnIndex > -1) {\n          visibleNewPos = Math.max(visibleNewPos, fixedColumnIndex + 1);\n        }\n      }\n\n      return visibleNewPos;\n    }\n  }, {\n    key: \"_renderColumnOrderChanges\",\n    value: function _renderColumnOrderChanges(oldColumnOrder) {\n      var column,\n          i,\n          j,\n          $orderedCells,\n          $cell,\n          $cells,\n          that = this,\n          $row;\n\n      if (this.header) {\n        this.header.onOrderChanged(oldColumnOrder);\n      } // move cells\n\n\n      this.$rows(true).each(function () {\n        $row = $(this);\n        $orderedCells = $();\n        $cells = $row.children();\n\n        for (i = 0; i < that.columns.length; i++) {\n          column = that.columns[i]; // Find $cell for given column\n\n          for (j = 0; j < oldColumnOrder.length; j++) {\n            if (oldColumnOrder[j] === column) {\n              $cell = $cells[j];\n              break;\n            }\n          }\n\n          $orderedCells.push($cell);\n        }\n\n        $row.prepend($orderedCells);\n      });\n    }\n  }, {\n    key: \"_triggerRowsInserted\",\n    value: function _triggerRowsInserted(rows) {\n      this.trigger('rowsInserted', {\n        rows: rows\n      });\n    }\n  }, {\n    key: \"_triggerRowsDeleted\",\n    value: function _triggerRowsDeleted(rows) {\n      this.trigger('rowsDeleted', {\n        rows: rows\n      });\n    }\n  }, {\n    key: \"_triggerRowsUpdated\",\n    value: function _triggerRowsUpdated(rows) {\n      this.trigger('rowsUpdated', {\n        rows: rows\n      });\n    }\n  }, {\n    key: \"_triggerAllRowsDeleted\",\n    value: function _triggerAllRowsDeleted(rows) {\n      this.trigger('allRowsDeleted', {\n        rows: rows\n      });\n    }\n  }, {\n    key: \"_triggerRowsSelected\",\n    value: function _triggerRowsSelected(debounce) {\n      this.trigger('rowsSelected', {\n        debounce: debounce\n      });\n    }\n  }, {\n    key: \"_triggerRowsChecked\",\n    value: function _triggerRowsChecked(rows) {\n      this.trigger('rowsChecked', {\n        rows: rows\n      });\n    }\n  }, {\n    key: \"_triggerRowsExpanded\",\n    value: function _triggerRowsExpanded(rows) {\n      this.trigger('rowsExpanded', {\n        rows: rows\n      });\n    }\n  }, {\n    key: \"_triggerFilter\",\n    value: function _triggerFilter() {\n      this.trigger('filter');\n    }\n  }, {\n    key: \"_triggerFilterReset\",\n    value: function _triggerFilterReset() {\n      this.trigger('filterReset');\n    }\n  }, {\n    key: \"_triggerAppLinkAction\",\n    value: function _triggerAppLinkAction(column, ref) {\n      this.trigger('appLinkAction', {\n        column: column,\n        ref: ref\n      });\n    }\n  }, {\n    key: \"_triggerReload\",\n    value: function _triggerReload(reloadReason) {\n      this.trigger('reload', {\n        reloadReason: reloadReason\n      });\n    }\n  }, {\n    key: \"_triggerClipboardExport\",\n    value: function _triggerClipboardExport() {\n      var event = new Event();\n      this.trigger('clipboardExport', event);\n\n      if (!event.defaultPrevented) {\n        this._exportToClipboard();\n      }\n    }\n  }, {\n    key: \"_triggerRowOrderChanged\",\n    value: function _triggerRowOrderChanged(row, animating) {\n      var event = {\n        row: row,\n        animating: animating\n      };\n      this.trigger('rowOrderChanged', event);\n    }\n  }, {\n    key: \"_triggerColumnResized\",\n    value: function _triggerColumnResized(column) {\n      var event = {\n        column: column\n      };\n      this.trigger('columnResized', event);\n    }\n  }, {\n    key: \"_triggerColumnResizedToFit\",\n    value: function _triggerColumnResizedToFit(column) {\n      var event = {\n        column: column\n      };\n      this.trigger('columnResizedToFit', event);\n    }\n  }, {\n    key: \"_triggerColumnMoved\",\n    value: function _triggerColumnMoved(column, oldPos, newPos, dragged) {\n      var event = {\n        column: column,\n        oldPos: oldPos,\n        newPos: newPos,\n        dragged: dragged\n      };\n      this.trigger('columnMoved', event);\n    }\n  }, {\n    key: \"_triggerAggregationFunctionChanged\",\n    value: function _triggerAggregationFunctionChanged(column) {\n      var event = {\n        column: column\n      };\n      this.trigger('aggregationFunctionChanged', event);\n    }\n  }, {\n    key: \"setHeaderVisible\",\n    value: function setHeaderVisible(visible) {\n      this.setProperty('headerVisible', visible);\n    }\n  }, {\n    key: \"_renderHeaderVisible\",\n    value: function _renderHeaderVisible() {\n      this._renderTableHeader();\n    }\n  }, {\n    key: \"setHeaderEnabled\",\n    value: function setHeaderEnabled(headerEnabled) {\n      this.setProperty('headerEnabled', headerEnabled);\n    }\n  }, {\n    key: \"_renderHeaderEnabled\",\n    value: function _renderHeaderEnabled() {\n      // Rebuild the table header when this property changes\n      this._removeTableHeader();\n\n      this._renderTableHeader();\n    }\n  }, {\n    key: \"setHeaderMenusEnabled\",\n    value: function setHeaderMenusEnabled(headerMenusEnabled) {\n      this.setProperty('headerMenusEnabled', headerMenusEnabled);\n\n      if (this.header) {\n        this.header.setHeaderMenusEnabled(this.headerMenusEnabled);\n      }\n    }\n  }, {\n    key: \"hasPermanentHeadOrTailSortColumns\",\n    value: function hasPermanentHeadOrTailSortColumns() {\n      return this._permanentHeadSortColumns.length !== 0 || this._permanentTailSortColumns.length !== 0;\n    }\n  }, {\n    key: \"_setHeadAndTailSortColumns\",\n    value: function _setHeadAndTailSortColumns() {\n      // find all sort columns (head and tail sort columns should always be included)\n      var sortColumns = this.columns.filter(function (c) {\n        return c.sortIndex >= 0;\n      });\n      sortColumns.sort(function (a, b) {\n        return a.sortIndex - b.sortIndex;\n      });\n      this._permanentHeadSortColumns = [];\n      this._permanentTailSortColumns = [];\n      sortColumns.forEach(function (c) {\n        if (c.initialAlwaysIncludeSortAtBegin) {\n          this._permanentHeadSortColumns.push(c);\n        } else if (c.initialAlwaysIncludeSortAtEnd) {\n          this._permanentTailSortColumns.push(c);\n        }\n      }, this);\n    }\n  }, {\n    key: \"setTileMode\",\n    value: function setTileMode(tileMode) {\n      this.setProperty('tileMode', tileMode);\n    }\n  }, {\n    key: \"_setTileMode\",\n    value: function _setTileMode(tileMode) {\n      if (tileMode) {\n        this._ensureMediator();\n\n        if (!this.tileTableHeader) {\n          this._setTileTableHeader(this._createTileTableHeader());\n        }\n\n        this.tableTileGridMediator.loadTiles();\n        this.tableTileGridMediator.activate();\n      }\n\n      this._setProperty('tileMode', tileMode);\n\n      if (!tileMode && this.tableTileGridMediator) {\n        this.tableTileGridMediator.deactivate();\n      }\n    }\n  }, {\n    key: \"_ensureMediator\",\n    value: function _ensureMediator() {\n      if (!this.tableTileGridMediator) {\n        this.tableTileGridMediator = scout.create('TableTileGridMediator', {\n          parent: this,\n          gridColumnCount: 6\n        });\n      }\n    }\n  }, {\n    key: \"_renderTileMode\",\n    value: function _renderTileMode() {\n      if (this.tableTileGridMediator) {\n        this.tableTileGridMediator.renderTileMode();\n      }\n    }\n  }, {\n    key: \"createTiles\",\n    value: function createTiles(rows) {\n      return rows.map(function (row) {\n        var tile = this.createTileForRow(row);\n\n        this._adaptTile(tile);\n\n        tile.rowId = row.id;\n        return tile;\n      }, this);\n    }\n  }, {\n    key: \"_adaptTile\",\n    value: function _adaptTile(tile) {\n      tile.gridDataHints = {\n        weightX: 0\n      };\n    }\n  }, {\n    key: \"createTileForRow\",\n    value: function createTileForRow(row) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"_setTileTableHeader\",\n    value: function _setTileTableHeader(tileTableHeader) {\n      if (tileTableHeader) {\n        tileTableHeader.addCssClass('tile-table-header');\n      }\n\n      this._setProperty('tileTableHeader', tileTableHeader);\n    }\n  }, {\n    key: \"_createTileTableHeader\",\n    value: function _createTileTableHeader() {\n      return scout.create('TileTableHeaderBox', {\n        parent: this\n      });\n    }\n  }, {\n    key: \"setRowIconVisible\",\n    value: function setRowIconVisible(rowIconVisible) {\n      this.setProperty('rowIconVisible', rowIconVisible);\n    }\n  }, {\n    key: \"_setRowIconVisible\",\n    value: function _setRowIconVisible(rowIconVisible) {\n      this._setProperty('rowIconVisible', rowIconVisible);\n\n      var column = this.rowIconColumn;\n\n      if (this.rowIconVisible && !column) {\n        this._insertRowIconColumn();\n\n        this._calculateTableNodeColumn();\n\n        this.trigger('columnStructureChanged');\n      } else if (!this.rowIconVisible && column) {\n        arrays.remove(this.columns, column);\n        this.rowIconColumn = null;\n\n        this._calculateTableNodeColumn();\n\n        this.trigger('columnStructureChanged');\n      }\n    }\n  }, {\n    key: \"setRowIconColumnWidth\",\n    value: function setRowIconColumnWidth(width) {\n      this.setProperty('rowIconColumnWidth', width);\n    }\n  }, {\n    key: \"_setRowIconColumnWidth\",\n    value: function _setRowIconColumnWidth(width) {\n      this._setProperty('rowIconColumnWidth', width);\n\n      var column = this.rowIconColumn;\n\n      if (column) {\n        column.width = width;\n      }\n    }\n  }, {\n    key: \"_setSelectedRows\",\n    value: function _setSelectedRows(selectedRows) {\n      if (typeof selectedRows[0] === 'string') {\n        selectedRows = this._rowsByIds(selectedRows);\n      }\n\n      this._setProperty('selectedRows', selectedRows);\n    }\n  }, {\n    key: \"setMenus\",\n    value: function setMenus(menus) {\n      this.setProperty('menus', menus);\n    }\n  }, {\n    key: \"_setMenus\",\n    value: function _setMenus(menus, oldMenus) {\n      this.updateKeyStrokes(menus, oldMenus);\n\n      this._setProperty('menus', menus);\n\n      this._updateMenuBar();\n\n      if (this.header) {\n        this.header.updateMenuBar();\n      }\n    }\n  }, {\n    key: \"setMenuBarVisible\",\n    value: function setMenuBarVisible(visible) {\n      this.setProperty('menuBarVisible', visible);\n    }\n  }, {\n    key: \"_setMenuBarVisible\",\n    value: function _setMenuBarVisible(visible) {\n      this._setProperty('menuBarVisible', visible);\n\n      this._updateMenuBar();\n    }\n  }, {\n    key: \"_renderMenuBarVisible\",\n    value: function _renderMenuBarVisible() {\n      if (this.menuBarVisible) {\n        this.menuBar.render();\n\n        this._refreshMenuBarPosition();\n      } else {\n        this.menuBar.remove();\n      }\n\n      this._updateMenuBar();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_refreshMenuBarPosition\",\n    value: function _refreshMenuBarPosition() {\n      if (this.menuBarVisible && this.menuBar.rendered) {\n        if (this.menuBar.position === MenuBar.Position.TOP) {\n          this.menuBar.$container.prependTo(this.$container);\n        } else {\n          this.menuBar.$container.appendTo(this.$container);\n        }\n      }\n    }\n  }, {\n    key: \"_createMenuBar\",\n    value: function _createMenuBar() {\n      return scout.create('MenuBar', {\n        parent: this,\n        position: MenuBar.Position.BOTTOM,\n        menuOrder: new MenuItemsOrder(this.session, 'Table'),\n        menuFilter: this._filterMenusHandler\n      });\n    }\n  }, {\n    key: \"_updateMenuBar\",\n    value: function _updateMenuBar() {\n      if (this.menuBarVisible) {\n        // Do not update menuBar while it is invisible, the menus may now be managed by another widget.\n        // -> this makes sure the parent is not accidentally set to the table, the other widget should remain responsible\n        var notAllowedTypes = ['Header'];\n\n        var menuItems = this._filterMenus(this.menus, MenuDestinations.MENU_BAR, false, true, notAllowedTypes);\n\n        menuItems = this.staticMenus.concat(menuItems);\n        this.menuBar.setMenuItems(menuItems);\n      }\n\n      if (this.contextMenu) {\n        var contextMenuItems = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true, false, ['Header']);\n\n        this.contextMenu.updateMenuItems(contextMenuItems);\n      }\n    }\n  }, {\n    key: \"_setKeyStrokes\",\n    value: function _setKeyStrokes(keyStrokes) {\n      this.updateKeyStrokes(keyStrokes, this.keyStrokes);\n\n      this._setProperty('keyStrokes', keyStrokes);\n    }\n  }, {\n    key: \"setFilters\",\n    value: function setFilters(filters) {\n      var filter;\n\n      for (var key in this._filterMap) {\n        // NOSONAR\n        filter = this._filterMap[key];\n\n        if (filter instanceof TableUserFilter) {\n          this.removeFilterByKey(key);\n        }\n      }\n\n      if (filters) {\n        filters.forEach(function (filter) {\n          filter = this._ensureFilter(filter);\n          this.addFilter(filter);\n        }, this);\n      }\n    }\n  }, {\n    key: \"_ensureFilter\",\n    value: function _ensureFilter(filter) {\n      if (filter instanceof TableUserFilter) {\n        return filter;\n      }\n\n      if (filter.column) {\n        filter.column = this.columnById(filter.column);\n      }\n\n      filter.table = this;\n      filter.session = this.session;\n      return scout.create(filter);\n    }\n  }, {\n    key: \"setTableStatus\",\n    value: function setTableStatus(status) {\n      this.setProperty('tableStatus', status);\n    }\n  }, {\n    key: \"_setTableStatus\",\n    value: function _setTableStatus(status) {\n      status = Status.ensure(status);\n\n      this._setProperty('tableStatus', status);\n    }\n  }, {\n    key: \"setTableStatusVisible\",\n    value: function setTableStatusVisible(visible) {\n      this.setProperty('tableStatusVisible', visible);\n\n      this._updateFooterVisibility();\n    }\n  }, {\n    key: \"_updateFooterVisibility\",\n    value: function _updateFooterVisibility() {\n      this.setFooterVisible(this.tableStatusVisible || this._hasVisibleTableControls());\n    }\n  }, {\n    key: \"setHierarchicalStyle\",\n    value: function setHierarchicalStyle(style) {\n      this.setProperty('hierarchicalStyle', style);\n    }\n  }, {\n    key: \"_renderHierarchicalStyle\",\n    value: function _renderHierarchicalStyle() {\n      this.$container.toggleClass('structured', Table.HierarchicalStyle.STRUCTURED === this.hierarchicalStyle);\n    }\n  }, {\n    key: \"setFooterVisible\",\n    value: function setFooterVisible(visible) {\n      this._setProperty('footerVisible', visible);\n\n      if (visible && !this.footer) {\n        this.footer = this._createFooter();\n      } // relink table controls to new footer\n\n\n      this.tableControls.forEach(function (control) {\n        control.tableFooter = this.footer;\n      }, this);\n\n      if (this.rendered) {\n        this._renderFooterVisible();\n      }\n\n      if (!visible && this.footer) {\n        this.footer.destroy();\n        this.footer = null;\n      }\n    }\n    /**\n     * Renders the background effect of every column, if column.backgroundEffect is set\n     */\n\n  }, {\n    key: \"_renderBackgroundEffect\",\n    value: function _renderBackgroundEffect() {\n      this.columns.forEach(function (column) {\n        if (!column.backgroundEffect) {\n          return;\n        }\n\n        column._renderBackgroundEffect();\n      }, this);\n    }\n  }, {\n    key: \"_renderRowChecked\",\n    value: function _renderRowChecked(row) {\n      if (!this.checkable) {\n        return;\n      }\n\n      if (!row.$row) {\n        return;\n      }\n\n      var $styleElem;\n\n      if (this.checkableStyle === Table.CheckableStyle.TABLE_ROW) {\n        $styleElem = row.$row;\n      } else {\n        if (!this.checkableColumn) {\n          throw new Error('checkableColumn not set');\n        }\n\n        $styleElem = this.checkableColumn.$checkBox(row.$row);\n      }\n\n      $styleElem.toggleClass('checked', row.checked);\n    }\n  }, {\n    key: \"setCheckable\",\n    value: function setCheckable(checkable) {\n      this.setProperty('checkable', checkable);\n    }\n  }, {\n    key: \"_setCheckable\",\n    value: function _setCheckable(checkable) {\n      this._setProperty('checkable', checkable);\n\n      this._updateCheckableColumn();\n    }\n  }, {\n    key: \"_updateCheckableColumn\",\n    value: function _updateCheckableColumn() {\n      var column = this.checkableColumn;\n      var showCheckBoxes = this.checkable && scout.isOneOf(this.checkableStyle, Table.CheckableStyle.CHECKBOX, Table.CheckableStyle.CHECKBOX_TABLE_ROW);\n\n      if (showCheckBoxes && !column) {\n        this._insertBooleanColumn();\n\n        this._calculateTableNodeColumn();\n\n        this.trigger('columnStructureChanged');\n      } else if (!showCheckBoxes && column && column.guiOnly) {\n        arrays.remove(this.columns, column);\n        this.checkableColumn = null;\n\n        this._calculateTableNodeColumn();\n\n        this.trigger('columnStructureChanged');\n      }\n    }\n  }, {\n    key: \"_renderCheckable\",\n    value: function _renderCheckable() {\n      this.columnLayoutDirty = true;\n\n      this._updateRowWidth();\n\n      this._redraw();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"setCheckableStyle\",\n    value: function setCheckableStyle(checkableStyle) {\n      this.setProperty('checkableStyle', checkableStyle);\n    }\n  }, {\n    key: \"_setCheckableStyle\",\n    value: function _setCheckableStyle(checkableStyle) {\n      this._setProperty('checkableStyle', checkableStyle);\n\n      this._updateCheckableColumn();\n    }\n  }, {\n    key: \"_renderCheckableStyle\",\n    value: function _renderCheckableStyle() {\n      this.$container.toggleClass('checkable', scout.isOneOf(this.checkableStyle, Table.CheckableStyle.TABLE_ROW, Table.CheckableStyle.CHECKBOX_TABLE_ROW));\n      this.$container.toggleClass('table-row-check', this.checkableStyle === Table.CheckableStyle.TABLE_ROW);\n\n      if (this._isDataRendered()) {\n        this._redraw();\n      }\n    }\n  }, {\n    key: \"_renderRowIconVisible\",\n    value: function _renderRowIconVisible() {\n      this.columnLayoutDirty = true;\n\n      this._updateRowWidth();\n\n      this._redraw();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_renderRowIconColumnWidth\",\n    value: function _renderRowIconColumnWidth() {\n      if (!this.rowIconVisible) {\n        return;\n      }\n\n      this._renderRowIconVisible();\n    }\n  }, {\n    key: \"setGroupingStyle\",\n    value: function setGroupingStyle(groupingStyle) {\n      this.setProperty('groupingStyle', groupingStyle);\n    }\n  }, {\n    key: \"_setGroupingStyle\",\n    value: function _setGroupingStyle(groupingStyle) {\n      this._setProperty('groupingStyle', groupingStyle);\n\n      this._group();\n    }\n  }, {\n    key: \"_renderGroupingStyle\",\n    value: function _renderGroupingStyle() {\n      this._rerenderViewport();\n    }\n  }, {\n    key: \"_redraw\",\n    value: function _redraw() {\n      if (this._isDataRendered()) {\n        this._rerenderHeaderColumns();\n\n        this._rerenderViewport();\n      }\n    }\n  }, {\n    key: \"_rerenderHeaderColumns\",\n    value: function _rerenderHeaderColumns() {\n      if (this.header) {\n        this.header.rerenderColumns();\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_renderTableHeader\",\n    value: function _renderTableHeader() {\n      if (this.tileMode) {\n        return;\n      }\n\n      var changed = false;\n\n      if (this.headerVisible && !this.header) {\n        this.header = this._createHeader();\n        this.header.render();\n\n        this._renderEmptyData();\n\n        changed = true;\n      } else if (!this.headerVisible && this.header) {\n        this._removeTableHeader();\n\n        this._removeEmptyData();\n\n        changed = true;\n      }\n\n      this.$container.toggleClass('header-invisible', !this.header);\n\n      if (changed) {\n        this.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"_removeTableHeader\",\n    value: function _removeTableHeader() {\n      if (this.header) {\n        this.header.destroy();\n        this.header = null;\n      }\n    }\n    /**\n     * @param width optional width of emptyData, if omitted the width is set to the header's scrollWidth.\n     */\n\n  }, {\n    key: \"_renderEmptyData\",\n    value: function _renderEmptyData() {\n      if (!this.header || this.visibleRows.length > 0) {\n        return;\n      }\n\n      if (!this.$emptyData) {\n        this.$emptyData = this.$data.appendDiv().html('&nbsp;');\n      }\n\n      this.$emptyData.css('min-width', this.rowWidth).css('max-width', this.rowWidth);\n      this.updateScrollbars();\n    }\n  }, {\n    key: \"_removeEmptyData\",\n    value: function _removeEmptyData() {\n      if (this.header && this.visibleRows.length === 0) {\n        return;\n      }\n\n      if (this.$emptyData) {\n        this.$emptyData.remove();\n        this.$emptyData = null;\n        this.updateScrollbars();\n      }\n    }\n  }, {\n    key: \"_renderFooterVisible\",\n    value: function _renderFooterVisible() {\n      if (!this.footer) {\n        return;\n      }\n\n      if (this.footerVisible) {\n        this._renderFooter();\n      } else {\n        this._removeFooter();\n      }\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_renderFooter\",\n    value: function _renderFooter() {\n      if (this.footer.rendered) {\n        return;\n      }\n\n      this.footer.render();\n    }\n  }, {\n    key: \"_removeFooter\",\n    value: function _removeFooter() {\n      if (!this.footer.rendered) {\n        return;\n      }\n\n      this.footer.remove();\n    }\n    /**\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_renderEnabled\",\n    value: function _renderEnabled() {\n      _get(_getPrototypeOf(Table.prototype), \"_renderEnabled\", this).call(this);\n\n      var enabled = this.enabledComputed;\n\n      if (!this.tileMode) {\n        this.$data.setEnabled(enabled);\n      }\n\n      this.$container.setTabbable(enabled);\n\n      if (this._isDataRendered()) {\n        // Enable/disable all checkboxes\n        this.$rows().each(function () {\n          var $row = $(this),\n              row = $row.data('row');\n          $row.find('input').setEnabled(enabled && row.enabled);\n        });\n      }\n    }\n    /**\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_renderDisabledStyle\",\n    value: function _renderDisabledStyle() {\n      _get(_getPrototypeOf(Table.prototype), \"_renderDisabledStyle\", this).call(this);\n\n      this._renderDisabledStyleInternal(this.$data);\n    }\n  }, {\n    key: \"setAutoResizeColumns\",\n    value: function setAutoResizeColumns(autoResizeColumns) {\n      this.setProperty('autoResizeColumns', autoResizeColumns);\n    }\n  }, {\n    key: \"_renderAutoResizeColumns\",\n    value: function _renderAutoResizeColumns() {\n      if (!this.autoResizeColumns && Device.get().hasTableCellZoomBug()) {\n        // Clear real width so that row width is updated correctly by the table layout if autoResizeColumns is disabled on the fly\n        this.visibleColumns().forEach(function (column, colIndex) {\n          column._realWidth = null;\n        });\n      }\n\n      this.columnLayoutDirty = true;\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"setMultilineText\",\n    value: function setMultilineText(multilineText) {\n      this.setProperty('multilineText', multilineText);\n    }\n  }, {\n    key: \"_renderMultilineText\",\n    value: function _renderMultilineText() {\n      this._markAutoOptimizeWidthColumnsAsDirty();\n\n      this._redraw();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_renderDropType\",\n    value: function _renderDropType() {\n      if (this.dropType) {\n        this._installDragAndDropHandler();\n      } else {\n        this._uninstallDragAndDropHandler();\n      }\n    }\n  }, {\n    key: \"_installDragAndDropHandler\",\n    value: function _installDragAndDropHandler(event) {\n      if (this.dragAndDropHandler) {\n        return;\n      }\n\n      this.dragAndDropHandler = dragAndDrop.handler(this, {\n        supportedScoutTypes: dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n        dropType: function () {\n          return this.dropType;\n        }.bind(this),\n        dropMaximumSize: function () {\n          return this.dropMaximumSize;\n        }.bind(this),\n        additionalDropProperties: function additionalDropProperties(event) {\n          var $target = $(event.currentTarget);\n          var properties = {\n            rowId: ''\n          };\n\n          if ($target.hasClass('table-row')) {\n            var row = $target.data('row');\n            properties.rowId = row.id;\n          }\n\n          return properties;\n        }\n      });\n      this.dragAndDropHandler.install(this.$container, '.table-data,.table-row');\n    }\n  }, {\n    key: \"_uninstallDragAndDropHandler\",\n    value: function _uninstallDragAndDropHandler(event) {\n      if (!this.dragAndDropHandler) {\n        return;\n      }\n\n      this.dragAndDropHandler.uninstall();\n      this.dragAndDropHandler = null;\n    }\n    /**\n     * This listener is used to invalidate table layout when an image icon has been loaded (which happens async in the browser).\n     */\n\n  }, {\n    key: \"_installImageListeners\",\n    value: function _installImageListeners() {\n      this._imageLoadListener = this._onImageLoadOrError.bind(this); // Image events don't bubble -> use capture phase instead\n\n      this.$data[0].addEventListener('load', this._imageLoadListener, true);\n      this.$data[0].addEventListener('error', this._imageLoadListener, true);\n    }\n  }, {\n    key: \"_uninstallImageListeners\",\n    value: function _uninstallImageListeners() {\n      this.$data[0].removeEventListener('load', this._imageLoadListener, true);\n      this.$data[0].removeEventListener('error', this._imageLoadListener, true);\n    }\n    /**\n     * Calculates the optimal view range size (number of rows to be rendered).\n     * It uses the default row height to estimate how many rows fit in the view port.\n     * The view range size is this value * 2.\n     */\n\n  }, {\n    key: \"calculateViewRangeSize\",\n    value: function calculateViewRangeSize() {\n      // Make sure row height is up to date (row height may be different after zooming)\n      this._updateRowHeight();\n\n      if (this.rowHeight === 0) {\n        throw new Error('Cannot calculate view range with rowHeight = 0');\n      }\n\n      return Math.ceil(this.$data.outerHeight() / this.rowHeight) * 2;\n    }\n  }, {\n    key: \"setViewRangeSize\",\n    value: function setViewRangeSize(viewRangeSize) {\n      if (this.viewRangeSize === viewRangeSize) {\n        return;\n      }\n\n      this._setProperty('viewRangeSize', viewRangeSize);\n\n      if (this._isDataRendered()) {\n        this._renderViewport();\n      }\n    }\n  }, {\n    key: \"_calculateCurrentViewRange\",\n    value: function _calculateCurrentViewRange() {\n      var rowIndex,\n          scrollTop = this.$data[0].scrollTop,\n          maxScrollTop = this.$data[0].scrollHeight - this.$data[0].clientHeight;\n\n      if (maxScrollTop === 0) {\n        // no scrollbars visible\n        rowIndex = 0;\n      } else {\n        rowIndex = this._rowIndexAtScrollTop(scrollTop);\n      }\n\n      return this._calculateViewRangeForRowIndex(rowIndex);\n    }\n    /**\n     * Returns the index of the row which is at position scrollTop.\n     */\n\n  }, {\n    key: \"_rowIndexAtScrollTop\",\n    value: function _rowIndexAtScrollTop(scrollTop) {\n      var height = 0,\n          index = -1;\n      this.visibleRows.some(function (row, i) {\n        height += this._heightForRow(row);\n\n        if (scrollTop < height) {\n          index = i;\n          return true;\n        }\n      }.bind(this));\n      return index;\n    }\n  }, {\n    key: \"_heightForRow\",\n    value: function _heightForRow(row) {\n      var height = 0,\n          aggregateRow = row.aggregateRowAfter;\n\n      if (row.height) {\n        height = row.height;\n      } else {\n        height = this.rowHeight;\n      } // Add height of aggregate row as well\n\n\n      if (aggregateRow) {\n        if (aggregateRow.height) {\n          height += aggregateRow.height;\n        } else {\n          height += this.aggregateRowHeight;\n        }\n      }\n\n      return height;\n    }\n    /**\n     * Returns a range of size this.viewRangeSize. Start of range is rowIndex - viewRangeSize / 4.\n     * -> 1/4 of the rows are before the viewport 2/4 in the viewport 1/4 after the viewport,\n     * assuming viewRangeSize is 2*number of possible rows in the viewport (see calculateViewRangeSize).\n     */\n\n  }, {\n    key: \"_calculateViewRangeForRowIndex\",\n    value: function _calculateViewRangeForRowIndex(rowIndex) {\n      // regular / non-virtual scrolling? -> all rows are already rendered in the DOM\n      if (!this.virtual) {\n        return new Range(0, this.visibleRows.length);\n      }\n\n      var viewRange = new Range(),\n          quarterRange = Math.floor(this.viewRangeSize / 4),\n          diff;\n      viewRange.from = Math.max(rowIndex - quarterRange, 0);\n      viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.visibleRows.length); // Try to use the whole viewRangeSize (extend from if necessary)\n\n      diff = this.viewRangeSize - viewRange.size();\n\n      if (diff > 0) {\n        viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);\n      }\n\n      return viewRange;\n    }\n    /**\n     * Calculates and renders the rows which should be visible in the current viewport based on scroll top.\n     */\n\n  }, {\n    key: \"_renderViewport\",\n    value: function _renderViewport() {\n      if (!this.isAttachedAndRendered()) {\n        // if table is not attached the correct viewPort can not be evaluated. Mark for render after attach.\n        this._renderViewPortAfterAttach = true;\n        return;\n      }\n\n      if (this._renderViewportBlocked) {\n        return;\n      }\n\n      if (this.visibleColumns().length === 0) {\n        return;\n      }\n\n      if (!this.$container.isEveryParentVisible()) {\n        // If the table is invisible, the height of the rows cannot be determined.\n        // In that case, the table won't be layouted either -> as soon as it will be layouted, renderViewport will be called again\n        this.invalidateLayoutTree();\n        return;\n      }\n\n      var viewRange = this._calculateCurrentViewRange();\n\n      this._renderViewRange(viewRange);\n    }\n  }, {\n    key: \"_rerenderViewport\",\n    value: function _rerenderViewport() {\n      if (!this.isAttachedAndRendered()) {\n        // if table is not attached the correct viewPort can not be evaluated. Mark for rerender after attach.\n        this._rerenderViewPortAfterAttach = true;\n        return;\n      }\n\n      this._removeRows();\n\n      this._removeAggregateRows();\n\n      this._renderFiller();\n\n      this._renderViewport();\n    }\n  }, {\n    key: \"_renderViewRangeForRowIndex\",\n    value: function _renderViewRangeForRowIndex(rowIndex) {\n      var viewRange = this._calculateViewRangeForRowIndex(rowIndex);\n\n      this._renderViewRange(viewRange);\n    }\n    /**\n     * Renders the rows visible in the viewport and removes the other rows\n     */\n\n  }, {\n    key: \"_renderViewRange\",\n    value: function _renderViewRange(viewRange) {\n      if (viewRange.from === this.viewRangeRendered.from && viewRange.to === this.viewRangeRendered.to && !this.viewRangeDirty) {\n        // Range already rendered -> do nothing\n        return;\n      }\n\n      this._removeRangeMarkers();\n\n      var rangesToRender = viewRange.subtract(this.viewRangeRendered);\n      var rangesToRemove = this.viewRangeRendered.subtract(viewRange);\n      rangesToRemove.forEach(function (range) {\n        this._removeRowsInRange(range);\n      }.bind(this));\n      rangesToRender.forEach(function (range) {\n        this._renderRowsInRange(range);\n      }.bind(this)); // check if at least last and first row in range got correctly rendered\n\n      if (this.viewRangeRendered.size() > 0) {\n        var rows = this.visibleRows;\n        var firstRow = rows[this.viewRangeRendered.from];\n        var lastRow = rows[this.viewRangeRendered.to - 1];\n\n        if (!firstRow.$row || !lastRow.$row) {\n          throw new Error('Rows not rendered as expected. ' + this.viewRangeRendered + '. First: ' + firstRow.$row + '. Last: ' + lastRow.$row);\n        }\n      }\n\n      this._renderRangeMarkers();\n\n      this._removeAggregateRows();\n\n      this._renderAggregateRows();\n\n      this._renderFiller();\n\n      this._renderEmptyData();\n\n      this._renderBackgroundEffect();\n\n      this._renderSelection();\n\n      this.viewRangeDirty = false;\n    }\n  }, {\n    key: \"_removeRangeMarkers\",\n    value: function _removeRangeMarkers() {\n      this._modifyRangeMarkers('removeClass');\n    }\n  }, {\n    key: \"_renderRangeMarkers\",\n    value: function _renderRangeMarkers() {\n      this._modifyRangeMarkers('addClass');\n    }\n  }, {\n    key: \"_modifyRangeMarkers\",\n    value: function _modifyRangeMarkers(funcName) {\n      if (this.viewRangeRendered.size() === 0) {\n        return;\n      }\n\n      var visibleRows = this.visibleRows;\n      modifyRangeMarker(visibleRows[this.viewRangeRendered.from], 'first');\n      modifyRangeMarker(visibleRows[this.viewRangeRendered.to - 1], 'last');\n\n      function modifyRangeMarker(row, cssClass) {\n        if (row && row.$row) {\n          row.$row[funcName](cssClass);\n        }\n      }\n    }\n    /**\n     * Renders the view range that contains the given row.<br>\n     * Does nothing if the row is already rendered or not visible (e.g. due to filtering).\n     * @param {TableRow} row\n     */\n\n  }, {\n    key: \"ensureRowRendered\",\n    value: function ensureRowRendered(row) {\n      if (row.$row) {\n        return;\n      }\n\n      var rowIndex = this.visibleRows.indexOf(row);\n\n      if (rowIndex < 0) {\n        return;\n      }\n\n      this._renderViewRangeForRowIndex(rowIndex);\n    }\n  }, {\n    key: \"_renderFiller\",\n    value: function _renderFiller() {\n      if (!this.$fillBefore) {\n        this.$fillBefore = this.$data.prependDiv('table-data-fill');\n\n        this._applyFillerStyle(this.$fillBefore);\n      }\n\n      var fillBeforeHeight = this._calculateFillerHeight(new Range(0, this.viewRangeRendered.from));\n\n      this.$fillBefore.cssHeight(fillBeforeHeight);\n      this.$fillBefore.cssWidth(this.rowWidth);\n      $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeHeight);\n\n      if (!this.$fillAfter) {\n        this.$fillAfter = this.$data.appendDiv('table-data-fill');\n\n        this._applyFillerStyle(this.$fillAfter);\n      }\n\n      var fillAfterHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.to, this.visibleRows.length));\n\n      this.$fillAfter.cssHeight(fillAfterHeight);\n      this.$fillAfter.cssWidth(this.rowWidth);\n      $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterHeight);\n    }\n  }, {\n    key: \"_applyFillerStyle\",\n    value: function _applyFillerStyle($filler) {\n      var lineColor = $filler.css('background-color'); // In order to get a 1px border we need to get the right value in percentage for the linear gradient\n\n      var lineWidth = ((1 - 1 / this.rowHeight) * 100).toFixed(2) + '%';\n      $filler.css({\n        background: 'linear-gradient(to bottom, transparent, transparent ' + lineWidth + ', ' + lineColor + ' ' + lineWidth + ', ' + lineColor + ')',\n        backgroundSize: '100% ' + this.rowHeight + 'px',\n        backgroundColor: 'transparent'\n      });\n    }\n  }, {\n    key: \"_calculateFillerHeight\",\n    value: function _calculateFillerHeight(range) {\n      var totalHeight = 0;\n\n      for (var i = range.from; i < range.to; i++) {\n        var row = this.visibleRows[i];\n        totalHeight += this._heightForRow(row);\n      }\n\n      return totalHeight;\n    }\n  }, {\n    key: \"containsAggregatedNumberColumn\",\n    value: function containsAggregatedNumberColumn() {\n      if (!this.initialized) {\n        return false;\n      }\n\n      return this.visibleColumns().some(function (column) {\n        return column instanceof NumberColumn && column.aggregationFunction !== 'none';\n      });\n    }\n    /**\n     * Rebuilds the header.<br>\n     * Does not modify the rows, it expects a deleteAll and insert operation to follow which will do the job.\n     */\n\n  }, {\n    key: \"updateColumnStructure\",\n    value: function updateColumnStructure(columns) {\n      this._destroyColumns();\n\n      this.columns = columns;\n\n      this._initColumns();\n\n      if (this._isDataRendered()) {\n        this._updateRowWidth();\n\n        this.$rows(true).css('width', this.rowWidth);\n\n        this._rerenderHeaderColumns();\n\n        this._renderEmptyData();\n      }\n\n      this.trigger('columnStructureChanged');\n    }\n  }, {\n    key: \"updateColumnOrder\",\n    value: function updateColumnOrder(columns) {\n      var i, column, currentPosition, oldColumnOrder;\n\n      if (columns.length !== this.columns.length) {\n        throw new Error('Column order may not be updated because lengths of the arrays differ.');\n      }\n\n      oldColumnOrder = this.columns.slice();\n\n      for (i = 0; i < columns.length; i++) {\n        column = columns[i];\n        currentPosition = this.columns.indexOf(column);\n\n        if (currentPosition < 0) {\n          throw new Error('Column with id ' + column.id + 'not found.');\n        }\n\n        if (currentPosition !== i) {\n          // Update model\n          arrays.remove(this.columns, column);\n          arrays.insert(this.columns, column, i);\n        }\n      }\n\n      if (this._isDataRendered()) {\n        this._renderColumnOrderChanges(oldColumnOrder);\n      }\n    }\n    /**\n     * @param columns array of columns which were updated.\n     */\n\n  }, {\n    key: \"updateColumnHeaders\",\n    value: function updateColumnHeaders(columns) {\n      var column, oldColumnState; // Update model columns\n\n      for (var i = 0; i < columns.length; i++) {\n        column = this.columnById(columns[i].id);\n        oldColumnState = $.extend(oldColumnState, column);\n        column.text = columns[i].text;\n        column.headerTooltipText = columns[i].headerTooltipText;\n        column.headerTooltipHtmlEnabled = columns[i].headerTooltipHtmlEnabled;\n        column.headerCssClass = columns[i].headerCssClass;\n        column.headerHtmlEnabled = columns[i].headerHtmlEnabled;\n        column.headerBackgroundColor = columns[i].headerBackgroundColor;\n        column.headerForegroundColor = columns[i].headerForegroundColor;\n        column.headerFont = columns[i].headerFont;\n        column.headerIconId = columns[i].headerIconId;\n        column.sortActive = columns[i].sortActive;\n        column.sortAscending = columns[i].sortAscending;\n\n        if (column.grouped && !columns[i].grouped) {\n          this._removeGroupColumn(column);\n        }\n\n        column.grouped = columns[i].grouped;\n\n        if (!column.sortActive && column.sortIndex !== -1) {\n          // Adjust indices of other sort columns (if a sort column in the middle got removed, there won't necessarily be an event for the other columns)\n          this._removeSortColumn(column);\n        } else if (column.grouped && column.sortActive && column.sortIndex === -1) {\n          this._addGroupColumn(column);\n        } else if (column.sortActive && column.sortIndex === -1) {\n          // Necessary if there is a tail sort column (there won't be an event for the tail sort column if another sort column was added before)\n          this._addSortColumn(column);\n        } else {\n          column.sortIndex = columns[i].sortIndex;\n        }\n\n        if (this._isDataRendered() && this.header) {\n          this.header.updateHeader(column, oldColumnState);\n        }\n      }\n    }\n  }, {\n    key: \"focusCell\",\n    value: function focusCell(column, row) {\n      if (!this._isDataRendered() || !this.isAttachedAndRendered()) {\n        this._postRenderActions.push(this.focusCell.bind(this, column, row));\n\n        return;\n      }\n\n      var cell = this.cell(column, row);\n\n      if (this.enabledComputed && row.enabled && cell.editable) {\n        this.prepareCellEdit(column, row, false);\n      }\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {\n      this.$parent.append(this.$container);\n\n      _get(_getPrototypeOf(Table.prototype), \"_attach\", this).call(this);\n    }\n    /**\n     * Method invoked when this is a 'detailTable' and the outline content is displayed.\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_postAttach\",\n    value: function _postAttach() {\n      var htmlParent = this.htmlComp.getParent();\n      this.htmlComp.setSize(htmlParent.size());\n\n      _get(_getPrototypeOf(Table.prototype), \"_postAttach\", this).call(this);\n    }\n    /**\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_renderOnAttach\",\n    value: function _renderOnAttach() {\n      _get(_getPrototypeOf(Table.prototype), \"_renderOnAttach\", this).call(this); // this is an \"if... else if...\" to avoid rendering the viewport multiple\n      // times in case all ...afterAttach flags are set to true.\n\n\n      if (this._rerenderViewPortAfterAttach) {\n        this._rerenderViewport();\n\n        this._rerenderViewPortAfterAttach = false;\n      } else if (this._renderViewPortAfterAttach) {\n        this._renderViewport();\n\n        this._renderViewPortAfterAttach = false;\n      }\n    }\n    /**\n     * Method invoked when this is a 'detailTable' and the outline content is not displayed anymore.\n     * @override Widget.js\n     */\n\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      this.$container.detach(); // Detach helper stores the current scroll pos and restores in attach.\n      // To make it work scrollTop needs to be reset here otherwise viewport won't be rendered by _onDataScroll\n\n      _get(_getPrototypeOf(Table.prototype), \"_detach\", this).call(this);\n    }\n  }, {\n    key: \"_onDetach\",\n    value: function _onDetach() {\n      _get(_getPrototypeOf(Table.prototype), \"_onDetach\", this).call(this);\n\n      this._destroyCellEditorPopup();\n    }\n  }, {\n    key: \"_destroyCellEditorPopup\",\n    value: function _destroyCellEditorPopup() {\n      // When a cell editor popup is open and table is detached, we close the popup immediately\n      // and don't wait for the model event 'endCellEdit'. By doing this we can avoid problems\n      // with invalid focus contexts.\n      // However: when 'completeCellEdit' is already scheduled, we must wait because Scout classic\n      // must send a request to the server first #249385.\n      if (this.cellEditorPopup) {\n        var destroyEditor = function () {\n          this.cellEditorPopup.destroy();\n          this.cellEditorPopup = null;\n        }.bind(this);\n\n        var promise = this.cellEditorPopup.waitForCompleteCellEdit();\n\n        if (promise.state() === 'resolved') {\n          // Do it immediately if promise has already been resolved.\n          // This makes sure updateRow does not immediately reopen the editor after closing.\n          // At least for Scout JS, for Scout Classic it prevents flickering (endCellEdit comes after updateRows, but updateRows does not know whether the editor is closing so it will reopen it)\n          destroyEditor();\n        } else {\n          promise.then(destroyEditor);\n        }\n      }\n    }\n  }, {\n    key: \"setVirtual\",\n    value: function setVirtual(virtual) {\n      this._setProperty('virtual', virtual);\n    }\n  }, {\n    key: \"setCellValue\",\n    value: function setCellValue(column, row, value) {\n      column.setCellValue(row, value);\n    }\n  }, {\n    key: \"setCellText\",\n    value: function setCellText(column, row, displayText) {\n      column.setCellText(row, displayText);\n    }\n  }, {\n    key: \"setCellErrorStatus\",\n    value: function setCellErrorStatus(column, row, errorStatus) {\n      column.setCellErrorStatus(row, errorStatus);\n    }\n  }, {\n    key: \"visibleColumns\",\n    value: function visibleColumns(includeGuiColumns) {\n      includeGuiColumns = scout.nvl(includeGuiColumns, true);\n      return this.columns.filter(function (column) {\n        return column.isVisible() && (includeGuiColumns || !column.guiOnly);\n      }, this);\n    } // same as on Tree.prototype._onDesktopPopupOpen\n\n  }, {\n    key: \"_onDesktopPopupOpen\",\n    value: function _onDesktopPopupOpen(event) {\n      var popup = event.popup;\n\n      if (!this.enabledComputed) {\n        return;\n      } // Set table style to focused if a context menu or a menu bar popup opens, so that it looks as it still has the focus\n\n\n      if (this.has(popup) && popup instanceof ContextMenuPopup) {\n        this.$container.addClass('focused');\n        popup.one('destroy', function () {\n          if (this._isDataRendered()) {\n            this.$container.removeClass('focused');\n          }\n        }.bind(this));\n      }\n    }\n  }, {\n    key: \"_onDesktopPropertyChange\",\n    value: function _onDesktopPropertyChange(event) {\n      // The height of the menuBar changes by css when switching to or from the dense mode\n      if (event.propertyName === 'dense') {\n        this.menuBar.invalidateLayoutTree();\n      }\n    }\n  }, {\n    key: \"markRowsAsNonChanged\",\n    value: function markRowsAsNonChanged(rows) {\n      arrays.ensure(rows || this.rows).forEach(function (row) {\n        row.status = TableRow.Status.NON_CHANGED;\n      });\n    }\n    /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  }], [{\n    key: \"parseHorizontalAlignment\",\n    value: function parseHorizontalAlignment(alignment) {\n      if (alignment > 0) {\n        return 'right';\n      }\n\n      if (alignment === 0) {\n        return 'center';\n      }\n\n      return 'left';\n    }\n  }, {\n    key: \"linkRowToDiv\",\n    value: function linkRowToDiv(row, $row) {\n      if (row) {\n        row.$row = $row;\n      }\n\n      if ($row) {\n        $row.data('row', row);\n      }\n    }\n  }]);\n\n  return Table;\n}(Widget);\n\n_defineProperty(Table, \"HierarchicalStyle\", {\n  DEFAULT: 'default',\n  STRUCTURED: 'structured'\n});\n\n_defineProperty(Table, \"GroupingStyle\", {\n  /**\n   * Aggregate row is rendered on top of the row-group.\n   */\n  TOP: 'top',\n\n  /**\n   * Aggregate row is rendered on the bottom of the row-group (default).\n   */\n  BOTTOM: 'bottom'\n});\n\n_defineProperty(Table, \"CheckableStyle\", {\n  /**\n   * When row is checked a boolean column with a checkbox is inserted into the table.\n   */\n  CHECKBOX: 'checkbox',\n\n  /**\n   * When a row is checked the table-row is marked as checked. By default a background\n   * color is set on the table-row when the row is checked.\n   */\n  TABLE_ROW: 'tableRow',\n\n  /**\n   * Like the CHECKBOX Style but a click anywhere on the row triggers the check.\n   */\n  CHECKBOX_TABLE_ROW: 'checkbox_table_row'\n});\n\n_defineProperty(Table, \"ReloadReason\", {\n  /**\n   * No specific reason, just reload data using the current search settings, the current row limits and the current\n   * filter (Default)\n   */\n  UNSPECIFIED: 'unspecified',\n\n  /**\n   * Some search parameters changed or the search was reset and the search was triggered\n   */\n  SEARCH: 'search',\n\n  /**\n   * The user requested loading more data than his soft limit, up to the application specific hard limit\n   */\n  OVERRIDE_ROW_LIMIT: 'overrideRowLimit',\n\n  /**\n   * The user requested loading no more data than his soft limit;\n   */\n  RESET_ROW_LIMIT: 'resetRowLimit',\n\n  /**\n   * The column structure of the table was changed\n   */\n  ORGANIZE_COLUMNS: 'organizeColumns',\n\n  /**\n   * Any call to IPage#dataChanged\n   */\n  DATA_CHANGED_TRIGGER: 'dataChangedTrigger'\n});\n\n_defineProperty(Table, \"SELECTION_CLASSES\", 'select-middle select-top select-bottom select-single selected');\n\nexport { Table as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/table/Table.js"],"names":["AggregateTableControl","AppLinkKeyStroke","arrays","BooleanColumn","clipboard","Column","ContextMenuKeyStroke","ContextMenuPopup","Device","DoubleClickSupport","dragAndDrop","Event","graphics","HtmlComponent","keys","KeyStrokeContext","LoadingSupport","MenuBar","MenuDestinations","MenuItemsOrder","menus","NumberColumn","objects","Range","scout","scrollbars","Status","strings","styles","TableCopyKeyStroke","TableFocusFilterFieldKeyStroke","TableLayout","TableNavigationCollapseKeyStroke","TableNavigationDownKeyStroke","TableNavigationEndKeyStroke","TableNavigationExpandKeyStroke","TableNavigationHomeKeyStroke","TableNavigationPageDownKeyStroke","TableNavigationPageUpKeyStroke","TableNavigationUpKeyStroke","TableRefreshKeyStroke","TableRow","TableSelectAllKeyStroke","TableSelectionHandler","TableStartCellEditKeyStroke","TableToggleRowKeyStroke","TableUpdateBuffer","TableUserFilter","tooltips","tooltips_1","Widget","$","Table","autoResizeColumns","columnAddable","columnLayoutDirty","columns","contextColumn","checkable","checkableStyle","CheckableStyle","CHECKBOX","dropType","dropMaximumSize","DEFAULT_DROP_MAXIMUM_SIZE","groupingStyle","GroupingStyle","BOTTOM","header","headerEnabled","headerVisible","headerMenusEnabled","hasReloadHandler","hierarchical","hierarchicalStyle","HierarchicalStyle","DEFAULT","keyStrokes","keyboardNavigation","menuBar","menuBarVisible","contextMenu","multiCheck","multiSelect","multilineText","scrollToSelection","scrollTop","selectedRows","sortEnabled","tableControls","tableStatusVisible","tableTileGridMediator","tileMode","tileTableHeader","footer","footerVisible","filters","rows","rootRows","visibleRows","estimatedRowCount","maxRowCount","truncatedCellTooltipEnabled","visibleRowsMap","rowLevelPadding","rowsMap","rowHeight","rowWidth","rowBorderWidth","rowBorderLeftWidth","rowBorderRightWidth","rowIconVisible","rowIconColumnWidth","NARROW_MIN_WIDTH","staticMenus","selectionHandler","_filterMap","_filteredRows","tableNodeColumn","_maxLevel","_aggregateRows","_animationRowLimit","_blockLoadThreshold","updateBuffer","viewRangeSize","viewRangeDirty","viewRangeRendered","virtual","_doubleClickSupport","_permanentHeadSortColumns","_permanentTailSortColumns","_filterMenusHandler","_filterMenus","bind","_popupOpenHandler","_onDesktopPopupOpen","_rerenderViewPortAfterAttach","_renderViewPortAfterAttach","_desktopPropertyChangeHandler","_onDesktopPropertyChange","_addWidgetProperties","$data","$emptyData","$fillBefore","$fillAfter","model","resolveConsts","property","constType","_initColumns","forEach","row","i","_initRow","setFilters","_updateRowStructure","updateTree","_createMenuBar","_setSelectedRows","_setKeyStrokes","_setMenus","_setTableControls","_setTableStatus","tableStatus","_calculateValuesForBackgroundEffect","_group","_setTileMode","_setTileTableHeader","parent","create","id","trigger","map","colModel","index","column","session","_setTable","table","checkableColumn","_setCheckable","_insertRowIconColumn","_calculateTableNodeColumn","_setHeadAndTailSortColumns","_destroyColumns","destroy","candidateColumns","visibleColumns","filter","nodeColumnCandidate","first","minWidth","_initialMinWidth","tableNodeLevel0CellPadding","width","_isDataRendered","resizeColumn","widget","$container","_initTableKeyStrokeContext","keyStrokeContext","registerKeyStroke","showContextMenu","handleAppLinkAction","registerStopPropagationInterceptor","event","ctrlKey","altKey","isOneOf","which","UP","DOWN","stopPropagation","preventDefault","TABLE_ROW","fixedWidth","fixedPosition","guiOnly","headerMenuEnabled","showSeparator","insert","position","rowIconColumn","$appLink","target","_columnAtX","offset","left","_triggerAppLinkAction","data","rendered","$parent","appendDiv","addDeviceClass","htmlComp","install","setLayout","uiCssClass","addClass","_renderTileMode","_renderData","desktop","on","_onRowMouseDown","_onRowMouseUp","_onRowDoubleClick","_installScrollbars","axis","_installImageListeners","_installCellTooltipSupport","_calculateRowBorderWidth","_updateRowWidth","_updateRowHeight","_renderViewport","revealSelection","_renderTableHeader","_renderMenuBarVisible","_renderFooterVisible","_renderDropType","_renderCheckableStyle","_renderHierarchicalStyle","cssClass","paddingClasses","push","setRowLevelPadding","getSize","reduce","acc","_destroyCellEditorPopup","_removeAggregateRows","_uninstallImageListeners","_uninstallCellTooltipSupport","_uninstallScrollbars","_removeRows","remove","off","_uninstallDragAndDropHandler","_removeData","setProperty","_rerenderViewport","controls","_renderControls","length","unregisterKeyStroke","_setProperty","_updateFooterVisibility","control","tableFooter","$target","$row","closest","oldRowHeight","height","outerHeight","invalidateLayoutTree","mousedown","_$mouseDownRow","currentTarget","_mouseDownRowId","_mouseDownColumn","pageX","window","one","setContextColumn","onMouseDown","isRightClick","_isRowControl","expanded","collapseRow","expandRow","CHECKBOX_TABLE_ROW","checked","is","hasClass","checkRow","pageY","$mouseUpRow","mouseButton","doubleClicked","onMouseUp","_find$AppLink","_triggerRowClick","doRowAction","options","onRequestsDone","_showContextMenu","attached","menuItems","_filterMenusForContextMenu","nvl","rowToDisplay","isRowSelectedAndVisible","lastActionRow","getLastSelectedAndVisibleRow","$rowToDisplay","dataOffsetBounds","offsetBounds","scrollLeft","top","Math","min","max","y","bottom","close","location","x","$anchor","menuFilter","open","isRowSelected","intersects","to","from","_redraw","some","visible","enabled","selector","text","_cellTooltipText","htmlEnabled","_isAggregatedTooltip","arrowPosition","arrowPositionUnit","nativeTooltip","get","isCustomEllipsisTooltipPossible","uninstall","$cell","cell","tooltipText","columnFor$Cell","trim","isContentTruncated","children","isVisible","clone","setVisible","html","_isTruncatedCellTooltipEnabled","plainText","reloadReason","_renderFiller","_triggerReload","loading","isBuffering","_triggerClipboardExport","copyText","_selectedRowsToText","value","_unwrapText","join","split","line","replace","deselectAll","selectAll","selectRows","opts","extend","checkRows","checkAll","update","animateAggregateRows","sortColumns","_sortColumns","_isSortingPossible","clearAggregateRows","union","_sortImpl","_triggerRowOrderChanged","_renderRowOrderChanges","every","isSortingPossible","c","sortIndex","sortFunction","row1","row2","s","result","compare","sortActive","sortAscending","_sortHierarchical","sortedFlatRows","visitRows","sort","filteredRows","applyFilters","visitFunc","level","childRows","sortFunc","animate","$rows","oldRowPositions","each","elem","rowWasInserted","_insertedRows","_order$AggregateRows","oldTop","undefined","css","progress","updateScrollbars","direction","multiSort","sorted","_removeSortColumn","_addSortColumn","onSortingChanged","_sort","sortingRemoved","sortingRequested","_animateAggregateRows","groupColCount","sortColCount","_updateSortIndexForColumn","_groupedColumns","grouped","deviation","initialAlwaysIncludeSortAtEnd","initialAlwaysIncludeSortAtBegin","eachSibling","siblingColumn","_removeSortColumnInternal","possible","allowedAggregationFunctions","isGrouped","hasAggregateTableControl","func","changeAggregations","functions","aggregationFunction","setAggregationFunction","_triggerAggregationFunctionChanged","multiGroup","isGroupingPossible","rowClass","filterAccepted","empty","rowDiv","buildCellForRow","$tableRowDummy","cssBorderLeftWidth","cssBorderRightWidth","sum","_realWidthIfAvailable","hasTableCellZoomBug","changed","eq","colIndex","_updateRealColumnWidth","_realWidth","realWidth","size","exact","$emptyRow","$emptyAggrRow","aggregateRowHeight","aggregateRow","range","rowString","numRowsRendered","prepend","maxRange","intersect","equals","Error","newRange","_removeEmptyData","r","_buildRowDiv","makeElement","insertAfter","prependTo","insertBefore","appendTo","rowObject","_updateRealColumnWidths","resizeHeaderItems","cssWidth","linkRowToDiv","_installRow","log","isTraceEnabled","trace","_rowsRenderedInfo","numRenderedRows","renderedRowsRange","rowIndex","indexOf","moveRow","targetIndex","siblings","candidate","parentRow","rowIndexSiblings","sibling","moveVisibleRowUp","visibleIndex","moveVisibleRowDown","sourceIndex","rowCount","move","updateRowOrder","numRowsRemoved","subtract","_removeRow","removeAllRows","tableAttached","isAttachedAndRendered","ensure","rowRendered","Boolean","rowInViewRange","contains","_destroyTooltipsForRow","_removeCellEditorForRow","hide","removeClass","stop","slideDown","duration","complete","slideUp","hasError","_showCellErrorForRow","cellEditorPopup","editorField","field","startCellEdit","_calcRowLevelPadding","$cells","$cellsForRow","that","cellByCellIndex","errorStatus","_showCellError","tooltip","message","autoRemove","render","columnOffsetRight","columnOffsetLeft","find","$elem","$stop","delegateTarget","destination","onlyVisible","enableDisableKeyStroke","notAllowedTypes","filterAccordingToSelection","CONTEXT_MENU","_updateMenuBar","_triggerRowsSelectedPending","_triggerRowsSelected","openFieldPopupOnCellEdit","promise","resolvedPromise","waitForCompleteCellEdit","then","prepareCellEditInternal","defaultPrevented","createEditor","iconId","editable","cells","cellIndex","currentColumn","currentRow","reverse","pos","startColumnIndex","startRowIndex","predicate","nextEditableCellPosForRow","findFrom","enabledComputed","prevRow","aggregateRowAfter","nextRow","aggregateRowBefore","_renderSelection","funcName","states","cellValueOrTextForCalculation","newGroup","firstRow","lastRow","groupColumns","onTop","TOP","_forEachVisibleColumn","_isNewGroup","_addAggregateRow","_renderAggregateRows","groupedColumns","col","newRow","hasCellTextForGroupingFunction","cellTextForGrouping","cellText","contents","slice","_hideRow","insertFunc","refRow","$aggregateRow","makeDiv","buildCellForAggregateRow","_resizeCell","_showRow","_removeGroupColumn","_addGroupColumn","groupAscending","groupingRemoved","groupingRequested","groupColumn","removeColumnGrouping","effect","setBackgroundEffect","backgroundEffect","updateBackgroundEffect","calculateMinMaxValues","autoOptimizeWidthRequired","autoOptimizeWidthColumns","oldRow","marked","cellValue","splice","checkOnlyEnabled","checkedRows","_renderRowChecked","_triggerRowsChecked","uncheckRows","collapseRows","expandRowsInternal","recursive","expandRows","changedRows","rowsForAnimation","_triggerRowsExpanded","_renderRowDelta","animateExpansion","ensureExpansionVisible","element","$element","$scrollable","get$Scrollable","isExpanded","getChildren","defaultChildHeight","_triggerRowAction","insertRows","wasEmpty","status","INSERTED","filterAcceptedRows","_applyFiltersForRow","_filterCount","_triggerFilter","_markAutoOptimizeWidthColumnsAsDirty","_triggerRowsInserted","_sortAfterInsert","setTimeout","pushAll","deleteRows","invalidate","filterChanged","removedRows","cancelEdit","clearLastSelectedRowMarker","deselectRows","_updateBackgroundEffect","_triggerRowsDeleted","_renderRangeMarkers","_renderEmptyData","_triggerAllRowsDeleted","updateRows","buffer","expansionChanged","autoOptimizeWidthColumnsDirty","autoOptimizeWidth","rowsToIndex","oldRowsMap","structureChanged","parentRowId","isNullOrUndefined","_parentRowId","NON_CHANGED","oldCell","UPDATED","_markAutoOptimizeWidthColumnsAsDirtyIfNeeded","_triggerRowsUpdated","_renderUpdateRows","_sortAfterUpdate","$updatedRow","copyCssClasses","SELECTION_CLASSES","replaceWith","removeAllColumnGroupings","_postRenderActions","ensureRowRendered","popup","saveEditorValue","endCellEdit","context","setCellErrorStatus","setCellText","displayText","setCellValue","scrollTo","newScrollTop","setScrollTop","scrollHeight","rendering","layoutValidator","schedulePostValidateFunction","firstCheckedRow","ids","_rowById","addOrRemoveClassIfNeededFunc","condition","classname","thisRowSelected","previousIndex","previousRowSelected","followingIndex","followingRowSelected","classChanged","pack","select","toggleClass","ongoingSelection","notifyRowSelectionFinished","debounceSend","selectedEqualRows","equalsIgnoreOrder","_removeSelection","removeAll","Object","includeAggrRows","columnIndex","columnId","columnIds","columnById","updateFilteredRows","updateVisibleRows","_rebuildTreeStructure","_updateFilteredRows","_updateVisibleRows","_setHierarchical","_hierarchyLevel","_computeVisibleRows","initialized","selectedRow","visibleChildRows","_expandable","concat","child","renderedRows","rowsToHide","detach","_order$Rows","_renderScrollTop","elem1","elem2","$row1","$row2","$aggregateRows","$aggrRow","key","accept","_rowAcceptedByFilters","filteredBy","createLabel","removeFilterByKey","_triggerFilterReset","values","maxWidth","returnValue","calculateOptimalWidth","isPlainObject","always","_resizeToFit","calculatedSize","isInternetExplorer","_triggerColumnResizedToFit","createKey","floor","visibleColumnIndex","colNum","$cellsForColIndex","_updateRowHeights","_triggerColumnResized","$cellIcon","visibleOldPos","visibleNewPos","dragged","_considerFixedPositionColumns","newColumn","newPos","_triggerColumnMoved","fixedColumnIndex","findIndexFrom","findIndexFromReverse","oldColumnOrder","j","$orderedCells","onOrderChanged","debounce","ref","_exportToClipboard","animating","oldPos","_removeTableHeader","setHeaderMenusEnabled","a","b","_ensureMediator","_createTileTableHeader","loadTiles","activate","deactivate","gridColumnCount","renderTileMode","tile","createTileForRow","_adaptTile","rowId","gridDataHints","weightX","addCssClass","_rowsByIds","oldMenus","updateKeyStrokes","updateMenuBar","_refreshMenuBarPosition","Position","menuOrder","MENU_BAR","setMenuItems","contextMenuItems","updateMenuItems","_ensureFilter","addFilter","setFooterVisible","_hasVisibleTableControls","style","STRUCTURED","_createFooter","_renderBackgroundEffect","$styleElem","$checkBox","_updateCheckableColumn","showCheckBoxes","_insertBooleanColumn","_renderRowIconVisible","_rerenderHeaderColumns","rerenderColumns","_createHeader","_renderFooter","_removeFooter","setEnabled","setTabbable","_renderDisabledStyleInternal","_installDragAndDropHandler","dragAndDropHandler","handler","supportedScoutTypes","SCOUT_TYPES","FILE_TRANSFER","additionalDropProperties","properties","_imageLoadListener","_onImageLoadOrError","addEventListener","removeEventListener","ceil","maxScrollTop","clientHeight","_rowIndexAtScrollTop","_calculateViewRangeForRowIndex","_heightForRow","viewRange","quarterRange","diff","_renderViewportBlocked","isEveryParentVisible","_calculateCurrentViewRange","_renderViewRange","_removeRangeMarkers","rangesToRender","rangesToRemove","_removeRowsInRange","_renderRowsInRange","_modifyRangeMarkers","modifyRangeMarker","_renderViewRangeForRowIndex","prependDiv","_applyFillerStyle","fillBeforeHeight","_calculateFillerHeight","cssHeight","fillAfterHeight","$filler","lineColor","lineWidth","toFixed","background","backgroundSize","backgroundColor","totalHeight","currentPosition","_renderColumnOrderChanges","oldColumnState","headerTooltipText","headerTooltipHtmlEnabled","headerCssClass","headerHtmlEnabled","headerBackgroundColor","headerForegroundColor","headerFont","headerIconId","updateHeader","focusCell","prepareCellEdit","append","htmlParent","getParent","setSize","destroyEditor","state","includeGuiColumns","has","propertyName","alignment","UNSPECIFIED","SEARCH","OVERRIDE_ROW_LIMIT","RESET_ROW_LIMIT","ORGANIZE_COLUMNS","DATA_CHANGED_TRIGGER"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2020 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  AggregateTableControl,\n  AppLinkKeyStroke,\n  arrays,\n  BooleanColumn,\n  clipboard,\n  Column,\n  ContextMenuKeyStroke,\n  ContextMenuPopup,\n  Device,\n  DoubleClickSupport,\n  dragAndDrop,\n  Event,\n  graphics,\n  HtmlComponent,\n  keys,\n  KeyStrokeContext,\n  LoadingSupport,\n  MenuBar,\n  MenuDestinations,\n  MenuItemsOrder,\n  menus,\n  NumberColumn,\n  objects,\n  Range,\n  scout,\n  scrollbars,\n  Status,\n  strings,\n  styles,\n  TableCopyKeyStroke,\n  TableFocusFilterFieldKeyStroke,\n  TableLayout,\n  TableNavigationCollapseKeyStroke,\n  TableNavigationDownKeyStroke,\n  TableNavigationEndKeyStroke,\n  TableNavigationExpandKeyStroke,\n  TableNavigationHomeKeyStroke,\n  TableNavigationPageDownKeyStroke,\n  TableNavigationPageUpKeyStroke,\n  TableNavigationUpKeyStroke,\n  TableRefreshKeyStroke,\n  TableRow,\n  TableSelectAllKeyStroke,\n  TableSelectionHandler,\n  TableStartCellEditKeyStroke,\n  TableToggleRowKeyStroke,\n  TableUpdateBuffer,\n  TableUserFilter,\n  tooltips as tooltips_1,\n  Widget\n} from '../index';\nimport $ from 'jquery';\n\nexport default class Table extends Widget {\n  constructor() {\n\n    super();\n\n    this.autoResizeColumns = false;\n    this.columnAddable = false;\n    this.columnLayoutDirty = false;\n    this.columns = [];\n    this.contextColumn = null;\n    this.checkable = false;\n    this.checkableStyle = Table.CheckableStyle.CHECKBOX;\n    this.dropType = 0;\n    this.dropMaximumSize = dragAndDrop.DEFAULT_DROP_MAXIMUM_SIZE;\n    this.groupingStyle = Table.GroupingStyle.BOTTOM;\n    this.header = null;\n    this.headerEnabled = true;\n    this.headerVisible = true;\n    this.headerMenusEnabled = true;\n    this.hasReloadHandler = false;\n    this.hierarchical = false;\n    this.hierarchicalStyle = Table.HierarchicalStyle.DEFAULT;\n    this.keyStrokes = [];\n    this.keyboardNavigation = true;\n    this.menus = [];\n    this.menuBar = null;\n    this.menuBarVisible = true;\n    this.contextMenu = null;\n    this.multiCheck = true;\n    this.multiSelect = true;\n    this.multilineText = false;\n    this.scrollToSelection = false;\n    this.scrollTop = 0;\n    this.selectedRows = [];\n    this.sortEnabled = true;\n    this.tableControls = [];\n    this.tableStatusVisible = false;\n    this.tableTileGridMediator = null;\n    this.tileMode = false;\n    this.tileTableHeader = null;\n    this.footer = null;\n    this.footerVisible = false;\n    this.filters = [];\n    this.rows = [];\n    this.rootRows = [];\n    this.visibleRows = [];\n    this.estimatedRowCount = 0;\n    this.maxRowCount = 0;\n    this.truncatedCellTooltipEnabled = null;\n    this.visibleRowsMap = {}; // visible rows by id\n    this.rowLevelPadding = 0;\n    this.rowsMap = {}; // rows by id\n    this.rowHeight = 0;\n    this.rowWidth = 0;\n    this.rowBorderWidth = 0; // read-only, set by _calculateRowBorderWidth(), also used in TableLayout.js\n    this.rowBorderLeftWidth = 0; // read-only, set by _calculateRowBorderWidth(), also used in TableHeader.js\n    this.rowBorderRightWidth = 0; // read-only, set by _calculateRowBorderWidth(), also used in TableHeader.js\n    this.rowIconVisible = false;\n    this.rowIconColumnWidth = Column.NARROW_MIN_WIDTH;\n    this.staticMenus = [];\n    this.selectionHandler = new TableSelectionHandler(this);\n    this.tooltips = [];\n    this._filterMap = {};\n    this._filteredRows = [];\n    this.tableNodeColumn = null;\n    this._maxLevel = 0;\n    this._aggregateRows = [];\n    this._animationRowLimit = 25;\n    this._blockLoadThreshold = 25;\n    this.updateBuffer = new TableUpdateBuffer(this);\n    // Initial value must be > 0 to make prefSize work (if it is 0, no filler will be generated).\n    // If rows have a variable height, prefSize is only correct for 10 rows.\n    // Layout will adjust this value depending on the view port size.\n    this.viewRangeSize = 10;\n    this.viewRangeDirty = false;\n    this.viewRangeRendered = new Range(0, 0);\n    this.virtual = true;\n    this._doubleClickSupport = new DoubleClickSupport();\n    this._permanentHeadSortColumns = [];\n    this._permanentTailSortColumns = [];\n    this._filterMenusHandler = this._filterMenus.bind(this);\n    this._popupOpenHandler = this._onDesktopPopupOpen.bind(this);\n    this._rerenderViewPortAfterAttach = false;\n    this._renderViewPortAfterAttach = false;\n    this._desktopPropertyChangeHandler = this._onDesktopPropertyChange.bind(this);\n    this._addWidgetProperties(['tableControls', 'menus', 'keyStrokes', 'staticMenus', 'tileTableHeader', 'tableTileGridMediator']);\n\n    this.$data = null;\n    this.$emptyData = null;\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n  }\n\n  // TODO [7.0] cgu create StringColumn.js incl. defaultValues from defaultValues.json\n\n  static HierarchicalStyle = {\n    DEFAULT: 'default',\n    STRUCTURED: 'structured'\n  };\n\n  static GroupingStyle = {\n    /**\n     * Aggregate row is rendered on top of the row-group.\n     */\n    TOP: 'top',\n    /**\n     * Aggregate row is rendered on the bottom of the row-group (default).\n     */\n    BOTTOM: 'bottom'\n  };\n\n  static CheckableStyle = {\n    /**\n     * When row is checked a boolean column with a checkbox is inserted into the table.\n     */\n    CHECKBOX: 'checkbox',\n    /**\n     * When a row is checked the table-row is marked as checked. By default a background\n     * color is set on the table-row when the row is checked.\n     */\n    TABLE_ROW: 'tableRow',\n    /**\n     * Like the CHECKBOX Style but a click anywhere on the row triggers the check.\n     */\n    CHECKBOX_TABLE_ROW: 'checkbox_table_row'\n  };\n\n  /**\n   * This enum defines the reload reasons for a table reload operation\n   */\n  static ReloadReason = {\n    /**\n     * No specific reason, just reload data using the current search settings, the current row limits and the current\n     * filter (Default)\n     */\n    UNSPECIFIED: 'unspecified',\n\n    /**\n     * Some search parameters changed or the search was reset and the search was triggered\n     */\n    SEARCH: 'search',\n\n    /**\n     * The user requested loading more data than his soft limit, up to the application specific hard limit\n     */\n    OVERRIDE_ROW_LIMIT: 'overrideRowLimit',\n\n    /**\n     * The user requested loading no more data than his soft limit;\n     */\n    RESET_ROW_LIMIT: 'resetRowLimit',\n\n    /**\n     * The column structure of the table was changed\n     */\n    ORGANIZE_COLUMNS: 'organizeColumns',\n\n    /**\n     * Any call to IPage#dataChanged\n     */\n    DATA_CHANGED_TRIGGER: 'dataChangedTrigger'\n  };\n\n  static SELECTION_CLASSES = 'select-middle select-top select-bottom select-single selected';\n\n  _init(model) {\n    super._init(model);\n    this.resolveConsts([{\n      property: 'hierarchicalStyle',\n      constType: Table.HierarchicalStyle\n    }, {\n      property: 'checkableStyle',\n      constType: Table.CheckableStyle\n    }, {\n      property: 'groupingStyle',\n      constType: Table.GroupingStyle\n    }]);\n    this._initColumns();\n\n    this.rows.forEach(function(row, i) {\n      this.rows[i] = this._initRow(row);\n    }, this);\n\n    this.setFilters(this.filters);\n\n    this._updateRowStructure({\n      updateTree: true\n    });\n\n    this.menuBar = this._createMenuBar();\n    this._setSelectedRows(this.selectedRows);\n    this._setKeyStrokes(this.keyStrokes);\n    this._setMenus(this.menus);\n    this._setTableControls(this.tableControls);\n    this._setTableStatus(this.tableStatus);\n    this._calculateValuesForBackgroundEffect();\n    this._group();\n    this._setTileMode(this.tileMode);\n    this._setTileTableHeader(this.tileTableHeader);\n  }\n\n  _initRow(row) {\n    if (!(row instanceof TableRow)) {\n      row.parent = this;\n      row = scout.create('TableRow', row);\n    }\n    this.rowsMap[row.id] = row;\n    this.trigger('rowInit', {\n      row: row\n    });\n    return row;\n  }\n\n  _initColumns() {\n    this.columns = this.columns.map(function(colModel, index) {\n      var column = colModel;\n      column.session = this.session;\n      if (column instanceof Column) {\n        column._setTable(this);\n      } else {\n        column.table = this;\n        column = scout.create(column);\n      }\n\n      if (column.index < 0) {\n        column.index = index;\n      }\n      if (column.checkable) {\n        // set checkable column if this column is the checkable one\n        this.checkableColumn = column;\n      }\n      return column;\n    }, this);\n\n    // Add gui only checkbox column at the beginning\n    this._setCheckable(this.checkable);\n\n    // Add gui only row icon column at the beginning\n    if (this.rowIconVisible) {\n      this._insertRowIconColumn();\n    }\n\n    this._calculateTableNodeColumn();\n\n    // Sync head and tail sort columns\n    this._setHeadAndTailSortColumns();\n    this.columnLayoutDirty = true;\n  }\n\n  _destroy() {\n    this._destroyColumns();\n    super._destroy();\n  }\n\n  _destroyColumns() {\n    this.columns.forEach(function(column) {\n      column.destroy();\n    });\n    this.checkableColumn = null;\n    this.columns = [];\n  }\n\n  _calculateTableNodeColumn() {\n    var candidateColumns = this.visibleColumns().filter(function(column) {\n      return column.nodeColumnCandidate;\n    });\n\n    var tableNodeColumn = arrays.first(candidateColumns);\n    if (this.tableNodeColumn && this.tableNodeColumn !== tableNodeColumn) {\n      // restore\n      this.tableNodeColumn.minWidth = this.tableNodeColumn._initialMinWidth;\n    }\n    this.tableNodeColumn = tableNodeColumn;\n    if (this.tableNodeColumn) {\n      this.tableNodeColumn._initialMinWidth = this.tableNodeColumn.minWidth;\n      this.tableNodeColumn.minWidth = this.rowLevelPadding * this._maxLevel + this.tableNodeColumn.tableNodeLevel0CellPadding + 8;\n\n      if (this.tableNodeColumn.minWidth > this.tableNodeColumn.width) {\n        if (this._isDataRendered()) {\n          this.resizeColumn(this.tableNodeColumn, this.tableNodeColumn.minWidth);\n        } else {\n          this.tableNodeColumn.width = this.tableNodeColumn.minWidth;\n        }\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  _createLoadingSupport() {\n    // noinspection JSCheckFunctionSignatures\n    return new LoadingSupport({\n      widget: this,\n      $container: function() {\n        return this.$data;\n      }.bind(this)\n    });\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this._initTableKeyStrokeContext();\n  }\n\n  _initTableKeyStrokeContext() {\n    this.keyStrokeContext.registerKeyStroke([\n      new TableNavigationUpKeyStroke(this),\n      new TableNavigationDownKeyStroke(this),\n      new TableNavigationPageUpKeyStroke(this),\n      new TableNavigationPageDownKeyStroke(this),\n      new TableNavigationHomeKeyStroke(this),\n      new TableNavigationEndKeyStroke(this),\n      new TableNavigationCollapseKeyStroke(this),\n      new TableNavigationExpandKeyStroke(this),\n      new TableFocusFilterFieldKeyStroke(this),\n      new TableStartCellEditKeyStroke(this),\n      new TableSelectAllKeyStroke(this),\n      new TableRefreshKeyStroke(this),\n      new TableToggleRowKeyStroke(this),\n      new TableCopyKeyStroke(this),\n      new ContextMenuKeyStroke(this, this.showContextMenu, this),\n      new AppLinkKeyStroke(this, this.handleAppLinkAction)\n    ]);\n\n    // Prevent default action and do not propagate ↓ or ↑ keys if ctrl- or alt-modifier is not pressed.\n    // Otherwise, an '↑-event' on the first row, or an '↓-event' on the last row will bubble up (because not consumed by table navigation keystrokes) and cause a superior table to move its selection.\n    // Use case: - outline page table with search form that contains a table field;\n    //           - shift + '↑-event'/'↓-event' are not consumed by a single selection table, and would propagate otherwise;\n    //           - preventDefault because of smartfield, so that the cursor is not moved on first or last row;\n    this.keyStrokeContext.registerStopPropagationInterceptor(function(event) {\n      if (!event.ctrlKey && !event.altKey && scout.isOneOf(event.which, keys.UP, keys.DOWN)) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    });\n  }\n\n  _insertBooleanColumn() {\n    // don't add checkbox column when we're in checkableStyle mode\n    if (this.checkableStyle === Table.CheckableStyle.TABLE_ROW) {\n      return;\n    }\n    var column = scout.create('BooleanColumn', {\n      session: this.session,\n      fixedWidth: true,\n      fixedPosition: true,\n      guiOnly: true,\n      nodeColumnCandidate: false,\n      headerMenuEnabled: false,\n      showSeparator: false,\n      width: Column.NARROW_MIN_WIDTH,\n      table: this\n    });\n\n    arrays.insert(this.columns, column, 0);\n    this.checkableColumn = column;\n  }\n\n  _insertRowIconColumn() {\n    var position = 0,\n      column = scout.create('IconColumn', {\n        session: this.session,\n        fixedWidth: true,\n        fixedPosition: true,\n        guiOnly: true,\n        nodeColumnCandidate: false,\n        headerMenuEnabled: false,\n        showSeparator: false,\n        width: this.rowIconColumnWidth,\n        table: this\n      });\n    if (this.columns[0] === this.checkableColumn) {\n      position = 1;\n    }\n    arrays.insert(this.columns, column, position);\n    this.rowIconColumn = column;\n  }\n\n  handleAppLinkAction(event) {\n    var $appLink = $(event.target);\n    var column = this._columnAtX($appLink.offset().left);\n    this._triggerAppLinkAction(column, $appLink.data('ref'));\n  }\n\n  _isDataRendered() {\n    return this.rendered && this.$data !== null;\n  }\n\n  _render() {\n    this.$container = this.$parent.appendDiv('table').addDeviceClass();\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.setLayout(new TableLayout(this));\n\n    if (this.uiCssClass) {\n      this.$container.addClass(this.uiCssClass);\n    }\n\n    if (this.tileMode) {\n      this._renderTileMode();\n    } else {\n      this._renderData();\n    }\n\n    this.session.desktop.on('popupOpen', this._popupOpenHandler);\n    this.session.desktop.on('propertyChange', this._desktopPropertyChangeHandler);\n  }\n\n  _renderData() {\n    this.$data = this.$container.appendDiv('table-data');\n    this.$data.on('mousedown', '.table-row', this._onRowMouseDown.bind(this))\n      .on('mouseup', '.table-row', this._onRowMouseUp.bind(this))\n      .on('dblclick', '.table-row', this._onRowDoubleClick.bind(this))\n      .on('contextmenu', function(event) {\n        event.preventDefault();\n      });\n    this._installScrollbars({\n      axis: 'both'\n    });\n    this._installImageListeners();\n    this._installCellTooltipSupport();\n    this._calculateRowBorderWidth();\n    this._updateRowWidth();\n    this._updateRowHeight();\n    this._renderViewport();\n    if (this.scrollToSelection) {\n      this.revealSelection();\n    }\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderTableHeader();\n    this._renderMenuBarVisible();\n    this._renderFooterVisible();\n    this._renderDropType();\n    this._renderCheckableStyle();\n    this._renderHierarchicalStyle();\n  }\n\n  _setCssClass(cssClass) {\n    super._setCssClass(cssClass);\n    // calculate row level padding\n    var paddingClasses = ['table-row-level-padding'];\n    if (this.cssClass) {\n      paddingClasses.push(this.cssClass);\n    }\n    this.setRowLevelPadding(styles.getSize(paddingClasses.reduce(function(acc, cssClass) {\n      return acc + ' ' + cssClass;\n    }, ''), 'width', 'width', 15));\n  }\n\n  _removeData() {\n    this._destroyCellEditorPopup();\n    this._removeAggregateRows();\n    this._uninstallImageListeners();\n    this._uninstallCellTooltipSupport();\n    this._uninstallScrollbars();\n    this._removeRows();\n    this.$fillBefore = null;\n    this.$fillAfter = null;\n    this.$data.remove();\n    this.$data = null;\n    this.$emptyData = null;\n  }\n\n  _remove() {\n    this.session.desktop.off('propertyChange', this._desktopPropertyChangeHandler);\n    this.session.desktop.off('popupOpen', this._popupOpenHandler);\n    this._uninstallDragAndDropHandler();\n    // TODO [7.0] cgu do not delete header, implement according to footer\n    this.header = null;\n    if (this.$data) {\n      this._removeData();\n    }\n    super._remove();\n  }\n\n  setRowLevelPadding(rowLevelPadding) {\n    this.setProperty('rowLevelPadding', rowLevelPadding);\n  }\n\n  _renderRowLevelPadding() {\n    this._rerenderViewport();\n  }\n\n  setTableControls(controls) {\n    this.setProperty('tableControls', controls);\n  }\n\n  _renderTableControls() {\n    if (this.footer) {\n      this.footer._renderControls();\n    }\n  }\n\n  _setTableControls(controls) {\n    var i;\n    for (i = 0; i < this.tableControls.length; i++) {\n      this.keyStrokeContext.unregisterKeyStroke(this.tableControls[i]);\n    }\n    this._setProperty('tableControls', controls);\n    for (i = 0; i < this.tableControls.length; i++) {\n      this.keyStrokeContext.registerKeyStroke(this.tableControls[i]);\n    }\n    this._updateFooterVisibility();\n    this.tableControls.forEach(function(control) {\n      control.tableFooter = this.footer;\n    }, this);\n  }\n\n  /**\n   * When an IMG has been loaded we must update the stored height in the model-row.\n   * Note: we don't change the width of the row or table.\n   */\n  _onImageLoadOrError(event) {\n    var $target = $(event.target);\n    if ($target.data('measure') === 'in-progress') {\n      // Ignore events created by autoOptimizeWidth measurement (see ColumnOptimalWidthMeasurer)\n      // Using event.stopPropagation() is not possible because the image load event does not bubble\n      return;\n    }\n\n    var $row = $target.closest('.table-row');\n    var row = $row.data('row');\n    if (!row) {\n      return; // row was removed while loading the image\n    }\n    var oldRowHeight = row.height;\n    row.height = $row.outerHeight(true);\n    if (oldRowHeight !== row.height) {\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _onRowMouseDown(event) {\n    this._doubleClickSupport.mousedown(event);\n    this._$mouseDownRow = $(event.currentTarget);\n    this._mouseDownRowId = this._$mouseDownRow.data('row').id;\n    this._mouseDownColumn = this._columnAtX(event.pageX);\n    this._$mouseDownRow.window().one('mouseup', function() {\n      this._$mouseDownRow = null;\n      this._mouseDownRowId = null;\n      this._mouseDownColumn = null;\n    }.bind(this));\n    this.setContextColumn(this._columnAtX(event.pageX));\n    this.selectionHandler.onMouseDown(event);\n    var isRightClick = event.which === 3;\n    var row = this._$mouseDownRow.data('row');\n\n    var $target = $(event.target);\n    // handle expansion\n    if (this._isRowControl($target)) {\n      if (row.expanded) {\n        this.collapseRow(row);\n      } else {\n        this.expandRow(row);\n      }\n    }\n    // For checkableStyle TABLE_ROW & CHECKBOX_TABLE_ROW only: check row if left click OR clicked row was not checked yet\n    if (scout.isOneOf(this.checkableStyle, Table.CheckableStyle.TABLE_ROW, Table.CheckableStyle.CHECKBOX_TABLE_ROW) &&\n      (!isRightClick || !row.checked) &&\n      !$(event.target).is('.table-row-control') &&\n      // Click on BooleanColumns should not trigger a row check. The only exception is if the BooleanColumn is the checkableColumn of this table (handled in BooleanColumn.js)\n      !($target.hasClass('checkable') || $target.parent().hasClass('checkable'))) {\n      this.checkRow(row, !row.checked);\n    }\n    if (isRightClick) {\n      this.showContextMenu({\n        pageX: event.pageX,\n        pageY: event.pageY\n      });\n      return false;\n    }\n  }\n\n  _isRowControl($target) {\n    return $target.hasClass('table-row-control') || $target.parent().hasClass('table-row-control');\n  }\n\n  _onRowMouseUp(event) {\n    var $row, $mouseUpRow, column, $appLink,\n      mouseButton = event.which;\n\n    if (this._doubleClickSupport.doubleClicked()) {\n      // Don't execute on double click events\n      return;\n    }\n\n    $mouseUpRow = $(event.currentTarget);\n    this.selectionHandler.onMouseUp(event, $mouseUpRow);\n\n    if (!this._$mouseDownRow || this._mouseDownRowId !== $mouseUpRow.data('row').id) {\n      // Don't accept if mouse up happens on another row than mouse down, or mousedown didn't happen on a row at all\n      return;\n    }\n\n    $row = $mouseUpRow;\n    column = this._columnAtX(event.pageX);\n    if (column !== this._mouseDownColumn) {\n      // Don't execute click / appLinks when the mouse gets pressed and moved outside of a cell\n      return;\n    }\n    var $target = $(event.target);\n    if (this._isRowControl($target)) {\n      // Don't start cell editor or trigger click if row control was clicked (expansion itself is handled by the mouse down handler)\n      return;\n    }\n    if (mouseButton === 1) {\n      column.onMouseUp(event, $row);\n      $appLink = this._find$AppLink(event);\n    }\n    if ($appLink) {\n      this._triggerAppLinkAction(column, $appLink.data('ref'));\n    } else {\n      var row = $row.data('row');\n      this._triggerRowClick(row, mouseButton);\n    }\n  }\n\n  _onRowDoubleClick(event) {\n    var $row = $(event.currentTarget),\n      column = this._columnAtX(event.pageX);\n\n    this.doRowAction($row.data('row'), column);\n  }\n\n  showContextMenu(options) {\n    this.session.onRequestsDone(this._showContextMenu.bind(this, options));\n  }\n\n  _showContextMenu(options) {\n    options = options || {};\n    if (!this._isDataRendered() || !this.attached) { // check needed because function is called asynchronously\n      return;\n    }\n    if (this.selectedRows.length === 0) {\n      return;\n    }\n    var menuItems = this._filterMenusForContextMenu();\n    if (menuItems.length === 0) {\n      return;\n    }\n    var pageX = scout.nvl(options.pageX, null);\n    var pageY = scout.nvl(options.pageY, null);\n    if (pageX === null || pageY === null) {\n      var rowToDisplay = this.isRowSelectedAndVisible(this.selectionHandler.lastActionRow) ? this.selectionHandler.lastActionRow : this.getLastSelectedAndVisibleRow();\n      if (rowToDisplay !== null) {\n        var $rowToDisplay = rowToDisplay.$row;\n        var offset = $rowToDisplay.offset();\n        var dataOffsetBounds = graphics.offsetBounds(this.$data);\n        offset.left += this.$data.scrollLeft();\n        pageX = offset.left + 10;\n        pageY = offset.top + $rowToDisplay.outerHeight() / 2;\n        pageY = Math.min(Math.max(pageY, dataOffsetBounds.y + 1), dataOffsetBounds.bottom() - 1);\n      } else {\n        pageX = this.$data.offset().left + 10;\n        pageY = this.$data.offset().top + 10;\n      }\n    }\n    // Prevent firing of 'onClose'-handler during contextMenu.open()\n    // (Can lead to null-access when adding a new handler to this.contextMenu)\n    if (this.contextMenu) {\n      this.contextMenu.close();\n    }\n    this.contextMenu = scout.create('ContextMenuPopup', {\n      parent: this,\n      menuItems: menuItems,\n      location: {\n        x: pageX,\n        y: pageY\n      },\n      $anchor: this.$data,\n      menuFilter: this._filterMenusHandler\n    });\n    this.contextMenu.open();\n  }\n\n  isRowSelectedAndVisible(row) {\n    if (!this.isRowSelected(row) || !row.$row) {\n      return false;\n    }\n    return graphics.offsetBounds(row.$row).intersects(graphics.offsetBounds(this.$data));\n  }\n\n  getLastSelectedAndVisibleRow() {\n    for (var i = this.viewRangeRendered.to; i >= this.viewRangeRendered.from; i--) {\n      if (this.isRowSelectedAndVisible(this.rows[i])) {\n        return this.rows[i];\n      }\n    }\n    return null;\n  }\n\n  onColumnVisibilityChanged(column) {\n    this.columnLayoutDirty = true;\n    if (this._isDataRendered()) {\n      this._updateRowWidth();\n      this._redraw();\n      this.invalidateLayoutTree();\n    }\n    this.trigger('columnStructureChanged');\n  }\n\n  /**\n   * @override\n   */\n  _onScroll() {\n    var scrollTop = this.$data[0].scrollTop;\n    var scrollLeft = this.$data[0].scrollLeft;\n    if (this.scrollTop !== scrollTop) {\n      this._renderViewport();\n    }\n    this.scrollTop = scrollTop;\n    this.scrollLeft = scrollLeft;\n  }\n\n  _renderTableStatus() {\n    this.trigger('statusChanged');\n  }\n\n  setContextColumn(contextColumn) {\n    this.setProperty('contextColumn', contextColumn);\n  }\n\n  _hasVisibleTableControls() {\n    return this.tableControls.some(function(control) {\n      return control.visible;\n    });\n  }\n\n  hasAggregateTableControl() {\n    return this.tableControls.some(function(control) {\n      return control instanceof AggregateTableControl;\n    });\n  }\n\n  _createHeader() {\n    return scout.create('TableHeader', {\n      parent: this,\n      table: this,\n      enabled: this.headerEnabled,\n      headerMenusEnabled: this.headerMenusEnabled\n    });\n  }\n\n  _createFooter() {\n    return scout.create('TableFooter', {\n      parent: this,\n      table: this\n    });\n  }\n\n  _installCellTooltipSupport() {\n    tooltips_1.install(this.$data, {\n      parent: this,\n      selector: '.table-cell',\n      text: this._cellTooltipText.bind(this),\n      htmlEnabled: this._isAggregatedTooltip.bind(this),\n      arrowPosition: 50,\n      arrowPositionUnit: '%',\n      nativeTooltip: !Device.get().isCustomEllipsisTooltipPossible()\n    });\n  }\n\n  _uninstallCellTooltipSupport() {\n    tooltips_1.uninstall(this.$data);\n  }\n\n  _cellTooltipText($cell) {\n    var cell, tooltipText,\n      $row = $cell.parent(),\n      column = this.columnFor$Cell($cell, $row),\n      row = $row.data('row');\n\n    if (row) {\n      cell = this.cell(column, row);\n      tooltipText = cell.tooltipText;\n    }\n\n    if (tooltipText) {\n      return tooltipText;\n    } else if ($row.data('aggregateRow') && $cell.text().trim() && ($cell.isContentTruncated() || ($cell.children('.table-cell-icon').length && !$cell.children('.table-cell-icon').isVisible()))) {\n      $cell = $cell.clone();\n      $cell.children('.table-cell-icon').setVisible(true);\n      return $cell.html();\n    } else if (this._isTruncatedCellTooltipEnabled(column) && $cell.isContentTruncated()) {\n      return strings.plainText($cell.html(), {\n        trim: true\n      });\n    }\n  }\n\n  setTruncatedCellTooltipEnabled(truncatedCellTooltipEnabled) {\n    this.setProperty('truncatedCellTooltipEnabled', truncatedCellTooltipEnabled);\n  }\n\n  /**\n   * Decides if a cell tooltip should be shown for a truncated cell.\n   */\n  _isTruncatedCellTooltipEnabled(column) {\n    if (this.truncatedCellTooltipEnabled === null) {\n      // Show cell tooltip only if it is not possible to resize the column.\n      return !this.headerVisible || !this.headerEnabled || column.fixedWidth;\n    }\n    return this.truncatedCellTooltipEnabled;\n  }\n\n  _isAggregatedTooltip($cell) {\n    var $row = $cell.parent();\n    if ($row.data('aggregateRow')) {\n      return true;\n    }\n  }\n\n  reload(reloadReason) {\n    if (!this.hasReloadHandler) {\n      return;\n    }\n    this._removeRows();\n    if (this._isDataRendered()) {\n      this._removeAggregateRows();\n      this._renderFiller();\n    }\n    this._triggerReload(reloadReason);\n  }\n\n  /**\n   * @override\n   */\n  setLoading(loading) {\n    if (!loading && this.updateBuffer.isBuffering()) {\n      // Don't abort loading while buffering, the buffer will do it at the end\n      return;\n    }\n    super.setLoading(loading);\n  }\n\n  exportToClipboard() {\n    this._triggerClipboardExport();\n  }\n\n  /**\n   * JS implementation of AbstractTable.execCopy(rows)\n   */\n  _exportToClipboard() {\n    clipboard.copyText({\n      parent: this,\n      text: this._selectedRowsToText()\n    });\n  }\n\n  _selectedRowsToText() {\n    var columns = this.visibleColumns();\n    return this.selectedRows.map(row => {\n      return columns.map(column => {\n        var cell = column.cell(row);\n        var text;\n        if (column instanceof BooleanColumn) {\n          text = cell.value ? 'X' : '';\n        } else if (cell.htmlEnabled) {\n          text = strings.plainText(cell.text);\n        } else {\n          text = cell.text;\n        }\n        // unwrap\n        return this._unwrapText(text);\n      }).join('\\t');\n    }).join('\\n');\n  }\n\n  _unwrapText(text) {\n    // Same implementation as in AbstractTable#unwrapText(String)\n    return strings.nvl(text)\n      .split(/[\\n\\r]/)\n      .map(line => line.replace(/\\t/g, ' '))\n      .map(line => line.trim())\n      .filter(line => !!line.length)\n      .join(' ');\n  }\n\n  setMultiSelect(multiSelect) {\n    this.setProperty('multiSelect', multiSelect);\n  }\n\n  toggleSelection() {\n    if (this.selectedRows.length === this.visibleRows.length) {\n      this.deselectAll();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  selectAll() {\n    this.selectRows(this.visibleRows);\n  }\n\n  deselectAll() {\n    this.selectRows([]);\n  }\n\n  checkAll(checked, options) {\n    var opts = $.extend(options, {\n      checked: checked\n    });\n    this.checkRows(this.visibleRows, opts);\n  }\n\n  uncheckAll(options) {\n    this.checkAll(false, options);\n  }\n\n  updateScrollbars() {\n    scrollbars.update(this.$data);\n  }\n\n  _sort(animateAggregateRows) {\n    var sortColumns = this._sortColumns();\n\n    // Initialize comparators\n    if (!this._isSortingPossible(sortColumns)) {\n      return false;\n    }\n    this.clearAggregateRows(animateAggregateRows);\n    if (!sortColumns.length) {\n      // no sort column defined.\n      return true;\n    }\n\n    // add all visible columns as fallback sorting to guarantee same sorting as in Java.\n    sortColumns = arrays.union(sortColumns, this.columns);\n\n    this._sortImpl(sortColumns);\n    this._triggerRowOrderChanged();\n    if (this._isDataRendered()) {\n      this._renderRowOrderChanges();\n    }\n\n    // Do it after row order has been rendered, because renderRowOrderChanges rerenders the whole viewport which would destroy the animation\n    this._group(animateAggregateRows);\n\n    // Sort was possible -> return true\n    return true;\n  }\n\n  /**\n   * @returns whether or not sorting is possible. Asks each column to answer this question by calling Column#isSortingPossible.\n   */\n  _isSortingPossible(sortColumns) {\n    return sortColumns.every(function(column) {\n      return column.isSortingPossible();\n    });\n  }\n\n  _sortColumns() {\n    var sortColumns = [];\n    for (var c = 0; c < this.columns.length; c++) {\n      var column = this.columns[c];\n      var sortIndex = column.sortIndex;\n      if (sortIndex >= 0) {\n        sortColumns[sortIndex] = column;\n      }\n    }\n    return sortColumns;\n  }\n\n  _sortImpl(sortColumns) {\n    var sortFunction = function(row1, row2) {\n      for (var s = 0; s < sortColumns.length; s++) {\n        var column = sortColumns[s];\n        var result = column.compare(row1, row2);\n        if (column.sortActive && !column.sortAscending) {\n          // only consider sortAscending flag when sort is active\n          // columns with !sortActive are always sorted ascending (sortAscending represents last state for those, thus not considered)\n          result = -result;\n        }\n        if (result !== 0) {\n          return result;\n        }\n      }\n      return 0;\n    };\n\n    if (this.hierarchical) {\n      // sort tree and set flat row array afterwards.\n      this._sortHierarchical(sortFunction);\n      var sortedFlatRows = [];\n      this.visitRows(function(row) {\n        sortedFlatRows.push(row);\n      });\n      this.rows = sortedFlatRows;\n    } else {\n      // sort the flat rows and set the rootRows afterwards.\n      this.rows.sort(sortFunction);\n      this.rootRows = this.rows;\n    }\n\n    this._updateRowStructure({\n      filteredRows: true,\n      applyFilters: false,\n      visibleRows: true\n    });\n  }\n\n  /**\n   * Pre-order (top-down) traversal of all rows in this table (if hierarchical).\n   */\n  visitRows(visitFunc, rows, level) {\n    level = scout.nvl(level, 0);\n    rows = rows || this.rootRows;\n    rows.forEach(function(row) {\n      visitFunc(row, level);\n      this.visitRows(visitFunc, row.childRows, level + 1);\n    }, this);\n  }\n\n  _sortHierarchical(sortFunc, rows) {\n    rows = rows || this.rootRows;\n    rows.sort(sortFunc);\n    rows.forEach(function(row) {\n      this._sortHierarchical(sortFunc, row.childRows);\n    }, this);\n  }\n\n  _renderRowOrderChanges() {\n    var animate,\n      $rows = this.$rows(),\n      oldRowPositions = {};\n\n    // store old position\n    // animate only if every row is rendered, otherwise some rows would be animated and some not\n    if ($rows.length === this.visibleRows.length) {\n      $rows.each(function(index, elem) {\n        var rowWasInserted = false,\n          $row = $(elem),\n          row = $row.data('row');\n\n        // Prevent the order animation for newly inserted rows (to not confuse the user)\n        if (this._insertedRows) {\n          for (var i = 0; i < this._insertedRows.length; i++) {\n            if (this._insertedRows[i].id === row.id) {\n              rowWasInserted = true;\n              break;\n            }\n          }\n        }\n\n        if (!rowWasInserted) {\n          animate = true;\n          oldRowPositions[row.id] = $row.offset().top;\n        }\n      }.bind(this));\n    }\n\n    this._rerenderViewport();\n    // If aggregate rows are being removed by animation, rerenderViewport does not delete them -> reorder\n    // This may happen if grouping gets deactivated and another column will get the new first sort column\n    this._order$AggregateRows();\n\n    // Ensure selected row is visible after ordering\n    if (this.scrollToSelection) {\n      this.revealSelection();\n    }\n\n    // for less than animationRowLimit rows: move to old position and then animate\n    if (animate) {\n      $rows = this.$rows();\n      $rows.each(function(index, elem) {\n        var $row = $(elem),\n          row = $row.data('row'),\n          oldTop = oldRowPositions[row.id];\n\n        if (oldTop !== undefined) {\n          $row.css('top', oldTop - $row.offset().top).animate({\n            top: 0\n          }, {\n            progress: function() {\n              this._triggerRowOrderChanged(row, true);\n              this.updateScrollbars();\n            }.bind(this)\n          });\n        }\n      }.bind(this));\n    }\n  }\n\n  setSortEnabled(sortEnabled) {\n    this.setProperty('sortEnabled', sortEnabled);\n  }\n\n  /**\n   * @param multiSort true to add the column to list of sorted columns. False to use this column exclusively as sort column (reset other columns)\n   * @param remove true to remove the column from the sort columns\n   */\n  sort(column, direction, multiSort, remove) {\n    var data, sorted, animateAggregateRows;\n    multiSort = scout.nvl(multiSort, false);\n    remove = scout.nvl(remove, false);\n    // Animate if sort removes aggregate rows\n    animateAggregateRows = !multiSort;\n    if (remove) {\n      this._removeSortColumn(column);\n    } else {\n      this._addSortColumn(column, direction, multiSort);\n    }\n    if (this.header) {\n      this.header.onSortingChanged();\n    }\n    sorted = this._sort(animateAggregateRows);\n\n    data = {\n      column: column,\n      sortAscending: column.sortAscending\n    };\n    if (remove) {\n      data.sortingRemoved = true;\n    }\n    if (multiSort) {\n      data.multiSort = true;\n    }\n    if (!sorted) {\n      // Delegate sorting to server when it is not possible on client side\n      data.sortingRequested = true;\n      // hint to animate the aggregate after the row order changed event\n      this._animateAggregateRows = animateAggregateRows;\n    }\n    this.trigger('sort', data);\n  }\n\n  _addSortColumn(column, direction, multiSort) {\n    var groupColCount, sortColCount;\n    direction = scout.nvl(direction, column.sortAscending ? 'asc' : 'desc');\n    multiSort = scout.nvl(multiSort, true);\n\n    this._updateSortIndexForColumn(column, multiSort);\n\n    // Reset grouped flag if column should be sorted exclusively\n    if (!multiSort) {\n      groupColCount = this._groupedColumns().length;\n      sortColCount = this._sortColumns().length;\n      if (sortColCount === 1 && groupColCount === 1) {\n        // special case: if it is the only sort column and also grouped, do not remove grouped property.\n      } else {\n        column.grouped = false;\n      }\n    }\n\n    column.sortAscending = direction === 'asc';\n    column.sortActive = true;\n  }\n\n  /**\n   * Intended to be called for new sort columns.\n   * Sets the sortIndex of the given column and its siblings.\n   */\n  _updateSortIndexForColumn(column, multiSort) {\n    var deviation,\n      sortIndex = -1;\n\n    if (multiSort) {\n      // if not already sorted set the appropriate sort index (check for sortIndex necessary if called by _onColumnHeadersUpdated)\n      if (!column.sortActive || column.sortIndex === -1) {\n        sortIndex = Math.max(-1, arrays.max(this.columns.map(function(c) {\n          return c.sortIndex === undefined || c.initialAlwaysIncludeSortAtEnd ? -1 : c.sortIndex;\n        })));\n        column.sortIndex = sortIndex + 1;\n\n        // increase sortIndex for all permanent tail columns (a column has been added in front of them)\n        this._permanentTailSortColumns.forEach(function(c) {\n          c.sortIndex++;\n        });\n      }\n    } else {\n      // do not update sort index for permanent head/tail sort columns, their order is fixed (see ColumnSet.java)\n      if (!(column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd)) {\n        column.sortIndex = this._permanentHeadSortColumns.length;\n      }\n\n      // remove sort index for siblings (ignore permanent head/tail columns, only if not multi sort)\n      arrays.eachSibling(this.columns, column, function(siblingColumn) {\n        if (siblingColumn.sortActive) {\n          this._removeSortColumnInternal(siblingColumn);\n        }\n      }.bind(this));\n\n      // set correct sort index for all permanent tail sort columns\n      deviation = column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd ? 0 : 1;\n      this._permanentTailSortColumns.forEach(function(c, index) {\n        c.sortIndex = this._permanentHeadSortColumns.length + deviation + index;\n      }, this);\n    }\n  }\n\n  _removeSortColumn(column) {\n    if (column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd) {\n      return;\n    }\n    // Adjust sibling columns with higher index\n    arrays.eachSibling(this.columns, column, function(siblingColumn) {\n      if (siblingColumn.sortIndex > column.sortIndex) {\n        siblingColumn.sortIndex = siblingColumn.sortIndex - 1;\n      }\n    });\n    this._removeSortColumnInternal(column);\n  }\n\n  _removeSortColumnInternal(column) {\n    if (column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd) {\n      return;\n    }\n    column.sortActive = false;\n    column.grouped = false;\n    column.sortIndex = -1;\n  }\n\n  isGroupingPossible(column) {\n    var possible = true;\n\n    if (this.hierarchical) {\n      return false;\n    }\n\n    if (!this.sortEnabled) {\n      // grouping without sorting is not possible\n      return false;\n    }\n\n    if (this._permanentHeadSortColumns && this._permanentHeadSortColumns.length === 0) {\n      // no permanent head sort columns. grouping ok.\n      return true;\n    }\n\n    if (column.initialAlwaysIncludeSortAtBegin) {\n      possible = true;\n      arrays.eachSibling(this._permanentHeadSortColumns, column, function(c) {\n        if (c.sortIndex < column.sortIndex) {\n          possible = possible && c.grouped;\n        }\n      });\n      return possible;\n    }\n\n    if (column.initialAlwaysIncludeSortAtEnd) {\n      // it is a tail sort column. Grouping does not make sense.\n      return false;\n    }\n\n    // column itself is not a head or tail sort column. Therefore, all head sort columns must be grouped.\n    this._permanentHeadSortColumns.forEach(function(c) {\n      possible = possible && c.grouped;\n    });\n    return possible;\n  }\n\n  isAggregationPossible(column) {\n    if (!(column instanceof NumberColumn)) {\n      return false;\n    }\n\n    if (column.grouped) {\n      // Aggregation is not possible if column is grouped\n      return false;\n    }\n\n    if (!column.allowedAggregationFunctions || column.allowedAggregationFunctions.length <= 1) {\n      // Aggregation is not possible if no aggregation functions are allowed or only exactly one aggregation is pre-defined.\n      return false;\n    }\n\n    // Aggregation is possible if it is grouped by another column or aggregation control is available\n    return this.isGrouped() || this.hasAggregateTableControl();\n  }\n\n  changeAggregation(column, func) {\n    this.changeAggregations([column], [func]);\n  }\n\n  changeAggregations(columns, functions) {\n    columns.forEach(function(column, i) {\n      var func = functions[i];\n      if (column.aggregationFunction !== func) {\n        column.setAggregationFunction(func);\n        this._triggerAggregationFunctionChanged(column);\n      }\n    }, this);\n\n    this._group();\n  }\n\n  _addGroupColumn(column, direction, multiGroup) {\n    var sortIndex = -1;\n\n    if (!this.isGroupingPossible(column)) {\n      return;\n    }\n\n    direction = scout.nvl(direction, column.sortAscending ? 'asc' : 'desc');\n    multiGroup = scout.nvl(multiGroup, true);\n    if (!(column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd)) {\n      // do not update sort index for permanent head/tail sort columns, their order is fixed (see ColumnSet.java)\n      if (multiGroup) {\n        sortIndex = Math.max(-1, arrays.max(this.columns.map(function(c) {\n          return c.sortIndex === undefined || c.initialAlwaysIncludeSortAtEnd || !c.grouped ? -1 : c.sortIndex;\n        })));\n\n        if (!column.sortActive) {\n          // column was not yet present: insert at determined position\n          // and move all subsequent nodes by one.\n          // add just after all other grouping columns in column set.\n          column.sortIndex = sortIndex + 1;\n          arrays.eachSibling(this.columns, column, function(siblingColumn) {\n            if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex > sortIndex) {\n              siblingColumn.sortIndex++;\n            }\n          });\n\n          // increase sortIndex for all permanent tail columns (a column has been added in front of them)\n          this._permanentTailSortColumns.forEach(function(c) {\n            c.sortIndex++;\n          });\n        } else {\n          // column already sorted, update position:\n          // move all sort columns between the newly determined sortindex and the old sortindex by one.\n          arrays.eachSibling(this.columns, column, function(siblingColumn) {\n            if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) &&\n              siblingColumn.sortIndex > sortIndex &&\n              siblingColumn.sortIndex < column.sortIndex) {\n              siblingColumn.sortIndex++;\n            }\n          });\n          column.sortIndex = sortIndex + 1;\n        }\n      } else {\n        // no multigroup:\n        sortIndex = this._permanentHeadSortColumns.length;\n\n        if (column.sortActive) {\n          // column already sorted, update position:\n          // move all sort columns between the newly determined sortindex and the old sortindex by one.\n          arrays.eachSibling(this.columns, column, function(siblingColumn) {\n            if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) &&\n              siblingColumn.sortIndex >= sortIndex &&\n              siblingColumn.sortIndex < column.sortIndex) {\n              siblingColumn.sortIndex++;\n            }\n          });\n          column.sortIndex = sortIndex;\n        } else { // not sorted yet\n          arrays.eachSibling(this.columns, column, function(siblingColumn) {\n            if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex >= sortIndex) {\n              siblingColumn.sortIndex++;\n            }\n          });\n\n          column.sortIndex = sortIndex;\n\n          // increase sortIndex for all permanent tail columns (a column has been added in front of them)\n          this._permanentTailSortColumns.forEach(function(c) {\n            c.sortIndex++;\n          });\n        }\n\n        // remove all other grouped properties:\n        arrays.eachSibling(this.columns, column, function(siblingColumn) {\n          if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex >= sortIndex) {\n            siblingColumn.grouped = false;\n          }\n        });\n      }\n\n      column.sortAscending = direction === 'asc';\n      column.sortActive = true;\n    } else if (column.initialAlwaysIncludeSortAtBegin) {\n      // do not change order or direction. just set grouped to true.\n      column.grouped = true;\n    }\n\n    column.grouped = true;\n  }\n\n  _removeGroupColumn(column) {\n    column.grouped = false;\n\n    if (column.initialAlwaysIncludeSortAtBegin) {\n      // head sort case: remove all groupings after this column.\n      this.columns.forEach(function(c) {\n        if (c.sortIndex >= column.sortIndex) {\n          c.grouped = false;\n        }\n      });\n    }\n\n    this._removeSortColumn(column);\n  }\n\n  _buildRowDiv(row) {\n    var rowWidth = this.rowWidth;\n    var rowClass = 'table-row';\n    if (row.cssClass) {\n      rowClass += ' ' + row.cssClass;\n    }\n    if (!row.enabled) {\n      rowClass += ' disabled';\n    }\n    if (row.checked && this.checkableStyle === Table.CheckableStyle.TABLE_ROW) {\n      rowClass += ' checked';\n    }\n    // if a row is not filterAccepted it must be visible since any of its child rows are filter accepted.\n    if (!row.filterAccepted) {\n      rowClass += ' filter-not-accepted';\n    }\n    if (arrays.empty(row.childRows)) {\n      rowClass += ' leaf';\n    }\n\n    var i, column,\n      rowDiv = '<div class=\"' + rowClass + '\" style=\"width: ' + rowWidth + 'px\">';\n    for (i = 0; i < this.columns.length; i++) {\n      column = this.columns[i];\n      if (column.isVisible()) {\n        rowDiv += column.buildCellForRow(row);\n      }\n    }\n    rowDiv += '</div>';\n\n    return rowDiv;\n  }\n\n  _calculateRowBorderWidth() {\n    var $tableRowDummy = this.$data.appendDiv('table-row');\n    this.rowBorderLeftWidth = $tableRowDummy.cssBorderLeftWidth();\n    this.rowBorderRightWidth = $tableRowDummy.cssBorderRightWidth();\n    this.rowBorderWidth = this.rowBorderLeftWidth + this.rowBorderRightWidth;\n    $tableRowDummy.remove();\n  }\n\n  _updateRowWidth() {\n    this.rowWidth = this.visibleColumns().reduce(function(sum, column) {\n      if (this.autoResizeColumns) {\n        return sum + column.width;\n      }\n      // Ensure the row is as long as all cells. Only necessary to use the _realWidth if the device.hasTableCellZoomBug().\n      // If autoResizeColumns is enabled, it is not possible to do a proper calculation with this bug\n      // -> Use regular width and live with the consequence that the last cell of a table with many columns is not fully visible\n      return sum + column._realWidthIfAvailable();\n    }.bind(this), this.rowBorderWidth);\n  }\n\n  /**\n   * A html element with display: table-cell gets the wrong width in Chrome when zoom is enabled, see\n   * https://bugs.chromium.org/p/chromium/issues/detail?id=740502.\n   * Because the table header items don't use display: table-cell, theirs width is correct.\n   * -> Header items and table cells are not in sync which is normally not a big deal but gets visible very well with a lot of columns.\n   * This method reads the real width and stores it on the column so that the header can use it when setting the header item's size.\n   * It is also necessary to update the row width accordingly otherwise it would be cut at the very right.\n   */\n  _updateRealColumnWidths($row) {\n    if (!Device.get().hasTableCellZoomBug()) {\n      return false;\n    }\n    var changed = false;\n    $row = $row || this.$rows().eq(0);\n    this.visibleColumns().forEach(function(column, colIndex) {\n      if (this._updateRealColumnWidth(column, colIndex, $row)) {\n        changed = true;\n      }\n    }, this);\n    return changed;\n  }\n\n  _updateRealColumnWidth(column, colIndex, $row) {\n    if (!Device.get().hasTableCellZoomBug()) {\n      return false;\n    }\n    $row = $row || this.$rows().eq(0);\n    var $cell = this.$cell(scout.nvl(colIndex, column), $row);\n    if ($cell.length === 0 && column._realWidth !== null) {\n      column._realWidth = null;\n      return true;\n    }\n    var realWidth = graphics.size($cell, {exact: true}).width;\n    if (realWidth !== column._realWidth) {\n      column._realWidth = realWidth;\n      return true;\n    }\n    return false;\n  }\n\n  _updateRowHeight() {\n    var $emptyRow = this.$data.appendDiv('table-row');\n    var $emptyAggrRow = this.$data.appendDiv('table-aggregate-row');\n\n    $emptyRow.appendDiv('table-cell').html('&nbsp;');\n    $emptyAggrRow.appendDiv('table-cell').html('&nbsp;');\n    this.rowHeight = $emptyRow.outerHeight(true);\n    this.aggregateRowHeight = $emptyAggrRow.outerHeight(true);\n    $emptyRow.remove();\n    $emptyAggrRow.remove();\n  }\n\n  /**\n   * Updates the row heights for every visible row and aggregate row and clears the height of the others\n   */\n  _updateRowHeights() {\n    this.rows.forEach(function(row) {\n      if (!row.$row) {\n        row.height = null;\n      } else {\n        row.height = row.$row.outerHeight(true);\n      }\n    });\n    this._aggregateRows.forEach(function(aggregateRow) {\n      if (!aggregateRow.$row) {\n        aggregateRow.height = null;\n      } else {\n        aggregateRow.height = aggregateRow.$row.outerHeight(true);\n      }\n    });\n  }\n\n  _renderRowsInRange(range) {\n    var $rows,\n      rowString = '',\n      numRowsRendered = 0,\n      prepend = false;\n\n    var rows = this.visibleRows;\n    if (rows.length === 0) {\n      return;\n    }\n\n    var maxRange = new Range(0, this.rows.length);\n    range = maxRange.intersect(range);\n    if (this.viewRangeRendered.size() > 0 && !range.intersect(this.viewRangeRendered).equals(new Range(0, 0))) {\n      throw new Error('New range must not intersect with existing.');\n    }\n    if (range.to <= this.viewRangeRendered.from) {\n      prepend = true;\n    }\n    var newRange = this.viewRangeRendered.union(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n    this._removeEmptyData();\n\n    // Build $rows (as string instead of jQuery objects due to efficiency reasons)\n    for (var r = range.from; r < range.to; r++) {\n      var row = rows[r];\n      rowString += this._buildRowDiv(row);\n      numRowsRendered++;\n    }\n\n    // append block of rows\n    $rows = this.$data.makeElement(rowString);\n    if (prepend) {\n      if (this.$fillBefore) {\n        $rows = $rows.insertAfter(this.$fillBefore);\n      } else {\n        $rows = $rows.prependTo(this.$data);\n      }\n    } else if (this.$fillAfter) {\n      $rows = $rows.insertBefore(this.$fillAfter);\n    } else {\n      $rows = $rows.appendTo(this.$data);\n    }\n\n    $rows.each(function(index, rowObject) {\n      var $row = $(rowObject);\n      // Workaround for Chrome bug, see _updateRealColumnWidths\n      // Can be removed when Chrome bug is resolved.\n      // This is only necessary once (when the first row is rendered)\n      if (this.viewRangeRendered.size() === numRowsRendered && this._updateRealColumnWidths($row)) {\n        this._updateRowWidth();\n        if (this.header && this.header.rendered) {\n          this.header.resizeHeaderItems();\n        }\n      }\n      $row.cssWidth(this.rowWidth);\n      // End workaround\n      var row = rows[range.from + index];\n      Table.linkRowToDiv(row, $row);\n      this._installRow(row);\n    }.bind(this));\n\n    if ($.log.isTraceEnabled()) {\n      $.log.trace(numRowsRendered + ' new rows rendered from ' + range);\n      $.log.trace(this._rowsRenderedInfo());\n    }\n  }\n\n  _rowsRenderedInfo() {\n    var numRenderedRows = this.$rows().length,\n      renderedRowsRange = '(' + this.viewRangeRendered + ')';\n    return numRenderedRows + ' rows rendered ' + renderedRowsRange;\n  }\n\n  /**\n   * Moves the row to the top.\n   */\n  moveRowToTop(row) {\n    var rowIndex = this.rows.indexOf(row);\n    this.moveRow(rowIndex, 0);\n  }\n\n  /**\n   * Moves the row to the bottom.\n   */\n  moveRowToBottom(row) {\n    var rowIndex = this.rows.indexOf(row);\n    this.moveRow(rowIndex, this.rows.length - 1);\n  }\n\n  /**\n   * Moves the row one up, disregarding filtered rows.\n   */\n  moveRowUp(row) {\n    var rowIndex = this.rows.indexOf(row),\n      targetIndex = rowIndex - 1;\n    if (this.hierarchical) {\n      // find index with same parent\n      var siblings = this.rows.filter(function(candidate) {\n          return row.parentRow === candidate.parentRow;\n        }, this),\n        rowIndexSiblings = siblings.indexOf(row),\n        sibling = siblings[rowIndexSiblings - 1];\n      if (sibling) {\n        targetIndex = this.rows.indexOf(sibling);\n      } else {\n        targetIndex = 0;\n      }\n    }\n\n    this.moveRow(rowIndex, targetIndex);\n  }\n\n  /**\n   * Moves the row one down, disregarding filtered rows.\n   */\n  moveRowDown(row) {\n    var rowIndex = this.rows.indexOf(row),\n      targetIndex = rowIndex + 1;\n    if (this.hierarchical) {\n      // find index with same parent\n      var siblings = this.rows.filter(function(candidate) {\n          return row.parentRow === candidate.parentRow;\n        }, this),\n        rowIndexSiblings = siblings.indexOf(row),\n        sibling = siblings[rowIndexSiblings + 1];\n      if (sibling) {\n        targetIndex = this.rows.indexOf(sibling);\n      } else {\n        targetIndex = this.rows.length;\n      }\n    }\n    this.moveRow(rowIndex, targetIndex);\n  }\n\n  /**\n   * Moves the row one up with respected to filtered rows. Row must be one of the filtered rows.\n   * @deprecated use moveVisibleRowUp instead\n   */\n  moveFilteredRowUp(row) {\n    this.moveVisibleRowUp(row);\n  }\n\n  moveVisibleRowUp(row) {\n    var rowIndex = this.rows.indexOf(row),\n      visibleIndex = this.visibleRows.indexOf(row),\n      sibling,\n      targetIndex;\n\n    if (this.hierarchical) {\n      var siblings = this.visibleRows.filter(function(candidate) {\n        return row.parentRow === candidate.parentRow;\n      }, this);\n      sibling = siblings[siblings.indexOf(row) - 1];\n      if (sibling) {\n        targetIndex = this.rows.indexOf(sibling);\n      } else {\n        // no previous sibling\n        return;\n      }\n    } else {\n      sibling = this.visibleRows[visibleIndex - 1];\n      if (!sibling) {\n        // no previous sibling\n        return;\n      }\n      targetIndex = this.rows.indexOf(sibling);\n    }\n    this.moveRow(rowIndex, targetIndex);\n  }\n\n  /**\n   * Moves the row one down with respected to filtered rows. Row must be one of the filtered rows.\n   * @deprecated use moveVisibleRowDown instead\n   */\n  moveFilteredRowDown(row) {\n    this.moveVisibleRowDown(row);\n  }\n\n  moveVisibleRowDown(row) {\n    var rowIndex = this.rows.indexOf(row),\n      visibleIndex = this.visibleRows.indexOf(row),\n      sibling,\n      targetIndex;\n\n    if (this.hierarchical) {\n      var siblings = this.visibleRows.filter(function(candidate) {\n        return row.parentRow === candidate.parentRow;\n      }, this);\n      sibling = siblings[siblings.indexOf(row) + 1];\n      if (sibling) {\n        targetIndex = this.rows.indexOf(sibling);\n      } else {\n        // no following sibling\n        return;\n      }\n    } else {\n      sibling = this.visibleRows[visibleIndex + 1];\n      if (!sibling) {\n        // no following sibling\n        return;\n      }\n      targetIndex = this.rows.indexOf(sibling);\n    }\n    this.moveRow(rowIndex, targetIndex);\n  }\n\n  moveRow(sourceIndex, targetIndex) {\n    var rowCount = this.rows.length;\n    sourceIndex = Math.max(sourceIndex, 0);\n    sourceIndex = Math.min(sourceIndex, rowCount - 1);\n    targetIndex = Math.max(targetIndex, 0);\n    targetIndex = Math.min(targetIndex, rowCount - 1);\n\n    if (sourceIndex === targetIndex) {\n      return;\n    }\n\n    arrays.move(this.rows, sourceIndex, targetIndex);\n    this.updateRowOrder(this.rows);\n  }\n\n  _removeRowsInRange(range) {\n    var row, i,\n      numRowsRemoved = 0,\n      rows = this.visibleRows;\n\n    var maxRange = new Range(0, rows.length);\n    range = maxRange.intersect(range);\n\n    var newRange = this.viewRangeRendered.subtract(range);\n    if (newRange.length === 2) {\n      throw new Error('Can only remove rows at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);\n    }\n    this.viewRangeRendered = newRange[0];\n\n    for (i = range.from; i < range.to; i++) {\n      row = rows[i];\n      this._removeRow(row);\n      numRowsRemoved++;\n    }\n\n    if ($.log.isTraceEnabled()) {\n      $.log.trace(numRowsRemoved + ' rows removed from ' + range + '.');\n      $.log.trace(this._rowsRenderedInfo());\n    }\n  }\n\n  removeAllRows() {\n    if (this._isDataRendered()) {\n      this.$rows().each(function(i, elem) {\n        var $row = $(elem),\n          row = $row.data('row');\n        if ($row.hasClass('hiding')) {\n          // Do not remove rows which are removed using an animation\n          // row.$row may already point to a new row -> don't call removeRow to not accidentally remove the new row\n          return;\n        }\n        this._removeRow(row);\n      }.bind(this));\n    }\n    this.viewRangeRendered = new Range(0, 0);\n  }\n\n  /**\n   *\n   * @param rows if undefined, all rows are removed\n   */\n  _removeRows(rows) {\n    if (!rows) {\n      this.removeAllRows();\n      return;\n    }\n\n    var tableAttached = this.isAttachedAndRendered();\n    rows = arrays.ensure(rows);\n    rows.forEach(function(row) {\n      var rowIndex = this.visibleRows.indexOf(row);\n      if (rowIndex === -1) {\n        // row is not visible\n        return;\n      }\n      var rowRendered = Boolean(row.$row);\n      var rowInViewRange = this.viewRangeRendered.contains(rowIndex);\n\n      // Note: these checks can only be done, when table is rendered _and_ attached. When the table is detached it can\n      // still add rows, but these new rows are not rendered while the table is detached. Thus this check would fail,\n      // when a row that has been added in detached state is removed again while table is still detached.\n      if (tableAttached) {\n        // if row is not rendered but its row-index is inside the view range -> inconsistency\n        if (!rowRendered && rowInViewRange) {\n          throw new Error('Inconsistency found while removing row. Row is undefined but inside rendered view range. RowIndex: ' + rowIndex);\n        }\n        // if row is rendered but its row-index is not inside the view range -> inconsistency\n        if (rowRendered && !rowInViewRange) {\n          throw new Error('Inconsistency found while removing row. Row is rendered but not inside rendered view range. RowIndex: ' + rowIndex);\n        }\n      }\n      this._removeRow(row);\n\n      // Adjust view range if row is inside or before range\n      if (rowInViewRange || rowIndex < this.viewRangeRendered.from) {\n        if (rowIndex < this.viewRangeRendered.from) {\n          this.viewRangeRendered.from--;\n          this.viewRangeRendered.to--;\n        } else if (rowIndex <= this.viewRangeRendered.to) {\n          this.viewRangeRendered.to--;\n        }\n      }\n    }.bind(this));\n  }\n\n  /**\n   * Just removes the row, does NOT adjust this.viewRangeRendered\n   */\n  _removeRow(row) {\n    var $row = row.$row;\n    if (!$row) {\n      return;\n    }\n\n    this._destroyTooltipsForRow(row);\n    this._removeCellEditorForRow(row);\n\n    // Do not remove rows which are removed using an animation\n    if (!$row.hasClass('hiding')) {\n      $row.remove();\n      row.$row = null;\n    }\n  }\n\n  /**\n   * Animates the rendering of a row by setting it to invisible before doing a slideDown animation. The row needs to already be rendered.\n   */\n  _showRow(row) {\n    var $row = row.$row;\n    if (!$row) {\n      return;\n    }\n    if ($row.is('.showing')) {\n      return;\n    }\n\n    $row.hide(); // intentionally don't use setVisible(false) here\n    $row.addClass('showing');\n    $row.removeClass('hiding');\n    $row.stop().slideDown({\n      duration: 250,\n      complete: function() {\n        $row.removeClass('showing');\n        this.updateScrollbars();\n      }.bind(this)\n    });\n  }\n\n  /**\n   * Animates the removal of a row by doing a slideUp animation. The row will be removed after the animation finishes.\n   */\n  _hideRow(row) {\n    var $row = row.$row;\n    if (!$row) {\n      return;\n    }\n    if ($row.is('.hiding')) {\n      return;\n    }\n\n    $row.addClass('hiding');\n    $row.removeClass('showing');\n    $row.stop().slideUp({\n      duration: 250,\n      complete: function() {\n        if (!row.$row) {\n          // ignore already removed rows\n          return;\n        }\n        $row.remove();\n        if ($row[0] === row.$row[0]) {\n          // Only set to null if row still is linked to to original $row\n          // If row got rendered again while the animation is still running, row.$row points to the new $row\n          row.$row = null;\n        }\n        this.updateScrollbars();\n      }.bind(this)\n    });\n  }\n\n  /**\n   * This method should be used after a row is added to the DOM (new rows, updated rows). The 'row'\n   * is expected to be linked with the corresponding '$row' (row.$row and $row.data('row')).\n   */\n  _installRow(row) {\n    row.height = row.$row.outerHeight(true);\n\n    if (row.hasError) {\n      this._showCellErrorForRow(row);\n    }\n    // Reopen editor popup (closed when row was removed)\n    if (this.cellEditorPopup && !this.cellEditorPopup.rendered && this.cellEditorPopup.row.id === row.id) {\n      var editorField = this.cellEditorPopup.cell.field;\n      this.startCellEdit(this.cellEditorPopup.column, row, editorField);\n    }\n  }\n\n  _calcRowLevelPadding(row) {\n    if (!row) {\n      return -this.rowLevelPadding;\n    }\n    return this._calcRowLevelPadding(row.parentRow) + this.rowLevelPadding;\n  }\n\n  _showCellErrorForRow(row) {\n    var $cells = this.$cellsForRow(row.$row),\n      that = this;\n\n    $cells.each(function(index) {\n      var $cell = $(this);\n      var cell = that.cellByCellIndex(index, row);\n      if (cell.errorStatus) {\n        that._showCellError(row, $cell, cell.errorStatus);\n      }\n    });\n  }\n\n  _showCellError(row, $cell, errorStatus) {\n    var tooltip, opts,\n      text = errorStatus.message;\n\n    opts = {\n      parent: this,\n      text: text,\n      autoRemove: false,\n      $anchor: $cell,\n      table: this\n    };\n    tooltip = scout.create('TableTooltip', opts);\n    tooltip.render();\n    // link to be able to remove it when row gets deleted\n    tooltip.row = row;\n    this.tooltips.push(tooltip);\n  }\n\n  /**\n   * @returns {Column} the column at position x (e.g. from event.pageX)\n   */\n  _columnAtX(x) {\n    var columnOffsetRight = 0,\n      columnOffsetLeft = this.$data.offset().left + this.rowBorderLeftWidth,\n      scrollLeft = this.$data.scrollLeft();\n\n    if (x < columnOffsetLeft) {\n      // Clicked left of first column (on selection border) --> return first column\n      return this.columns[0];\n    }\n\n    columnOffsetLeft -= scrollLeft;\n    var visibleColumns = this.visibleColumns();\n    var column = arrays.find(visibleColumns, function(column) {\n      columnOffsetRight = columnOffsetLeft + column.width;\n      if (x >= columnOffsetLeft && x < columnOffsetRight) {\n        return true;\n      }\n      columnOffsetLeft = columnOffsetRight;\n    });\n    if (!column) {\n      // No column found (clicked right of last column, on selection border) --> return last column\n      column = visibleColumns[visibleColumns.length - 1];\n    }\n    return column;\n  }\n\n  _find$AppLink(event) {\n    // bubble up from target to delegateTarget\n    var $elem = $(event.target);\n    var $stop = $(event.delegateTarget);\n    while ($elem.length > 0) {\n      if ($elem.hasClass('app-link')) {\n        return $elem;\n      }\n      if ($elem[0] === $stop[0]) {\n        return null;\n      }\n      $elem = $elem.parent();\n    }\n    return null;\n  }\n\n  _filterMenus(menuItems, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {\n    return menus.filterAccordingToSelection('Table', this.selectedRows.length, menuItems, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes);\n  }\n\n  _filterMenusForContextMenu() {\n    return this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true, false, ['Header']);\n  }\n\n  setStaticMenus(staticMenus) {\n    this.setProperty('staticMenus', staticMenus);\n    this._updateMenuBar();\n  }\n\n  _removeMenus() {\n    // menubar takes care about removal\n  }\n\n  notifyRowSelectionFinished() {\n    if (this._triggerRowsSelectedPending) {\n      this._triggerRowsSelected();\n      this._triggerRowsSelectedPending = false;\n    }\n    this.session.onRequestsDone(this._updateMenuBar.bind(this));\n  }\n\n  _triggerRowClick(row, mouseButton, column) {\n    var event = {\n      row: row,\n      mouseButton: mouseButton\n    };\n    this.trigger('rowClick', event);\n  }\n\n  _triggerRowAction(row, column) {\n    this.trigger('rowAction', {\n      row: row,\n      column: column\n    });\n  }\n\n  /**\n   * This functions starts the cell editor for the given row and column. Prepare must wait until\n   * a pending completeCellEdit operation is resolved.\n   */\n  prepareCellEdit(column, row, openFieldPopupOnCellEdit) {\n    var promise = $.resolvedPromise();\n    if (this.cellEditorPopup) {\n      promise = this.cellEditorPopup.waitForCompleteCellEdit();\n    }\n    promise.then(this.prepareCellEditInternal.bind(this, column, row, openFieldPopupOnCellEdit));\n  }\n\n  /**\n   * @param openFieldPopupOnCellEdit when this parameter is set to true, the CellEditorPopup sets an\n   *    additional property 'cellEditor' on the editor-field. The field instance may use this property\n   *    to decide whether or not it should open a popup immediately after it is rendered. This is used\n   *    for Smart- and DateFields.\n   */\n  prepareCellEditInternal(column, row, openFieldPopupOnCellEdit) {\n    var event = new Event({\n      column: column,\n      row: row\n    });\n    this.openFieldPopupOnCellEdit = scout.nvl(openFieldPopupOnCellEdit, false);\n    this.trigger('prepareCellEdit', event);\n\n    if (!event.defaultPrevented) {\n      var field = column.createEditor(row);\n      this.startCellEdit(column, row, field);\n    }\n  }\n\n  /**\n   * @returns {Cell} a cell for the given column and row. Row Icon column and cell icon column don't not have cells --> generate one.\n   */\n  cell(column, row) {\n    if (column === this.rowIconColumn) {\n      return scout.create('Cell', {\n        iconId: row.iconId,\n        cssClass: strings.join(' ', 'row-icon-cell', row.cssClass)\n      });\n    }\n\n    if (column === this.checkableColumn) {\n      return scout.create('Cell', {\n        value: row.checked,\n        editable: true,\n        cssClass: row.cssClass\n      });\n    }\n\n    return row.cells[column.index];\n  }\n\n  cellByCellIndex(cellIndex, row) {\n    return this.cell(this.columns[cellIndex], row);\n  }\n\n  cellValue(column, row) {\n    var cell = this.cell(column, row);\n    if (!cell) {\n      return cell;\n    }\n    if (cell.value !== undefined) {\n      return cell.value;\n    }\n    return '';\n  }\n\n  cellText(column, row) {\n    var cell = this.cell(column, row);\n    if (!cell) {\n      return '';\n    }\n    return cell.text || '';\n  }\n\n  /**\n   *\n   * @returns {object} the next editable position in the table, starting from the cell at (currentColumn / currentRow).\n   * A position is an object containing row and column (cell has no reference to a row or column due to memory reasons).\n   */\n  nextEditableCellPos(currentColumn, currentRow, reverse) {\n    var pos, startColumnIndex, rowIndex, startRowIndex, predicate,\n      colIndex = this.columns.indexOf(currentColumn);\n\n    startColumnIndex = colIndex + 1;\n    if (reverse) {\n      startColumnIndex = colIndex - 1;\n    }\n    pos = this.nextEditableCellPosForRow(startColumnIndex, currentRow, reverse);\n    if (pos) {\n      return pos;\n    }\n\n    predicate = function(row) {\n      if (!row.$row) {\n        return false;\n      }\n\n      startColumnIndex = 0;\n      if (reverse) {\n        startColumnIndex = this.columns.length - 1;\n      }\n      pos = this.nextEditableCellPosForRow(startColumnIndex, row, reverse);\n      if (pos) {\n        return true;\n      }\n    }.bind(this);\n\n    rowIndex = this.rows.indexOf(currentRow);\n    startRowIndex = rowIndex + 1;\n    if (reverse) {\n      startRowIndex = rowIndex - 1;\n    }\n    arrays.findFrom(this.rows, startRowIndex, predicate, reverse);\n\n    return pos;\n  }\n\n  nextEditableCellPosForRow(startColumnIndex, row, reverse) {\n    var cell, column, predicate;\n\n    predicate = function(column) {\n      if (column.guiOnly) {\n        // does not support tabbing\n        return false;\n      }\n      cell = this.cell(column, row);\n      return this.enabledComputed && row.enabled && cell.editable;\n    }.bind(this);\n\n    column = arrays.findFrom(this.columns, startColumnIndex, predicate, reverse);\n    if (column) {\n      return {\n        column: column,\n        row: row\n      };\n    }\n  }\n\n  clearAggregateRows(animate) {\n    // Remove \"hasAggregateRow\" markers from real rows\n    this._aggregateRows.forEach(function(aggregateRow) {\n      if (aggregateRow.prevRow) {\n        aggregateRow.prevRow.aggregateRowAfter = null;\n      }\n      if (aggregateRow.nextRow) {\n        aggregateRow.nextRow.aggregateRowBefore = null;\n      }\n    }, this);\n\n    if (this._isDataRendered()) {\n      this._removeAggregateRows(animate);\n      this._renderSelection(); // fix selection borders\n    }\n    this._aggregateRows = [];\n  }\n\n  /**\n   * Executes the aggregate function with the given funcName for each visible column, but only if the Column\n   * has that function, which is currently only the case for NumberColumns.\n   *\n   * @param states is a reference to an Array containing the results for each column.\n   * @param row (optional) if set, an additional cell-value parameter is passed to the aggregate function\n   */\n  _forEachVisibleColumn(funcName, states, row) {\n    var value;\n    this.visibleColumns().forEach(function(column, i) {\n      if (column[funcName]) {\n        if (row) {\n          value = column.cellValueOrTextForCalculation(row);\n        }\n        states[i] = column[funcName](states[i], value);\n      } else {\n        states[i] = undefined;\n      }\n    });\n  }\n\n  _group(animate) {\n    var rows, nextRow, newGroup, firstRow, lastRow,\n      groupColumns = this._groupedColumns(),\n      onTop = this.groupingStyle === Table.GroupingStyle.TOP,\n      states = [];\n\n    this.clearAggregateRows();\n    if (!groupColumns.length) {\n      return;\n    }\n\n    rows = this.visibleRows;\n    this._forEachVisibleColumn('aggrStart', states);\n\n    rows.forEach(function(row, r) {\n      if (!firstRow) {\n        firstRow = row;\n      }\n      this._forEachVisibleColumn('aggrStep', states, row);\n      // test if sum should be shown, if yes: reset sum-array\n      nextRow = rows[r + 1];\n      // test if group is finished\n      newGroup = r === rows.length - 1 || this._isNewGroup(groupColumns, row, nextRow);\n      // if group is finished: add group row\n      if (newGroup) {\n        // finish aggregation\n        this._forEachVisibleColumn('aggrFinish', states);\n        // append sum row\n        this._addAggregateRow(states,\n          onTop ? lastRow : row,\n          onTop ? firstRow : nextRow);\n        // reset after group\n        this._forEachVisibleColumn('aggrStart', states);\n        firstRow = null;\n        lastRow = row;\n      }\n    }.bind(this));\n\n    if (this._isDataRendered()) {\n      this._renderAggregateRows(animate);\n      this._renderSelection(); // fix selection borders\n    }\n  }\n\n  _isNewGroup(groupedColumns, row, nextRow) {\n    var i, col, newRow = false,\n      hasCellTextForGroupingFunction;\n\n    if (!nextRow) {\n      return true; // row is last row\n    }\n\n    for (i = 0; i < groupedColumns.length; i++) {\n      col = groupedColumns[i];\n      hasCellTextForGroupingFunction = col && col.cellTextForGrouping && typeof col.cellTextForGrouping === 'function';\n      newRow = newRow || hasCellTextForGroupingFunction && col.cellTextForGrouping(row) !== col.cellTextForGrouping(nextRow); // NOSONAR\n      newRow = newRow || !hasCellTextForGroupingFunction && this.cellText(col, row) !== this.cellText(col, nextRow);\n      if (newRow) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  _groupedColumns() {\n    return this.columns.filter(function(col) {\n      return col.grouped;\n    });\n  }\n\n  /**\n   * Inserts a new aggregation row between 'prevRow' and 'nextRow'.\n   *\n   * @param contents cells of the new aggregate row\n   * @param prevRow row _before_ the new aggregate row\n   * @param nextRow row _after_ the new aggregate row\n   */\n  _addAggregateRow(contents, prevRow, nextRow) {\n    var aggregateRow = {\n      contents: contents.slice(),\n      prevRow: prevRow,\n      nextRow: nextRow\n    };\n    this._aggregateRows.push(aggregateRow);\n    if (prevRow) {\n      prevRow.aggregateRowAfter = aggregateRow;\n    }\n    if (nextRow) {\n      nextRow.aggregateRowBefore = aggregateRow;\n    }\n  }\n\n  _removeAggregateRows(animate) {\n    if (this._aggregateRows.length === 0) {\n      return;\n    }\n    animate = scout.nvl(animate, false);\n    if (!animate) {\n      this._aggregateRows.forEach(function(aggregateRow) {\n        this._removeRow(aggregateRow);\n      }, this);\n      this.updateScrollbars();\n    } else {\n      this._aggregateRows.forEach(function(aggregateRow, i) {\n        this._hideRow(aggregateRow);\n      }, this);\n    }\n  }\n\n  _renderAggregateRows(animate) {\n    var onTop = this.groupingStyle === Table.GroupingStyle.TOP,\n      insertFunc = onTop ? 'insertBefore' : 'insertAfter';\n    animate = scout.nvl(animate, false);\n\n    this._aggregateRows.forEach(function(aggregateRow, r) {\n      var refRow, $cell, $aggregateRow;\n\n      if (aggregateRow.$row) {\n        // already rendered, no need to update again (necessary for subsequent renderAggregateRows calls (e.g. in insertRows -> renderRows)\n        return;\n      }\n\n      refRow = onTop ? aggregateRow.nextRow : aggregateRow.prevRow;\n      if (!refRow || !refRow.$row) {\n        return;\n      }\n\n      $aggregateRow = this.$container.makeDiv('table-aggregate-row')\n        .data('aggregateRow', aggregateRow);\n\n      $aggregateRow[insertFunc](refRow.$row).width(this.rowWidth);\n\n      this.visibleColumns().forEach(function(column) {\n        $cell = $(column.buildCellForAggregateRow(aggregateRow));\n        $cell.appendTo($aggregateRow);\n        this._resizeCell($cell);\n      }, this);\n\n      aggregateRow.height = $aggregateRow.outerHeight(true);\n      aggregateRow.$row = $aggregateRow;\n      if (animate) {\n        this._showRow(aggregateRow);\n      }\n    }, this);\n  }\n\n  groupColumn(column, multiGroup, direction, remove) {\n    var data, sorted;\n    multiGroup = scout.nvl(multiGroup, false);\n    remove = scout.nvl(remove, false);\n    if (remove) {\n      this._removeGroupColumn(column);\n    }\n    if (!this.isGroupingPossible(column)) {\n      return;\n    }\n    if (!remove) {\n      this._addGroupColumn(column, direction, multiGroup);\n    }\n\n    if (this.header) {\n      this.header.onSortingChanged();\n    }\n    sorted = this._sort(true);\n\n    data = {\n      column: column,\n      groupAscending: column.sortAscending\n    };\n    if (remove) {\n      data.groupingRemoved = true;\n    }\n    if (multiGroup) {\n      data.multiGroup = true;\n    }\n    if (!sorted) {\n      // Delegate sorting to server when it is not possible on client side\n      data.groupingRequested = true;\n\n      // hint to animate the aggregate after the row order changed event\n      this._animateAggregateRows = true;\n    }\n    this.trigger('group', data);\n  }\n\n  removeColumnGrouping(column) {\n    if (column) {\n      this.groupColumn(column, false, 'asc', true);\n    }\n  }\n\n  removeAllColumnGroupings() {\n    this.columns\n      .filter(function(column) {\n        return column.grouped;\n      })\n      .forEach(this.removeColumnGrouping.bind(this));\n  }\n\n  /**\n   * @returns {boolean} true if at least one column has grouped=true\n   */\n  isGrouped() {\n    return this.columns.some(function(column) {\n      return column.grouped;\n    });\n  }\n\n  setColumnBackgroundEffect(column, effect) {\n    column.setBackgroundEffect(effect);\n  }\n\n  /**\n   * Updates the background effect of every column, if column.backgroundEffect is set.\n   * Meaning: Recalculates the min / max values and renders the background effect again.\n   */\n  _updateBackgroundEffect() {\n    this.columns.forEach(function(column) {\n      if (!column.backgroundEffect) {\n        return;\n      }\n      column.updateBackgroundEffect();\n    }, this);\n  }\n\n  /**\n   * Recalculates the values necessary for the background effect of every column, if column.backgroundEffect is set\n   */\n  _calculateValuesForBackgroundEffect() {\n    this.columns.forEach(function(column) {\n      if (!column.backgroundEffect) {\n        return;\n      }\n      column.calculateMinMaxValues();\n    }, this);\n  }\n\n  _markAutoOptimizeWidthColumnsAsDirty() {\n    this.columns.forEach(function(column) {\n      column.autoOptimizeWidthRequired = true;\n    });\n  }\n\n  _markAutoOptimizeWidthColumnsAsDirtyIfNeeded(autoOptimizeWidthColumns, oldRow, newRow) {\n    var i,\n      marked = false;\n    for (i = autoOptimizeWidthColumns.length - 1; i >= 0; i--) {\n      var column = autoOptimizeWidthColumns[i];\n      if (this.cellValue(column, oldRow) !== this.cellValue(column, newRow)) {\n        column.autoOptimizeWidthRequired = true;\n        // Remove column from list since it is now marked and does not have to be processed next time\n        autoOptimizeWidthColumns.splice(i, 1);\n        marked = true;\n      }\n    }\n    return marked;\n  }\n\n  setMultiCheck(multiCheck) {\n    this.setProperty('multiCheck', multiCheck);\n  }\n\n  checkedRows() {\n    return this.rows.filter(function(row) {\n      return row.checked;\n    });\n  }\n\n  checkRow(row, checked, options) {\n    var opts = $.extend(options, {\n      checked: checked\n    });\n    this.checkRows([row], opts);\n  }\n\n  checkRows(rows, options) {\n    var opts = $.extend({\n      checked: true,\n      checkOnlyEnabled: true\n    }, options);\n    var checkedRows = [];\n    // use enabled computed because when the parent of the table is disabled, it should not be allowed to check rows\n    if (!this.checkable || !this.enabledComputed && opts.checkOnlyEnabled) {\n      return;\n    }\n    rows = arrays.ensure(rows);\n    rows.forEach(function(row) {\n      if (!row.enabled && opts.checkOnlyEnabled || row.checked === opts.checked) {\n        return;\n      }\n      if (!this.multiCheck && opts.checked) {\n        for (var i = 0; i < this.rows.length; i++) {\n          if (this.rows[i].checked) {\n            this.rows[i].checked = false;\n            checkedRows.push(this.rows[i]);\n          }\n        }\n      }\n      row.checked = opts.checked;\n      checkedRows.push(row);\n    }, this);\n\n    if (this._isDataRendered()) {\n      checkedRows.forEach(function(row) {\n        this._renderRowChecked(row);\n      }, this);\n    }\n    this._triggerRowsChecked(checkedRows);\n  }\n\n  uncheckRow(row, options) {\n    this.uncheckRows([row], options);\n  }\n\n  uncheckRows(rows, options) {\n    var opts = $.extend({\n      checked: false\n    }, options);\n    this.checkRows(rows, opts);\n  }\n\n  isTableNodeColumn(column) {\n    return this.hierarchical && this.tableNodeColumn === column;\n  }\n\n  collapseRow(row) {\n    this.collapseRows(arrays.ensure(row));\n  }\n\n  collapseAll() {\n    this.expandRowsInternal(this.rootRows, false, true);\n  }\n\n  expandAll() {\n    this.expandRowsInternal(this.rootRows, true, true);\n  }\n\n  collapseRows(rows, recursive) {\n    this.expandRowsInternal(rows, false, recursive);\n  }\n\n  expandRow(row, recursive) {\n    this.expandRows(arrays.ensure(row));\n  }\n\n  expandRows(rows, recursive) {\n    this.expandRowsInternal(rows, true, recursive);\n  }\n\n  expandRowsInternal(rows, expanded, recursive) {\n    var changedRows = [],\n      rowsForAnimation = [];\n    rows = rows || this.rootRows;\n    expanded = scout.nvl(expanded, true);\n    recursive = scout.nvl(recursive, false);\n    if (recursive) {\n      // collect rows\n      this.visitRows(function(row) {\n        var changed = row.expanded !== expanded;\n        if (changed) {\n          row.expanded = expanded;\n          changedRows.push(row);\n          if (row.$row) {\n            rowsForAnimation.push(row);\n          }\n        }\n      }, rows);\n    } else {\n      changedRows = rows.filter(function(row) {\n        var changed = row.expanded !== expanded;\n        if (changed && row.$row) {\n          rowsForAnimation.push(row);\n        }\n        row.expanded = expanded;\n        return changed;\n      });\n    }\n    if (changedRows.length === 0) {\n      return;\n    }\n    this._updateRowStructure({\n      visibleRows: true\n    });\n    this._triggerRowsExpanded(changedRows);\n\n    if (this._isDataRendered()) {\n      this._renderRowDelta();\n      rowsForAnimation.forEach(function(row) {\n        row.animateExpansion();\n      });\n\n      if (rows[0].$row) {\n        scrollbars.ensureExpansionVisible({\n          element: rows[0],\n          $element: rows[0].$row,\n          $scrollable: this.get$Scrollable(),\n          isExpanded: function(element) {\n            return element.expanded;\n          },\n          getChildren: function(parent) {\n            return parent.childRows;\n          },\n          defaultChildHeight: this.rowHeight\n        });\n      }\n    }\n  }\n\n  doRowAction(row, column) {\n    if (this.selectedRows.length !== 1 || this.selectedRows[0] !== row) {\n      // Only allow row action if the selected row was double clicked because the handler of the event expects a selected row.\n      // This may happen if the user modifies the selection using ctrl or shift while double clicking.\n      return;\n    }\n\n    column = column || this.columns[0];\n    if (column && column.guiOnly) {\n      column = arrays.find(this.columns, function(col) {\n        return !col.guiOnly;\n      });\n    }\n    if (!row || !column) {\n      return;\n    }\n    this._triggerRowAction(row, column);\n  }\n\n  insertRow(row) {\n    this.insertRows([row]);\n  }\n\n  insertRows(rows) {\n    var wasEmpty = this.rows.length === 0;\n\n    // Update model\n    rows.forEach(function(row, i) {\n      row = this._initRow(row);\n      row.status = TableRow.Status.INSERTED;\n      rows[i] = row;\n      // Always insert new rows at the end, if the order is wrong a rowOrderChanged event will follow\n      this.rows.push(row);\n    }, this);\n\n    var filterAcceptedRows = rows.filter(function(row) {\n      this._applyFiltersForRow(row);\n      return row.filterAccepted;\n    }, this);\n\n    this._updateRowStructure({\n      updateTree: true,\n      filteredRows: true,\n      applyFilters: false,\n      visibleRows: true\n    });\n    // Notify changed filter if there are user filters and at least one of the new rows is accepted by them\n    if (this._filterCount() > 0 && filterAcceptedRows.length > 0) {\n      this._triggerFilter();\n    }\n\n    this._calculateValuesForBackgroundEffect();\n    this._markAutoOptimizeWidthColumnsAsDirty();\n\n    // this event should be triggered before the rowOrderChanged event (triggered by the _sort function).\n    this._triggerRowsInserted(rows);\n    this._sortAfterInsert(wasEmpty);\n\n    // Update HTML\n    if (this._isDataRendered()) {\n      if (this.hierarchical) {\n        this._renderRowOrderChanges();\n      }\n      // Remember inserted rows for future events like rowOrderChanged\n      if (!this._insertedRows) {\n        this._insertedRows = rows;\n        setTimeout(function() {\n          this._insertedRows = null;\n        }.bind(this), 0);\n      } else {\n        arrays.pushAll(this._insertedRows, rows);\n      }\n\n      this.viewRangeDirty = true;\n      this._renderViewport();\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _sortAfterInsert(wasEmpty) {\n    this._sort();\n  }\n\n  deleteRow(row) {\n    this.deleteRows([row]);\n  }\n\n  deleteRows(rows) {\n    var invalidate,\n      filterChanged,\n      removedRows = [];\n\n    this.visitRows(function(row) {\n      if (!this.rowsMap[row.id]) {\n        return;\n      }\n\n      removedRows.push(row);\n      // Update HTML\n      if (this._isDataRendered()) {\n        // Cancel cell editing if cell editor belongs to a cell of the deleted row\n        if (this.cellEditorPopup && this.cellEditorPopup.row.id === row.id) {\n          this.cellEditorPopup.cancelEdit();\n        }\n\n        this._removeRows(row);\n        invalidate = true;\n      }\n\n      // Update model\n      arrays.remove(this.rows, row);\n      arrays.remove(this.visibleRows, row);\n      if (this._filterCount() > 0 && arrays.remove(this._filteredRows, row)) {\n        filterChanged = true;\n      }\n      delete this.rowsMap[row.id];\n\n      if (this.selectionHandler.lastActionRow === row) {\n        this.selectionHandler.clearLastSelectedRowMarker();\n      }\n    }.bind(this), rows);\n\n    this.deselectRows(removedRows);\n\n    this._updateRowStructure({\n      updateTree: true,\n      filteredRows: true,\n      applyFilters: false,\n      visibleRows: true\n    });\n    if (filterChanged) {\n      this._triggerFilter();\n    }\n    this._group();\n    this._updateBackgroundEffect();\n    this._markAutoOptimizeWidthColumnsAsDirty();\n    this._triggerRowsDeleted(rows);\n\n    if (invalidate) {\n      this._renderViewport();\n      // Update markers and filler because row may be removed by removeRows. RenderViewport doesn't do it if view range is already correctly rendered.\n      this._renderRangeMarkers();\n      this._renderFiller();\n      this._renderEmptyData();\n      this.invalidateLayoutTree();\n    }\n  }\n\n  deleteAllRows() {\n    var filterChanged = this._filterCount() > 0 && this._filteredRows.length > 0,\n      rows = this.rows;\n\n    // Update HTML\n    if (this._isDataRendered()) {\n      // Cancel cell editing\n      if (this.cellEditorPopup) {\n        this.cellEditorPopup.cancelEdit();\n      }\n\n      this.selectionHandler.clearLastSelectedRowMarker();\n      this._removeRows();\n    }\n\n    // Update model\n    this.rows = [];\n    this.rowsMap = {};\n    this._filteredRows = [];\n    this.deselectAll();\n\n    this._updateRowStructure({\n      updateTree: true,\n      filteredRows: true,\n      applyFilters: false,\n      visibleRows: true\n    });\n    if (filterChanged) {\n      this._triggerFilter();\n    }\n\n    this._markAutoOptimizeWidthColumnsAsDirty();\n    this._group();\n    this._updateBackgroundEffect();\n    this._triggerAllRowsDeleted(rows);\n\n    // Update HTML\n    if (this._isDataRendered()) {\n      this._renderFiller();\n      this._renderViewport();\n      this._renderEmptyData();\n      this.invalidateLayoutTree();\n    }\n  }\n\n  updateRow(row) {\n    this.updateRows([row]);\n  }\n\n  updateRows(rows) {\n    if (this.updateBuffer.isBuffering()) {\n      this.updateBuffer.buffer(rows);\n      return;\n    }\n    var filterChanged, expansionChanged, autoOptimizeWidthColumnsDirty;\n    var autoOptimizeWidthColumns = this.columns.filter(function(column) {\n      return column.autoOptimizeWidth && !column.autoOptimizeWidthRequired;\n    });\n\n    var rowsToIndex = {};\n    this.rows.forEach(function(row, index) {\n      rowsToIndex[row.id] = index;\n    }, this);\n\n    var oldRowsMap = {};\n    var structureChanged = false;\n    rows = rows.map(function(row) {\n      var parentRowId = row.parentRow,\n        oldRow = this.rowsMap[row.id];\n      // collect old rows\n      oldRowsMap[row.id] = oldRow;\n      if (!oldRow) {\n        throw new Error('Update event received for non existing row. RowId: ' + row.id);\n      }\n      // check structure changes\n      if (row.parentRow && !objects.isNullOrUndefined(row.parentRow.id)) {\n        parentRowId = row.parentRow.id;\n      }\n      structureChanged = structureChanged || (scout.nvl(oldRow._parentRowId, null) !== scout.nvl(parentRowId, null));\n      expansionChanged = expansionChanged || (oldRow.expanded !== scout.nvl(row.expanded, false));\n      row = this._initRow(row);\n      // Check if cell values have changed\n      if (row.status === TableRow.Status.NON_CHANGED) {\n        row.cells.some(function(cell, i) {\n          var oldCell = oldRow.cells[i];\n          if (!oldCell || oldCell.value !== cell.value) {\n            row.status = TableRow.Status.UPDATED;\n            return true; // break \"some()\" loop\n          }\n          return false;\n        });\n      }\n      // selection\n      if (this.selectionHandler.lastActionRow === oldRow) {\n        this.selectionHandler.lastActionRow = row;\n      }\n      arrays.replace(this.selectedRows, oldRow, row);\n      // replace row use index lookup for performance reasons\n      this.rows[rowsToIndex[row.id]] = row;\n      // filter\n      row.filterAccepted = oldRow.filterAccepted;\n      if (this._filterCount() > 0) {\n        filterChanged = this._applyFiltersForRow(row) || filterChanged;\n      }\n      // Check if cell content changed and if yes mark auto optimize width column as dirty\n      autoOptimizeWidthColumnsDirty = this._markAutoOptimizeWidthColumnsAsDirtyIfNeeded(autoOptimizeWidthColumns, oldRow, row);\n      return row;\n    }, this);\n\n    this._updateRowStructure({\n      updateTree: true,\n      filteredRows: true,\n      applyFilters: false,\n      visibleRows: true\n    });\n\n    this._triggerRowsUpdated(rows);\n\n    if (this._isDataRendered()) {\n      this._renderUpdateRows(rows, oldRowsMap);\n      if (structureChanged) {\n        this._renderRowOrderChanges();\n      }\n    }\n\n    if (filterChanged) {\n      this._triggerFilter();\n    }\n    if (filterChanged || expansionChanged) {\n      this._renderRowDelta();\n    }\n\n    this._sortAfterUpdate();\n    this._updateBackgroundEffect();\n    this.invalidateLayoutTree(); // this will also update the scroll-bars\n  }\n\n  _renderUpdateRows(rows, oldRowsMap) {\n    // render row and replace div in DOM\n    rows.forEach(function(row) {\n      var oldRow = oldRowsMap[row.id],\n        $updatedRow;\n      if (!oldRow.$row || oldRow.$row.hasClass('hiding')) {\n        // If row is not rendered or being removed by an animation, don't try to update it.\n        // If it were updated during animated removal, the new row would immediately be inserted again, so the removal would not work.\n        return;\n      }\n      $updatedRow = $(this._buildRowDiv(row));\n      $updatedRow.copyCssClasses(oldRow.$row, Table.SELECTION_CLASSES + ' first last');\n      oldRow.$row.replaceWith($updatedRow);\n      Table.linkRowToDiv(row, $updatedRow);\n      this._destroyTooltipsForRow(row);\n      this._removeCellEditorForRow(row);\n      this._installRow(row);\n      if (oldRow.$row.hasClass('showing') && oldRow.$row.outerHeight() < row.$row.outerHeight() / 3) {\n        // If the row was being shown by an animation, start the animation again for the new row, otherwise row would immediately appear without animation.\n        // Do it only, if the current running time of the animation does not exceed 33% (this won't be correct if the height of the new and old rows differ).\n        // Goal: if the update happens immediately after the animation started, the new row will be animated nicely. If the update happens later, don't start the animation again from the start.\n        this._showRow(row);\n      }\n    }, this);\n  }\n\n  _sortAfterUpdate() {\n    this._sort();\n  }\n\n  isHierarchical() {\n    return this.hierarchical;\n  }\n\n  _setHierarchical(hierarchical) {\n    if (this.hierarchical === hierarchical) {\n      return;\n    }\n\n    // Has to be called before the property is set! Otherwise the grouping will not completely removed,\n    // since isGroupingPossible() will return false.\n    if (hierarchical) {\n      this.removeAllColumnGroupings();\n    }\n\n    this._setProperty('hierarchical', hierarchical);\n  }\n\n  /**\n   * The given rows must be rows of this table in desired order.\n   * @param {TableRow[]} rows\n   */\n  updateRowOrder(rows) {\n    rows = arrays.ensure(rows);\n    if (rows.length !== this.rows.length) {\n      throw new Error('Row order may not be updated because lengths of the arrays differ.');\n    }\n\n    // update model (make a copy so that original array stays untouched)\n    this.rows = rows.slice();\n    this._updateRowStructure({\n      updateTree: true,\n      filteredRows: true,\n      applyFilters: false,\n      visibleRows: true\n    });\n    this.clearAggregateRows(this._animateAggregateRows);\n    if (this._isDataRendered()) {\n      this._renderRowOrderChanges();\n    }\n    this._triggerRowOrderChanged();\n\n    this._group(this._animateAggregateRows);\n    this._animateAggregateRows = false;\n  }\n\n  _destroyTooltipsForRow(row) {\n    for (var i = this.tooltips.length - 1; i >= 0; i--) {\n      if (this.tooltips[i].row.id === row.id) {\n        this.tooltips[i].destroy();\n        this.tooltips.splice(i, 1);\n      }\n    }\n  }\n\n  _removeCellEditorForRow(row) {\n    if (this.cellEditorPopup && this.cellEditorPopup.rendered && this.cellEditorPopup.row.id === row.id) {\n      this.cellEditorPopup.remove();\n    }\n  }\n\n  startCellEdit(column, row, field) {\n    if (!this._isDataRendered() || !this.isAttachedAndRendered()) {\n      this._postRenderActions.push(this.startCellEdit.bind(this, column, row, field));\n      return;\n    }\n\n    this.trigger('startCellEdit', {\n      column: column,\n      row: row,\n      field: field\n    });\n    this.ensureRowRendered(row);\n    var popup = column.startCellEdit(row, field);\n    this.cellEditorPopup = popup;\n    return popup;\n  }\n\n  /**\n   * @param saveEditorValue when this parameter is set to true, the value of the editor field is set as\n   *    new value on the edited cell. In remote case this parameter is always false, because the cell\n   *    value is updated by an updateRow event instead.\n   */\n  endCellEdit(field, saveEditorValue) {\n    if (!this._isDataRendered() || !this.isAttachedAndRendered()) {\n      this._postRenderActions.push(this.endCellEdit.bind(this, field, saveEditorValue));\n      return;\n    }\n\n    // the cellEditorPopup could already be removed by scrolling (out of view range) or be removed by update rows\n    if (this.cellEditorPopup) {\n      var context = this.cellEditorPopup;\n\n      // Remove the cell-editor popup prior destroying the field, so that the 'cell-editor-popup's focus context is\n      // uninstalled first and the focus can be restored onto the last focused element of the surrounding focus context.\n      // Otherwise, if the currently focused field is removed from DOM, the $entryPoint would be focused first, which can\n      // be avoided if removing the popup first.\n      this._destroyCellEditorPopup();\n\n      // Must store context in a local variable and call setCellValue _after_ cellEditorPopup is set to null\n      // because in updateRows we check if the popup is still there and start cell editing mode again.\n      saveEditorValue = scout.nvl(saveEditorValue, false);\n      if (saveEditorValue) {\n        var column = context.column;\n        var row = context.row;\n        this.setCellErrorStatus(column, row, field.errorStatus); // always get the errorStatus from the editor\n        if (field.errorStatus) {\n          // if there is an error from the editor, the displayText of the cell has to be updated\n          this.setCellText(column, row, field.displayText);\n        } else {\n          this.setCellValue(column, row, field.value);\n        }\n      }\n    }\n\n    field.destroy();\n  }\n\n  completeCellEdit() {\n    var field = this.cellEditorPopup.cell.field;\n    var event = new Event({\n      field: field,\n      row: this.cellEditorPopup.row,\n      column: this.cellEditorPopup.column,\n      cell: this.cellEditorPopup.cell\n    });\n    this.trigger('completeCellEdit', event);\n\n    if (!event.defaultPrevented) {\n      return this.endCellEdit(field, true);\n    }\n  }\n\n  cancelCellEdit() {\n    var field = this.cellEditorPopup.cell.field;\n    var event = new Event({\n      field: field,\n      row: this.cellEditorPopup.row,\n      column: this.cellEditorPopup.column,\n      cell: this.cellEditorPopup.cell\n    });\n    this.trigger('cancelCellEdit', event);\n\n    if (!event.defaultPrevented) {\n      this.endCellEdit(field);\n    }\n  }\n\n  scrollTo(row, options) {\n    if (this.viewRangeRendered.size() === 0) {\n      // Cannot scroll to a row no row is rendered\n      return;\n    }\n    this.ensureRowRendered(row);\n    if (!row.$row) {\n      // Row may not be visible due to the filter -> don't try to scroll because it would fail\n      return;\n    }\n    scrollbars.scrollTo(this.$data, row.$row, options);\n  }\n\n  scrollPageUp() {\n    var newScrollTop = Math.max(0, this.$data[0].scrollTop - this.$data.height());\n    this.setScrollTop(newScrollTop);\n  }\n\n  scrollPageDown() {\n    var newScrollTop = Math.min(this.$data[0].scrollHeight, this.$data[0].scrollTop + this.$data.height());\n    this.setScrollTop(newScrollTop);\n  }\n\n  /**\n   * @override\n   */\n  setScrollTop(scrollTop) {\n    this.setProperty('scrollTop', scrollTop);\n    // call _renderViewport to make sure rows are rendered immediately. The browser fires the scroll event handled by onDataScroll delayed\n    if (this._isDataRendered()) {\n      this._renderViewport();\n    }\n  }\n\n  /**\n   * @override\n   */\n  _renderScrollTop() {\n    if (this.rendering) {\n      // Not necessary to do it while rendering since it will be done by the layout\n      return;\n    }\n    scrollbars.scrollTop(this.get$Scrollable(), this.scrollTop);\n  }\n\n  /**\n   * @override\n   */\n  get$Scrollable() {\n    if (this.$data) {\n      return this.$data;\n    }\n    return this.$container;\n  }\n\n  setScrollToSelection(scrollToSelection) {\n    this.setProperty('scrollToSelection', scrollToSelection);\n  }\n\n  revealSelection() {\n    if (!this._isDataRendered()) {\n      // Execute delayed because table may be not layouted yet\n      this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));\n      return;\n    }\n\n    if (this.selectedRows.length > 0) {\n      this.scrollTo(this.selectedRows[0]);\n    }\n  }\n\n  revealChecked() {\n    var firstCheckedRow = arrays.find(this.rows, function(row) {\n      return row.checked === true;\n    });\n    if (firstCheckedRow) {\n      this.scrollTo(firstCheckedRow);\n    }\n  }\n\n  _rowById(id) {\n    return this.rowsMap[id];\n  }\n\n  _rowsByIds(ids) {\n    return ids.map(this._rowById.bind(this));\n  }\n\n  _rowsToIds(rows) {\n    return rows.map(function(row) {\n      return row.id;\n    });\n  }\n\n  /**\n   * Checks whether the given row is contained in the table. Uses the id of the row for the lookup.\n   */\n  hasRow(row) {\n    return Boolean(this.rowsMap[row.id]);\n  }\n\n  /**\n   * render borders and selection of row. default select if no argument or false is passed in deselect\n   * model has to be updated before calling this method.\n   */\n  _renderSelection(rows) {\n    rows = arrays.ensure(rows || this.selectedRows);\n\n    // helper function adds/removes a class for a row only if necessary, return true if classes have been changed\n    var addOrRemoveClassIfNeededFunc = function($row, condition, classname) {\n      var hasClass = $row.hasClass(classname);\n      if (condition && !hasClass) {\n        $row.addClass(classname);\n        return true;\n      } else if (!condition && hasClass) {\n        $row.removeClass(classname);\n        return true;\n      }\n      return false;\n    };\n\n    for (var i = 0; i < rows.length; i++) { // traditional for loop, elements might be added during loop\n      var row = rows[i];\n      if (!row.$row) {\n        continue;\n      }\n\n      var thisRowSelected = this.selectedRows.indexOf(row) !== -1,\n        visibleRows = this.visibleRows,\n        previousIndex = visibleRows.indexOf(row) - 1,\n        previousRowSelected = previousIndex >= 0 && this.selectedRows.indexOf(visibleRows[previousIndex]) !== -1,\n        followingIndex = visibleRows.indexOf(row) + 1,\n        followingRowSelected = followingIndex < visibleRows.length && this.selectedRows.indexOf(visibleRows[followingIndex]) !== -1;\n\n      // Don't collapse selection borders if two consecutively selected (real) rows are separated by an aggregation row\n      if (thisRowSelected && previousRowSelected && row.aggregateRowBefore) {\n        previousRowSelected = false;\n      }\n      if (thisRowSelected && followingRowSelected && row.aggregateRowAfter) {\n        followingRowSelected = false;\n      }\n\n      // Note: We deliberately use the '+' operator on booleans here! That way, _all_ methods are executed (boolean\n      // operators might stop in between) and the variable classChanged contains a number > 1 (which is truthy) when\n      // at least one method call returned true.\n      var classChanged = 0 +\n        addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected, 'selected') +\n        addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && !previousRowSelected && followingRowSelected, 'select-top') +\n        addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && previousRowSelected && !followingRowSelected, 'select-bottom') +\n        addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && !previousRowSelected && !followingRowSelected, 'select-single') +\n        addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && previousRowSelected && followingRowSelected, 'select-middle');\n\n      if (classChanged && previousRowSelected && rows.indexOf(visibleRows[previousIndex]) === -1) {\n        rows.push(visibleRows[previousIndex]);\n      }\n      if (classChanged && followingRowSelected && rows.indexOf(visibleRows[followingIndex]) === -1) {\n        rows.push(visibleRows[followingIndex]);\n      }\n    }\n\n    // Make sure the cell editor popup is correctly layouted because selection changes the cell bounds\n    if (this.cellEditorPopup && this.cellEditorPopup.rendered && this.selectedRows.indexOf(this.cellEditorPopup.row) > -1) {\n      this.cellEditorPopup.position();\n      this.cellEditorPopup.pack();\n    }\n  }\n\n  _removeSelection() {\n    this.selectedRows.forEach(function(row) {\n      if (!row.$row) {\n        return;\n      }\n      row.$row.select(false);\n      row.$row.toggleClass(Table.SELECTION_CLASSES, false);\n    }, this);\n  }\n\n  addRowToSelection(row, ongoingSelection) {\n    if (this.selectedRows.indexOf(row) > -1) {\n      return;\n    }\n    ongoingSelection = ongoingSelection !== undefined ? ongoingSelection : true;\n    this.selectedRows.push(row);\n\n    if (row.$row && this._isDataRendered()) {\n      row.$row.select(true);\n      this._renderSelection(row);\n      if (this.scrollToSelection) {\n        this.revealSelection();\n      }\n    }\n\n    this._triggerRowsSelectedPending = true;\n    if (!ongoingSelection) {\n      this.notifyRowSelectionFinished();\n    }\n  }\n\n  removeRowFromSelection(row, ongoingSelection) {\n    ongoingSelection = ongoingSelection !== undefined ? ongoingSelection : true;\n    if (arrays.remove(this.selectedRows, row)) {\n      if (this._isDataRendered()) {\n        this._renderSelection(row);\n      }\n      if (!ongoingSelection) {\n        this._triggerRowsSelected();\n      } else {\n        this._triggerRowsSelectedPending = true;\n      }\n    }\n  }\n\n  selectRow(row, debounceSend) {\n    this.selectRows(row, debounceSend);\n  }\n\n  selectRows(rows, debounceSend) {\n    // Exclude rows that are currently not visible because of a filter (they cannot be selected)\n    rows = arrays.ensure(rows).filter(function(row) {\n      return Boolean(this.visibleRowsMap[row.id]);\n    }, this);\n\n    var selectedEqualRows = arrays.equalsIgnoreOrder(rows, this.selectedRows);\n    // TODO [7.0] cgu: maybe make sure selectedRows are in correct order, this would make logic in AbstractTableNavigationKeyStroke or renderSelection easier\n    // but requires some effort (remember rowIndex, keep array in order after sort, ... see java Table)\n    if (selectedEqualRows) {\n      return;\n    }\n\n    if (this._isDataRendered()) {\n      this._removeSelection();\n    }\n\n    if (!this.multiSelect && rows.length > 1) {\n      rows = [rows[0]];\n    }\n\n    this.selectedRows = rows; // (Note: direct assignment is safe because the initial filtering created a copy of the original array)\n    this._triggerRowsSelected(debounceSend);\n\n    this._updateMenuBar();\n    if (this._isDataRendered()) {\n      this._renderSelection();\n      if (this.scrollToSelection) {\n        this.revealSelection();\n      }\n    }\n  }\n\n  deselectRow(row) {\n    this.deselectRows(row);\n  }\n\n  deselectRows(rows) {\n    rows = arrays.ensure(rows);\n    var selectedRows = this.selectedRows.slice(); // copy\n    if (arrays.removeAll(selectedRows, rows)) {\n      this.selectRows(selectedRows);\n    }\n  }\n\n  isRowSelected(row) {\n    return this.selectedRows.indexOf(row) > -1;\n  }\n\n  _filterCount() {\n    return Object.keys(this._filterMap).length;\n  }\n\n  filteredRows() {\n    return this._filteredRows;\n  }\n\n  $rows(includeAggrRows) {\n    var selector = '.table-row';\n    if (includeAggrRows) {\n      selector += ', .table-aggregate-row';\n    }\n    return this.$data.find(selector);\n  }\n\n  $aggregateRows() {\n    return this.$data.find('.table-aggregate-row');\n  }\n\n  /**\n   * @returns {TableRow} the first selected row of this table or null when no row is selected\n   */\n  selectedRow() {\n    if (this.selectedRows.length > 0) {\n      return this.selectedRows[0];\n    }\n    return null;\n  }\n\n  $selectedRows() {\n    if (!this.$data) {\n      return $();\n    }\n    return this.$data.find('.selected');\n  }\n\n  $cellsForColIndex(colIndex, includeAggrRows) {\n    var selector = '.table-row > div:nth-of-type(' + colIndex + ')';\n    if (includeAggrRows) {\n      selector += ', .table-aggregate-row > div:nth-of-type(' + colIndex + ')';\n    }\n    return this.$data.find(selector);\n  }\n\n  $cellsForColIndexWidthFix(colIndex, includeAggrRows) {\n    var selector = '.table-row > div:nth-of-type(' + colIndex + ') > .width-fix ';\n    if (includeAggrRows) {\n      selector += ', .table-aggregate-row > div:nth-of-type(' + colIndex + ') > .width-fix';\n    }\n    return this.$data.find(selector);\n  }\n\n  $cellsForRow($row) {\n    return $row.children('.table-cell');\n  }\n\n  /**\n   * @param {Column|number} column or columnIndex\n   * @returns {$}\n   */\n  $cell(column, $row) {\n    var columnIndex = column;\n    if (typeof column !== 'number') {\n      columnIndex = this.visibleColumns().indexOf(column);\n    }\n    return $row.children('.table-cell').eq(columnIndex);\n  }\n\n  columnById(columnId) {\n    return arrays.find(this.columns, function(column) {\n      return column.id === columnId;\n    });\n  }\n\n  /**\n   * @param {$} $cell the $cell to get the column for\n   * @param {$} [$row] the $row which contains the $cell. If not passed it will be determined automatically\n   * @returns {Column} the column for the given $cell\n   */\n  columnFor$Cell($cell, $row) {\n    $row = $row || $cell.closest('.table-row');\n    var cellIndex = this.$cellsForRow($row).index($cell);\n    return this.visibleColumns()[cellIndex];\n  }\n\n  columnsByIds(columnIds) {\n    return columnIds.map(this.columnById.bind(this));\n  }\n\n  getVisibleRows() {\n    return this.visibleRows;\n  }\n\n  _updateRowStructure(options) {\n    var updateTree = scout.nvl(options.updateTree, false),\n      updateFilteredRows = scout.nvl(options.filteredRows, updateTree),\n      applyFilters = scout.nvl(options.applyFilters, updateFilteredRows),\n      updateVisibleRows = scout.nvl(options.visibleRows, updateFilteredRows);\n    if (updateTree) {\n      this._rebuildTreeStructure();\n    }\n    if (updateFilteredRows) {\n      this._updateFilteredRows(applyFilters);\n    }\n    if (updateVisibleRows) {\n      this._updateVisibleRows();\n    }\n  }\n\n  _rebuildTreeStructure() {\n    var hierarchical = false;\n    this.rows.forEach(function(row) {\n      row.childRows = [];\n      hierarchical = hierarchical || !objects.isNullOrUndefined(row.parentRow);\n    }, this);\n    if (!hierarchical) {\n      this.rootRows = this.rows;\n      this._setHierarchical(hierarchical);\n      return;\n    }\n\n    this._setHierarchical(hierarchical);\n    this.rootRows = [];\n    this.rows.forEach(function(row) {\n      var parentRow;\n      if (objects.isNullOrUndefined(row.parentRow)) {\n        // root row\n        row.parentRow = null;\n        row._parentRowId = null;\n        this.rootRows.push(row);\n        return;\n      }\n      if (!objects.isNullOrUndefined(row.parentRow.id)) {\n        parentRow = this.rowsMap[row.parentRow.id];\n      } else {\n        // expect id\n        parentRow = this.rowsMap[row.parentRow];\n      }\n      if (parentRow) {\n        row.parentRow = parentRow;\n        row._parentRowId = parentRow.id;\n        parentRow.childRows.push(row);\n      } else {\n        // do not allow unresolvable parent rows.\n        throw new Error('Parent row of ' + row + ' can not be resolved.');\n      }\n    }, this);\n\n    // traverse row tree to have minimal order of rows.\n    this._maxLevel = 0;\n    this.rows = [];\n    this.visitRows(function(row, level) {\n      row._hierarchyLevel = level;\n      this._maxLevel = Math.max(level, this._maxLevel);\n      this.rows.push(row);\n    }.bind(this));\n\n    this._calculateTableNodeColumn();\n  }\n\n  _updateFilteredRows(applyFilters, changed) {\n    changed = Boolean(changed);\n    applyFilters = scout.nvl(applyFilters, true);\n    this._filteredRows = this.rows.filter(function(row) {\n      if (applyFilters) {\n        changed = this._applyFiltersForRow(row) || changed;\n      }\n      return row.filterAccepted;\n    }, this);\n\n    if (changed) {\n      this._triggerFilter();\n    }\n  }\n\n  _updateVisibleRows() {\n    this.visibleRows = this._computeVisibleRows();\n    // rebuild the rows by id map of visible rows\n    this.visibleRowsMap = this.visibleRows.reduce(function(map, row) {\n      map[row.id] = row;\n      return map;\n    }, {});\n\n    if (this.initialized) {\n      // deselect not visible rows\n      this.deselectRows(this.selectedRows.filter(function(selectedRow) {\n        return !this.visibleRowsMap[selectedRow.id];\n      }, this));\n    }\n  }\n\n  _computeVisibleRows(rows) {\n    var visibleRows = [];\n    rows = rows || this.rootRows;\n    rows.forEach(function(row) {\n      var visibleChildRows = this._computeVisibleRows(row.childRows);\n      if (row.filterAccepted) {\n        visibleRows.push(row);\n      } else if (visibleChildRows.length > 0) {\n        visibleRows.push(row);\n      }\n      row._expandable = visibleChildRows.length > 0;\n      if (row.expanded) {\n        visibleRows = visibleRows.concat(visibleChildRows);\n      }\n    }, this);\n    return visibleRows;\n  }\n\n  visibleChildRows(row) {\n    return row.childRows.filter(function(child) {\n      return Boolean(this.visibleRowsMap[child.id]);\n    }, this);\n  }\n\n  _renderRowDelta() {\n    if (!this._isDataRendered()) {\n      return;\n    }\n    var renderedRows = [];\n    var rowsToHide = [];\n    this.$rows().each(function(i, elem) {\n      var $row = $(elem),\n        row = $row.data('row');\n      if (this.visibleRows.indexOf(row) < 0) {\n        // remember for remove animated\n        row.$row.detach();\n        rowsToHide.push(row);\n      } else {\n        renderedRows.push(row);\n      }\n    }.bind(this));\n\n    this._rerenderViewport();\n    // insert rows to remove animated\n    rowsToHide.forEach(function(row) {\n      row.$row.insertAfter(this.$fillBefore);\n    }, this);\n    // Rows removed by an animation are still there, new rows were appended -> reset correct row order\n    this._order$Rows().insertAfter(this.$fillBefore);\n    // Also make sure aggregate rows are at the correct position (_renderAggregateRows does nothing because they are already rendered)\n    this._order$AggregateRows();\n\n    rowsToHide.forEach(function(row) {\n      // remove animated\n      this._hideRow(row);\n    }, this);\n\n    this.$rows().each(function(i, elem) {\n      var $row = $(elem),\n        row = $row.data('row');\n      if ($row.hasClass('hiding')) {\n        // Do not remove rows which are removed using an animation\n        // row.$row may already point to a new row -> don't call removeRow to not accidentally remove the new row\n        return;\n      }\n      if (renderedRows.indexOf(row) < 0) {\n        this._showRow(row);\n      }\n    }.bind(this));\n    this._renderScrollTop();\n    this._renderEmptyData();\n  }\n\n  filter() {\n    this._updateRowStructure({\n      filteredRows: true\n    });\n    this._renderRowDelta();\n    this._group();\n    this.revealSelection();\n  }\n\n  /**\n   * Sorts the given $rows according to the row index\n   */\n  _order$Rows($rows) {\n    // Find rows using jquery because\n    // this.filteredRows() may be empty but there may be $rows which are getting removed by animation\n    $rows = $rows || this.$rows();\n    return $rows.sort(function(elem1, elem2) {\n      var $row1 = $(elem1),\n        $row2 = $(elem2),\n        row1 = $row1.data('row'),\n        row2 = $row2.data('row');\n\n      return this.rows.indexOf(row1) - this.rows.indexOf(row2);\n    }.bind(this));\n  }\n\n  _order$AggregateRows($rows) {\n    // Find aggregate rows using jquery because\n    // this._aggregateRows may be empty but there may be $aggregateRows which are getting removed by animation\n    $rows = $rows || this.$aggregateRows();\n    $rows.each(function(i, elem) {\n      var $aggrRow = $(elem),\n        aggregateRow = $aggrRow.data('aggregateRow');\n      if (!aggregateRow || !aggregateRow.prevRow) {\n        return;\n      }\n      $aggrRow.insertAfter(aggregateRow.prevRow.$row);\n    });\n  }\n\n  _rowAcceptedByFilters(row) {\n    for (var key in this._filterMap) { // NOSONAR\n      var filter = this._filterMap[key];\n      if (!filter.accept(row)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @returns {Boolean} true if row state has changed, false if not\n   */\n  _applyFiltersForRow(row) {\n    if (this._rowAcceptedByFilters(row)) {\n      if (!row.filterAccepted) {\n        row.filterAccepted = true;\n        return true;\n      }\n    } else if (row.filterAccepted) {\n      row.filterAccepted = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {String[]} labels of the currently active Filters that provide a createLabel() function\n   */\n  filteredBy() {\n    var filteredBy = [];\n    for (var key in this._filterMap) { // NOSONAR\n      var filter = this._filterMap[key];\n      // check if filter supports label\n      if (typeof filter.createLabel === 'function') {\n        filteredBy.push(filter.createLabel());\n      }\n    }\n    return filteredBy;\n  }\n\n  resetUserFilter() {\n    var filter;\n    for (var key in this._filterMap) { // NOSONAR\n      filter = this._filterMap[key];\n      if (filter instanceof TableUserFilter) {\n        this.removeFilterByKey(key);\n      }\n    }\n\n    // reset rows\n    this.filter();\n    this._triggerFilterReset();\n  }\n\n  hasUserFilter() {\n    return objects.values(this._filterMap)\n      .filter(function(filter) {\n        return filter instanceof TableUserFilter;\n      })\n      .length > 0;\n  }\n\n  resizeToFit(column, maxWidth) {\n    if (column.fixedWidth) {\n      return;\n    }\n    var returnValue = column.calculateOptimalWidth();\n    if (objects.isPlainObject(returnValue)) {\n      // Function returned a promise -> delay resizing\n      returnValue.always(this._resizeToFit.bind(this, column, maxWidth));\n    } else {\n      this._resizeToFit(column, maxWidth, returnValue);\n    }\n  }\n\n  _resizeToFit(column, maxWidth, calculatedSize) {\n    if (calculatedSize === -1) {\n      // Calculation has been aborted -> don't resize\n      return;\n    }\n    if (maxWidth && maxWidth > 0 && calculatedSize > maxWidth) {\n      calculatedSize = maxWidth;\n    }\n    if (Device.get().isInternetExplorer() && calculatedSize !== column.minWidth) {\n      calculatedSize++;\n    }\n    if (column.width !== calculatedSize) {\n      this.resizeColumn(column, calculatedSize);\n    }\n    column.autoOptimizeWidthRequired = false;\n    this._triggerColumnResizedToFit();\n  }\n\n  /**\n   * @param filter object with createKey() and accept()\n   */\n  addFilter(filter) {\n    var key = filter.createKey();\n    if (!key) {\n      throw new Error('key has to be defined');\n    }\n    this._filterMap[key] = filter;\n\n    this.trigger('filterAdded', {\n      filter: filter\n    });\n  }\n\n  removeFilter(filter) {\n    this.removeFilterByKey(filter.createKey());\n  }\n\n  removeFilterByKey(key) {\n    if (!key) {\n      throw new Error('key has to be defined');\n    }\n    var filter = this._filterMap[key];\n    if (!filter) {\n      return;\n    }\n    delete this._filterMap[key];\n    this.trigger('filterRemoved', {\n      filter: filter\n    });\n  }\n\n  getFilter(key) {\n    if (!key) {\n      throw new Error('key has to be defined');\n    }\n    return this._filterMap[key];\n  }\n\n  /**\n   * Resizes the given column to the new size.\n   *\n   * @param column\n   *          column to resize\n   * @param width\n   *          new column size\n   */\n  resizeColumn(column, width) {\n    if (column.fixedWidth) {\n      return;\n    }\n    width = Math.floor(width);\n    column.width = width;\n\n    var visibleColumnIndex = this.visibleColumns().indexOf(column);\n    if (visibleColumnIndex !== -1) {\n      var colNum = visibleColumnIndex + 1;\n      this.$cellsForColIndex(colNum, true)\n        .css('min-width', width)\n        .css('max-width', width);\n\n      this._updateRealColumnWidth(column);\n      this._updateRowWidth();\n      this.$rows(true)\n        .css('width', this.rowWidth);\n\n      // If resized column contains cells with wrapped text, view port needs to be updated\n      // Remove row height for non rendered rows because it may have changed due to resizing (wrap text)\n      this._updateRowHeights();\n      this._renderFiller();\n      this._renderViewport();\n      this.updateScrollbars();\n      this._renderEmptyData();\n    }\n\n    this._aggregateRows.forEach(function(aggregateRow) {\n      if (aggregateRow.$row) {\n        this._resizeCell(this.$cell(column, aggregateRow.$row));\n      }\n    }, this);\n\n    this._triggerColumnResized(column);\n  }\n\n  _resizeCell($cell) {\n    var $cellIcon = $cell.children('.table-cell-icon');\n    $cellIcon.setVisible(true);\n    if ($cell.isContentTruncated()) {\n      $cellIcon.setVisible(false);\n    }\n  }\n\n  moveColumn(column, visibleOldPos, visibleNewPos, dragged) {\n    // If there are fixed columns, don't allow moving the column onto the other side of the fixed columns\n    visibleNewPos = this._considerFixedPositionColumns(visibleOldPos, visibleNewPos);\n\n    // Translate position of 'visible columns' array to position in 'all columns' array\n    var visibleColumns = this.visibleColumns();\n    var newColumn = visibleColumns[visibleNewPos];\n    var newPos = this.columns.indexOf(newColumn);\n\n    arrays.remove(this.columns, column);\n    arrays.insert(this.columns, column, newPos);\n\n    visibleColumns = this.visibleColumns();\n    visibleNewPos = visibleColumns.indexOf(column); // we must re-evaluate visible columns\n    this._calculateTableNodeColumn();\n\n    this._triggerColumnMoved(column, visibleOldPos, visibleNewPos, dragged);\n\n    // move aggregated rows\n    this._aggregateRows.forEach(function(aggregateRow) {\n      arrays.move(aggregateRow.contents, visibleOldPos, visibleNewPos);\n    });\n\n    // move cells\n    if (this._isDataRendered()) {\n      this._rerenderViewport();\n    }\n  }\n\n  /**\n   * Ensures the given newPos does not pass a fixed column boundary (necessary when moving columns)\n   */\n  _considerFixedPositionColumns(visibleOldPos, visibleNewPos) {\n    var fixedColumnIndex = -1;\n    if (visibleNewPos > visibleOldPos) {\n      // move to right\n      fixedColumnIndex = arrays.findIndexFrom(this.visibleColumns(), visibleOldPos, function(col) {\n        return col.fixedPosition;\n      });\n      if (fixedColumnIndex > -1) {\n        visibleNewPos = Math.min(visibleNewPos, fixedColumnIndex - 1);\n      }\n    } else {\n      // move to left\n      fixedColumnIndex = arrays.findIndexFromReverse(this.visibleColumns(), visibleOldPos, function(col) {\n        return col.fixedPosition;\n      });\n      if (fixedColumnIndex > -1) {\n        visibleNewPos = Math.max(visibleNewPos, fixedColumnIndex + 1);\n      }\n    }\n    return visibleNewPos;\n  }\n\n  _renderColumnOrderChanges(oldColumnOrder) {\n    var column, i, j, $orderedCells, $cell, $cells, that = this,\n      $row;\n\n    if (this.header) {\n      this.header.onOrderChanged(oldColumnOrder);\n    }\n\n    // move cells\n    this.$rows(true).each(function() {\n      $row = $(this);\n      $orderedCells = $();\n      $cells = $row.children();\n      for (i = 0; i < that.columns.length; i++) {\n        column = that.columns[i];\n\n        // Find $cell for given column\n        for (j = 0; j < oldColumnOrder.length; j++) {\n          if (oldColumnOrder[j] === column) {\n            $cell = $cells[j];\n            break;\n          }\n        }\n        $orderedCells.push($cell);\n      }\n      $row.prepend($orderedCells);\n    });\n  }\n\n  _triggerRowsInserted(rows) {\n    this.trigger('rowsInserted', {\n      rows: rows\n    });\n  }\n\n  _triggerRowsDeleted(rows) {\n    this.trigger('rowsDeleted', {\n      rows: rows\n    });\n  }\n\n  _triggerRowsUpdated(rows) {\n    this.trigger('rowsUpdated', {\n      rows: rows\n    });\n  }\n\n  _triggerAllRowsDeleted(rows) {\n    this.trigger('allRowsDeleted', {\n      rows: rows\n    });\n  }\n\n  _triggerRowsSelected(debounce) {\n    this.trigger('rowsSelected', {\n      debounce: debounce\n    });\n  }\n\n  _triggerRowsChecked(rows) {\n    this.trigger('rowsChecked', {\n      rows: rows\n    });\n  }\n\n  _triggerRowsExpanded(rows) {\n    this.trigger('rowsExpanded', {\n      rows: rows\n    });\n  }\n\n  _triggerFilter() {\n    this.trigger('filter');\n  }\n\n  _triggerFilterReset() {\n    this.trigger('filterReset');\n  }\n\n  _triggerAppLinkAction(column, ref) {\n    this.trigger('appLinkAction', {\n      column: column,\n      ref: ref\n    });\n  }\n\n  _triggerReload(reloadReason) {\n    this.trigger('reload', {\n      reloadReason: reloadReason\n    });\n  }\n\n  _triggerClipboardExport() {\n    var event = new Event();\n    this.trigger('clipboardExport', event);\n    if (!event.defaultPrevented) {\n      this._exportToClipboard();\n    }\n  }\n\n  _triggerRowOrderChanged(row, animating) {\n    var event = {\n      row: row,\n      animating: animating\n    };\n    this.trigger('rowOrderChanged', event);\n  }\n\n  _triggerColumnResized(column) {\n    var event = {\n      column: column\n    };\n    this.trigger('columnResized', event);\n  }\n\n  _triggerColumnResizedToFit(column) {\n    var event = {\n      column: column\n    };\n    this.trigger('columnResizedToFit', event);\n  }\n\n  _triggerColumnMoved(column, oldPos, newPos, dragged) {\n    var event = {\n      column: column,\n      oldPos: oldPos,\n      newPos: newPos,\n      dragged: dragged\n    };\n    this.trigger('columnMoved', event);\n  }\n\n  _triggerAggregationFunctionChanged(column) {\n    var event = {\n      column: column\n    };\n    this.trigger('aggregationFunctionChanged', event);\n  }\n\n  setHeaderVisible(visible) {\n    this.setProperty('headerVisible', visible);\n  }\n\n  _renderHeaderVisible() {\n    this._renderTableHeader();\n  }\n\n  setHeaderEnabled(headerEnabled) {\n    this.setProperty('headerEnabled', headerEnabled);\n  }\n\n  _renderHeaderEnabled() {\n    // Rebuild the table header when this property changes\n    this._removeTableHeader();\n    this._renderTableHeader();\n  }\n\n  setHeaderMenusEnabled(headerMenusEnabled) {\n    this.setProperty('headerMenusEnabled', headerMenusEnabled);\n    if (this.header) {\n      this.header.setHeaderMenusEnabled(this.headerMenusEnabled);\n    }\n  }\n\n  hasPermanentHeadOrTailSortColumns() {\n    return this._permanentHeadSortColumns.length !== 0 || this._permanentTailSortColumns.length !== 0;\n  }\n\n  _setHeadAndTailSortColumns() {\n    // find all sort columns (head and tail sort columns should always be included)\n    var sortColumns = this.columns.filter(function(c) {\n      return c.sortIndex >= 0;\n    });\n    sortColumns.sort(function(a, b) {\n      return a.sortIndex - b.sortIndex;\n    });\n\n    this._permanentHeadSortColumns = [];\n    this._permanentTailSortColumns = [];\n\n    sortColumns.forEach(function(c) {\n      if (c.initialAlwaysIncludeSortAtBegin) {\n        this._permanentHeadSortColumns.push(c);\n      } else if (c.initialAlwaysIncludeSortAtEnd) {\n        this._permanentTailSortColumns.push(c);\n      }\n    }, this);\n  }\n\n  setTileMode(tileMode) {\n    this.setProperty('tileMode', tileMode);\n  }\n\n  _setTileMode(tileMode) {\n    if (tileMode) {\n      this._ensureMediator();\n      if (!this.tileTableHeader) {\n        this._setTileTableHeader(this._createTileTableHeader());\n      }\n      this.tableTileGridMediator.loadTiles();\n      this.tableTileGridMediator.activate();\n    }\n    this._setProperty('tileMode', tileMode);\n\n    if (!tileMode && this.tableTileGridMediator) {\n      this.tableTileGridMediator.deactivate();\n    }\n  }\n\n  _ensureMediator() {\n    if (!this.tableTileGridMediator) {\n      this.tableTileGridMediator = scout.create('TableTileGridMediator', {\n        parent: this,\n        gridColumnCount: 6\n      });\n    }\n  }\n\n  _renderTileMode() {\n    if (this.tableTileGridMediator) {\n      this.tableTileGridMediator.renderTileMode();\n    }\n  }\n\n  createTiles(rows) {\n    return rows.map(function(row) {\n      var tile = this.createTileForRow(row);\n      this._adaptTile(tile);\n      tile.rowId = row.id;\n      return tile;\n    }, this);\n  }\n\n  _adaptTile(tile) {\n    tile.gridDataHints = {\n      weightX: 0\n    };\n  }\n\n  createTileForRow(row) {\n    throw new Error('Not implemented');\n  }\n\n  _setTileTableHeader(tileTableHeader) {\n    if (tileTableHeader) {\n      tileTableHeader.addCssClass('tile-table-header');\n    }\n    this._setProperty('tileTableHeader', tileTableHeader);\n  }\n\n  _createTileTableHeader() {\n    return scout.create('TileTableHeaderBox', {\n      parent: this\n    });\n  }\n\n  setRowIconVisible(rowIconVisible) {\n    this.setProperty('rowIconVisible', rowIconVisible);\n  }\n\n  _setRowIconVisible(rowIconVisible) {\n    this._setProperty('rowIconVisible', rowIconVisible);\n    var column = this.rowIconColumn;\n    if (this.rowIconVisible && !column) {\n      this._insertRowIconColumn();\n      this._calculateTableNodeColumn();\n      this.trigger('columnStructureChanged');\n    } else if (!this.rowIconVisible && column) {\n      arrays.remove(this.columns, column);\n      this.rowIconColumn = null;\n      this._calculateTableNodeColumn();\n      this.trigger('columnStructureChanged');\n    }\n  }\n\n  setRowIconColumnWidth(width) {\n    this.setProperty('rowIconColumnWidth', width);\n  }\n\n  _setRowIconColumnWidth(width) {\n    this._setProperty('rowIconColumnWidth', width);\n    var column = this.rowIconColumn;\n    if (column) {\n      column.width = width;\n    }\n  }\n\n  _setSelectedRows(selectedRows) {\n    if (typeof selectedRows[0] === 'string') {\n      selectedRows = this._rowsByIds(selectedRows);\n    }\n    this._setProperty('selectedRows', selectedRows);\n  }\n\n  setMenus(menus) {\n    this.setProperty('menus', menus);\n  }\n\n  _setMenus(menus, oldMenus) {\n    this.updateKeyStrokes(menus, oldMenus);\n    this._setProperty('menus', menus);\n    this._updateMenuBar();\n\n    if (this.header) {\n      this.header.updateMenuBar();\n    }\n  }\n\n  setMenuBarVisible(visible) {\n    this.setProperty('menuBarVisible', visible);\n  }\n\n  _setMenuBarVisible(visible) {\n    this._setProperty('menuBarVisible', visible);\n    this._updateMenuBar();\n  }\n\n  _renderMenuBarVisible() {\n    if (this.menuBarVisible) {\n      this.menuBar.render();\n      this._refreshMenuBarPosition();\n    } else {\n      this.menuBar.remove();\n    }\n    this._updateMenuBar();\n    this.invalidateLayoutTree();\n  }\n\n  _refreshMenuBarPosition() {\n    if (this.menuBarVisible && this.menuBar.rendered) {\n      if (this.menuBar.position === MenuBar.Position.TOP) {\n        this.menuBar.$container.prependTo(this.$container);\n      } else {\n        this.menuBar.$container.appendTo(this.$container);\n      }\n    }\n  }\n\n  _createMenuBar() {\n    return scout.create('MenuBar', {\n      parent: this,\n      position: MenuBar.Position.BOTTOM,\n      menuOrder: new MenuItemsOrder(this.session, 'Table'),\n      menuFilter: this._filterMenusHandler\n    });\n  }\n\n  _updateMenuBar() {\n    if (this.menuBarVisible) {\n      // Do not update menuBar while it is invisible, the menus may now be managed by another widget.\n      // -> this makes sure the parent is not accidentally set to the table, the other widget should remain responsible\n      var notAllowedTypes = ['Header'];\n      var menuItems = this._filterMenus(this.menus, MenuDestinations.MENU_BAR, false, true, notAllowedTypes);\n      menuItems = this.staticMenus.concat(menuItems);\n      this.menuBar.setMenuItems(menuItems);\n    }\n    if (this.contextMenu) {\n      var contextMenuItems = this._filterMenus(this.menus, MenuDestinations.CONTEXT_MENU, true, false, ['Header']);\n      this.contextMenu.updateMenuItems(contextMenuItems);\n    }\n  }\n\n  _setKeyStrokes(keyStrokes) {\n    this.updateKeyStrokes(keyStrokes, this.keyStrokes);\n    this._setProperty('keyStrokes', keyStrokes);\n  }\n\n  setFilters(filters) {\n    var filter;\n    for (var key in this._filterMap) { // NOSONAR\n      filter = this._filterMap[key];\n      if (filter instanceof TableUserFilter) {\n        this.removeFilterByKey(key);\n      }\n    }\n    if (filters) {\n      filters.forEach(function(filter) {\n        filter = this._ensureFilter(filter);\n        this.addFilter(filter);\n      }, this);\n    }\n  }\n\n  _ensureFilter(filter) {\n    if (filter instanceof TableUserFilter) {\n      return filter;\n    }\n    if (filter.column) {\n      filter.column = this.columnById(filter.column);\n    }\n    filter.table = this;\n    filter.session = this.session;\n    return scout.create(filter);\n  }\n\n  setTableStatus(status) {\n    this.setProperty('tableStatus', status);\n  }\n\n  _setTableStatus(status) {\n    status = Status.ensure(status);\n    this._setProperty('tableStatus', status);\n  }\n\n  setTableStatusVisible(visible) {\n    this.setProperty('tableStatusVisible', visible);\n    this._updateFooterVisibility();\n  }\n\n  _updateFooterVisibility() {\n    this.setFooterVisible(this.tableStatusVisible || this._hasVisibleTableControls());\n  }\n\n  setHierarchicalStyle(style) {\n    this.setProperty('hierarchicalStyle', style);\n  }\n\n  _renderHierarchicalStyle() {\n    this.$container.toggleClass('structured', Table.HierarchicalStyle.STRUCTURED === this.hierarchicalStyle);\n  }\n\n  setFooterVisible(visible) {\n    this._setProperty('footerVisible', visible);\n    if (visible && !this.footer) {\n      this.footer = this._createFooter();\n    }\n\n    // relink table controls to new footer\n    this.tableControls.forEach(function(control) {\n      control.tableFooter = this.footer;\n    }, this);\n\n    if (this.rendered) {\n      this._renderFooterVisible();\n    }\n    if (!visible && this.footer) {\n      this.footer.destroy();\n      this.footer = null;\n    }\n  }\n\n  /**\n   * Renders the background effect of every column, if column.backgroundEffect is set\n   */\n  _renderBackgroundEffect() {\n    this.columns.forEach(function(column) {\n      if (!column.backgroundEffect) {\n        return;\n      }\n      column._renderBackgroundEffect();\n    }, this);\n  }\n\n  _renderRowChecked(row) {\n    if (!this.checkable) {\n      return;\n    }\n    if (!row.$row) {\n      return;\n    }\n    var $styleElem;\n    if (this.checkableStyle === Table.CheckableStyle.TABLE_ROW) {\n      $styleElem = row.$row;\n    } else {\n      if (!this.checkableColumn) {\n        throw new Error('checkableColumn not set');\n      }\n      $styleElem = this.checkableColumn.$checkBox(row.$row);\n    }\n    $styleElem.toggleClass('checked', row.checked);\n  }\n\n  setCheckable(checkable) {\n    this.setProperty('checkable', checkable);\n  }\n\n  _setCheckable(checkable) {\n    this._setProperty('checkable', checkable);\n    this._updateCheckableColumn();\n  }\n\n  _updateCheckableColumn() {\n    var column = this.checkableColumn;\n    var showCheckBoxes = this.checkable && scout.isOneOf(this.checkableStyle, Table.CheckableStyle.CHECKBOX, Table.CheckableStyle.CHECKBOX_TABLE_ROW);\n    if (showCheckBoxes && !column) {\n      this._insertBooleanColumn();\n      this._calculateTableNodeColumn();\n      this.trigger('columnStructureChanged');\n    } else if (!showCheckBoxes && column && column.guiOnly) {\n      arrays.remove(this.columns, column);\n      this.checkableColumn = null;\n      this._calculateTableNodeColumn();\n      this.trigger('columnStructureChanged');\n    }\n  }\n\n  _renderCheckable() {\n    this.columnLayoutDirty = true;\n    this._updateRowWidth();\n    this._redraw();\n    this.invalidateLayoutTree();\n  }\n\n  setCheckableStyle(checkableStyle) {\n    this.setProperty('checkableStyle', checkableStyle);\n  }\n\n  _setCheckableStyle(checkableStyle) {\n    this._setProperty('checkableStyle', checkableStyle);\n    this._updateCheckableColumn();\n  }\n\n  _renderCheckableStyle() {\n    this.$container.toggleClass('checkable', scout.isOneOf(this.checkableStyle, Table.CheckableStyle.TABLE_ROW, Table.CheckableStyle.CHECKBOX_TABLE_ROW));\n    this.$container.toggleClass('table-row-check', this.checkableStyle === Table.CheckableStyle.TABLE_ROW);\n    if (this._isDataRendered()) {\n      this._redraw();\n    }\n  }\n\n  _renderRowIconVisible() {\n    this.columnLayoutDirty = true;\n    this._updateRowWidth();\n    this._redraw();\n    this.invalidateLayoutTree();\n  }\n\n  _renderRowIconColumnWidth() {\n    if (!this.rowIconVisible) {\n      return;\n    }\n    this._renderRowIconVisible();\n  }\n\n  setGroupingStyle(groupingStyle) {\n    this.setProperty('groupingStyle', groupingStyle);\n  }\n\n  _setGroupingStyle(groupingStyle) {\n    this._setProperty('groupingStyle', groupingStyle);\n    this._group();\n  }\n\n  _renderGroupingStyle() {\n    this._rerenderViewport();\n  }\n\n  _redraw() {\n    if (this._isDataRendered()) {\n      this._rerenderHeaderColumns();\n      this._rerenderViewport();\n    }\n  }\n\n  _rerenderHeaderColumns() {\n    if (this.header) {\n      this.header.rerenderColumns();\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _renderTableHeader() {\n    if (this.tileMode) {\n      return;\n    }\n    var changed = false;\n    if (this.headerVisible && !this.header) {\n      this.header = this._createHeader();\n      this.header.render();\n      this._renderEmptyData();\n      changed = true;\n    } else if (!this.headerVisible && this.header) {\n      this._removeTableHeader();\n      this._removeEmptyData();\n      changed = true;\n    }\n    this.$container.toggleClass('header-invisible', !this.header);\n    if (changed) {\n      this.invalidateLayoutTree();\n    }\n  }\n\n  _removeTableHeader() {\n    if (this.header) {\n      this.header.destroy();\n      this.header = null;\n    }\n  }\n\n  /**\n   * @param width optional width of emptyData, if omitted the width is set to the header's scrollWidth.\n   */\n  _renderEmptyData() {\n    if (!this.header || this.visibleRows.length > 0) {\n      return;\n    }\n    if (!this.$emptyData) {\n      this.$emptyData = this.$data.appendDiv().html('&nbsp;');\n    }\n    this.$emptyData\n      .css('min-width', this.rowWidth)\n      .css('max-width', this.rowWidth);\n    this.updateScrollbars();\n  }\n\n  _removeEmptyData() {\n    if (this.header && this.visibleRows.length === 0) {\n      return;\n    }\n    if (this.$emptyData) {\n      this.$emptyData.remove();\n      this.$emptyData = null;\n      this.updateScrollbars();\n    }\n  }\n\n  _renderFooterVisible() {\n    if (!this.footer) {\n      return;\n    }\n    if (this.footerVisible) {\n      this._renderFooter();\n    } else {\n      this._removeFooter();\n    }\n    this.invalidateLayoutTree();\n  }\n\n  _renderFooter() {\n    if (this.footer.rendered) {\n      return;\n    }\n\n    this.footer.render();\n  }\n\n  _removeFooter() {\n    if (!this.footer.rendered) {\n      return;\n    }\n    this.footer.remove();\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _renderEnabled() {\n    super._renderEnabled();\n\n    var enabled = this.enabledComputed;\n    if (!this.tileMode) {\n      this.$data.setEnabled(enabled);\n    }\n\n    this.$container.setTabbable(enabled);\n\n    if (this._isDataRendered()) {\n      // Enable/disable all checkboxes\n      this.$rows().each(function() {\n        var $row = $(this),\n          row = $row.data('row');\n        $row.find('input').setEnabled(enabled && row.enabled);\n      });\n    }\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _renderDisabledStyle() {\n    super._renderDisabledStyle();\n    this._renderDisabledStyleInternal(this.$data);\n  }\n\n  setAutoResizeColumns(autoResizeColumns) {\n    this.setProperty('autoResizeColumns', autoResizeColumns);\n  }\n\n  _renderAutoResizeColumns() {\n    if (!this.autoResizeColumns && Device.get().hasTableCellZoomBug()) {\n      // Clear real width so that row width is updated correctly by the table layout if autoResizeColumns is disabled on the fly\n      this.visibleColumns().forEach(function(column, colIndex) {\n        column._realWidth = null;\n      });\n    }\n    this.columnLayoutDirty = true;\n    this.invalidateLayoutTree();\n  }\n\n  setMultilineText(multilineText) {\n    this.setProperty('multilineText', multilineText);\n  }\n\n  _renderMultilineText() {\n    this._markAutoOptimizeWidthColumnsAsDirty();\n    this._redraw();\n    this.invalidateLayoutTree();\n  }\n\n  _renderDropType() {\n    if (this.dropType) {\n      this._installDragAndDropHandler();\n    } else {\n      this._uninstallDragAndDropHandler();\n    }\n  }\n\n  _installDragAndDropHandler(event) {\n    if (this.dragAndDropHandler) {\n      return;\n    }\n    this.dragAndDropHandler = dragAndDrop.handler(this, {\n      supportedScoutTypes: dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,\n      dropType: function() {\n        return this.dropType;\n      }.bind(this),\n      dropMaximumSize: function() {\n        return this.dropMaximumSize;\n      }.bind(this),\n      additionalDropProperties: function(event) {\n        var $target = $(event.currentTarget);\n        var properties = {\n          rowId: ''\n        };\n        if ($target.hasClass('table-row')) {\n          var row = $target.data('row');\n          properties.rowId = row.id;\n        }\n        return properties;\n      }\n    });\n    this.dragAndDropHandler.install(this.$container, '.table-data,.table-row');\n  }\n\n  _uninstallDragAndDropHandler(event) {\n    if (!this.dragAndDropHandler) {\n      return;\n    }\n    this.dragAndDropHandler.uninstall();\n    this.dragAndDropHandler = null;\n  }\n\n  /**\n   * This listener is used to invalidate table layout when an image icon has been loaded (which happens async in the browser).\n   */\n  _installImageListeners() {\n    this._imageLoadListener = this._onImageLoadOrError.bind(this);\n    // Image events don't bubble -> use capture phase instead\n    this.$data[0].addEventListener('load', this._imageLoadListener, true);\n    this.$data[0].addEventListener('error', this._imageLoadListener, true);\n  }\n\n  _uninstallImageListeners() {\n    this.$data[0].removeEventListener('load', this._imageLoadListener, true);\n    this.$data[0].removeEventListener('error', this._imageLoadListener, true);\n  }\n\n  /**\n   * Calculates the optimal view range size (number of rows to be rendered).\n   * It uses the default row height to estimate how many rows fit in the view port.\n   * The view range size is this value * 2.\n   */\n  calculateViewRangeSize() {\n    // Make sure row height is up to date (row height may be different after zooming)\n    this._updateRowHeight();\n\n    if (this.rowHeight === 0) {\n      throw new Error('Cannot calculate view range with rowHeight = 0');\n    }\n    return Math.ceil(this.$data.outerHeight() / this.rowHeight) * 2;\n  }\n\n  setViewRangeSize(viewRangeSize) {\n    if (this.viewRangeSize === viewRangeSize) {\n      return;\n    }\n    this._setProperty('viewRangeSize', viewRangeSize);\n    if (this._isDataRendered()) {\n      this._renderViewport();\n    }\n  }\n\n  _calculateCurrentViewRange() {\n    var rowIndex,\n      scrollTop = this.$data[0].scrollTop,\n      maxScrollTop = this.$data[0].scrollHeight - this.$data[0].clientHeight;\n\n    if (maxScrollTop === 0) {\n      // no scrollbars visible\n      rowIndex = 0;\n    } else {\n      rowIndex = this._rowIndexAtScrollTop(scrollTop);\n    }\n\n    return this._calculateViewRangeForRowIndex(rowIndex);\n  }\n\n  /**\n   * Returns the index of the row which is at position scrollTop.\n   */\n  _rowIndexAtScrollTop(scrollTop) {\n    var height = 0,\n      index = -1;\n    this.visibleRows.some(function(row, i) {\n      height += this._heightForRow(row);\n      if (scrollTop < height) {\n        index = i;\n        return true;\n      }\n    }.bind(this));\n    return index;\n  }\n\n  _heightForRow(row) {\n    var height = 0,\n      aggregateRow = row.aggregateRowAfter;\n\n    if (row.height) {\n      height = row.height;\n    } else {\n      height = this.rowHeight;\n    }\n\n    // Add height of aggregate row as well\n    if (aggregateRow) {\n      if (aggregateRow.height) {\n        height += aggregateRow.height;\n      } else {\n        height += this.aggregateRowHeight;\n      }\n    }\n\n    return height;\n  }\n\n  /**\n   * Returns a range of size this.viewRangeSize. Start of range is rowIndex - viewRangeSize / 4.\n   * -> 1/4 of the rows are before the viewport 2/4 in the viewport 1/4 after the viewport,\n   * assuming viewRangeSize is 2*number of possible rows in the viewport (see calculateViewRangeSize).\n   */\n  _calculateViewRangeForRowIndex(rowIndex) {\n    // regular / non-virtual scrolling? -> all rows are already rendered in the DOM\n    if (!this.virtual) {\n      return new Range(0, this.visibleRows.length);\n    }\n\n    var viewRange = new Range(),\n      quarterRange = Math.floor(this.viewRangeSize / 4),\n      diff;\n\n    viewRange.from = Math.max(rowIndex - quarterRange, 0);\n    viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.visibleRows.length);\n\n    // Try to use the whole viewRangeSize (extend from if necessary)\n    diff = this.viewRangeSize - viewRange.size();\n    if (diff > 0) {\n      viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);\n    }\n    return viewRange;\n  }\n\n  /**\n   * Calculates and renders the rows which should be visible in the current viewport based on scroll top.\n   */\n  _renderViewport() {\n    if (!this.isAttachedAndRendered()) {\n      // if table is not attached the correct viewPort can not be evaluated. Mark for render after attach.\n      this._renderViewPortAfterAttach = true;\n      return;\n    }\n    if (this._renderViewportBlocked) {\n      return;\n    }\n    if (this.visibleColumns().length === 0) {\n      return;\n    }\n    if (!this.$container.isEveryParentVisible()) {\n      // If the table is invisible, the height of the rows cannot be determined.\n      // In that case, the table won't be layouted either -> as soon as it will be layouted, renderViewport will be called again\n      this.invalidateLayoutTree();\n      return;\n    }\n    var viewRange = this._calculateCurrentViewRange();\n    this._renderViewRange(viewRange);\n  }\n\n  _rerenderViewport() {\n    if (!this.isAttachedAndRendered()) {\n      // if table is not attached the correct viewPort can not be evaluated. Mark for rerender after attach.\n      this._rerenderViewPortAfterAttach = true;\n      return;\n    }\n    this._removeRows();\n    this._removeAggregateRows();\n    this._renderFiller();\n    this._renderViewport();\n  }\n\n  _renderViewRangeForRowIndex(rowIndex) {\n    var viewRange = this._calculateViewRangeForRowIndex(rowIndex);\n    this._renderViewRange(viewRange);\n  }\n\n  /**\n   * Renders the rows visible in the viewport and removes the other rows\n   */\n  _renderViewRange(viewRange) {\n    if (viewRange.from === this.viewRangeRendered.from && viewRange.to === this.viewRangeRendered.to && !this.viewRangeDirty) {\n      // Range already rendered -> do nothing\n      return;\n    }\n    this._removeRangeMarkers();\n    var rangesToRender = viewRange.subtract(this.viewRangeRendered);\n    var rangesToRemove = this.viewRangeRendered.subtract(viewRange);\n    rangesToRemove.forEach(function(range) {\n      this._removeRowsInRange(range);\n    }.bind(this));\n    rangesToRender.forEach(function(range) {\n      this._renderRowsInRange(range);\n    }.bind(this));\n\n    // check if at least last and first row in range got correctly rendered\n    if (this.viewRangeRendered.size() > 0) {\n      var rows = this.visibleRows;\n      var firstRow = rows[this.viewRangeRendered.from];\n      var lastRow = rows[this.viewRangeRendered.to - 1];\n      if (!firstRow.$row || !lastRow.$row) {\n        throw new Error('Rows not rendered as expected. ' + this.viewRangeRendered + '. First: ' + firstRow.$row + '. Last: ' + lastRow.$row);\n      }\n    }\n\n    this._renderRangeMarkers();\n    this._removeAggregateRows();\n    this._renderAggregateRows();\n    this._renderFiller();\n    this._renderEmptyData();\n    this._renderBackgroundEffect();\n    this._renderSelection();\n    this.viewRangeDirty = false;\n  }\n\n  _removeRangeMarkers() {\n    this._modifyRangeMarkers('removeClass');\n  }\n\n  _renderRangeMarkers() {\n    this._modifyRangeMarkers('addClass');\n  }\n\n  _modifyRangeMarkers(funcName) {\n    if (this.viewRangeRendered.size() === 0) {\n      return;\n    }\n    var visibleRows = this.visibleRows;\n    modifyRangeMarker(visibleRows[this.viewRangeRendered.from], 'first');\n    modifyRangeMarker(visibleRows[this.viewRangeRendered.to - 1], 'last');\n\n    function modifyRangeMarker(row, cssClass) {\n      if (row && row.$row) {\n        row.$row[funcName](cssClass);\n      }\n    }\n  }\n\n  /**\n   * Renders the view range that contains the given row.<br>\n   * Does nothing if the row is already rendered or not visible (e.g. due to filtering).\n   * @param {TableRow} row\n   */\n  ensureRowRendered(row) {\n    if (row.$row) {\n      return;\n    }\n    let rowIndex = this.visibleRows.indexOf(row);\n    if (rowIndex < 0) {\n      return;\n    }\n    this._renderViewRangeForRowIndex(rowIndex);\n  }\n\n  _renderFiller() {\n    if (!this.$fillBefore) {\n      this.$fillBefore = this.$data.prependDiv('table-data-fill');\n      this._applyFillerStyle(this.$fillBefore);\n    }\n\n    var fillBeforeHeight = this._calculateFillerHeight(new Range(0, this.viewRangeRendered.from));\n    this.$fillBefore.cssHeight(fillBeforeHeight);\n    this.$fillBefore.cssWidth(this.rowWidth);\n    $.log.isTraceEnabled() && $.log.trace('FillBefore height: ' + fillBeforeHeight);\n\n    if (!this.$fillAfter) {\n      this.$fillAfter = this.$data.appendDiv('table-data-fill');\n      this._applyFillerStyle(this.$fillAfter);\n    }\n\n    var fillAfterHeight = this._calculateFillerHeight(new Range(this.viewRangeRendered.to, this.visibleRows.length));\n    this.$fillAfter.cssHeight(fillAfterHeight);\n    this.$fillAfter.cssWidth(this.rowWidth);\n    $.log.isTraceEnabled() && $.log.trace('FillAfter height: ' + fillAfterHeight);\n  }\n\n  _applyFillerStyle($filler) {\n    var lineColor = $filler.css('background-color');\n    // In order to get a 1px border we need to get the right value in percentage for the linear gradient\n    var lineWidth = ((1 - 1 / this.rowHeight) * 100).toFixed(2) + '%';\n    $filler.css({\n      background: 'linear-gradient(to bottom, transparent, transparent ' + lineWidth + ', ' + lineColor + ' ' + lineWidth + ', ' + lineColor + ')',\n      backgroundSize: '100% ' + this.rowHeight + 'px',\n      backgroundColor: 'transparent'\n    });\n  }\n\n  _calculateFillerHeight(range) {\n    var totalHeight = 0;\n    for (var i = range.from; i < range.to; i++) {\n      var row = this.visibleRows[i];\n      totalHeight += this._heightForRow(row);\n    }\n    return totalHeight;\n  }\n\n  containsAggregatedNumberColumn() {\n    if (!this.initialized) {\n      return false;\n    }\n    return this.visibleColumns().some(function(column) {\n      return column instanceof NumberColumn && column.aggregationFunction !== 'none';\n    });\n  }\n\n  /**\n   * Rebuilds the header.<br>\n   * Does not modify the rows, it expects a deleteAll and insert operation to follow which will do the job.\n   */\n  updateColumnStructure(columns) {\n    this._destroyColumns();\n    this.columns = columns;\n    this._initColumns();\n\n    if (this._isDataRendered()) {\n      this._updateRowWidth();\n      this.$rows(true).css('width', this.rowWidth);\n      this._rerenderHeaderColumns();\n      this._renderEmptyData();\n    }\n    this.trigger('columnStructureChanged');\n  }\n\n  updateColumnOrder(columns) {\n    var i, column, currentPosition, oldColumnOrder;\n    if (columns.length !== this.columns.length) {\n      throw new Error('Column order may not be updated because lengths of the arrays differ.');\n    }\n\n    oldColumnOrder = this.columns.slice();\n\n    for (i = 0; i < columns.length; i++) {\n      column = columns[i];\n      currentPosition = this.columns.indexOf(column);\n      if (currentPosition < 0) {\n        throw new Error('Column with id ' + column.id + 'not found.');\n      }\n\n      if (currentPosition !== i) {\n        // Update model\n        arrays.remove(this.columns, column);\n        arrays.insert(this.columns, column, i);\n      }\n    }\n\n    if (this._isDataRendered()) {\n      this._renderColumnOrderChanges(oldColumnOrder);\n    }\n  }\n\n  /**\n   * @param columns array of columns which were updated.\n   */\n  updateColumnHeaders(columns) {\n    var column, oldColumnState;\n\n    // Update model columns\n    for (var i = 0; i < columns.length; i++) {\n      column = this.columnById(columns[i].id);\n      oldColumnState = $.extend(oldColumnState, column);\n      column.text = columns[i].text;\n      column.headerTooltipText = columns[i].headerTooltipText;\n      column.headerTooltipHtmlEnabled = columns[i].headerTooltipHtmlEnabled;\n      column.headerCssClass = columns[i].headerCssClass;\n      column.headerHtmlEnabled = columns[i].headerHtmlEnabled;\n      column.headerBackgroundColor = columns[i].headerBackgroundColor;\n      column.headerForegroundColor = columns[i].headerForegroundColor;\n      column.headerFont = columns[i].headerFont;\n      column.headerIconId = columns[i].headerIconId;\n      column.sortActive = columns[i].sortActive;\n      column.sortAscending = columns[i].sortAscending;\n      if (column.grouped && !columns[i].grouped) {\n        this._removeGroupColumn(column);\n      }\n      column.grouped = columns[i].grouped;\n      if (!column.sortActive && column.sortIndex !== -1) {\n        // Adjust indices of other sort columns (if a sort column in the middle got removed, there won't necessarily be an event for the other columns)\n        this._removeSortColumn(column);\n      } else if (column.grouped && column.sortActive && column.sortIndex === -1) {\n        this._addGroupColumn(column);\n      } else if (column.sortActive && column.sortIndex === -1) {\n        // Necessary if there is a tail sort column (there won't be an event for the tail sort column if another sort column was added before)\n        this._addSortColumn(column);\n      } else {\n        column.sortIndex = columns[i].sortIndex;\n      }\n\n      if (this._isDataRendered() && this.header) {\n        this.header.updateHeader(column, oldColumnState);\n      }\n    }\n  }\n\n  focusCell(column, row) {\n    if (!this._isDataRendered() || !this.isAttachedAndRendered()) {\n      this._postRenderActions.push(this.focusCell.bind(this, column, row));\n      return;\n    }\n\n    var cell = this.cell(column, row);\n    if (this.enabledComputed && row.enabled && cell.editable) {\n      this.prepareCellEdit(column, row, false);\n    }\n  }\n\n  _attach() {\n    this.$parent.append(this.$container);\n    super._attach();\n  }\n\n  /**\n   * Method invoked when this is a 'detailTable' and the outline content is displayed.\n   * @override Widget.js\n   */\n  _postAttach() {\n    var htmlParent = this.htmlComp.getParent();\n    this.htmlComp.setSize(htmlParent.size());\n    super._postAttach();\n  }\n\n  /**\n   * @override Widget.js\n   */\n  _renderOnAttach() {\n    super._renderOnAttach();\n    // this is an \"if... else if...\" to avoid rendering the viewport multiple\n    // times in case all ...afterAttach flags are set to true.\n    if (this._rerenderViewPortAfterAttach) {\n      this._rerenderViewport();\n      this._rerenderViewPortAfterAttach = false;\n    } else if (this._renderViewPortAfterAttach) {\n      this._renderViewport();\n      this._renderViewPortAfterAttach = false;\n    }\n  }\n\n  /**\n   * Method invoked when this is a 'detailTable' and the outline content is not displayed anymore.\n   * @override Widget.js\n   */\n  _detach() {\n    this.$container.detach();\n    // Detach helper stores the current scroll pos and restores in attach.\n    // To make it work scrollTop needs to be reset here otherwise viewport won't be rendered by _onDataScroll\n    super._detach();\n  }\n\n  _onDetach() {\n    super._onDetach();\n    this._destroyCellEditorPopup();\n  }\n\n  _destroyCellEditorPopup() {\n    // When a cell editor popup is open and table is detached, we close the popup immediately\n    // and don't wait for the model event 'endCellEdit'. By doing this we can avoid problems\n    // with invalid focus contexts.\n    // However: when 'completeCellEdit' is already scheduled, we must wait because Scout classic\n    // must send a request to the server first #249385.\n    if (this.cellEditorPopup) {\n      var destroyEditor = function() {\n        this.cellEditorPopup.destroy();\n        this.cellEditorPopup = null;\n      }.bind(this);\n\n      var promise = this.cellEditorPopup.waitForCompleteCellEdit();\n      if (promise.state() === 'resolved') {\n        // Do it immediately if promise has already been resolved.\n        // This makes sure updateRow does not immediately reopen the editor after closing.\n        // At least for Scout JS, for Scout Classic it prevents flickering (endCellEdit comes after updateRows, but updateRows does not know whether the editor is closing so it will reopen it)\n        destroyEditor();\n      } else {\n        promise.then(destroyEditor);\n      }\n    }\n  }\n\n  setVirtual(virtual) {\n    this._setProperty('virtual', virtual);\n  }\n\n  setCellValue(column, row, value) {\n    column.setCellValue(row, value);\n  }\n\n  setCellText(column, row, displayText) {\n    column.setCellText(row, displayText);\n  }\n\n  setCellErrorStatus(column, row, errorStatus) {\n    column.setCellErrorStatus(row, errorStatus);\n  }\n\n  visibleColumns(includeGuiColumns) {\n    includeGuiColumns = scout.nvl(includeGuiColumns, true);\n    return this.columns.filter(function(column) {\n      return column.isVisible() && (includeGuiColumns || !column.guiOnly);\n    }, this);\n  }\n\n  // same as on Tree.prototype._onDesktopPopupOpen\n  _onDesktopPopupOpen(event) {\n    var popup = event.popup;\n    if (!this.enabledComputed) {\n      return;\n    }\n    // Set table style to focused if a context menu or a menu bar popup opens, so that it looks as it still has the focus\n    if (this.has(popup) && popup instanceof ContextMenuPopup) {\n      this.$container.addClass('focused');\n      popup.one('destroy', function() {\n        if (this._isDataRendered()) {\n          this.$container.removeClass('focused');\n        }\n      }.bind(this));\n    }\n  }\n\n  _onDesktopPropertyChange(event) {\n    // The height of the menuBar changes by css when switching to or from the dense mode\n    if (event.propertyName === 'dense') {\n      this.menuBar.invalidateLayoutTree();\n    }\n  }\n\n  markRowsAsNonChanged(rows) {\n    arrays.ensure(rows || this.rows).forEach(function(row) {\n      row.status = TableRow.Status.NON_CHANGED;\n    });\n  }\n\n  /* --- STATIC HELPERS ------------------------------------------------------------- */\n\n  static parseHorizontalAlignment(alignment) {\n    if (alignment > 0) {\n      return 'right';\n    }\n    if (alignment === 0) {\n      return 'center';\n    }\n    return 'left';\n  }\n\n  static linkRowToDiv(row, $row) {\n    if (row) {\n      row.$row = $row;\n    }\n    if ($row) {\n      $row.data('row', row);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}