{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Event, focusUtils, FormField, menus as menus_1, objects, scout, Status, strings } from '../../index';\nimport $ from 'jquery';\n/**\n * @abstract\n */\n\nvar ValueField = /*#__PURE__*/function (_FormField) {\n  _inherits(ValueField, _FormField);\n\n  var _super = _createSuper(ValueField);\n\n  function ValueField() {\n    var _this;\n\n    _classCallCheck(this, ValueField);\n\n    _this = _super.call(this);\n    _this.clearable = ValueField.Clearable.FOCUSED;\n    _this.displayText = null;\n    _this.formatter = _this._formatValue.bind(_assertThisInitialized(_this));\n    _this.hasText = false;\n    _this.initialValue = null;\n    _this.invalidValueMessageKey = 'InvalidValueMessageX';\n    _this.parser = _this._parseValue.bind(_assertThisInitialized(_this));\n    _this.value = null;\n    _this.validators = [];\n\n    _this.validators.push(_this._validateValue.bind(_assertThisInitialized(_this)));\n\n    _this.$clearIcon = null;\n\n    _this._addCloneProperties(['value', 'displayText', 'clearable']);\n\n    return _this;\n  }\n\n  _createClass(ValueField, [{\n    key: \"_init\",\n    value: function _init(model) {\n      _get(_getPrototypeOf(ValueField.prototype), \"_init\", this).call(this, model);\n\n      if (this.validator) {\n        // Validators are kept in a list, allow a single validator to be set in the model, similar to parser and formatter.\n        // setValidator will add the new validator to this.validators and remove the other ones.\n        this.setValidator(this.validator);\n        delete this.validator;\n      }\n\n      this._initValue(this.value);\n    }\n    /**\n     * Override this method if you need to influence the value initialization (e.g. do something before the value is initially set)\n     */\n\n  }, {\n    key: \"_initValue\",\n    value: function _initValue(value) {\n      // Delete value first, value may be invalid and must not be set\n      this.value = null;\n\n      this._setValue(value);\n\n      this._updateEmpty();\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      _get(_getPrototypeOf(ValueField.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderDisplayText();\n\n      this._renderClearable();\n\n      this._renderHasText();\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      _get(_getPrototypeOf(ValueField.prototype), \"_remove\", this).call(this);\n\n      this.$clearIcon = null;\n    }\n    /**\n     * The default impl. is a NOP, because not every ValueField has a sensible display text.\n     */\n\n  }, {\n    key: \"_renderDisplayText\",\n    value: function _renderDisplayText() {\n      this._updateHasText();\n    }\n    /**\n     * The default impl. returns an empty string, because not every ValueField has a sensible display text.\n     */\n\n  }, {\n    key: \"_readDisplayText\",\n    value: function _readDisplayText() {\n      return '';\n    }\n  }, {\n    key: \"_onClearIconMouseDown\",\n    value: function _onClearIconMouseDown(event) {\n      this.clear();\n      event.preventDefault();\n    }\n  }, {\n    key: \"_onFieldBlur\",\n    value: function _onFieldBlur() {\n      _get(_getPrototypeOf(ValueField.prototype), \"_onFieldBlur\", this).call(this);\n\n      this.acceptInput(false);\n    }\n    /**\n     * Accepts the current input and writes it to the model.\n     * <p>\n     * This method is typically called by the _onBlur() function of the field, but may actually be called from anywhere (e.g. button, actions, cell editor, etc).\n     * It is also called by the _aboutToBlurByMouseDown() function, which is required because our Ok- and Cancel-buttons are not focusable (thus _onBlur() is\n     * never called) but changes in the value-field must be sent to the server anyway when a button is clicked.\n     * <p>\n     * The default reads the display text using this._readDisplayText() and writes it to the model by calling _triggerAcceptInput().\n     * If subclasses don't have a display-text or want to write another state to the server, they may override this method.\n     */\n\n  }, {\n    key: \"acceptInput\",\n    value: function acceptInput(whileTyping) {\n      whileTyping = !!whileTyping; // cast to boolean\n\n      var displayText = scout.nvl(this._readDisplayText(), ''); // trigger only if displayText has really changed\n\n      if (this._checkDisplayTextChanged(displayText, whileTyping)) {\n        // Don't call setDisplayText() to prevent re-rendering of display text (which is unnecessary and\n        // might change the cursor position). Don't call _callSetProperty() as well, as this eventually\n        // executes this._setDisplayText(), which updates the value.\n        this._setProperty('displayText', displayText);\n\n        if (!whileTyping) {\n          this.parseAndSetValue(displayText);\n        } // Display text may be formatted -> Use this.displayText\n\n\n        this._triggerAcceptInput(whileTyping);\n      }\n    }\n  }, {\n    key: \"parseAndSetValue\",\n    value: function parseAndSetValue(displayText) {\n      this.clearErrorStatus();\n\n      try {\n        var event = new Event({\n          displayText: displayText\n        });\n        this.trigger('parse', event);\n\n        if (!event.defaultPrevented) {\n          var parsedValue = this.parseValue(displayText);\n          this.setValue(parsedValue);\n        }\n      } catch (error) {\n        this._parsingFailed(displayText, error);\n      }\n    }\n  }, {\n    key: \"_parsingFailed\",\n    value: function _parsingFailed(displayText, error) {\n      $.log.isDebugEnabled() && $.log.debug('Parsing failed for field with id ' + this.id, error);\n      var event = new Event({\n        displayText: displayText,\n        error: error\n      });\n      this.trigger('parseError', event);\n\n      if (!event.defaultPrevented) {\n        var status = this._createParsingFailedStatus(displayText, error);\n\n        this.setErrorStatus(status);\n      }\n    }\n  }, {\n    key: \"_createParsingFailedStatus\",\n    value: function _createParsingFailedStatus(displayText, error) {\n      return this._createInvalidValueStatus(displayText, error);\n    }\n    /**\n     * Replaces the existing parser. The parser is called during {@link #parseValue(displayText)}.\n     * <p>\n     * Remember calling the default parser passed as parameter to the parse function, if needed.\n     * @param {function} parser the new parser. If null, the default parser is used.\n     */\n\n  }, {\n    key: \"setParser\",\n    value: function setParser(parser) {\n      this.setProperty('parser', parser);\n\n      if (this.initialized) {\n        this.parseAndSetValue(this.displayText);\n      }\n    }\n  }, {\n    key: \"_setParser\",\n    value: function _setParser(parser) {\n      if (!parser) {\n        parser = this._parseValue.bind(this);\n      }\n\n      this._setProperty('parser', parser);\n    }\n    /**\n     * @returns {*} the parsed value\n     * @throws a message, a Status or an error if the parsing fails\n     */\n\n  }, {\n    key: \"parseValue\",\n    value: function parseValue(displayText) {\n      var defaultParser = this._parseValue.bind(this);\n\n      return this.parser(displayText, defaultParser);\n    }\n    /**\n     * @throws a message, a Status or an error if the parsing fails\n     */\n\n  }, {\n    key: \"_parseValue\",\n    value: function _parseValue(displayText) {\n      return displayText;\n    }\n  }, {\n    key: \"_checkDisplayTextChanged\",\n    value: function _checkDisplayTextChanged(displayText, whileTyping) {\n      var oldDisplayText = scout.nvl(this.displayText, '');\n      return displayText !== oldDisplayText;\n    }\n    /**\n     * Method invoked upon a mousedown click with this field as the currently focused control, and is invoked just before the mousedown click will be interpreted.\n     * However, the mousedown target must not be this control, but any other control instead.\n     *\n     * The default implementation checks, whether the click occurred outside this control, and if so invokes 'ValueField.acceptInput'.\n     *\n     * @param target\n     *        the DOM target where the mouse down event occurred.\n     */\n\n  }, {\n    key: \"aboutToBlurByMouseDown\",\n    value: function aboutToBlurByMouseDown(target) {\n      var eventOnField = this.isFocusOnField(target);\n\n      if (!eventOnField) {\n        this.acceptInput(); // event outside this value field.\n      }\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"isFocused\",\n    value: function isFocused() {\n      return this.rendered && focusUtils.isActiveElement(this.$field);\n    }\n  }, {\n    key: \"isFocusOnField\",\n    value: function isFocusOnField(target) {\n      return this.$field.isOrHas(target) || this.$clearIcon && this.$clearIcon.isOrHas(target);\n    }\n  }, {\n    key: \"_triggerAcceptInput\",\n    value: function _triggerAcceptInput(whileTyping) {\n      var event = {\n        displayText: this.displayText,\n        whileTyping: !!whileTyping\n      };\n      this.trigger('acceptInput', event);\n    }\n  }, {\n    key: \"setDisplayText\",\n    value: function setDisplayText(displayText) {\n      this.setProperty('displayText', displayText);\n    }\n  }, {\n    key: \"_updateHasText\",\n    value: function _updateHasText() {\n      this.setHasText(strings.hasText(this._readDisplayText()));\n    }\n  }, {\n    key: \"setHasText\",\n    value: function setHasText(hasText) {\n      this.setProperty('hasText', hasText);\n    }\n  }, {\n    key: \"_renderHasText\",\n    value: function _renderHasText() {\n      if (this.$field) {\n        this.$field.toggleClass('has-text', this.hasText);\n      }\n\n      this.$container.toggleClass('has-text', this.hasText);\n    }\n  }, {\n    key: \"setClearable\",\n    value: function setClearable(clearableStyle) {\n      this.setProperty('clearable', clearableStyle);\n    }\n  }, {\n    key: \"_renderClearable\",\n    value: function _renderClearable() {\n      if (this.isClearable()) {\n        if (!this.$clearIcon) {\n          this.addClearIcon();\n        }\n      } else {\n        if (this.$clearIcon) {\n          // Remove $dateField\n          this.$clearIcon.remove();\n          this.$clearIcon = null;\n        }\n      }\n\n      this.invalidateLayoutTree(false);\n\n      this._updateClearableStyles();\n    }\n  }, {\n    key: \"_updateClearableStyles\",\n    value: function _updateClearableStyles() {\n      this.$container.removeClass('clearable-always clearable-focused');\n\n      if (this.isClearable()) {\n        if (this.clearable === ValueField.Clearable.ALWAYS) {\n          this.$container.addClass('clearable-always');\n        } else if (this.clearable === ValueField.Clearable.FOCUSED) {\n          this.$container.addClass('clearable-focused');\n        }\n      }\n    }\n  }, {\n    key: \"isClearable\",\n    value: function isClearable() {\n      return this.clearable === ValueField.Clearable.ALWAYS || this.clearable === ValueField.Clearable.FOCUSED;\n    }\n    /**\n     * Clears the display text and the value to null.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._clear();\n\n      this._updateHasText();\n\n      this.acceptInput();\n\n      this._triggerClear();\n    }\n  }, {\n    key: \"_clear\",\n    value: function _clear() {// to be implemented by sublcasses\n    }\n  }, {\n    key: \"_triggerClear\",\n    value: function _triggerClear() {\n      this.trigger('clear');\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      // Same code as in Widget#setProperty expect for the equals check\n      // -> _setValue has to be called even if the value is equal so that update display text will be executed\n      value = this._prepareProperty('value', value);\n\n      if (this.rendered) {\n        this._callRemoveProperty('value');\n      }\n\n      this._callSetProperty('value', value);\n\n      if (this.rendered) {\n        this._callRenderProperty('value');\n      }\n    }\n    /**\n     * Resets the value to its initial value.\n     */\n\n  }, {\n    key: \"resetValue\",\n    value: function resetValue() {\n      this.setValue(this.initialValue);\n    }\n    /**\n     * Default does nothing because the value field does not know which type the concrete field uses.\n     * May be overridden to cast the value to the required type.\n     * @returns {*} the value with the correct type.\n     */\n\n  }, {\n    key: \"_ensureValue\",\n    value: function _ensureValue(value) {\n      return value;\n    }\n  }, {\n    key: \"_setValue\",\n    value: function _setValue(value) {\n      var oldValue = this.value;\n\n      this._updateErrorStatus(null);\n\n      var typedValue = null;\n\n      try {\n        typedValue = this._ensureValue(value);\n        this.value = this.validateValue(typedValue);\n      } catch (error) {\n        typedValue = typedValue || value;\n\n        this._validationFailed(typedValue, error);\n\n        return;\n      }\n\n      this._updateDisplayText();\n\n      if (this._valueEquals(oldValue, this.value)) {\n        return;\n      }\n\n      this._valueChanged();\n\n      this._updateTouched();\n\n      this._updateEmpty();\n\n      this.triggerPropertyChange('value', oldValue, this.value);\n    }\n  }, {\n    key: \"_valueEquals\",\n    value: function _valueEquals(valueA, valueB) {\n      return objects.equals(valueA, valueB);\n    }\n    /**\n     * Is called after a value is changed. May be implemented by subclasses. The default does nothing.\n     */\n\n  }, {\n    key: \"_valueChanged\",\n    value: function _valueChanged() {// NOP\n    }\n    /**\n     * Validates the value by executing the validators. If a new value is the result, it will be set.\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      this._setValue(this.value);\n    }\n    /**\n     * @param {function} validator the validator to be added\n     * @param {boolean} [revalidate] True, to revalidate the value, false to just add the validator and do nothing else. Default is true.\n     */\n\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(validator, revalidate) {\n      var validators = this.validators.slice();\n      validators.push(validator);\n      this.setValidators(validators, revalidate);\n    }\n    /**\n     * @param {function} validator the validator to be removed\n     * @param {boolean} [revalidate] True, to revalidate the value, false to just remove the validator and do nothing else. Default is true.\n     */\n\n  }, {\n    key: \"removeValidator\",\n    value: function removeValidator(validator, revalidate) {\n      var validators = this.validators.slice();\n      arrays.remove(validators, validator);\n      this.setValidators(validators, revalidate);\n    }\n    /**\n     * Replaces all existing validators with the given one. If you want to add multiple validators, use {@link #addValidator}.\n     * <p>\n     * Remember calling the default validator which is passed as parameter to the validate function, if needed.\n     * @param {function} validator the new validator which replaces every other. If null, the default validator is used.\n     */\n\n  }, {\n    key: \"setValidator\",\n    value: function setValidator(validator, revalidate) {\n      if (!validator) {\n        validator = this._validateValue.bind(this);\n      }\n\n      var validators = [];\n\n      if (validator) {\n        validators = [validator];\n      }\n\n      this.setValidators(validators, revalidate);\n    }\n  }, {\n    key: \"setValidators\",\n    value: function setValidators(validators, revalidate) {\n      this.setProperty('validators', validators);\n\n      if (this.initialized && scout.nvl(revalidate, true)) {\n        this.validate();\n      }\n    }\n    /**\n     * @param the value to be validated\n     * @returns {*} the validated value\n     * @throws a message, a Status or an error if the validation fails\n     */\n\n  }, {\n    key: \"validateValue\",\n    value: function validateValue(value) {\n      var defaultValidator = this._validateValue.bind(this);\n\n      this.validators.forEach(function (validator) {\n        value = validator(value, defaultValidator);\n      });\n      value = scout.nvl(value, null); // Ensure value is never undefined (necessary for _updateTouched and should make it easier generally)\n\n      return value;\n    }\n    /**\n     * @returns {*} the validated value\n     * @throws a message, a Status or an error if the validation fails\n     */\n\n  }, {\n    key: \"_validateValue\",\n    value: function _validateValue(value) {\n      if (typeof value === 'string' && value === '') {\n        // Convert empty string to null.\n        // Not using strings.nullIfEmpty is by purpose because it also removes white space characters which may not be desired here\n        value = null;\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_validationFailed\",\n    value: function _validationFailed(value, error) {\n      $.log.isDebugEnabled() && $.log.debug('Validation failed for field with id ' + this.id, error);\n\n      var status = this._createValidationFailedStatus(value, error);\n\n      this._updateErrorStatus(status);\n\n      this._updateDisplayText(value);\n    }\n  }, {\n    key: \"_createValidationFailedStatus\",\n    value: function _createValidationFailedStatus(value, error) {\n      return this._createInvalidValueStatus(value, error);\n    }\n  }, {\n    key: \"_createInvalidValueStatus\",\n    value: function _createInvalidValueStatus(value, error) {\n      if (error instanceof Status) {\n        return error;\n      }\n\n      if (typeof error === 'string') {\n        return Status.error({\n          message: error\n        });\n      }\n\n      return Status.error({\n        message: this.session.text(this.invalidValueMessageKey, value)\n      });\n    }\n  }, {\n    key: \"_updateErrorStatus\",\n    value: function _updateErrorStatus(status) {\n      if (!this.initialized && this.errorStatus) {\n        // Don't override the error status specified by the init model\n        return;\n      }\n\n      if (!status) {\n        this.clearErrorStatus();\n      } else {\n        this.setErrorStatus(status);\n      }\n    }\n  }, {\n    key: \"_updateDisplayText\",\n    value: function _updateDisplayText(value) {\n      if (!this.initialized && !objects.isNullOrUndefined(this.displayText)) {\n        // If a displayText is provided initially, use that text instead of using formatValue to generate a text based on the value\n        return;\n      }\n\n      value = scout.nvl(value, this.value);\n      var returned = this.formatValue(value);\n\n      if (returned && $.isFunction(returned.promise)) {\n        // Promise is returned -> set display text later\n        returned.done(this.setDisplayText.bind(this)).fail(function () {\n          this.setDisplayText('');\n          $.log.isInfoEnabled() && $.log.info('Could not resolve display text for value: ' + value);\n        }.bind(this));\n      } else {\n        this.setDisplayText(returned);\n      }\n    }\n    /**\n     * Replaces the existing formatter. The formatter is called during {@link #formatValue(value)}.\n     * <p>\n     * Remember calling the default formatter which is passed as parameter to the format function, if needed.\n     * @param {function} formatter the new formatter. If null, the default formatter is used.\n     */\n\n  }, {\n    key: \"setFormatter\",\n    value: function setFormatter(formatter) {\n      this.setProperty('formatter', formatter);\n\n      if (this.initialized) {\n        this.validate();\n      }\n    }\n  }, {\n    key: \"_setFormatter\",\n    value: function _setFormatter(formatter) {\n      if (!formatter) {\n        formatter = this._formatValue.bind(this);\n      }\n\n      this._setProperty('formatter', formatter);\n    }\n    /**\n     * @returns {string|Promise} the formatted display text\n     */\n\n  }, {\n    key: \"formatValue\",\n    value: function formatValue(value) {\n      var defaultFormatter = this._formatValue.bind(this);\n\n      return this.formatter(value, defaultFormatter);\n    }\n    /**\n     * @returns {string|Promise} the formatted string or a promise\n     */\n\n  }, {\n    key: \"_formatValue\",\n    value: function _formatValue(value) {\n      return scout.nvl(value, '') + '';\n    }\n  }, {\n    key: \"_updateTouched\",\n    value: function _updateTouched() {\n      this.touched = !this._valueEquals(this.value, this.initialValue);\n    }\n  }, {\n    key: \"addClearIcon\",\n    value: function addClearIcon($parent) {\n      if (!$parent) {\n        $parent = this.$container;\n      }\n\n      this.$clearIcon = $parent.appendSpan('clear-icon needsclick unfocusable').on('mousedown', this._onClearIconMouseDown.bind(this));\n    }\n  }, {\n    key: \"addContainer\",\n    value: function addContainer($parent, cssClass, layout) {\n      _get(_getPrototypeOf(ValueField.prototype), \"addContainer\", this).call(this, $parent, cssClass, layout);\n\n      this.$container.addClass('value-field');\n    }\n  }, {\n    key: \"addField\",\n    value: function addField($field) {\n      _get(_getPrototypeOf(ValueField.prototype), \"addField\", this).call(this, $field);\n\n      this.$field.data('valuefield', this);\n    }\n  }, {\n    key: \"setCurrentMenuTypes\",\n    value: function setCurrentMenuTypes(currentMenuTypes) {\n      this.setProperty('currentMenuTypes', currentMenuTypes);\n    }\n  }, {\n    key: \"_renderCurrentMenuTypes\",\n    value: function _renderCurrentMenuTypes() {\n      // If a tooltip is shown, update it with the new menus\n      this._updateFieldStatus();\n    }\n  }, {\n    key: \"_getCurrentMenus\",\n    value: function _getCurrentMenus() {\n      if (this.currentMenuTypes) {\n        var menuTypes = this.currentMenuTypes.map(function (elem) {\n          return 'ValueField.' + elem;\n        });\n        return menus_1.filter(this.menus, menuTypes);\n      }\n\n      return _get(_getPrototypeOf(ValueField.prototype), \"_getCurrentMenus\", this).call(this);\n    }\n  }, {\n    key: \"markAsSaved\",\n    value: function markAsSaved() {\n      _get(_getPrototypeOf(ValueField.prototype), \"markAsSaved\", this).call(this);\n\n      this.initialValue = this.value;\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_updateEmpty\",\n    value: function _updateEmpty() {\n      this.empty = this.value === null || this.value === undefined;\n    } // ==== static helper methods ==== //\n\n    /**\n     * Invokes 'ValueField.aboutToBlurByMouseDown' on the currently active value field.\n     * This method has no effect if another element is the focus owner.\n     */\n\n  }], [{\n    key: \"invokeValueFieldAboutToBlurByMouseDown\",\n    value: function invokeValueFieldAboutToBlurByMouseDown(target) {\n      var activeValueField = this._getActiveValueField(target);\n\n      if (activeValueField) {\n        activeValueField.aboutToBlurByMouseDown(target);\n      }\n    }\n    /**\n     * Invokes 'ValueField.acceptInput' on the currently active value field.\n     * This method has no effect if another element is the focus owner.\n     */\n\n  }, {\n    key: \"invokeValueFieldAcceptInput\",\n    value: function invokeValueFieldAcceptInput(target) {\n      var activeValueField = this._getActiveValueField(target);\n\n      if (activeValueField) {\n        activeValueField.acceptInput();\n      }\n    }\n    /**\n     * Returns the currently active value field, or null if another element is active.\n     * Also, if no value field currently owns the focus, its parent is checked to be a value field and is returned accordingly.\n     * That is used in DateField.js with multiple input elements.\n     */\n\n  }, {\n    key: \"_getActiveValueField\",\n    value: function _getActiveValueField(target) {\n      var $activeElement = $(target).activeElement(),\n          activeWidget = scout.widget($activeElement);\n\n      if (activeWidget instanceof ValueField && activeWidget.enabledComputed) {\n        return activeWidget;\n      }\n\n      return null;\n    }\n  }]);\n\n  return ValueField;\n}(FormField);\n\n_defineProperty(ValueField, \"Clearable\", {\n  /**\n   * The clear icon is showed when the field has text.\n   */\n  ALWAYS: 'always',\n\n  /**\n   * The clear icon will be showed when the field is focused and has text.\n   */\n  FOCUSED: 'focused',\n\n  /**\n   * Never show the clear icon.\n   */\n  NEVER: 'never'\n});\n\nexport { ValueField as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/form/fields/ValueField.js"],"names":["arrays","Event","focusUtils","FormField","menus","menus_1","objects","scout","Status","strings","$","ValueField","clearable","Clearable","FOCUSED","displayText","formatter","_formatValue","bind","hasText","initialValue","invalidValueMessageKey","parser","_parseValue","value","validators","push","_validateValue","$clearIcon","_addCloneProperties","model","validator","setValidator","_initValue","_setValue","_updateEmpty","_renderDisplayText","_renderClearable","_renderHasText","_updateHasText","event","clear","preventDefault","acceptInput","whileTyping","nvl","_readDisplayText","_checkDisplayTextChanged","_setProperty","parseAndSetValue","_triggerAcceptInput","clearErrorStatus","trigger","defaultPrevented","parsedValue","parseValue","setValue","error","_parsingFailed","log","isDebugEnabled","debug","id","status","_createParsingFailedStatus","setErrorStatus","_createInvalidValueStatus","setProperty","initialized","defaultParser","oldDisplayText","target","eventOnField","isFocusOnField","rendered","isActiveElement","$field","isOrHas","setHasText","toggleClass","$container","clearableStyle","isClearable","addClearIcon","remove","invalidateLayoutTree","_updateClearableStyles","removeClass","ALWAYS","addClass","_clear","_triggerClear","_prepareProperty","_callRemoveProperty","_callSetProperty","_callRenderProperty","oldValue","_updateErrorStatus","typedValue","_ensureValue","validateValue","_validationFailed","_updateDisplayText","_valueEquals","_valueChanged","_updateTouched","triggerPropertyChange","valueA","valueB","equals","revalidate","slice","setValidators","validate","defaultValidator","forEach","_createValidationFailedStatus","message","session","text","errorStatus","isNullOrUndefined","returned","formatValue","isFunction","promise","done","setDisplayText","fail","isInfoEnabled","info","defaultFormatter","touched","$parent","appendSpan","on","_onClearIconMouseDown","cssClass","layout","data","currentMenuTypes","_updateFieldStatus","menuTypes","map","elem","filter","empty","undefined","activeValueField","_getActiveValueField","aboutToBlurByMouseDown","$activeElement","activeElement","activeWidget","widget","enabledComputed","NEVER"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Event, focusUtils, FormField, menus as menus_1, objects, scout, Status, strings} from '../../index';\nimport $ from 'jquery';\n\n/**\n * @abstract\n */\nexport default class ValueField extends FormField {\n\n  constructor() {\n    super();\n    this.clearable = ValueField.Clearable.FOCUSED;\n    this.displayText = null;\n    this.formatter = this._formatValue.bind(this);\n    this.hasText = false;\n    this.initialValue = null;\n    this.invalidValueMessageKey = 'InvalidValueMessageX';\n    this.parser = this._parseValue.bind(this);\n    this.value = null;\n    this.validators = [];\n    this.validators.push(this._validateValue.bind(this));\n\n    this.$clearIcon = null;\n\n    this._addCloneProperties(['value', 'displayText', 'clearable']);\n  }\n\n  static Clearable = {\n    /**\n     * The clear icon is showed when the field has text.\n     */\n    ALWAYS: 'always',\n    /**\n     * The clear icon will be showed when the field is focused and has text.\n     */\n    FOCUSED: 'focused',\n    /**\n     * Never show the clear icon.\n     */\n    NEVER: 'never'\n  };\n\n  _init(model) {\n    super._init(model);\n    if (this.validator) {\n      // Validators are kept in a list, allow a single validator to be set in the model, similar to parser and formatter.\n      // setValidator will add the new validator to this.validators and remove the other ones.\n      this.setValidator(this.validator);\n      delete this.validator;\n    }\n    this._initValue(this.value);\n  }\n\n  /**\n   * Override this method if you need to influence the value initialization (e.g. do something before the value is initially set)\n   */\n  _initValue(value) {\n    // Delete value first, value may be invalid and must not be set\n    this.value = null;\n    this._setValue(value);\n    this._updateEmpty();\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderDisplayText();\n    this._renderClearable();\n    this._renderHasText();\n  }\n\n  _remove() {\n    super._remove();\n    this.$clearIcon = null;\n  }\n\n  /**\n   * The default impl. is a NOP, because not every ValueField has a sensible display text.\n   */\n  _renderDisplayText() {\n    this._updateHasText();\n  }\n\n  /**\n   * The default impl. returns an empty string, because not every ValueField has a sensible display text.\n   */\n  _readDisplayText() {\n    return '';\n  }\n\n  _onClearIconMouseDown(event) {\n    this.clear();\n    event.preventDefault();\n  }\n\n  _onFieldBlur() {\n    super._onFieldBlur();\n    this.acceptInput(false);\n  }\n\n  /**\n   * Accepts the current input and writes it to the model.\n   * <p>\n   * This method is typically called by the _onBlur() function of the field, but may actually be called from anywhere (e.g. button, actions, cell editor, etc).\n   * It is also called by the _aboutToBlurByMouseDown() function, which is required because our Ok- and Cancel-buttons are not focusable (thus _onBlur() is\n   * never called) but changes in the value-field must be sent to the server anyway when a button is clicked.\n   * <p>\n   * The default reads the display text using this._readDisplayText() and writes it to the model by calling _triggerAcceptInput().\n   * If subclasses don't have a display-text or want to write another state to the server, they may override this method.\n   */\n  acceptInput(whileTyping) {\n    whileTyping = !!whileTyping; // cast to boolean\n    var displayText = scout.nvl(this._readDisplayText(), '');\n\n    // trigger only if displayText has really changed\n    if (this._checkDisplayTextChanged(displayText, whileTyping)) {\n      // Don't call setDisplayText() to prevent re-rendering of display text (which is unnecessary and\n      // might change the cursor position). Don't call _callSetProperty() as well, as this eventually\n      // executes this._setDisplayText(), which updates the value.\n      this._setProperty('displayText', displayText);\n      if (!whileTyping) {\n        this.parseAndSetValue(displayText);\n      }\n      // Display text may be formatted -> Use this.displayText\n      this._triggerAcceptInput(whileTyping);\n    }\n  }\n\n  parseAndSetValue(displayText) {\n    this.clearErrorStatus();\n    try {\n      var event = new Event({\n        displayText: displayText\n      });\n      this.trigger('parse', event);\n      if (!event.defaultPrevented) {\n        var parsedValue = this.parseValue(displayText);\n        this.setValue(parsedValue);\n      }\n    } catch (error) {\n      this._parsingFailed(displayText, error);\n    }\n  }\n\n  _parsingFailed(displayText, error) {\n    $.log.isDebugEnabled() && $.log.debug('Parsing failed for field with id ' + this.id, error);\n    var event = new Event({\n      displayText: displayText,\n      error: error\n    });\n    this.trigger('parseError', event);\n    if (!event.defaultPrevented) {\n      var status = this._createParsingFailedStatus(displayText, error);\n      this.setErrorStatus(status);\n    }\n  }\n\n  _createParsingFailedStatus(displayText, error) {\n    return this._createInvalidValueStatus(displayText, error);\n  }\n\n  /**\n   * Replaces the existing parser. The parser is called during {@link #parseValue(displayText)}.\n   * <p>\n   * Remember calling the default parser passed as parameter to the parse function, if needed.\n   * @param {function} parser the new parser. If null, the default parser is used.\n   */\n  setParser(parser) {\n    this.setProperty('parser', parser);\n    if (this.initialized) {\n      this.parseAndSetValue(this.displayText);\n    }\n  }\n\n  _setParser(parser) {\n    if (!parser) {\n      parser = this._parseValue.bind(this);\n    }\n    this._setProperty('parser', parser);\n  }\n\n  /**\n   * @returns {*} the parsed value\n   * @throws a message, a Status or an error if the parsing fails\n   */\n  parseValue(displayText) {\n    var defaultParser = this._parseValue.bind(this);\n    return this.parser(displayText, defaultParser);\n  }\n\n  /**\n   * @throws a message, a Status or an error if the parsing fails\n   */\n  _parseValue(displayText) {\n    return displayText;\n  }\n\n  _checkDisplayTextChanged(displayText, whileTyping) {\n    var oldDisplayText = scout.nvl(this.displayText, '');\n    return displayText !== oldDisplayText;\n  }\n\n  /**\n   * Method invoked upon a mousedown click with this field as the currently focused control, and is invoked just before the mousedown click will be interpreted.\n   * However, the mousedown target must not be this control, but any other control instead.\n   *\n   * The default implementation checks, whether the click occurred outside this control, and if so invokes 'ValueField.acceptInput'.\n   *\n   * @param target\n   *        the DOM target where the mouse down event occurred.\n   */\n  aboutToBlurByMouseDown(target) {\n    var eventOnField = this.isFocusOnField(target);\n    if (!eventOnField) {\n      this.acceptInput(); // event outside this value field.\n    }\n  }\n\n  /**\n   * @override\n   */\n  isFocused() {\n    return this.rendered && focusUtils.isActiveElement(this.$field);\n  }\n\n  isFocusOnField(target) {\n    return this.$field.isOrHas(target) || (this.$clearIcon && this.$clearIcon.isOrHas(target));\n  }\n\n  _triggerAcceptInput(whileTyping) {\n    var event = {\n      displayText: this.displayText,\n      whileTyping: !!whileTyping\n    };\n    this.trigger('acceptInput', event);\n  }\n\n  setDisplayText(displayText) {\n    this.setProperty('displayText', displayText);\n  }\n\n  _updateHasText() {\n    this.setHasText(strings.hasText(this._readDisplayText()));\n  }\n\n  setHasText(hasText) {\n    this.setProperty('hasText', hasText);\n  }\n\n  _renderHasText() {\n    if (this.$field) {\n      this.$field.toggleClass('has-text', this.hasText);\n    }\n    this.$container.toggleClass('has-text', this.hasText);\n  }\n\n  setClearable(clearableStyle) {\n    this.setProperty('clearable', clearableStyle);\n  }\n\n  _renderClearable() {\n    if (this.isClearable()) {\n      if (!this.$clearIcon) {\n        this.addClearIcon();\n      }\n    } else {\n      if (this.$clearIcon) {\n        // Remove $dateField\n        this.$clearIcon.remove();\n        this.$clearIcon = null;\n      }\n    }\n    this.invalidateLayoutTree(false);\n    this._updateClearableStyles();\n  }\n\n  _updateClearableStyles() {\n    this.$container.removeClass('clearable-always clearable-focused');\n    if (this.isClearable()) {\n      if (this.clearable === ValueField.Clearable.ALWAYS) {\n        this.$container.addClass('clearable-always');\n      } else if (this.clearable === ValueField.Clearable.FOCUSED) {\n        this.$container.addClass('clearable-focused');\n      }\n    }\n  }\n\n  isClearable() {\n    return this.clearable === ValueField.Clearable.ALWAYS || this.clearable === ValueField.Clearable.FOCUSED;\n  }\n\n  /**\n   * Clears the display text and the value to null.\n   */\n  clear() {\n    this._clear();\n    this._updateHasText();\n    this.acceptInput();\n    this._triggerClear();\n  }\n\n  _clear() {\n    // to be implemented by sublcasses\n  }\n\n  _triggerClear() {\n    this.trigger('clear');\n  }\n\n  setValue(value) {\n    // Same code as in Widget#setProperty expect for the equals check\n    // -> _setValue has to be called even if the value is equal so that update display text will be executed\n    value = this._prepareProperty('value', value);\n    if (this.rendered) {\n      this._callRemoveProperty('value');\n    }\n    this._callSetProperty('value', value);\n    if (this.rendered) {\n      this._callRenderProperty('value');\n    }\n  }\n\n  /**\n   * Resets the value to its initial value.\n   */\n  resetValue() {\n    this.setValue(this.initialValue);\n  }\n\n  /**\n   * Default does nothing because the value field does not know which type the concrete field uses.\n   * May be overridden to cast the value to the required type.\n   * @returns {*} the value with the correct type.\n   */\n  _ensureValue(value) {\n    return value;\n  }\n\n  _setValue(value) {\n    var oldValue = this.value;\n    this._updateErrorStatus(null);\n    var typedValue = null;\n    try {\n      typedValue = this._ensureValue(value);\n      this.value = this.validateValue(typedValue);\n    } catch (error) {\n      typedValue = typedValue || value;\n      this._validationFailed(typedValue, error);\n      return;\n    }\n\n    this._updateDisplayText();\n    if (this._valueEquals(oldValue, this.value)) {\n      return;\n    }\n\n    this._valueChanged();\n    this._updateTouched();\n    this._updateEmpty();\n    this.triggerPropertyChange('value', oldValue, this.value);\n  }\n\n  _valueEquals(valueA, valueB) {\n    return objects.equals(valueA, valueB);\n  }\n\n  /**\n   * Is called after a value is changed. May be implemented by subclasses. The default does nothing.\n   */\n  _valueChanged() {\n    // NOP\n  }\n\n  /**\n   * Validates the value by executing the validators. If a new value is the result, it will be set.\n   */\n  validate() {\n    this._setValue(this.value);\n  }\n\n  /**\n   * @param {function} validator the validator to be added\n   * @param {boolean} [revalidate] True, to revalidate the value, false to just add the validator and do nothing else. Default is true.\n   */\n  addValidator(validator, revalidate) {\n    var validators = this.validators.slice();\n    validators.push(validator);\n    this.setValidators(validators, revalidate);\n  }\n\n  /**\n   * @param {function} validator the validator to be removed\n   * @param {boolean} [revalidate] True, to revalidate the value, false to just remove the validator and do nothing else. Default is true.\n   */\n  removeValidator(validator, revalidate) {\n    var validators = this.validators.slice();\n    arrays.remove(validators, validator);\n    this.setValidators(validators, revalidate);\n  }\n\n  /**\n   * Replaces all existing validators with the given one. If you want to add multiple validators, use {@link #addValidator}.\n   * <p>\n   * Remember calling the default validator which is passed as parameter to the validate function, if needed.\n   * @param {function} validator the new validator which replaces every other. If null, the default validator is used.\n   */\n  setValidator(validator, revalidate) {\n    if (!validator) {\n      validator = this._validateValue.bind(this);\n    }\n    var validators = [];\n    if (validator) {\n      validators = [validator];\n    }\n    this.setValidators(validators, revalidate);\n  }\n\n  setValidators(validators, revalidate) {\n    this.setProperty('validators', validators);\n    if (this.initialized && scout.nvl(revalidate, true)) {\n      this.validate();\n    }\n  }\n\n  /**\n   * @param the value to be validated\n   * @returns {*} the validated value\n   * @throws a message, a Status or an error if the validation fails\n   */\n  validateValue(value) {\n    var defaultValidator = this._validateValue.bind(this);\n    this.validators.forEach(function(validator) {\n      value = validator(value, defaultValidator);\n    });\n    value = scout.nvl(value, null); // Ensure value is never undefined (necessary for _updateTouched and should make it easier generally)\n    return value;\n  }\n\n  /**\n   * @returns {*} the validated value\n   * @throws a message, a Status or an error if the validation fails\n   */\n  _validateValue(value) {\n    if (typeof value === 'string' && value === '') {\n      // Convert empty string to null.\n      // Not using strings.nullIfEmpty is by purpose because it also removes white space characters which may not be desired here\n      value = null;\n    }\n    return value;\n  }\n\n  _validationFailed(value, error) {\n    $.log.isDebugEnabled() && $.log.debug('Validation failed for field with id ' + this.id, error);\n    var status = this._createValidationFailedStatus(value, error);\n    this._updateErrorStatus(status);\n    this._updateDisplayText(value);\n  }\n\n  _createValidationFailedStatus(value, error) {\n    return this._createInvalidValueStatus(value, error);\n  }\n\n  _createInvalidValueStatus(value, error) {\n    if (error instanceof Status) {\n      return error;\n    }\n    if (typeof error === 'string') {\n      return Status.error({\n        message: error\n      });\n    }\n    return Status.error({\n      message: this.session.text(this.invalidValueMessageKey, value)\n    });\n  }\n\n  _updateErrorStatus(status) {\n    if (!this.initialized && this.errorStatus) {\n      // Don't override the error status specified by the init model\n      return;\n    }\n    if (!status) {\n      this.clearErrorStatus();\n    } else {\n      this.setErrorStatus(status);\n    }\n  }\n\n  _updateDisplayText(value) {\n    if (!this.initialized && !objects.isNullOrUndefined(this.displayText)) {\n      // If a displayText is provided initially, use that text instead of using formatValue to generate a text based on the value\n      return;\n    }\n    value = scout.nvl(value, this.value);\n    var returned = this.formatValue(value);\n    if (returned && $.isFunction(returned.promise)) {\n      // Promise is returned -> set display text later\n      returned\n        .done(this.setDisplayText.bind(this))\n        .fail(function() {\n          this.setDisplayText('');\n          $.log.isInfoEnabled() && $.log.info('Could not resolve display text for value: ' + value);\n        }.bind(this));\n    } else {\n      this.setDisplayText(returned);\n    }\n  }\n\n  /**\n   * Replaces the existing formatter. The formatter is called during {@link #formatValue(value)}.\n   * <p>\n   * Remember calling the default formatter which is passed as parameter to the format function, if needed.\n   * @param {function} formatter the new formatter. If null, the default formatter is used.\n   */\n  setFormatter(formatter) {\n    this.setProperty('formatter', formatter);\n    if (this.initialized) {\n      this.validate();\n    }\n  }\n\n  _setFormatter(formatter) {\n    if (!formatter) {\n      formatter = this._formatValue.bind(this);\n    }\n    this._setProperty('formatter', formatter);\n  }\n\n  /**\n   * @returns {string|Promise} the formatted display text\n   */\n  formatValue(value) {\n    var defaultFormatter = this._formatValue.bind(this);\n    return this.formatter(value, defaultFormatter);\n  }\n\n  /**\n   * @returns {string|Promise} the formatted string or a promise\n   */\n  _formatValue(value) {\n    return scout.nvl(value, '') + '';\n  }\n\n  _updateTouched() {\n    this.touched = !this._valueEquals(this.value, this.initialValue);\n  }\n\n  addClearIcon($parent) {\n    if (!$parent) {\n      $parent = this.$container;\n    }\n    this.$clearIcon = $parent.appendSpan('clear-icon needsclick unfocusable')\n      .on('mousedown', this._onClearIconMouseDown.bind(this));\n  }\n\n  addContainer($parent, cssClass, layout) {\n    super.addContainer($parent, cssClass, layout);\n    this.$container.addClass('value-field');\n  }\n\n  addField($field) {\n    super.addField($field);\n    this.$field.data('valuefield', this);\n  }\n\n  setCurrentMenuTypes(currentMenuTypes) {\n    this.setProperty('currentMenuTypes', currentMenuTypes);\n  }\n\n  _renderCurrentMenuTypes() {\n    // If a tooltip is shown, update it with the new menus\n    this._updateFieldStatus();\n  }\n\n  _getCurrentMenus() {\n    if (this.currentMenuTypes) {\n      var menuTypes = this.currentMenuTypes.map(function(elem) {\n        return 'ValueField.' + elem;\n      });\n      return menus_1.filter(this.menus, menuTypes);\n    }\n    return super._getCurrentMenus();\n  }\n\n  markAsSaved() {\n    super.markAsSaved();\n    this.initialValue = this.value;\n  }\n\n  /**\n   * @override\n   */\n  _updateEmpty() {\n    this.empty = this.value === null || this.value === undefined;\n  }\n\n  // ==== static helper methods ==== //\n\n  /**\n   * Invokes 'ValueField.aboutToBlurByMouseDown' on the currently active value field.\n   * This method has no effect if another element is the focus owner.\n   */\n  static invokeValueFieldAboutToBlurByMouseDown(target) {\n    var activeValueField = this._getActiveValueField(target);\n    if (activeValueField) {\n      activeValueField.aboutToBlurByMouseDown(target);\n    }\n  }\n\n  /**\n   * Invokes 'ValueField.acceptInput' on the currently active value field.\n   * This method has no effect if another element is the focus owner.\n   */\n  static invokeValueFieldAcceptInput(target) {\n    var activeValueField = this._getActiveValueField(target);\n    if (activeValueField) {\n      activeValueField.acceptInput();\n    }\n  }\n\n  /**\n   * Returns the currently active value field, or null if another element is active.\n   * Also, if no value field currently owns the focus, its parent is checked to be a value field and is returned accordingly.\n   * That is used in DateField.js with multiple input elements.\n   */\n  static _getActiveValueField(target) {\n    var $activeElement = $(target).activeElement(),\n      activeWidget = scout.widget($activeElement);\n    if (activeWidget instanceof ValueField && activeWidget.enabledComputed) {\n      return activeWidget;\n    }\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}