{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { numbers, Range, scout } from '../index';\nimport $ from 'jquery';\n\nvar VirtualScrolling = /*#__PURE__*/function () {\n  function VirtualScrolling(options) {\n    _classCallCheck(this, VirtualScrolling);\n\n    this.enabled = true;\n    this.minRowHeight = 0;\n    this.scrollHandler = null;\n    this.viewRangeSize = new Range();\n    this.widget = null;\n    this.$scrollable = null;\n    $.extend(this, options);\n  }\n\n  _createClass(VirtualScrolling, [{\n    key: \"setEnabled\",\n    value: function setEnabled(enabled) {\n      this.enabled = enabled;\n    }\n  }, {\n    key: \"set$Scrollable\",\n    value: function set$Scrollable($scrollable) {\n      if (this.$scrollable === $scrollable) {\n        return;\n      }\n\n      this.$scrollable = $scrollable;\n    }\n  }, {\n    key: \"setMinRowHeight\",\n    value: function setMinRowHeight(minRowHeight) {\n      if (this.minRowHeight === minRowHeight) {\n        return;\n      }\n\n      if (!numbers.isNumber(minRowHeight)) {\n        throw new Error('minRowHeight is not a number: ' + minRowHeight);\n      }\n\n      this.minRowHeight = minRowHeight;\n\n      if (this.widget.rendered) {\n        this.setViewRangeSize(this.calculateViewRangeSize());\n      }\n    }\n  }, {\n    key: \"setViewRangeSize\",\n    value: function setViewRangeSize(viewRangeSize, updateViewPort) {\n      if (this.viewRangeSize === viewRangeSize) {\n        return;\n      }\n\n      this.viewRangeSize = viewRangeSize;\n\n      if (this.widget.rendered && scout.nvl(updateViewPort, true)) {\n        this._renderViewPort();\n      }\n    }\n    /**\n     * Calculates the optimal view range size (number of rows to be rendered).\n     * It uses the default row height to estimate how many rows fit in the view port.\n     * The view range size is this value * 2.\n     */\n\n  }, {\n    key: \"calculateViewRangeSize\",\n    value: function calculateViewRangeSize() {\n      if (!this.enabled || this.$scrollable.length === 0) {\n        return this.rowCount();\n      }\n\n      if (this.minRowHeight === 0) {\n        throw new Error('Cannot calculate view range with rowHeight = 0');\n      }\n\n      return Math.ceil(this.$scrollable.height() / this.minRowHeight) * 2;\n    }\n  }, {\n    key: \"calculateCurrentViewRange\",\n    value: function calculateCurrentViewRange() {\n      if (!this.enabled) {\n        return this.maxViewRange();\n      }\n\n      if (this.viewRangeSize === 0) {\n        return new Range(0, 0);\n      }\n\n      var rowIndex;\n\n      if (this.$scrollable.length === 0) {\n        return this.maxViewRange();\n      }\n\n      var scrollTop = this.$scrollable[0].scrollTop;\n      var maxScrollTop = this.$scrollable[0].scrollHeight - this.$scrollable[0].clientHeight;\n      var widgetBounds = this.widget.$container[0].getBoundingClientRect();\n      var scrollableBounds = this.$scrollable[0].getBoundingClientRect();\n\n      if (widgetBounds.height > 0 && (widgetBounds.bottom < scrollableBounds.top || widgetBounds.top > scrollableBounds.bottom)) {\n        // If widget is not in the view port, no need to draw any row\n        return new Range(0, 0);\n      }\n\n      if (maxScrollTop === 0) {\n        // no scrollbars visible\n        rowIndex = 0;\n      } else {\n        rowIndex = this._rowIndexAtScrollTop(scrollTop);\n      }\n\n      return this.calculateViewRangeForRowIndex(rowIndex);\n    }\n  }, {\n    key: \"maxViewRange\",\n    value: function maxViewRange() {\n      return new Range(0, this.rowCount());\n    }\n    /**\n     * Returns a range of size this.viewRangeSize. Start of range is rowIndex - viewRangeSize / 4.\n     * -> 1/4 of the rows are before the viewport 2/4 in the viewport 1/4 after the viewport,\n     * assuming viewRangeSize is 2*number of possible rows in the viewport (see calculateViewRangeSize).\n     */\n\n  }, {\n    key: \"calculateViewRangeForRowIndex\",\n    value: function calculateViewRangeForRowIndex(rowIndex) {\n      if (!this.enabled) {\n        return this.maxViewRange();\n      }\n\n      var viewRange = new Range(),\n          quarterRange = Math.floor(this.viewRangeSize / 4),\n          diff;\n      viewRange.from = Math.max(rowIndex - quarterRange, 0);\n      viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.rowCount()); // Try to use the whole viewRangeSize (extend from if necessary)\n\n      diff = this.viewRangeSize - viewRange.size();\n\n      if (diff > 0) {\n        viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);\n      }\n\n      return viewRange;\n    }\n    /**\n     * Returns the index of the row which is at position scrollTop.\n     */\n\n  }, {\n    key: \"_rowIndexAtScrollTop\",\n    value: function _rowIndexAtScrollTop(scrollTop) {\n      var height = 0,\n          rowCount = this.rowCount(),\n          index = rowCount - 1;\n\n      if (this.widget.$container[0] !== this.$scrollable[0]) {\n        // If container itself is not scrollable but a parent, height must not start at 0\n        height = scrollTop + (this.widget.$container.offset().top - this.$scrollable.offset().top);\n      }\n\n      for (var row = 0; row < rowCount; row++) {\n        height += this.rowHeight(row);\n\n        if (scrollTop < height) {\n          index = row;\n          break;\n        }\n      }\n\n      return index;\n    }\n  }, {\n    key: \"rowHeight\",\n    value: function rowHeight(row) {\n      throw new Error('Function has to be provided by widget');\n    }\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"rowCount\",\n    value: function rowCount() {\n      throw new Error('Function has to be provided by widget');\n    }\n    /**\n     * Calculates and renders the rows which should be visible in the current viewport based on scroll top.\n     */\n\n  }, {\n    key: \"_renderViewPort\",\n    value: function _renderViewPort() {\n      var viewRange = this.calculateCurrentViewRange();\n\n      this._renderViewRange(viewRange);\n    }\n  }, {\n    key: \"_renderViewRangeForRowIndex\",\n    value: function _renderViewRangeForRowIndex(rowIndex) {\n      var viewRange = this.calculateViewRangeForRowIndex(rowIndex);\n\n      this._renderViewRange(viewRange);\n    }\n    /**\n     * Renders the rows visible in the viewport and removes the other rows\n     */\n\n  }, {\n    key: \"_renderViewRange\",\n    value: function _renderViewRange(viewRange) {\n      throw new Error('Function has to be provided by widget');\n    }\n  }]);\n\n  return VirtualScrolling;\n}();\n\nexport { VirtualScrolling as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/scrollbar/VirtualScrolling.js"],"names":["numbers","Range","scout","$","VirtualScrolling","options","enabled","minRowHeight","scrollHandler","viewRangeSize","widget","$scrollable","extend","isNumber","Error","rendered","setViewRangeSize","calculateViewRangeSize","updateViewPort","nvl","_renderViewPort","length","rowCount","Math","ceil","height","maxViewRange","rowIndex","scrollTop","maxScrollTop","scrollHeight","clientHeight","widgetBounds","$container","getBoundingClientRect","scrollableBounds","bottom","top","_rowIndexAtScrollTop","calculateViewRangeForRowIndex","viewRange","quarterRange","floor","diff","from","max","to","min","size","index","offset","row","rowHeight","calculateCurrentViewRange","_renderViewRange"],"mappings":"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","sourcesContent":["import {numbers, Range, scout} from '../index';\nimport $ from 'jquery';\n\nexport default class VirtualScrolling {\n\n  constructor(options) {\n    this.enabled = true;\n    this.minRowHeight = 0;\n    this.scrollHandler = null;\n    this.viewRangeSize = new Range();\n    this.widget = null;\n    this.$scrollable = null;\n\n    $.extend(this, options);\n  }\n\n  setEnabled(enabled) {\n    this.enabled = enabled;\n  }\n\n  set$Scrollable($scrollable) {\n    if (this.$scrollable === $scrollable) {\n      return;\n    }\n    this.$scrollable = $scrollable;\n  }\n\n  setMinRowHeight(minRowHeight) {\n    if (this.minRowHeight === minRowHeight) {\n      return;\n    }\n    if (!numbers.isNumber(minRowHeight)) {\n      throw new Error('minRowHeight is not a number: ' + minRowHeight);\n    }\n    this.minRowHeight = minRowHeight;\n    if (this.widget.rendered) {\n      this.setViewRangeSize(this.calculateViewRangeSize());\n    }\n  }\n\n  setViewRangeSize(viewRangeSize, updateViewPort) {\n    if (this.viewRangeSize === viewRangeSize) {\n      return;\n    }\n    this.viewRangeSize = viewRangeSize;\n    if (this.widget.rendered && scout.nvl(updateViewPort, true)) {\n      this._renderViewPort();\n    }\n  }\n\n  /**\n   * Calculates the optimal view range size (number of rows to be rendered).\n   * It uses the default row height to estimate how many rows fit in the view port.\n   * The view range size is this value * 2.\n   */\n  calculateViewRangeSize() {\n    if (!this.enabled || this.$scrollable.length === 0) {\n      return this.rowCount();\n    }\n    if (this.minRowHeight === 0) {\n      throw new Error('Cannot calculate view range with rowHeight = 0');\n    }\n    return Math.ceil(this.$scrollable.height() / this.minRowHeight) * 2;\n  }\n\n  calculateCurrentViewRange() {\n    if (!this.enabled) {\n      return this.maxViewRange();\n    }\n    if (this.viewRangeSize === 0) {\n      return new Range(0, 0);\n    }\n    var rowIndex;\n    if (this.$scrollable.length === 0) {\n      return this.maxViewRange();\n    }\n    var scrollTop = this.$scrollable[0].scrollTop;\n    var maxScrollTop = this.$scrollable[0].scrollHeight - this.$scrollable[0].clientHeight;\n    var widgetBounds = this.widget.$container[0].getBoundingClientRect();\n    var scrollableBounds = this.$scrollable[0].getBoundingClientRect();\n    if (widgetBounds.height > 0 && (\n      widgetBounds.bottom < scrollableBounds.top ||\n      widgetBounds.top > scrollableBounds.bottom)) {\n      // If widget is not in the view port, no need to draw any row\n      return new Range(0, 0);\n    }\n\n    if (maxScrollTop === 0) {\n      // no scrollbars visible\n      rowIndex = 0;\n    } else {\n      rowIndex = this._rowIndexAtScrollTop(scrollTop);\n    }\n\n    return this.calculateViewRangeForRowIndex(rowIndex);\n  }\n\n  maxViewRange() {\n    return new Range(0, this.rowCount());\n  }\n\n  /**\n   * Returns a range of size this.viewRangeSize. Start of range is rowIndex - viewRangeSize / 4.\n   * -> 1/4 of the rows are before the viewport 2/4 in the viewport 1/4 after the viewport,\n   * assuming viewRangeSize is 2*number of possible rows in the viewport (see calculateViewRangeSize).\n   */\n  calculateViewRangeForRowIndex(rowIndex) {\n    if (!this.enabled) {\n      return this.maxViewRange();\n    }\n\n    var viewRange = new Range(),\n      quarterRange = Math.floor(this.viewRangeSize / 4),\n      diff;\n\n    viewRange.from = Math.max(rowIndex - quarterRange, 0);\n    viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.rowCount());\n\n    // Try to use the whole viewRangeSize (extend from if necessary)\n    diff = this.viewRangeSize - viewRange.size();\n    if (diff > 0) {\n      viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);\n    }\n    return viewRange;\n  }\n\n  /**\n   * Returns the index of the row which is at position scrollTop.\n   */\n  _rowIndexAtScrollTop(scrollTop) {\n    var height = 0,\n      rowCount = this.rowCount(),\n      index = rowCount - 1;\n\n    if (this.widget.$container[0] !== this.$scrollable[0]) {\n      // If container itself is not scrollable but a parent, height must not start at 0\n      height = scrollTop + (this.widget.$container.offset().top - this.$scrollable.offset().top);\n    }\n\n    for (var row = 0; row < rowCount; row++) {\n      height += this.rowHeight(row);\n      if (scrollTop < height) {\n        index = row;\n        break;\n      }\n    }\n    return index;\n  }\n\n  rowHeight(row) {\n    throw new Error('Function has to be provided by widget');\n  }\n\n  /**\n   * @returns {number}\n   */\n  rowCount() {\n    throw new Error('Function has to be provided by widget');\n  }\n\n  /**\n   * Calculates and renders the rows which should be visible in the current viewport based on scroll top.\n   */\n  _renderViewPort() {\n    var viewRange = this.calculateCurrentViewRange();\n    this._renderViewRange(viewRange);\n  }\n\n  _renderViewRangeForRowIndex(rowIndex) {\n    var viewRange = this.calculateViewRangeForRowIndex(rowIndex);\n    this._renderViewRange(viewRange);\n  }\n\n  /**\n   * Renders the rows visible in the viewport and removes the other rows\n   */\n  _renderViewRange(viewRange) {\n    throw new Error('Function has to be provided by widget');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}