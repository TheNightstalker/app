{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, LookupRow, objects, ProposalChooser, scout, Tree } from '../../../index';\n\nvar TreeProposalChooser = /*#__PURE__*/function (_ProposalChooser) {\n  _inherits(TreeProposalChooser, _ProposalChooser);\n\n  var _super = _createSuper(TreeProposalChooser);\n\n  function TreeProposalChooser() {\n    _classCallCheck(this, TreeProposalChooser);\n\n    return _super.call(this);\n  }\n\n  _createClass(TreeProposalChooser, [{\n    key: \"_createModel\",\n    value: function _createModel() {\n      var tree = scout.create('Tree', {\n        parent: this,\n        requestFocusOnNodeControlMouseDown: false,\n        scrollToSelection: true\n      });\n      tree.on('nodeClick', this._onNodeClick.bind(this));\n      return tree;\n    }\n  }, {\n    key: \"_onNodeClick\",\n    value: function _onNodeClick(event) {\n      this.triggerLookupRowSelected(event.node);\n    }\n  }, {\n    key: \"selectedRow\",\n    value: function selectedRow() {\n      return this.model.selectedNode();\n    }\n  }, {\n    key: \"isBrowseLoadIncremental\",\n    value: function isBrowseLoadIncremental() {\n      return this.smartField.browseLoadIncremental;\n    }\n  }, {\n    key: \"getSelectedLookupRow\",\n    value: function getSelectedLookupRow() {\n      var selectedNode = this.model.selectedNode();\n\n      if (!selectedNode) {\n        return null;\n      }\n\n      return selectedNode.lookupRow;\n    }\n  }, {\n    key: \"selectFirstLookupRow\",\n    value: function selectFirstLookupRow() {\n      if (this.model.nodes.length) {\n        this.model.selectNode(this.model.nodes[0]);\n      }\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      this.model.deselectAll();\n    }\n    /**\n     * @param {LookupRow[]} lookupRows\n     * @param {boolean} appendResult whether or not we must delete the tree\n     */\n\n  }, {\n    key: \"setLookupResult\",\n    value: function setLookupResult(result) {\n      var treeNodes,\n          treeNodesFlat,\n          lookupRows = result.lookupRows,\n          appendResult = scout.nvl(result.appendResult, false);\n\n      if (appendResult) {\n        treeNodesFlat = lookupRows.map(this._createTreeNode.bind(this));\n        treeNodes = this._flatListToSubTree(treeNodesFlat);\n\n        if (treeNodes.length) {\n          var parentNode = null;\n          treeNodes.forEach(function (treeNode) {\n            parentNode = this.model.nodesMap[treeNode.parentId];\n\n            this._appendChildNode(parentNode, treeNode);\n          }.bind(this));\n\n          if (parentNode) {\n            this.model.insertNodes(treeNodes, parentNode);\n          }\n        } else {\n          // remove control icon, when no child nodes are available\n          var node = this.model.nodesMap[result.rec];\n          node.leaf = true;\n          node.childrenLoaded = true;\n          this.model.updateNode(node);\n        }\n      } else {\n        this.model.deleteAllChildNodes();\n        treeNodesFlat = lookupRows.map(this._createTreeNode.bind(this));\n        treeNodes = this._flatListToSubTree(treeNodesFlat);\n\n        if (result.byText) {\n          this._expandAllParentNodes(treeNodesFlat);\n        }\n\n        this.model.insertNodes(treeNodes);\n      }\n\n      this._selectProposal(result, treeNodesFlat);\n    }\n  }, {\n    key: \"_expandAllParentNodes\",\n    value: function _expandAllParentNodes(treeNodesFlat) {\n      // when tree node is a leaf or children are not loaded yet\n      var leafs = treeNodesFlat.reduce(function (aggr, treeNode) {\n        if (treeNode.leaf || !treeNode.childNodesLoaded && treeNode.childNodes.length === 0) {\n          aggr.push(treeNode);\n        }\n\n        return aggr;\n      }, []);\n      leafs.forEach(expandPath.bind(this));\n\n      function expandPath(treeNode) {\n        if (!treeNode.parentNode || treeNode.parentNode.expanded) {\n          return;\n        }\n\n        treeNode = treeNode.parentNode;\n\n        while (treeNode) {\n          this.model.setNodeExpanded(treeNode, true);\n          treeNode = treeNode.parentNode;\n        }\n      }\n    }\n  }, {\n    key: \"trySelectCurrentValue\",\n    value: function trySelectCurrentValue() {\n      var currentValue = this.smartField.getValueForSelection();\n\n      if (objects.isNullOrUndefined(currentValue)) {\n        return;\n      }\n\n      var allTreeNodes = objects.values(this.model.nodesMap);\n      var treeNode = arrays.find(allTreeNodes, function (node) {\n        return node.lookupRow.key === currentValue;\n      });\n\n      if (treeNode) {\n        this.model.selectNode(treeNode);\n      }\n    }\n  }, {\n    key: \"_createTreeNode\",\n    value: function _createTreeNode(lookupRow) {\n      var initialLeaf = true,\n          expandAll = this.smartField.browseAutoExpandAll,\n          loadIncremental = this.isBrowseLoadIncremental();\n\n      if (loadIncremental) {\n        // when smartfield / lookup is configured as 'load incremental' it cannot expand all tree nodes\n        // because then we'd load the whole tree anyway, which is not the idea of load incremental\n        expandAll = false; // when smartfield / lookup is configured as 'load incremental' we don't know if a node has children\n        // or not until we've made a lookup for that node. Thus all nodes are initially leaf=false, so the UI\n        // shows the expand icon.\n\n        initialLeaf = false;\n      }\n\n      return scout.create('ProposalTreeNode', {\n        parent: this.model,\n        proposalChooser: this,\n        childNodeIndex: 0,\n        enabled: lookupRow.enabled,\n        htmlEnabled: false,\n        iconId: lookupRow.iconId,\n        id: lookupRow.key,\n        parentId: lookupRow.parentKey,\n        expanded: expandAll,\n        initialExpanded: expandAll,\n        text: lookupRow.text,\n        lookupRow: lookupRow,\n        leaf: initialLeaf,\n        tooltipText: lookupRow.tooltipText\n      });\n    }\n    /**\n     * This function is required in the 'accept input' case to find out\n     * if we have exactly one lookup row that matches. With a tree this is a bit difficult\n     * because the lookup call does not only return the lookup rows with a match, but also\n     * their parent nodes up to the root node (which don't match).\n     *\n     * Note: because we only match nodes that have the property leaf set to true, it's not\n     * possible to accept a node with accept input that is not a leaf.\n     *\n     * @returns {TreeNode[]} the leafs in the current tree model.\n     */\n\n  }, {\n    key: \"findLeafs\",\n    value: function findLeafs() {\n      var leafs = [];\n      Tree.visitNodes(function (node, parentNode) {\n        if (node.leaf || !node.childNodes.length) {\n          leafs.push(node);\n        }\n      }, this.model.nodes);\n      return leafs;\n    }\n    /**\n     * This function creates a sub-tree from a list of flat tree nodes. It sets the parent/child references\n     * between the nodes and returns the top-level nodes of the sub-tree. This subtree is not yet attached\n     * to the real tree (= this.model).\n     */\n\n  }, {\n    key: \"_flatListToSubTree\",\n    value: function _flatListToSubTree(treeNodesFlat) {\n      // 1. put all nodes with the same parent in a map (key=parentId, value=[nodes])\n      var nodesMap = {};\n      treeNodesFlat.forEach(function (treeNode) {\n        nodesMap[treeNode.id] = treeNode;\n      });\n      var rootNodes = []; // 2. based on this map, set the childNodes references on the treeNodes\n\n      treeNodesFlat.forEach(function (treeNode) {\n        var parentNode = nodesMap[treeNode.parentId];\n\n        if (parentNode) {\n          this._appendChildNode(parentNode, treeNode);\n        } else {\n          treeNode.childNodeIndex = rootNodes.length;\n          treeNode.parentNode = null;\n          rootNodes.push(treeNode);\n        }\n      }.bind(this));\n      return rootNodes;\n    }\n    /**\n     * This functions appends a tree node to a parent node and sets the required flags on the parent node.\n     */\n\n  }, {\n    key: \"_appendChildNode\",\n    value: function _appendChildNode(parentNode, treeNode) {\n      if (!parentNode.childNodes) {\n        parentNode.childNodes = [];\n      }\n\n      treeNode.childNodeIndex = parentNode.childNodes.length;\n      treeNode.parentNode = parentNode;\n      parentNode.childNodes.push(treeNode);\n      parentNode.leaf = false;\n      parentNode.childrenLoaded = true;\n    }\n  }, {\n    key: \"clearLookupRows\",\n    value: function clearLookupRows() {\n      this.model.deleteAllNodes();\n    }\n  }]);\n\n  return TreeProposalChooser;\n}(ProposalChooser);\n\nexport { TreeProposalChooser as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/form/fields/smartfield/TreeProposalChooser.js"],"names":["arrays","LookupRow","objects","ProposalChooser","scout","Tree","TreeProposalChooser","tree","create","parent","requestFocusOnNodeControlMouseDown","scrollToSelection","on","_onNodeClick","bind","event","triggerLookupRowSelected","node","model","selectedNode","smartField","browseLoadIncremental","lookupRow","nodes","length","selectNode","deselectAll","result","treeNodes","treeNodesFlat","lookupRows","appendResult","nvl","map","_createTreeNode","_flatListToSubTree","parentNode","forEach","treeNode","nodesMap","parentId","_appendChildNode","insertNodes","rec","leaf","childrenLoaded","updateNode","deleteAllChildNodes","byText","_expandAllParentNodes","_selectProposal","leafs","reduce","aggr","childNodesLoaded","childNodes","push","expandPath","expanded","setNodeExpanded","currentValue","getValueForSelection","isNullOrUndefined","allTreeNodes","values","find","key","initialLeaf","expandAll","browseAutoExpandAll","loadIncremental","isBrowseLoadIncremental","proposalChooser","childNodeIndex","enabled","htmlEnabled","iconId","id","parentKey","initialExpanded","text","tooltipText","visitNodes","rootNodes","deleteAllNodes"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, LookupRow, objects, ProposalChooser, scout, Tree} from '../../../index';\n\nexport default class TreeProposalChooser extends ProposalChooser {\n\n  constructor() {\n    super();\n  }\n\n  _createModel() {\n    var tree = scout.create('Tree', {\n      parent: this,\n      requestFocusOnNodeControlMouseDown: false,\n      scrollToSelection: true\n    });\n    tree.on('nodeClick', this._onNodeClick.bind(this));\n    return tree;\n  }\n\n  _onNodeClick(event) {\n    this.triggerLookupRowSelected(event.node);\n  }\n\n  selectedRow() {\n    return this.model.selectedNode();\n  }\n\n  isBrowseLoadIncremental() {\n    return this.smartField.browseLoadIncremental;\n  }\n\n  getSelectedLookupRow() {\n    var selectedNode = this.model.selectedNode();\n    if (!selectedNode) {\n      return null;\n    }\n    return selectedNode.lookupRow;\n  }\n\n  selectFirstLookupRow() {\n    if (this.model.nodes.length) {\n      this.model.selectNode(this.model.nodes[0]);\n    }\n  }\n\n  clearSelection() {\n    this.model.deselectAll();\n  }\n\n  /**\n   * @param {LookupRow[]} lookupRows\n   * @param {boolean} appendResult whether or not we must delete the tree\n   */\n  setLookupResult(result) {\n    var treeNodes, treeNodesFlat,\n      lookupRows = result.lookupRows,\n      appendResult = scout.nvl(result.appendResult, false);\n\n    if (appendResult) {\n      treeNodesFlat = lookupRows.map(this._createTreeNode.bind(this));\n      treeNodes = this._flatListToSubTree(treeNodesFlat);\n      if (treeNodes.length) {\n        var parentNode = null;\n        treeNodes.forEach(function(treeNode) {\n          parentNode = this.model.nodesMap[treeNode.parentId];\n          this._appendChildNode(parentNode, treeNode);\n        }.bind(this));\n        if (parentNode) {\n          this.model.insertNodes(treeNodes, parentNode);\n        }\n      } else {\n        // remove control icon, when no child nodes are available\n        var node = this.model.nodesMap[result.rec];\n        node.leaf = true;\n        node.childrenLoaded = true;\n        this.model.updateNode(node);\n      }\n    } else {\n      this.model.deleteAllChildNodes();\n      treeNodesFlat = lookupRows.map(this._createTreeNode.bind(this));\n      treeNodes = this._flatListToSubTree(treeNodesFlat);\n      if (result.byText) {\n        this._expandAllParentNodes(treeNodesFlat);\n      }\n      this.model.insertNodes(treeNodes);\n    }\n\n    this._selectProposal(result, treeNodesFlat);\n  }\n\n  _expandAllParentNodes(treeNodesFlat) {\n    // when tree node is a leaf or children are not loaded yet\n    var leafs = treeNodesFlat.reduce(function(aggr, treeNode) {\n      if (treeNode.leaf || !treeNode.childNodesLoaded && treeNode.childNodes.length === 0) {\n        aggr.push(treeNode);\n      }\n      return aggr;\n    }, []);\n    leafs.forEach(expandPath.bind(this));\n\n    function expandPath(treeNode) {\n      if (!treeNode.parentNode || treeNode.parentNode.expanded) {\n        return;\n      }\n      treeNode = treeNode.parentNode;\n      while (treeNode) {\n        this.model.setNodeExpanded(treeNode, true);\n        treeNode = treeNode.parentNode;\n      }\n    }\n  }\n\n  trySelectCurrentValue() {\n    var currentValue = this.smartField.getValueForSelection();\n    if (objects.isNullOrUndefined(currentValue)) {\n      return;\n    }\n    var allTreeNodes = objects.values(this.model.nodesMap);\n    var treeNode = arrays.find(allTreeNodes, function(node) {\n      return node.lookupRow.key === currentValue;\n    });\n    if (treeNode) {\n      this.model.selectNode(treeNode);\n    }\n  }\n\n  _createTreeNode(lookupRow) {\n    var\n      initialLeaf = true,\n      expandAll = this.smartField.browseAutoExpandAll,\n      loadIncremental = this.isBrowseLoadIncremental();\n\n    if (loadIncremental) {\n      // when smartfield / lookup is configured as 'load incremental' it cannot expand all tree nodes\n      // because then we'd load the whole tree anyway, which is not the idea of load incremental\n      expandAll = false;\n\n      // when smartfield / lookup is configured as 'load incremental' we don't know if a node has children\n      // or not until we've made a lookup for that node. Thus all nodes are initially leaf=false, so the UI\n      // shows the expand icon.\n      initialLeaf = false;\n    }\n\n    return scout.create('ProposalTreeNode', {\n      parent: this.model,\n      proposalChooser: this,\n      childNodeIndex: 0,\n      enabled: lookupRow.enabled,\n      htmlEnabled: false,\n      iconId: lookupRow.iconId,\n      id: lookupRow.key,\n      parentId: lookupRow.parentKey,\n      expanded: expandAll,\n      initialExpanded: expandAll,\n      text: lookupRow.text,\n      lookupRow: lookupRow,\n      leaf: initialLeaf,\n      tooltipText: lookupRow.tooltipText\n    });\n  }\n\n  /**\n   * This function is required in the 'accept input' case to find out\n   * if we have exactly one lookup row that matches. With a tree this is a bit difficult\n   * because the lookup call does not only return the lookup rows with a match, but also\n   * their parent nodes up to the root node (which don't match).\n   *\n   * Note: because we only match nodes that have the property leaf set to true, it's not\n   * possible to accept a node with accept input that is not a leaf.\n   *\n   * @returns {TreeNode[]} the leafs in the current tree model.\n   */\n  findLeafs() {\n    var leafs = [];\n    Tree.visitNodes(function(node, parentNode) {\n      if (node.leaf || !node.childNodes.length) {\n        leafs.push(node);\n      }\n    }, this.model.nodes);\n    return leafs;\n  }\n\n  /**\n   * This function creates a sub-tree from a list of flat tree nodes. It sets the parent/child references\n   * between the nodes and returns the top-level nodes of the sub-tree. This subtree is not yet attached\n   * to the real tree (= this.model).\n   */\n  _flatListToSubTree(treeNodesFlat) {\n    // 1. put all nodes with the same parent in a map (key=parentId, value=[nodes])\n    var nodesMap = {};\n    treeNodesFlat.forEach(function(treeNode) {\n      nodesMap[treeNode.id] = treeNode;\n    });\n\n    var rootNodes = [];\n\n    // 2. based on this map, set the childNodes references on the treeNodes\n    treeNodesFlat.forEach(function(treeNode) {\n      var parentNode = nodesMap[treeNode.parentId];\n      if (parentNode) {\n        this._appendChildNode(parentNode, treeNode);\n      } else {\n        treeNode.childNodeIndex = rootNodes.length;\n        treeNode.parentNode = null;\n        rootNodes.push(treeNode);\n      }\n    }.bind(this));\n\n    return rootNodes;\n  }\n\n  /**\n   * This functions appends a tree node to a parent node and sets the required flags on the parent node.\n   */\n  _appendChildNode(parentNode, treeNode) {\n    if (!parentNode.childNodes) {\n      parentNode.childNodes = [];\n    }\n    treeNode.childNodeIndex = parentNode.childNodes.length;\n    treeNode.parentNode = parentNode;\n    parentNode.childNodes.push(treeNode);\n    parentNode.leaf = false;\n    parentNode.childrenLoaded = true;\n  }\n\n  clearLookupRows() {\n    this.model.deleteAllNodes();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}