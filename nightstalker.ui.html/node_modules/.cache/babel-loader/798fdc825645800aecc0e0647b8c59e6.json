{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { CloseKeyStroke, DialogLayout, Dimension, Event, FocusRule, GlassPaneRenderer, graphics, HtmlComponent, Insets, KeyStrokeContext, Point, PopupLayout, Rectangle, scout, scrollbars, strings, Widget } from '../index';\nimport $ from 'jquery';\n\nvar Popup = /*#__PURE__*/function (_Widget) {\n  _inherits(Popup, _Widget);\n\n  var _super = _createSuper(Popup);\n\n  function Popup() {\n    var _this;\n\n    _classCallCheck(this, Popup);\n\n    _this = _super.call(this);\n    _this._documentMouseDownHandler = null;\n    _this._anchorScrollHandler = null;\n    _this._anchorLocationChangeHandler = null;\n    _this._popupOpenHandler = null;\n    _this._glassPaneRenderer = null;\n    _this.anchorBounds = null;\n    _this.animateOpening = false;\n    _this.animateResize = false;\n    _this.anchor = null;\n    _this.$anchor = null;\n    _this.windowPaddingX = 10;\n    _this.windowPaddingY = 5;\n    _this.withGlassPane = false;\n    _this.withFocusContext = true;\n\n    _this.initialFocus = function () {\n      return FocusRule.AUTO;\n    };\n\n    _this.focusableContainer = false; // The alignment defines how the popup is positioned around the anchor.\n    // If there is no anchor or anchor bounds the alignment has no effect.\n\n    _this.horizontalAlignment = Popup.Alignment.LEFTEDGE;\n    _this.verticalAlignment = Popup.Alignment.BOTTOM; // Gives the current alignment after applying horizontal and vertical switch options\n\n    _this.calculatedHorizontalAlignment = _this.horizontalAlignment;\n    _this.calculatedVerticalAlignment = _this.verticalAlignment; // If switch is enabled, the alignment will be changed if the popup overlaps a window border.\n\n    _this.horizontalSwitch = false;\n    _this.verticalSwitch = true; // Hints for the layout to control whether the size should be adjusted if the popup does not fit into the window.\n    // Before trimming is applied the popup will be switched, if the switch option is enabled.\n    // If neither switch nor trim is enabled, the popup will be moved until its right border is visible.\n\n    _this.trimWidth = false;\n    _this.trimHeight = true; // Defines what should happen when the scroll parent is scrolled. It is also used if the anchor changes its location (needs to support the locationChange event)\n\n    _this.scrollType = 'remove';\n    _this.windowResizeType = null; // If true, the anchor is considered when computing the position and size of the popup\n\n    _this.boundToAnchor = true; // If true, an arrow is shown pointing to the anchor. If there is no anchor, no arrow will be visible.\n    // Please note: some alignment combinations are not supported, which are: LEFT or RIGHT + BOTTOM or TOP\n\n    _this.withArrow = false; // If false, the attached mouse down handler will NOT close the popup if the anchor was clicked, the anchor is responsible to close it.\n    // This is necessary because the mousedown listener is attached to the capture phase and therefore executed before any other.\n    // If anchor was clicked, popup would already be closed and then opened again -> popup could never be closed by clicking the anchor\n\n    _this.closeOnAnchorMouseDown = true; // Defines whether the popup should be closed on a mouse click outside of the popup\n\n    _this.closeOnMouseDownOutside = true; // Defines whether the popup should be closed whenever another popup opens.\n\n    _this.closeOnOtherPopupOpen = true;\n    _this._openLater = false;\n    _this.$arrow = null;\n    _this.$arrowOverlay = null;\n    _this._windowResizeHandler = _this._onWindowResize.bind(_assertThisInitialized(_this));\n    _this._anchorRenderHandler = _this._onAnchorRender.bind(_assertThisInitialized(_this));\n\n    _this._addWidgetProperties(['anchor']);\n\n    _this._addPreserveOnPropertyChangeProperties(['anchor']);\n\n    return _this;\n  } // Note that these strings are also used as CSS classes\n\n\n  _createClass(Popup, [{\n    key: \"_init\",\n\n    /**\n     * @param options:\n     *          initialFocus: a function that returns the element to be focused or a <code>FocusRule</code>. Default returns <code>FocusRule.AUTO</code>\n     *          focusableContainer: a boolean whether or not the container of the Popup is focusable\n     */\n    value: function _init(options) {\n      _get(_getPrototypeOf(Popup.prototype), \"_init\", this).call(this, options);\n\n      if (options.location) {\n        this.anchorBounds = new Rectangle(options.location.x, options.location.y, 0, 0);\n      }\n\n      if (this.withGlassPane) {\n        this._glassPaneRenderer = new GlassPaneRenderer(this);\n      }\n\n      this._setAnchor(this.anchor);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_createKeyStrokeContext\",\n    value: function _createKeyStrokeContext() {\n      return new KeyStrokeContext();\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_initKeyStrokeContext\",\n    value: function _initKeyStrokeContext() {\n      _get(_getPrototypeOf(Popup.prototype), \"_initKeyStrokeContext\", this).call(this);\n\n      this.keyStrokeContext.registerKeyStroke(this._createCloseKeyStroke());\n    }\n    /**\n     * Override this method to provide a key stroke which closes the popup.\n     * The default impl. returns a CloseKeyStroke which handles the ESC key.\n     */\n\n  }, {\n    key: \"_createCloseKeyStroke\",\n    value: function _createCloseKeyStroke() {\n      return new CloseKeyStroke(this);\n    }\n  }, {\n    key: \"_createLayout\",\n    value: function _createLayout() {\n      return new PopupLayout(this);\n    }\n  }, {\n    key: \"_openWithoutParent\",\n    value: function _openWithoutParent() {\n      // resolve parent for entry-point (don't change the actual property)\n      var parent = this.parent;\n\n      if (parent.destroyed) {\n        return;\n      }\n\n      if (parent.rendered || parent.rendering) {\n        this.open(parent.entryPoint());\n        return;\n      } // This is important for popups rendered in another (native) browser window. The DOM in the popup window\n      // is rendered later, so we must wait until that window is rendered and layouted. See popup-window.html.\n\n\n      parent.one('render', function () {\n        this.session.layoutValidator.schedulePostValidateFunction(function () {\n          if (this.destroyed || this.rendered) {\n            return;\n          }\n\n          this.open();\n        }.bind(this));\n      }.bind(this));\n    }\n  }, {\n    key: \"open\",\n    value: function open($parent) {\n      if (!$parent) {\n        this._openWithoutParent();\n\n        return;\n      }\n\n      this._triggerPopupOpenEvent();\n\n      this._open($parent);\n\n      if (this._openLater) {\n        return;\n      } // Focus the popup\n      // It is important that this happens after layouting and positioning, otherwise we'd focus an element\n      // that is currently not on the screen. Which would cause the whole desktop to\n      // be shifted for a few pixels.\n\n\n      this.validateFocus();\n\n      if (this.animateOpening) {\n        this.$container.addClassForAnimation('animate-open');\n      }\n    }\n  }, {\n    key: \"validateFocus\",\n    value: function validateFocus() {\n      if (!this.withFocusContext) {\n        return;\n      }\n\n      var context = this.session.focusManager.getFocusContext(this.$container);\n      context.ready();\n\n      if (!context.lastValidFocusedElement) {\n        // No widget requested focus -> try to determine the initial focus\n        this._requestInitialFocus();\n      }\n    }\n  }, {\n    key: \"_requestInitialFocus\",\n    value: function _requestInitialFocus() {\n      var initialFocusElement = this.session.focusManager.evaluateFocusRule(this.$container, this.initialFocus());\n\n      if (!initialFocusElement) {\n        return;\n      }\n\n      this.session.focusManager.requestFocus(initialFocusElement);\n    }\n  }, {\n    key: \"_open\",\n    value: function _open($parent) {\n      this.render($parent);\n\n      if (this._openLater) {\n        return;\n      }\n\n      this.revalidateLayout();\n      this.position();\n    }\n  }, {\n    key: \"render\",\n    value: function render($parent) {\n      var $popupParent = $parent || this.entryPoint(); // when the parent is detached it is not possible to render the popup -> do it later\n\n      if (!$popupParent || !$popupParent.length || !$popupParent.isAttached()) {\n        this._openLater = true;\n        return;\n      }\n\n      _get(_getPrototypeOf(Popup.prototype), \"render\", this).call(this, $popupParent);\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      this.$container = this.$parent.appendDiv('popup');\n      this.htmlComp = HtmlComponent.install(this.$container, this.session);\n      this.htmlComp.validateRoot = true;\n      this.htmlComp.setLayout(this._createLayout());\n      this.$container.window().on('resize', this._windowResizeHandler);\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      _get(_getPrototypeOf(Popup.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderAnchor();\n\n      this._renderWithArrow();\n\n      this._renderWithFocusContext();\n\n      this._renderWithGlassPane();\n    }\n  }, {\n    key: \"_postRender\",\n    value: function _postRender() {\n      _get(_getPrototypeOf(Popup.prototype), \"_postRender\", this).call(this);\n\n      this.size();\n\n      this._attachCloseHandlers();\n\n      this._attachAnchorHandlers();\n\n      this._handleGlassPanes();\n    }\n  }, {\n    key: \"_onAttach\",\n    value: function _onAttach() {\n      _get(_getPrototypeOf(Popup.prototype), \"_onAttach\", this).call(this);\n\n      if (this._openLater && !this.rendered) {\n        this._openLater = false;\n        this.open();\n      }\n    }\n  }, {\n    key: \"_renderOnDetach\",\n    value: function _renderOnDetach() {\n      this._openLater = true;\n      this.remove();\n\n      _get(_getPrototypeOf(Popup.prototype), \"_renderOnDetach\", this).call(this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var currentAnimateRemoval = this.animateRemoval;\n\n      if (this.boundToAnchor && this.$anchor && !this._isInView()) {\n        this.animateRemoval = false;\n      }\n\n      _get(_getPrototypeOf(Popup.prototype), \"remove\", this).call(this);\n\n      this.animateRemoval = currentAnimateRemoval;\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      this.$container.window().off('resize', this._windowResizeHandler);\n\n      if (this._glassPaneRenderer) {\n        this._glassPaneRenderer.removeGlassPanes();\n      }\n\n      if (this.withFocusContext) {\n        this.session.focusManager.uninstallFocusContext(this.$container);\n      }\n\n      if (this.$arrow) {\n        this.$arrow.remove();\n        this.$arrow = null;\n      }\n\n      if (this.anchor) {\n        // reopen when the anchor gets rendered again\n        this.anchor.one('render', this._anchorRenderHandler);\n      } // remove all clean-up handlers\n\n\n      this._detachAnchorHandlers();\n\n      this._detachCloseHandlers();\n\n      _get(_getPrototypeOf(Popup.prototype), \"_remove\", this).call(this);\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      if (this.anchor) {\n        this.anchor.off('render', this._anchorRenderHandler);\n      }\n\n      _get(_getPrototypeOf(Popup.prototype), \"_destroy\", this).call(this);\n    }\n  }, {\n    key: \"_renderWithFocusContext\",\n    value: function _renderWithFocusContext() {\n      if (this.withFocusContext) {\n        // Don't allow an element to be focused while the popup is opened.\n        // The popup will focus the element as soon as the opening is finished (see open());\n        // The context needs to be already installed so that child elements don't try to focus an element outside of this context\n        this.session.focusManager.installFocusContext(this.$container, FocusRule.PREPARE);\n      } // Add programmatic 'tabindex' if the $container itself should be focusable (used by context menu popups with no focusable elements)\n\n\n      if (this.withFocusContext && this.focusableContainer) {\n        this.$container.attr('tabindex', -1);\n      }\n    }\n  }, {\n    key: \"_renderWithGlassPane\",\n    value: function _renderWithGlassPane() {\n      if (this._glassPaneRenderer) {\n        this._glassPaneRenderer.renderGlassPanes();\n      }\n    }\n  }, {\n    key: \"setWithArrow\",\n    value: function setWithArrow(withArrow) {\n      this.setProperty('withArrow', withArrow);\n    }\n  }, {\n    key: \"_renderWithArrow\",\n    value: function _renderWithArrow() {\n      if (this.$arrow) {\n        this.$arrow.remove();\n        this.$arrow = null;\n      }\n\n      if (this.$arrowOverlay) {\n        this.$arrowOverlay.remove();\n        this.$arrowOverlay = null;\n      }\n\n      if (this.withArrow) {\n        this.$arrowOverlay = this.$container.prependDiv('popup-arrow-overlay');\n        this.$arrow = this.$container.prependDiv('popup-arrow');\n\n        this._updateArrowClass();\n      }\n\n      this.$container.toggleClass('with-arrow', this.withArrow);\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"_updateArrowClass\",\n    value: function _updateArrowClass(verticalAlignment, horizontalAlignment) {\n      if (this.$arrow) {\n        this.$arrow.removeClass(this._alignClasses());\n        this.$arrow.addClass(this._computeArrowPositionClass(verticalAlignment, horizontalAlignment));\n      }\n    }\n  }, {\n    key: \"_computeArrowPositionClass\",\n    value: function _computeArrowPositionClass(verticalAlignment, horizontalAlignment) {\n      var Alignment = Popup.Alignment;\n      var cssClass = '';\n      horizontalAlignment = horizontalAlignment || this.horizontalAlignment;\n      verticalAlignment = verticalAlignment || this.verticalAlignment;\n\n      switch (horizontalAlignment) {\n        case Alignment.LEFT:\n          cssClass = Alignment.RIGHT;\n          break;\n\n        case Alignment.RIGHT:\n          cssClass = Alignment.LEFT;\n          break;\n\n        default:\n          cssClass = horizontalAlignment;\n          break;\n      }\n\n      switch (verticalAlignment) {\n        case Alignment.BOTTOM:\n          cssClass += ' ' + Alignment.TOP;\n          break;\n\n        case Alignment.TOP:\n          cssClass += ' ' + Alignment.BOTTOM;\n          break;\n\n        default:\n          cssClass += ' ' + verticalAlignment;\n          break;\n      }\n\n      return cssClass;\n    }\n  }, {\n    key: \"_isRemovalPrevented\",\n    value: function _isRemovalPrevented() {\n      // Never prevent. Default returns true if removal is pending by an animation, but popups should be closed before the animation starts\n      return false;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      var event = new Event();\n      this.trigger('close', event);\n\n      if (!event.defaultPrevented) {\n        this.destroy();\n      }\n    }\n    /**\n     * Install listeners to close the popup once clicking outside the popup,\n     * or changing the anchor's scroll position, or another popup is opened.\n     */\n\n  }, {\n    key: \"_attachCloseHandlers\",\n    value: function _attachCloseHandlers() {\n      // Install mouse close handler\n      // The listener needs to be executed in the capturing phase -> prevents that _onDocumentMouseDown will be executed right after the popup gets opened using mouse down, otherwise the popup would be closed immediately\n      if (this.closeOnMouseDownOutside) {\n        this._documentMouseDownHandler = this._onDocumentMouseDown.bind(this);\n        this.$container.document(true).addEventListener('mousedown', this._documentMouseDownHandler, true); // true=the event handler is executed in the capturing phase\n      } // Install popup open close handler\n\n\n      if (this.closeOnOtherPopupOpen) {\n        this._popupOpenHandler = this._onPopupOpen.bind(this);\n        this.session.desktop.on('popupOpen', this._popupOpenHandler);\n      }\n    }\n  }, {\n    key: \"_attachAnchorHandlers\",\n    value: function _attachAnchorHandlers() {\n      if (!this.$anchor || !this.boundToAnchor || !this.scrollType) {\n        return;\n      } // Attach a scroll handler to each scrollable parent of the anchor\n\n\n      this._anchorScrollHandler = this._onAnchorScroll.bind(this);\n      scrollbars.onScroll(this.$anchor, this._anchorScrollHandler); // Attach a location change handler as well (will only work if the anchor is a widget which triggers a locationChange event, e.g. another Popup)\n\n      var anchor = scout.widget(this.$anchor);\n\n      if (anchor) {\n        this._anchorLocationChangeHandler = this._onAnchorLocationChange.bind(this);\n        anchor.on('locationChange', this._anchorLocationChangeHandler);\n      }\n    }\n  }, {\n    key: \"_detachAnchorHandlers\",\n    value: function _detachAnchorHandlers() {\n      if (this._anchorScrollHandler) {\n        scrollbars.offScroll(this._anchorScrollHandler);\n        this._anchorScrollHandler = null;\n      }\n\n      if (this._anchorLocationChangeHandler) {\n        var anchor = scout.widget(this.$anchor);\n\n        if (anchor) {\n          anchor.off('locationChange', this._anchorLocationChangeHandler);\n          this._anchorLocationChangeHandler = null;\n        }\n      }\n    }\n  }, {\n    key: \"_detachCloseHandlers\",\n    value: function _detachCloseHandlers() {\n      // Uninstall popup open close handler\n      if (this._popupOpenHandler) {\n        this.session.desktop.off('popupOpen', this._popupOpenHandler);\n        this._popupOpenHandler = null;\n      } // Uninstall mouse close handler\n\n\n      if (this._documentMouseDownHandler) {\n        this.$container.document(true).removeEventListener('mousedown', this._documentMouseDownHandler, true);\n        this._documentMouseDownHandler = null;\n      }\n    }\n  }, {\n    key: \"_onDocumentMouseDown\",\n    value: function _onDocumentMouseDown(event) {\n      // in some cases the mousedown handler is executed although it has been already\n      // detached on the _remove() method. However, since we're in the middle of\n      // processing the mousedown event, it's too late to detach the event and we must\n      // deal with that situation by checking the rendered flag. Otherwise we would\n      // run into an error later, since the $container is not available anymore.\n      if (!this.rendered) {\n        return;\n      }\n\n      if (this._isMouseDownOutside(event)) {\n        this._onMouseDownOutside(event);\n      }\n    }\n  }, {\n    key: \"_isMouseDownOutside\",\n    value: function _isMouseDownOutside(event) {\n      var $target = $(event.target),\n          targetWidget;\n\n      if (!this.closeOnAnchorMouseDown && this._isMouseDownOnAnchor(event)) {\n        // 1. Often times, click on the anchor opens and 2. click closes the popup\n        // If we were closing the popup here, it would not be possible to achieve the described behavior anymore -> let anchor handle open and close.\n        return false;\n      }\n\n      targetWidget = scout.widget($target); // close the popup only if the click happened outside of the popup and its children\n      // It is not sufficient to check the dom hierarchy using $container.has($target)\n      // because the popup may open other popups which probably is not a dom child but a sibling\n      // Also ignore clicks if the popup is covert by a glasspane\n\n      return !this.isOrHas(targetWidget) && !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);\n    }\n  }, {\n    key: \"_isMouseDownOnAnchor\",\n    value: function _isMouseDownOnAnchor(event) {\n      return !!this.$anchor && this.$anchor.isOrHas(event.target);\n    }\n    /**\n     * Method invoked once a mouse down event occurs outside the popup.\n     */\n\n  }, {\n    key: \"_onMouseDownOutside\",\n    value: function _onMouseDownOutside(event) {\n      this.close();\n    }\n    /**\n     * Method invoked once the 'options.$anchor' is scrolled.\n     */\n\n  }, {\n    key: \"_onAnchorScroll\",\n    value: function _onAnchorScroll(event) {\n      if (!this.rendered) {\n        // Scroll events may be fired delayed, even if scroll listeners are already removed.\n        return;\n      }\n\n      this._handleAnchorPositionChange();\n    }\n  }, {\n    key: \"_handleAnchorPositionChange\",\n    value: function _handleAnchorPositionChange(event) {\n      if (scout.isOneOf(this.scrollType, 'position', 'layoutAndPosition') && this.isOpeningAnimationRunning()) {\n        // If the popup is opened with an animation which transforms the popup the sizes used by prefSize and position will likely be wrong.\n        // In that case it is not possible to layout and position it correctly -> do nothing.\n        return;\n      }\n\n      if (this.scrollType === 'position') {\n        this.position();\n      } else if (this.scrollType === 'layoutAndPosition') {\n        this.revalidateLayout();\n        this.position();\n      } else if (this.scrollType === 'remove') {\n        this.close();\n      }\n    }\n  }, {\n    key: \"isOpeningAnimationRunning\",\n    value: function isOpeningAnimationRunning() {\n      return this.rendered && this.animateOpening && this.$container.hasClass('animate-open');\n    }\n  }, {\n    key: \"_onAnchorLocationChange\",\n    value: function _onAnchorLocationChange(event) {\n      this._handleAnchorPositionChange();\n    }\n    /**\n     * Method invoked once a popup is opened.\n     */\n\n  }, {\n    key: \"_onPopupOpen\",\n    value: function _onPopupOpen(event) {\n      // Make sure child popups don't close the parent popup, we must check parent hierarchy in both directions\n      // Use case: Opening of a context menu or cell editor in a form popup\n      // Also, popups covered by a glass pane (a modal dialog is open) must never be closed\n      // Use case: popup opens a modal dialog. User clicks on a smartfield on this dialog -> underlying popup must not get closed\n      var closable = !this.isOrHas(event.popup) && !event.popup.isOrHas(this);\n\n      if (this.rendered) {\n        closable = closable && !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);\n      }\n\n      if (closable) {\n        this.close();\n      }\n    }\n  }, {\n    key: \"setHorizontalAlignment\",\n    value: function setHorizontalAlignment(horizontalAlignment) {\n      this.setProperty('horizontalAlignment', horizontalAlignment);\n    }\n  }, {\n    key: \"_renderHorizontalAlignment\",\n    value: function _renderHorizontalAlignment() {\n      this._updateArrowClass();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"setVerticalAlignment\",\n    value: function setVerticalAlignment(verticalAlignment) {\n      this.setProperty('verticalAlignment', verticalAlignment);\n    }\n  }, {\n    key: \"_renderVerticalAlignment\",\n    value: function _renderVerticalAlignment() {\n      this._updateArrowClass();\n\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"setHorizontalSwitch\",\n    value: function setHorizontalSwitch(horizontalSwitch) {\n      this.setProperty('horizontalSwitch', horizontalSwitch);\n    }\n  }, {\n    key: \"_renderHorizontalSwitch\",\n    value: function _renderHorizontalSwitch() {\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"setVerticalSwitch\",\n    value: function setVerticalSwitch(verticalSwitch) {\n      this.setProperty('verticalSwitch', verticalSwitch);\n    }\n  }, {\n    key: \"_renderVerticalSwitch\",\n    value: function _renderVerticalSwitch() {\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"setTrimWidth\",\n    value: function setTrimWidth(trimWidth) {\n      this.setProperty('trimWidth', trimWidth);\n    }\n  }, {\n    key: \"_renderTrimWidth\",\n    value: function _renderTrimWidth() {\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"setTrimHeight\",\n    value: function setTrimHeight(trimHeight) {\n      this.setProperty('trimHeight', trimHeight);\n    }\n  }, {\n    key: \"_renderTrimHeight\",\n    value: function _renderTrimHeight() {\n      this.invalidateLayoutTree();\n    }\n  }, {\n    key: \"prefLocation\",\n    value: function prefLocation(verticalAlignment, horizontalAlignment) {\n      if (!this.boundToAnchor || !this.anchorBounds && !this.$anchor) {\n        return this._prefLocationWithoutAnchor();\n      }\n\n      return this._prefLocationWithAnchor(verticalAlignment, horizontalAlignment);\n    }\n  }, {\n    key: \"_prefLocationWithoutAnchor\",\n    value: function _prefLocationWithoutAnchor() {\n      return DialogLayout.positionContainerInWindow(this.$container);\n    }\n  }, {\n    key: \"_prefLocationWithAnchor\",\n    value: function _prefLocationWithAnchor(verticalAlignment, horizontalAlignment) {\n      var $container = this.$container;\n      horizontalAlignment = horizontalAlignment || this.horizontalAlignment;\n      verticalAlignment = verticalAlignment || this.verticalAlignment;\n      var anchorBounds = this.getAnchorBounds();\n      var size = graphics.size($container);\n      var margins = graphics.margins($container);\n      var Alignment = Popup.Alignment;\n      var arrowBounds = null;\n\n      if (this.$arrow) {\n        // Ensure the arrow has the correct class\n        this._updateArrowClass(verticalAlignment, horizontalAlignment); // Remove margin added by moving logic, otherwise the bounds would not be correct\n\n\n        graphics.setMargins(this.$arrow, new Insets());\n        arrowBounds = graphics.bounds(this.$arrow);\n      }\n\n      $container.removeClass(this._alignClasses());\n      $container.addClass(verticalAlignment + ' ' + horizontalAlignment);\n      var widthWithMargin = size.width + margins.horizontal();\n      var width = size.width;\n      var x = anchorBounds.x;\n\n      if (horizontalAlignment === Alignment.LEFT) {\n        x -= widthWithMargin;\n      } else if (horizontalAlignment === Alignment.LEFTEDGE) {\n        if (this.withArrow) {\n          x += anchorBounds.width / 2 - arrowBounds.center().x - margins.left;\n        } else {\n          x = anchorBounds.x - margins.left;\n        }\n      } else if (horizontalAlignment === Alignment.CENTER) {\n        x += anchorBounds.width / 2 - width / 2 - margins.left;\n      } else if (horizontalAlignment === Alignment.RIGHT) {\n        x += anchorBounds.width;\n      } else if (horizontalAlignment === Alignment.RIGHTEDGE) {\n        if (this.withArrow) {\n          x += anchorBounds.width / 2 - arrowBounds.center().x - margins.right;\n        } else {\n          x = anchorBounds.x + anchorBounds.width - width - margins.right;\n        }\n      }\n\n      var heightWithMargin = size.height + margins.vertical();\n      var height = size.height;\n      var y = anchorBounds.y;\n\n      if (verticalAlignment === Alignment.TOP) {\n        y -= heightWithMargin;\n      } else if (verticalAlignment === Alignment.TOPEDGE) {\n        if (this.withArrow) {\n          y += anchorBounds.height / 2 - arrowBounds.center().y - margins.top;\n        } else {\n          y = anchorBounds.y - margins.top;\n        }\n      } else if (verticalAlignment === Alignment.CENTER) {\n        y += anchorBounds.height / 2 - height / 2 - margins.top;\n      } else if (verticalAlignment === Alignment.BOTTOM) {\n        y += anchorBounds.height;\n      } else if (verticalAlignment === Alignment.BOTTOMEDGE) {\n        if (this.withArrow) {\n          y += anchorBounds.height / 2 - arrowBounds.center().y - margins.bottom;\n        } else {\n          y = anchorBounds.y + anchorBounds.height - height - margins.bottom;\n        }\n      } // this.$parent might not be at (0,0) of the document\n\n\n      var parentOffset = this.$parent.offset();\n      x -= parentOffset.left;\n      y -= parentOffset.top;\n      return new Point(x, y);\n    }\n  }, {\n    key: \"_alignClasses\",\n    value: function _alignClasses() {\n      var Alignment = Popup.Alignment;\n      return strings.join(' ', Alignment.LEFT, Alignment.LEFTEDGE, Alignment.CENTER, Alignment.RIGHT, Alignment.RIGHTEDGE, Alignment.TOP, Alignment.TOPEDGE, Alignment.CENTER, Alignment.BOTTOM, Alignment.BOTTOMEDGE);\n    }\n  }, {\n    key: \"getAnchorBounds\",\n    value: function getAnchorBounds() {\n      var anchorBounds = this.anchorBounds;\n\n      if (!this.$anchor) {\n        // Use manually set anchor bounds\n        return anchorBounds;\n      }\n\n      var realAnchorBounds = graphics.offsetBounds(this.$anchor, {\n        exact: true\n      });\n\n      if (!anchorBounds) {\n        // Use measured anchor bounds\n        anchorBounds = realAnchorBounds;\n      } else {\n        // Fill incomplete anchorBounds from measured anchor bounds. This allows setting one\n        // coordinate to a fixed value (e.g. the current mouse cursor position) while still\n        // aligning the other coordinate to the $anchor element.\n        //\n        // Implementation note:\n        // A coordinate is considered \"undefined\", when it is 0. Technically, this is not 100%\n        // correct, but will give the desired result in most of the cases. If would require too\n        // many code changes to correctly set missing values to undefined/null.\n        if (!anchorBounds.x) {\n          anchorBounds.x = realAnchorBounds.x;\n          anchorBounds.width = realAnchorBounds.width;\n        }\n\n        if (!anchorBounds.y) {\n          anchorBounds.y = realAnchorBounds.y;\n          anchorBounds.height = realAnchorBounds.height;\n        }\n      }\n\n      return anchorBounds;\n    }\n  }, {\n    key: \"getWindowSize\",\n    value: function getWindowSize() {\n      var $window = this.$parent.window();\n      return new Dimension($window.width(), $window.height());\n    }\n    /**\n     * @returns Point the amount of overlap at the window borders.\n     * A positive value indicates that it is overlapping the right / bottom border, a negative value indicates that it is overlapping the left / top border.\n     * Prefers the right and bottom over the left and top border, meaning if a positive value is returned it does not mean that the left border is overlapping as well.\n     */\n\n  }, {\n    key: \"overlap\",\n    value: function overlap(location, includeMargin) {\n      var $container = this.$container;\n\n      if (!$container || !location) {\n        return null;\n      }\n\n      includeMargin = scout.nvl(includeMargin, true);\n      var height = $container.outerHeight(includeMargin);\n      var width = $container.outerWidth(includeMargin);\n      var popupBounds = new Rectangle(location.x, location.y, width, height);\n      var bounds = graphics.offsetBounds($container.entryPoint(), true);\n      var overlapX = popupBounds.right() + this.windowPaddingX - bounds.width;\n\n      if (overlapX < 0) {\n        overlapX = Math.min(popupBounds.x - this.windowPaddingX - bounds.x, 0);\n      }\n\n      var overlapY = popupBounds.bottom() + this.windowPaddingY - bounds.height;\n\n      if (overlapY < 0) {\n        overlapY = Math.min(popupBounds.y - this.windowPaddingY - bounds.y, 0);\n      }\n\n      return new Point(overlapX, overlapY);\n    }\n  }, {\n    key: \"adjustLocation\",\n    value: function adjustLocation(location, switchIfNecessary) {\n      this.calculatedVerticalAlignment = this.verticalAlignment;\n      this.calculatedHorizontalAlignment = this.horizontalAlignment;\n      var overlap = this.overlap(location); // Reset arrow style\n\n      if (this.$arrow) {\n        this._updateArrowClass(this.calculatedVerticalAlignment, this.calculatedHorizontalAlignment);\n\n        graphics.setMargins(this.$arrow, new Insets());\n      }\n\n      location = location.clone();\n\n      if (overlap.y !== 0) {\n        var verticalSwitch = scout.nvl(switchIfNecessary, this.verticalSwitch);\n\n        if (verticalSwitch) {\n          // Switch vertical alignment\n          this.calculatedVerticalAlignment = Popup.SwitchRule[this.calculatedVerticalAlignment];\n          location.y = this.prefLocation(this.calculatedVerticalAlignment).y;\n        } else {\n          // Move popup to the top until it gets fully visible (if switch is disabled)\n          location.y -= overlap.y;\n        }\n      }\n\n      if (overlap.x !== 0) {\n        var horizontalSwitch = scout.nvl(switchIfNecessary, this.horizontalSwitch);\n\n        if (horizontalSwitch) {\n          // Switch horizontal alignment\n          this.calculatedHorizontalAlignment = Popup.SwitchRule[this.calculatedHorizontalAlignment];\n          location.x = this.prefLocation(this.calculatedVerticalAlignment, this.calculatedHorizontalAlignment).x;\n        } else {\n          // Move popup to the left until it gets fully visible (if switch is disabled)\n          location.x -= overlap.x;\n        }\n      } // Also move arrow so that it still points to the center of the anchor\n\n\n      if (this.$arrow) {\n        if (overlap.y !== 0 && (this.$arrow.hasClass(Popup.Alignment.LEFT) || this.$arrow.hasClass(Popup.Alignment.RIGHT))) {\n          if (overlap.y > 0) {\n            this.$arrow.cssMarginTop(overlap.y);\n          } else {\n            this.$arrow.cssMarginBottom(-overlap.y);\n          }\n        }\n\n        if (overlap.x !== 0 && (this.$arrow.hasClass(Popup.Alignment.TOP) || this.$arrow.hasClass(Popup.Alignment.BOTTOM))) {\n          if (overlap.x > 0) {\n            this.$arrow.cssMarginLeft(overlap.x);\n          } else {\n            this.$arrow.cssMarginRight(-overlap.x);\n          }\n        }\n      }\n\n      return location;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      var size = this.prefSize(this.$container);\n\n      if (!size) {\n        return;\n      }\n\n      graphics.setSize(this.$container, size);\n    }\n  }, {\n    key: \"prefSize\",\n    value: function prefSize($container) {\n      return null;\n    }\n  }, {\n    key: \"position\",\n    value: function position(switchIfNecessary) {\n      this._validateVisibility();\n\n      this._position(switchIfNecessary);\n    }\n  }, {\n    key: \"_position\",\n    value: function _position(switchIfNecessary) {\n      var location = this.prefLocation();\n\n      if (!location) {\n        return;\n      }\n\n      location = this.adjustLocation(location, switchIfNecessary);\n      this.setLocation(location);\n    }\n  }, {\n    key: \"setLocation\",\n    value: function setLocation(location) {\n      this.$container.css('left', location.x).css('top', location.y);\n\n      this._triggerLocationChange();\n    }\n    /**\n     * Popups with an anchor must only be visible if the anchor is in view (prevents that the popup points at an invisible anchor)\n     */\n\n  }, {\n    key: \"_validateVisibility\",\n    value: function _validateVisibility() {\n      if (!this.boundToAnchor || !this.$anchor) {\n        return;\n      }\n\n      var inView = this._isInView();\n\n      var needsLayouting = this.$container.hasClass('invisible') === inView && inView;\n      this.$container.toggleClass('invisible', !inView); // Use visibility: hidden to not break layouting / size measurement\n\n      if (needsLayouting) {\n        var currentAnimateResize = this.animateResize;\n        this.animateResize = false;\n        this.revalidateLayout();\n        this.animateResize = currentAnimateResize;\n\n        if (this.withFocusContext) {\n          this.session.focusManager.validateFocus();\n        }\n      }\n    }\n  }, {\n    key: \"_isInView\",\n    value: function _isInView() {\n      if (!this.boundToAnchor || !this.$anchor) {\n        return;\n      }\n\n      var anchorBounds = this.getAnchorBounds();\n      return scrollbars.isLocationInView(anchorBounds.center(), this.$anchor.scrollParent());\n    }\n  }, {\n    key: \"_triggerLocationChange\",\n    value: function _triggerLocationChange() {\n      this.trigger('locationChange');\n    }\n    /**\n     * Fire event that this popup is about to open.\n     */\n\n  }, {\n    key: \"_triggerPopupOpenEvent\",\n    value: function _triggerPopupOpenEvent() {\n      this.session.desktop.trigger('popupOpen', {\n        popup: this\n      });\n    }\n  }, {\n    key: \"belongsTo\",\n    value: function belongsTo($anchor) {\n      return this.$anchor[0] === $anchor[0];\n    }\n  }, {\n    key: \"set$Anchor\",\n    value: function set$Anchor($anchor) {\n      if (this.$anchor) {\n        this._detachAnchorHandlers();\n      }\n\n      this.setProperty('$anchor', $anchor);\n\n      if (this.rendered) {\n        this._attachAnchorHandlers();\n\n        this.revalidateLayout();\n\n        if (!this.animateResize) {\n          // PopupLayout will move it -> don't break move animation\n          this.position();\n        }\n      }\n    }\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return this.rendered;\n    }\n  }, {\n    key: \"ensureOpen\",\n    value: function ensureOpen() {\n      if (!this.isOpen()) {\n        this.open();\n      }\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(anchor) {\n      this.setProperty('anchor', anchor);\n    }\n  }, {\n    key: \"_setAnchor\",\n    value: function _setAnchor(anchor) {\n      if (anchor) {\n        this.setParent(anchor);\n      }\n\n      this._setProperty('anchor', anchor);\n    }\n  }, {\n    key: \"_onAnchorRender\",\n    value: function _onAnchorRender() {\n      this.session.layoutValidator.schedulePostValidateFunction(function () {\n        if (this.rendered || this.destroyed) {\n          return;\n        }\n\n        if (this.anchor && !this.anchor.rendered) {\n          // Anchor was removed again while this function was scheduled -> wait again for rendering\n          this.anchor.one('render', this._anchorRenderHandler);\n          return;\n        }\n\n        var currentAnimateOpening = this.animateOpening;\n        this.animateOpening = false;\n        this.open();\n        this.animateOpening = currentAnimateOpening;\n      }.bind(this));\n    }\n  }, {\n    key: \"_renderAnchor\",\n    value: function _renderAnchor() {\n      if (this.anchor) {\n        this.set$Anchor(this.anchor.$container);\n      }\n    }\n  }, {\n    key: \"_onWindowResize\",\n    value: function _onWindowResize() {\n      if (!this.rendered) {\n        // may already be removed if a parent popup is closed during the resize event\n        return;\n      }\n\n      if (this.windowResizeType === 'position') {\n        this.position();\n      } else if (this.windowResizeType === 'layoutAndPosition') {\n        this.revalidateLayoutTree(false);\n        this.position();\n      } else if (this.windowResizeType === 'remove') {\n        this.close();\n      }\n    }\n  }, {\n    key: \"_handleGlassPanes\",\n    value: function _handleGlassPanes() {\n      var parentCoveredByGlassPane = this.session.focusManager.isElementCovertByGlassPane(this.parent.$container); // if a popup is covered by a glass pane the glass pane's need to be rerendered to ensure a glass pane is also painted over the popup\n\n      if (parentCoveredByGlassPane) {\n        this.session.focusManager.rerenderGlassPanes();\n      }\n    }\n  }]);\n\n  return Popup;\n}(Widget);\n\n_defineProperty(Popup, \"Alignment\", {\n  LEFT: 'left',\n  LEFTEDGE: 'leftedge',\n  TOP: 'top',\n  TOPEDGE: 'topedge',\n  CENTER: 'center',\n  RIGHT: 'right',\n  RIGHTEDGE: 'rightedge',\n  BOTTOM: 'bottom',\n  BOTTOMEDGE: 'bottomedge'\n});\n\n_defineProperty(Popup, \"SwitchRule\", {});\n\nexport { Popup as default };\n\n(function () {\n  // Initialize switch rules (wrapped in IIFE to have local function scope for the variables)\n  var SwitchRule = Popup.SwitchRule;\n  var Alignment = Popup.Alignment;\n  SwitchRule[Alignment.LEFT] = Alignment.RIGHT;\n  SwitchRule[Alignment.LEFTEDGE] = Alignment.RIGHTEDGE;\n  SwitchRule[Alignment.TOP] = Alignment.BOTTOM;\n  SwitchRule[Alignment.TOPEDGE] = Alignment.BOTTOMEDGE;\n  SwitchRule[Alignment.CENTER] = Alignment.CENTER;\n  SwitchRule[Alignment.RIGHT] = Alignment.LEFT;\n  SwitchRule[Alignment.RIGHTEDGE] = Alignment.LEFTEDGE;\n  SwitchRule[Alignment.BOTTOM] = Alignment.TOP;\n  SwitchRule[Alignment.BOTTOMEDGE] = Alignment.TOPEDGE;\n})();","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/popup/Popup.js"],"names":["CloseKeyStroke","DialogLayout","Dimension","Event","FocusRule","GlassPaneRenderer","graphics","HtmlComponent","Insets","KeyStrokeContext","Point","PopupLayout","Rectangle","scout","scrollbars","strings","Widget","$","Popup","_documentMouseDownHandler","_anchorScrollHandler","_anchorLocationChangeHandler","_popupOpenHandler","_glassPaneRenderer","anchorBounds","animateOpening","animateResize","anchor","$anchor","windowPaddingX","windowPaddingY","withGlassPane","withFocusContext","initialFocus","AUTO","focusableContainer","horizontalAlignment","Alignment","LEFTEDGE","verticalAlignment","BOTTOM","calculatedHorizontalAlignment","calculatedVerticalAlignment","horizontalSwitch","verticalSwitch","trimWidth","trimHeight","scrollType","windowResizeType","boundToAnchor","withArrow","closeOnAnchorMouseDown","closeOnMouseDownOutside","closeOnOtherPopupOpen","_openLater","$arrow","$arrowOverlay","_windowResizeHandler","_onWindowResize","bind","_anchorRenderHandler","_onAnchorRender","_addWidgetProperties","_addPreserveOnPropertyChangeProperties","options","location","x","y","_setAnchor","keyStrokeContext","registerKeyStroke","_createCloseKeyStroke","parent","destroyed","rendered","rendering","open","entryPoint","one","session","layoutValidator","schedulePostValidateFunction","$parent","_openWithoutParent","_triggerPopupOpenEvent","_open","validateFocus","$container","addClassForAnimation","context","focusManager","getFocusContext","ready","lastValidFocusedElement","_requestInitialFocus","initialFocusElement","evaluateFocusRule","requestFocus","render","revalidateLayout","position","$popupParent","length","isAttached","appendDiv","htmlComp","install","validateRoot","setLayout","_createLayout","window","on","_renderAnchor","_renderWithArrow","_renderWithFocusContext","_renderWithGlassPane","size","_attachCloseHandlers","_attachAnchorHandlers","_handleGlassPanes","remove","currentAnimateRemoval","animateRemoval","_isInView","off","removeGlassPanes","uninstallFocusContext","_detachAnchorHandlers","_detachCloseHandlers","installFocusContext","PREPARE","attr","renderGlassPanes","setProperty","prependDiv","_updateArrowClass","toggleClass","invalidateLayoutTree","removeClass","_alignClasses","addClass","_computeArrowPositionClass","cssClass","LEFT","RIGHT","TOP","event","trigger","defaultPrevented","destroy","_onDocumentMouseDown","document","addEventListener","_onPopupOpen","desktop","_onAnchorScroll","onScroll","widget","_onAnchorLocationChange","offScroll","removeEventListener","_isMouseDownOutside","_onMouseDownOutside","$target","target","targetWidget","_isMouseDownOnAnchor","isOrHas","isElementCovertByGlassPane","close","_handleAnchorPositionChange","isOneOf","isOpeningAnimationRunning","hasClass","closable","popup","_prefLocationWithoutAnchor","_prefLocationWithAnchor","positionContainerInWindow","getAnchorBounds","margins","arrowBounds","setMargins","bounds","widthWithMargin","width","horizontal","center","left","CENTER","RIGHTEDGE","right","heightWithMargin","height","vertical","TOPEDGE","top","BOTTOMEDGE","bottom","parentOffset","offset","join","realAnchorBounds","offsetBounds","exact","$window","includeMargin","nvl","outerHeight","outerWidth","popupBounds","overlapX","Math","min","overlapY","switchIfNecessary","overlap","clone","SwitchRule","prefLocation","cssMarginTop","cssMarginBottom","cssMarginLeft","cssMarginRight","prefSize","setSize","_validateVisibility","_position","adjustLocation","setLocation","css","_triggerLocationChange","inView","needsLayouting","currentAnimateResize","isLocationInView","scrollParent","isOpen","setParent","_setProperty","currentAnimateOpening","set$Anchor","revalidateLayoutTree","parentCoveredByGlassPane","rerenderGlassPanes"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2010-2019 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  CloseKeyStroke,\n  DialogLayout,\n  Dimension,\n  Event,\n  FocusRule,\n  GlassPaneRenderer,\n  graphics,\n  HtmlComponent,\n  Insets,\n  KeyStrokeContext,\n  Point,\n  PopupLayout,\n  Rectangle,\n  scout,\n  scrollbars,\n  strings,\n  Widget\n} from '../index';\nimport $ from 'jquery';\n\nexport default class Popup extends Widget {\n\n  constructor() {\n    super();\n\n    this._documentMouseDownHandler = null;\n    this._anchorScrollHandler = null;\n    this._anchorLocationChangeHandler = null;\n    this._popupOpenHandler = null;\n    this._glassPaneRenderer = null;\n    this.anchorBounds = null;\n    this.animateOpening = false;\n    this.animateResize = false;\n    this.anchor = null;\n    this.$anchor = null;\n    this.windowPaddingX = 10;\n    this.windowPaddingY = 5;\n    this.withGlassPane = false;\n    this.withFocusContext = true;\n    this.initialFocus = function() {\n      return FocusRule.AUTO;\n    };\n    this.focusableContainer = false;\n\n    // The alignment defines how the popup is positioned around the anchor.\n    // If there is no anchor or anchor bounds the alignment has no effect.\n    this.horizontalAlignment = Popup.Alignment.LEFTEDGE;\n    this.verticalAlignment = Popup.Alignment.BOTTOM;\n\n    // Gives the current alignment after applying horizontal and vertical switch options\n    this.calculatedHorizontalAlignment = this.horizontalAlignment;\n    this.calculatedVerticalAlignment = this.verticalAlignment;\n\n    // If switch is enabled, the alignment will be changed if the popup overlaps a window border.\n    this.horizontalSwitch = false;\n    this.verticalSwitch = true;\n\n    // Hints for the layout to control whether the size should be adjusted if the popup does not fit into the window.\n    // Before trimming is applied the popup will be switched, if the switch option is enabled.\n    // If neither switch nor trim is enabled, the popup will be moved until its right border is visible.\n    this.trimWidth = false;\n    this.trimHeight = true;\n\n    // Defines what should happen when the scroll parent is scrolled. It is also used if the anchor changes its location (needs to support the locationChange event)\n    this.scrollType = 'remove';\n    this.windowResizeType = null;\n\n    // If true, the anchor is considered when computing the position and size of the popup\n    this.boundToAnchor = true;\n\n    // If true, an arrow is shown pointing to the anchor. If there is no anchor, no arrow will be visible.\n    // Please note: some alignment combinations are not supported, which are: LEFT or RIGHT + BOTTOM or TOP\n    this.withArrow = false;\n\n    // If false, the attached mouse down handler will NOT close the popup if the anchor was clicked, the anchor is responsible to close it.\n    // This is necessary because the mousedown listener is attached to the capture phase and therefore executed before any other.\n    // If anchor was clicked, popup would already be closed and then opened again -> popup could never be closed by clicking the anchor\n    this.closeOnAnchorMouseDown = true;\n\n    // Defines whether the popup should be closed on a mouse click outside of the popup\n    this.closeOnMouseDownOutside = true;\n\n    // Defines whether the popup should be closed whenever another popup opens.\n    this.closeOnOtherPopupOpen = true;\n\n    this._openLater = false;\n\n    this.$arrow = null;\n    this.$arrowOverlay = null;\n    this._windowResizeHandler = this._onWindowResize.bind(this);\n    this._anchorRenderHandler = this._onAnchorRender.bind(this);\n    this._addWidgetProperties(['anchor']);\n    this._addPreserveOnPropertyChangeProperties(['anchor']);\n  }\n\n  // Note that these strings are also used as CSS classes\n  static Alignment = {\n    LEFT: 'left',\n    LEFTEDGE: 'leftedge',\n    TOP: 'top',\n    TOPEDGE: 'topedge',\n    CENTER: 'center',\n    RIGHT: 'right',\n    RIGHTEDGE: 'rightedge',\n    BOTTOM: 'bottom',\n    BOTTOMEDGE: 'bottomedge'\n  };\n\n  static SwitchRule = {};\n\n  /**\n   * @param options:\n   *          initialFocus: a function that returns the element to be focused or a <code>FocusRule</code>. Default returns <code>FocusRule.AUTO</code>\n   *          focusableContainer: a boolean whether or not the container of the Popup is focusable\n   */\n  _init(options) {\n    super._init(options);\n\n    if (options.location) {\n      this.anchorBounds = new Rectangle(options.location.x, options.location.y, 0, 0);\n    }\n    if (this.withGlassPane) {\n      this._glassPaneRenderer = new GlassPaneRenderer(this);\n    }\n    this._setAnchor(this.anchor);\n  }\n\n  /**\n   * @override\n   */\n  _createKeyStrokeContext() {\n    return new KeyStrokeContext();\n  }\n\n  /**\n   * @override\n   */\n  _initKeyStrokeContext() {\n    super._initKeyStrokeContext();\n\n    this.keyStrokeContext.registerKeyStroke(this._createCloseKeyStroke());\n  }\n\n  /**\n   * Override this method to provide a key stroke which closes the popup.\n   * The default impl. returns a CloseKeyStroke which handles the ESC key.\n   */\n  _createCloseKeyStroke() {\n    return new CloseKeyStroke(this);\n  }\n\n  _createLayout() {\n    return new PopupLayout(this);\n  }\n\n  _openWithoutParent() {\n    // resolve parent for entry-point (don't change the actual property)\n    var parent = this.parent;\n    if (parent.destroyed) {\n      return;\n    }\n    if (parent.rendered || parent.rendering) {\n      this.open(parent.entryPoint());\n      return;\n    }\n\n    // This is important for popups rendered in another (native) browser window. The DOM in the popup window\n    // is rendered later, so we must wait until that window is rendered and layouted. See popup-window.html.\n    parent.one('render', function() {\n      this.session.layoutValidator.schedulePostValidateFunction(function() {\n        if (this.destroyed || this.rendered) {\n          return;\n        }\n        this.open();\n      }.bind(this));\n    }.bind(this));\n  }\n\n  open($parent) {\n    if (!$parent) {\n      this._openWithoutParent();\n      return;\n    }\n\n    this._triggerPopupOpenEvent();\n\n    this._open($parent);\n    if (this._openLater) {\n      return;\n    }\n\n    // Focus the popup\n    // It is important that this happens after layouting and positioning, otherwise we'd focus an element\n    // that is currently not on the screen. Which would cause the whole desktop to\n    // be shifted for a few pixels.\n    this.validateFocus();\n    if (this.animateOpening) {\n      this.$container.addClassForAnimation('animate-open');\n    }\n  }\n\n  validateFocus() {\n    if (!this.withFocusContext) {\n      return;\n    }\n    var context = this.session.focusManager.getFocusContext(this.$container);\n    context.ready();\n    if (!context.lastValidFocusedElement) {\n      // No widget requested focus -> try to determine the initial focus\n      this._requestInitialFocus();\n    }\n  }\n\n  _requestInitialFocus() {\n    var initialFocusElement = this.session.focusManager.evaluateFocusRule(this.$container, this.initialFocus());\n    if (!initialFocusElement) {\n      return;\n    }\n    this.session.focusManager.requestFocus(initialFocusElement);\n  }\n\n  _open($parent) {\n    this.render($parent);\n    if (this._openLater) {\n      return;\n    }\n    this.revalidateLayout();\n    this.position();\n  }\n\n  render($parent) {\n    var $popupParent = $parent || this.entryPoint();\n    // when the parent is detached it is not possible to render the popup -> do it later\n    if (!$popupParent || !$popupParent.length || !$popupParent.isAttached()) {\n      this._openLater = true;\n      return;\n    }\n    super.render($popupParent);\n  }\n\n  _render() {\n    this.$container = this.$parent.appendDiv('popup');\n    this.htmlComp = HtmlComponent.install(this.$container, this.session);\n    this.htmlComp.validateRoot = true;\n    this.htmlComp.setLayout(this._createLayout());\n    this.$container.window().on('resize', this._windowResizeHandler);\n  }\n\n  _renderProperties() {\n    super._renderProperties();\n    this._renderAnchor();\n    this._renderWithArrow();\n    this._renderWithFocusContext();\n    this._renderWithGlassPane();\n  }\n\n  _postRender() {\n    super._postRender();\n\n    this.size();\n    this._attachCloseHandlers();\n    this._attachAnchorHandlers();\n    this._handleGlassPanes();\n  }\n\n  _onAttach() {\n    super._onAttach();\n    if (this._openLater && !this.rendered) {\n      this._openLater = false;\n      this.open();\n    }\n  }\n\n  _renderOnDetach() {\n    this._openLater = true;\n    this.remove();\n    super._renderOnDetach();\n  }\n\n  remove() {\n    var currentAnimateRemoval = this.animateRemoval;\n    if ((this.boundToAnchor && this.$anchor) && !this._isInView()) {\n      this.animateRemoval = false;\n    }\n    super.remove();\n    this.animateRemoval = currentAnimateRemoval;\n  }\n\n  _remove() {\n    this.$container.window().off('resize', this._windowResizeHandler);\n    if (this._glassPaneRenderer) {\n      this._glassPaneRenderer.removeGlassPanes();\n    }\n    if (this.withFocusContext) {\n      this.session.focusManager.uninstallFocusContext(this.$container);\n    }\n    if (this.$arrow) {\n      this.$arrow.remove();\n      this.$arrow = null;\n    }\n\n    if (this.anchor) {\n      // reopen when the anchor gets rendered again\n      this.anchor.one('render', this._anchorRenderHandler);\n    }\n\n    // remove all clean-up handlers\n    this._detachAnchorHandlers();\n    this._detachCloseHandlers();\n    super._remove();\n  }\n\n  _destroy() {\n    if (this.anchor) {\n      this.anchor.off('render', this._anchorRenderHandler);\n    }\n    super._destroy();\n  }\n\n  _renderWithFocusContext() {\n    if (this.withFocusContext) {\n      // Don't allow an element to be focused while the popup is opened.\n      // The popup will focus the element as soon as the opening is finished (see open());\n      // The context needs to be already installed so that child elements don't try to focus an element outside of this context\n      this.session.focusManager.installFocusContext(this.$container, FocusRule.PREPARE);\n    }\n    // Add programmatic 'tabindex' if the $container itself should be focusable (used by context menu popups with no focusable elements)\n    if (this.withFocusContext && this.focusableContainer) {\n      this.$container.attr('tabindex', -1);\n    }\n  }\n\n  _renderWithGlassPane() {\n    if (this._glassPaneRenderer) {\n      this._glassPaneRenderer.renderGlassPanes();\n    }\n  }\n\n  setWithArrow(withArrow) {\n    this.setProperty('withArrow', withArrow);\n  }\n\n  _renderWithArrow() {\n    if (this.$arrow) {\n      this.$arrow.remove();\n      this.$arrow = null;\n    }\n    if (this.$arrowOverlay) {\n      this.$arrowOverlay.remove();\n      this.$arrowOverlay = null;\n    }\n    if (this.withArrow) {\n      this.$arrowOverlay = this.$container.prependDiv('popup-arrow-overlay');\n      this.$arrow = this.$container.prependDiv('popup-arrow');\n      this._updateArrowClass();\n    }\n    this.$container.toggleClass('with-arrow', this.withArrow);\n    this.invalidateLayoutTree();\n  }\n\n  _updateArrowClass(verticalAlignment, horizontalAlignment) {\n    if (this.$arrow) {\n      this.$arrow.removeClass(this._alignClasses());\n      this.$arrow.addClass(this._computeArrowPositionClass(verticalAlignment, horizontalAlignment));\n    }\n  }\n\n  _computeArrowPositionClass(verticalAlignment, horizontalAlignment) {\n    var Alignment = Popup.Alignment;\n    var cssClass = '';\n    horizontalAlignment = horizontalAlignment || this.horizontalAlignment;\n    verticalAlignment = verticalAlignment || this.verticalAlignment;\n    switch (horizontalAlignment) {\n      case Alignment.LEFT:\n        cssClass = Alignment.RIGHT;\n        break;\n      case Alignment.RIGHT:\n        cssClass = Alignment.LEFT;\n        break;\n      default:\n        cssClass = horizontalAlignment;\n        break;\n    }\n\n    switch (verticalAlignment) {\n      case Alignment.BOTTOM:\n        cssClass += ' ' + Alignment.TOP;\n        break;\n      case Alignment.TOP:\n        cssClass += ' ' + Alignment.BOTTOM;\n        break;\n      default:\n        cssClass += ' ' + verticalAlignment;\n        break;\n    }\n    return cssClass;\n  }\n\n  _isRemovalPrevented() {\n    // Never prevent. Default returns true if removal is pending by an animation, but popups should be closed before the animation starts\n    return false;\n  }\n\n  close() {\n    var event = new Event();\n    this.trigger('close', event);\n    if (!event.defaultPrevented) {\n      this.destroy();\n    }\n  }\n\n  /**\n   * Install listeners to close the popup once clicking outside the popup,\n   * or changing the anchor's scroll position, or another popup is opened.\n   */\n  _attachCloseHandlers() {\n    // Install mouse close handler\n    // The listener needs to be executed in the capturing phase -> prevents that _onDocumentMouseDown will be executed right after the popup gets opened using mouse down, otherwise the popup would be closed immediately\n    if (this.closeOnMouseDownOutside) {\n      this._documentMouseDownHandler = this._onDocumentMouseDown.bind(this);\n      this.$container.document(true).addEventListener('mousedown', this._documentMouseDownHandler, true); // true=the event handler is executed in the capturing phase\n    }\n\n    // Install popup open close handler\n    if (this.closeOnOtherPopupOpen) {\n      this._popupOpenHandler = this._onPopupOpen.bind(this);\n      this.session.desktop.on('popupOpen', this._popupOpenHandler);\n    }\n  }\n\n  _attachAnchorHandlers() {\n    if (!this.$anchor || !this.boundToAnchor || !this.scrollType) {\n      return;\n    }\n    // Attach a scroll handler to each scrollable parent of the anchor\n    this._anchorScrollHandler = this._onAnchorScroll.bind(this);\n    scrollbars.onScroll(this.$anchor, this._anchorScrollHandler);\n\n    // Attach a location change handler as well (will only work if the anchor is a widget which triggers a locationChange event, e.g. another Popup)\n    var anchor = scout.widget(this.$anchor);\n    if (anchor) {\n      this._anchorLocationChangeHandler = this._onAnchorLocationChange.bind(this);\n      anchor.on('locationChange', this._anchorLocationChangeHandler);\n    }\n  }\n\n  _detachAnchorHandlers() {\n    if (this._anchorScrollHandler) {\n      scrollbars.offScroll(this._anchorScrollHandler);\n      this._anchorScrollHandler = null;\n    }\n    if (this._anchorLocationChangeHandler) {\n      var anchor = scout.widget(this.$anchor);\n      if (anchor) {\n        anchor.off('locationChange', this._anchorLocationChangeHandler);\n        this._anchorLocationChangeHandler = null;\n      }\n    }\n  }\n\n  _detachCloseHandlers() {\n    // Uninstall popup open close handler\n    if (this._popupOpenHandler) {\n      this.session.desktop.off('popupOpen', this._popupOpenHandler);\n      this._popupOpenHandler = null;\n    }\n\n    // Uninstall mouse close handler\n    if (this._documentMouseDownHandler) {\n      this.$container.document(true).removeEventListener('mousedown', this._documentMouseDownHandler, true);\n      this._documentMouseDownHandler = null;\n    }\n  }\n\n  _onDocumentMouseDown(event) {\n    // in some cases the mousedown handler is executed although it has been already\n    // detached on the _remove() method. However, since we're in the middle of\n    // processing the mousedown event, it's too late to detach the event and we must\n    // deal with that situation by checking the rendered flag. Otherwise we would\n    // run into an error later, since the $container is not available anymore.\n    if (!this.rendered) {\n      return;\n    }\n    if (this._isMouseDownOutside(event)) {\n      this._onMouseDownOutside(event);\n    }\n  }\n\n  _isMouseDownOutside(event) {\n    var $target = $(event.target),\n      targetWidget;\n\n    if (!this.closeOnAnchorMouseDown && this._isMouseDownOnAnchor(event)) {\n      // 1. Often times, click on the anchor opens and 2. click closes the popup\n      // If we were closing the popup here, it would not be possible to achieve the described behavior anymore -> let anchor handle open and close.\n      return false;\n    }\n\n    targetWidget = scout.widget($target);\n\n    // close the popup only if the click happened outside of the popup and its children\n    // It is not sufficient to check the dom hierarchy using $container.has($target)\n    // because the popup may open other popups which probably is not a dom child but a sibling\n    // Also ignore clicks if the popup is covert by a glasspane\n    return !this.isOrHas(targetWidget) && !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);\n  }\n\n  _isMouseDownOnAnchor(event) {\n    return !!this.$anchor && this.$anchor.isOrHas(event.target);\n  }\n\n  /**\n   * Method invoked once a mouse down event occurs outside the popup.\n   */\n  _onMouseDownOutside(event) {\n    this.close();\n  }\n\n  /**\n   * Method invoked once the 'options.$anchor' is scrolled.\n   */\n  _onAnchorScroll(event) {\n    if (!this.rendered) {\n      // Scroll events may be fired delayed, even if scroll listeners are already removed.\n      return;\n    }\n    this._handleAnchorPositionChange();\n  }\n\n  _handleAnchorPositionChange(event) {\n    if (scout.isOneOf(this.scrollType, 'position', 'layoutAndPosition') && this.isOpeningAnimationRunning()) {\n      // If the popup is opened with an animation which transforms the popup the sizes used by prefSize and position will likely be wrong.\n      // In that case it is not possible to layout and position it correctly -> do nothing.\n      return;\n    }\n\n    if (this.scrollType === 'position') {\n      this.position();\n    } else if (this.scrollType === 'layoutAndPosition') {\n      this.revalidateLayout();\n      this.position();\n    } else if (this.scrollType === 'remove') {\n      this.close();\n    }\n  }\n\n  isOpeningAnimationRunning() {\n    return this.rendered && this.animateOpening && this.$container.hasClass('animate-open');\n  }\n\n  _onAnchorLocationChange(event) {\n    this._handleAnchorPositionChange();\n  }\n\n  /**\n   * Method invoked once a popup is opened.\n   */\n  _onPopupOpen(event) {\n    // Make sure child popups don't close the parent popup, we must check parent hierarchy in both directions\n    // Use case: Opening of a context menu or cell editor in a form popup\n    // Also, popups covered by a glass pane (a modal dialog is open) must never be closed\n    // Use case: popup opens a modal dialog. User clicks on a smartfield on this dialog -> underlying popup must not get closed\n    var closable = !this.isOrHas(event.popup) &&\n      !event.popup.isOrHas(this);\n    if (this.rendered) {\n      closable = closable && !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);\n    }\n    if (closable) {\n      this.close();\n    }\n  }\n\n  setHorizontalAlignment(horizontalAlignment) {\n    this.setProperty('horizontalAlignment', horizontalAlignment);\n  }\n\n  _renderHorizontalAlignment() {\n    this._updateArrowClass();\n    this.invalidateLayoutTree();\n  }\n\n  setVerticalAlignment(verticalAlignment) {\n    this.setProperty('verticalAlignment', verticalAlignment);\n  }\n\n  _renderVerticalAlignment() {\n    this._updateArrowClass();\n    this.invalidateLayoutTree();\n  }\n\n  setHorizontalSwitch(horizontalSwitch) {\n    this.setProperty('horizontalSwitch', horizontalSwitch);\n  }\n\n  _renderHorizontalSwitch() {\n    this.invalidateLayoutTree();\n  }\n\n  setVerticalSwitch(verticalSwitch) {\n    this.setProperty('verticalSwitch', verticalSwitch);\n  }\n\n  _renderVerticalSwitch() {\n    this.invalidateLayoutTree();\n  }\n\n  setTrimWidth(trimWidth) {\n    this.setProperty('trimWidth', trimWidth);\n  }\n\n  _renderTrimWidth() {\n    this.invalidateLayoutTree();\n  }\n\n  setTrimHeight(trimHeight) {\n    this.setProperty('trimHeight', trimHeight);\n  }\n\n  _renderTrimHeight() {\n    this.invalidateLayoutTree();\n  }\n\n  prefLocation(verticalAlignment, horizontalAlignment) {\n    if (!this.boundToAnchor || (!this.anchorBounds && !this.$anchor)) {\n      return this._prefLocationWithoutAnchor();\n    }\n    return this._prefLocationWithAnchor(verticalAlignment, horizontalAlignment);\n  }\n\n  _prefLocationWithoutAnchor() {\n    return DialogLayout.positionContainerInWindow(this.$container);\n  }\n\n  _prefLocationWithAnchor(verticalAlignment, horizontalAlignment) {\n    var $container = this.$container;\n    horizontalAlignment = horizontalAlignment || this.horizontalAlignment;\n    verticalAlignment = verticalAlignment || this.verticalAlignment;\n    var anchorBounds = this.getAnchorBounds();\n    var size = graphics.size($container);\n    var margins = graphics.margins($container);\n    var Alignment = Popup.Alignment;\n\n    var arrowBounds = null;\n    if (this.$arrow) {\n      // Ensure the arrow has the correct class\n      this._updateArrowClass(verticalAlignment, horizontalAlignment);\n      // Remove margin added by moving logic, otherwise the bounds would not be correct\n      graphics.setMargins(this.$arrow, new Insets());\n      arrowBounds = graphics.bounds(this.$arrow);\n    }\n\n    $container.removeClass(this._alignClasses());\n    $container.addClass(verticalAlignment + ' ' + horizontalAlignment);\n\n    var widthWithMargin = size.width + margins.horizontal();\n    var width = size.width;\n    var x = anchorBounds.x;\n    if (horizontalAlignment === Alignment.LEFT) {\n      x -= widthWithMargin;\n    } else if (horizontalAlignment === Alignment.LEFTEDGE) {\n      if (this.withArrow) {\n        x += anchorBounds.width / 2 - arrowBounds.center().x - margins.left;\n      } else {\n        x = anchorBounds.x - margins.left;\n      }\n    } else if (horizontalAlignment === Alignment.CENTER) {\n      x += anchorBounds.width / 2 - width / 2 - margins.left;\n    } else if (horizontalAlignment === Alignment.RIGHT) {\n      x += anchorBounds.width;\n    } else if (horizontalAlignment === Alignment.RIGHTEDGE) {\n      if (this.withArrow) {\n        x += anchorBounds.width / 2 - arrowBounds.center().x - margins.right;\n      } else {\n        x = anchorBounds.x + anchorBounds.width - width - margins.right;\n      }\n    }\n\n    var heightWithMargin = size.height + margins.vertical();\n    var height = size.height;\n    var y = anchorBounds.y;\n    if (verticalAlignment === Alignment.TOP) {\n      y -= heightWithMargin;\n    } else if (verticalAlignment === Alignment.TOPEDGE) {\n      if (this.withArrow) {\n        y += anchorBounds.height / 2 - arrowBounds.center().y - margins.top;\n      } else {\n        y = anchorBounds.y - margins.top;\n      }\n    } else if (verticalAlignment === Alignment.CENTER) {\n      y += anchorBounds.height / 2 - height / 2 - margins.top;\n    } else if (verticalAlignment === Alignment.BOTTOM) {\n      y += anchorBounds.height;\n    } else if (verticalAlignment === Alignment.BOTTOMEDGE) {\n      if (this.withArrow) {\n        y += anchorBounds.height / 2 - arrowBounds.center().y - margins.bottom;\n      } else {\n        y = anchorBounds.y + anchorBounds.height - height - margins.bottom;\n      }\n    }\n\n    // this.$parent might not be at (0,0) of the document\n    var parentOffset = this.$parent.offset();\n    x -= parentOffset.left;\n    y -= parentOffset.top;\n\n    return new Point(x, y);\n  }\n\n  _alignClasses() {\n    var Alignment = Popup.Alignment;\n    return strings.join(' ', Alignment.LEFT, Alignment.LEFTEDGE, Alignment.CENTER, Alignment.RIGHT, Alignment.RIGHTEDGE,\n      Alignment.TOP, Alignment.TOPEDGE, Alignment.CENTER, Alignment.BOTTOM, Alignment.BOTTOMEDGE);\n  }\n\n  getAnchorBounds() {\n    var anchorBounds = this.anchorBounds;\n    if (!this.$anchor) {\n      // Use manually set anchor bounds\n      return anchorBounds;\n    }\n    var realAnchorBounds = graphics.offsetBounds(this.$anchor, {\n      exact: true\n    });\n    if (!anchorBounds) {\n      // Use measured anchor bounds\n      anchorBounds = realAnchorBounds;\n    } else {\n      // Fill incomplete anchorBounds from measured anchor bounds. This allows setting one\n      // coordinate to a fixed value (e.g. the current mouse cursor position) while still\n      // aligning the other coordinate to the $anchor element.\n      //\n      // Implementation note:\n      // A coordinate is considered \"undefined\", when it is 0. Technically, this is not 100%\n      // correct, but will give the desired result in most of the cases. If would require too\n      // many code changes to correctly set missing values to undefined/null.\n      if (!anchorBounds.x) {\n        anchorBounds.x = realAnchorBounds.x;\n        anchorBounds.width = realAnchorBounds.width;\n      }\n      if (!anchorBounds.y) {\n        anchorBounds.y = realAnchorBounds.y;\n        anchorBounds.height = realAnchorBounds.height;\n      }\n    }\n    return anchorBounds;\n  }\n\n  getWindowSize() {\n    var $window = this.$parent.window();\n    return new Dimension($window.width(), $window.height());\n  }\n\n  /**\n   * @returns Point the amount of overlap at the window borders.\n   * A positive value indicates that it is overlapping the right / bottom border, a negative value indicates that it is overlapping the left / top border.\n   * Prefers the right and bottom over the left and top border, meaning if a positive value is returned it does not mean that the left border is overlapping as well.\n   */\n  overlap(location, includeMargin) {\n    var $container = this.$container;\n    if (!$container || !location) {\n      return null;\n    }\n    includeMargin = scout.nvl(includeMargin, true);\n    var height = $container.outerHeight(includeMargin);\n    var width = $container.outerWidth(includeMargin);\n    var popupBounds = new Rectangle(location.x, location.y, width, height);\n    var bounds = graphics.offsetBounds($container.entryPoint(), true);\n\n    var overlapX = popupBounds.right() + this.windowPaddingX - bounds.width;\n    if (overlapX < 0) {\n      overlapX = Math.min(popupBounds.x - this.windowPaddingX - bounds.x, 0);\n    }\n    var overlapY = popupBounds.bottom() + this.windowPaddingY - bounds.height;\n    if (overlapY < 0) {\n      overlapY = Math.min(popupBounds.y - this.windowPaddingY - bounds.y, 0);\n    }\n    return new Point(overlapX, overlapY);\n  }\n\n  adjustLocation(location, switchIfNecessary) {\n    this.calculatedVerticalAlignment = this.verticalAlignment;\n    this.calculatedHorizontalAlignment = this.horizontalAlignment;\n    var overlap = this.overlap(location);\n\n    // Reset arrow style\n    if (this.$arrow) {\n      this._updateArrowClass(this.calculatedVerticalAlignment, this.calculatedHorizontalAlignment);\n      graphics.setMargins(this.$arrow, new Insets());\n    }\n\n    location = location.clone();\n    if (overlap.y !== 0) {\n      var verticalSwitch = scout.nvl(switchIfNecessary, this.verticalSwitch);\n      if (verticalSwitch) {\n        // Switch vertical alignment\n        this.calculatedVerticalAlignment = Popup.SwitchRule[this.calculatedVerticalAlignment];\n        location.y = this.prefLocation(this.calculatedVerticalAlignment).y;\n      } else {\n        // Move popup to the top until it gets fully visible (if switch is disabled)\n        location.y -= overlap.y;\n      }\n    }\n    if (overlap.x !== 0) {\n      var horizontalSwitch = scout.nvl(switchIfNecessary, this.horizontalSwitch);\n      if (horizontalSwitch) {\n        // Switch horizontal alignment\n        this.calculatedHorizontalAlignment = Popup.SwitchRule[this.calculatedHorizontalAlignment];\n        location.x = this.prefLocation(this.calculatedVerticalAlignment, this.calculatedHorizontalAlignment).x;\n      } else {\n        // Move popup to the left until it gets fully visible (if switch is disabled)\n        location.x -= overlap.x;\n      }\n    }\n\n    // Also move arrow so that it still points to the center of the anchor\n    if (this.$arrow) {\n      if (overlap.y !== 0 && (this.$arrow.hasClass(Popup.Alignment.LEFT) || this.$arrow.hasClass(Popup.Alignment.RIGHT))) {\n        if (overlap.y > 0) {\n          this.$arrow.cssMarginTop(overlap.y);\n        } else {\n          this.$arrow.cssMarginBottom(-overlap.y);\n        }\n      }\n      if (overlap.x !== 0 && (this.$arrow.hasClass(Popup.Alignment.TOP) || this.$arrow.hasClass(Popup.Alignment.BOTTOM))) {\n        if (overlap.x > 0) {\n          this.$arrow.cssMarginLeft(overlap.x);\n        } else {\n          this.$arrow.cssMarginRight(-overlap.x);\n        }\n      }\n    }\n\n    return location;\n  }\n\n  size() {\n    var size = this.prefSize(this.$container);\n    if (!size) {\n      return;\n    }\n    graphics.setSize(this.$container, size);\n  }\n\n  prefSize($container) {\n    return null;\n  }\n\n  position(switchIfNecessary) {\n    this._validateVisibility();\n    this._position(switchIfNecessary);\n  }\n\n  _position(switchIfNecessary) {\n    var location = this.prefLocation();\n    if (!location) {\n      return;\n    }\n    location = this.adjustLocation(location, switchIfNecessary);\n    this.setLocation(location);\n  }\n\n  setLocation(location) {\n    this.$container\n      .css('left', location.x)\n      .css('top', location.y);\n    this._triggerLocationChange();\n  }\n\n  /**\n   * Popups with an anchor must only be visible if the anchor is in view (prevents that the popup points at an invisible anchor)\n   */\n  _validateVisibility() {\n    if (!this.boundToAnchor || !this.$anchor) {\n      return;\n    }\n    var inView = this._isInView();\n    var needsLayouting = this.$container.hasClass('invisible') === inView && inView;\n    this.$container.toggleClass('invisible', !inView); // Use visibility: hidden to not break layouting / size measurement\n    if (needsLayouting) {\n      var currentAnimateResize = this.animateResize;\n      this.animateResize = false;\n      this.revalidateLayout();\n      this.animateResize = currentAnimateResize;\n      if (this.withFocusContext) {\n        this.session.focusManager.validateFocus();\n      }\n    }\n  }\n\n  _isInView() {\n    if (!this.boundToAnchor || !this.$anchor) {\n      return;\n    }\n    var anchorBounds = this.getAnchorBounds();\n    return scrollbars.isLocationInView(anchorBounds.center(), this.$anchor.scrollParent());\n  }\n\n  _triggerLocationChange() {\n    this.trigger('locationChange');\n  }\n\n  /**\n   * Fire event that this popup is about to open.\n   */\n  _triggerPopupOpenEvent() {\n    this.session.desktop.trigger('popupOpen', {\n      popup: this\n    });\n  }\n\n  belongsTo($anchor) {\n    return this.$anchor[0] === $anchor[0];\n  }\n\n  set$Anchor($anchor) {\n    if (this.$anchor) {\n      this._detachAnchorHandlers();\n    }\n    this.setProperty('$anchor', $anchor);\n    if (this.rendered) {\n      this._attachAnchorHandlers();\n      this.revalidateLayout();\n      if (!this.animateResize) { // PopupLayout will move it -> don't break move animation\n        this.position();\n      }\n    }\n  }\n\n  isOpen() {\n    return this.rendered;\n  }\n\n  ensureOpen() {\n    if (!this.isOpen()) {\n      this.open();\n    }\n  }\n\n  setAnchor(anchor) {\n    this.setProperty('anchor', anchor);\n  }\n\n  _setAnchor(anchor) {\n    if (anchor) {\n      this.setParent(anchor);\n    }\n    this._setProperty('anchor', anchor);\n  }\n\n  _onAnchorRender() {\n    this.session.layoutValidator.schedulePostValidateFunction(function() {\n      if (this.rendered || this.destroyed) {\n        return;\n      }\n      if (this.anchor && !this.anchor.rendered) {\n        // Anchor was removed again while this function was scheduled -> wait again for rendering\n        this.anchor.one('render', this._anchorRenderHandler);\n        return;\n      }\n      var currentAnimateOpening = this.animateOpening;\n      this.animateOpening = false;\n      this.open();\n      this.animateOpening = currentAnimateOpening;\n    }.bind(this));\n  }\n\n  _renderAnchor() {\n    if (this.anchor) {\n      this.set$Anchor(this.anchor.$container);\n    }\n  }\n\n  _onWindowResize() {\n    if (!this.rendered) {\n      // may already be removed if a parent popup is closed during the resize event\n      return;\n    }\n    if (this.windowResizeType === 'position') {\n      this.position();\n    } else if (this.windowResizeType === 'layoutAndPosition') {\n      this.revalidateLayoutTree(false);\n      this.position();\n    } else if (this.windowResizeType === 'remove') {\n      this.close();\n    }\n  }\n\n  _handleGlassPanes() {\n    var parentCoveredByGlassPane = this.session.focusManager.isElementCovertByGlassPane(this.parent.$container);\n    // if a popup is covered by a glass pane the glass pane's need to be rerendered to ensure a glass pane is also painted over the popup\n    if (parentCoveredByGlassPane) {\n      this.session.focusManager.rerenderGlassPanes();\n    }\n  }\n}\n\n(function() {\n  // Initialize switch rules (wrapped in IIFE to have local function scope for the variables)\n  var SwitchRule = Popup.SwitchRule;\n  var Alignment = Popup.Alignment;\n  SwitchRule[Alignment.LEFT] = Alignment.RIGHT;\n  SwitchRule[Alignment.LEFTEDGE] = Alignment.RIGHTEDGE;\n  SwitchRule[Alignment.TOP] = Alignment.BOTTOM;\n  SwitchRule[Alignment.TOPEDGE] = Alignment.BOTTOMEDGE;\n  SwitchRule[Alignment.CENTER] = Alignment.CENTER;\n  SwitchRule[Alignment.RIGHT] = Alignment.LEFT;\n  SwitchRule[Alignment.RIGHTEDGE] = Alignment.LEFTEDGE;\n  SwitchRule[Alignment.BOTTOM] = Alignment.TOP;\n  SwitchRule[Alignment.BOTTOMEDGE] = Alignment.TOPEDGE;\n}());\n"]},"metadata":{},"sourceType":"module"}