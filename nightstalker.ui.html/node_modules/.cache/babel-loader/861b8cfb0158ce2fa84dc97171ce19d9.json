{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { graphics } from '../../index';\nimport $ from 'jquery';\n\nvar ColumnOptimalWidthMeasurer = /*#__PURE__*/function () {\n  function ColumnOptimalWidthMeasurer(column) {\n    _classCallCheck(this, ColumnOptimalWidthMeasurer);\n\n    this.column = column;\n    this.table = null;\n    this.$measurement = null;\n    this.deferred = null;\n    this.imageCount = 0;\n    this.completeImageCount = 0;\n    this._imageLoadOrErrorHandler = this._onImageLoadOrError.bind(this);\n    this._columnCellContents = {};\n  }\n\n  _createClass(ColumnOptimalWidthMeasurer, [{\n    key: \"measure\",\n    value: function measure(promise) {\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring started for column ' + this.column.id); // Table is not yet available on the column in the constructor -> set it here\n\n      this.table = this.column.table;\n\n      if (this.$measurement) {\n        $.log.isDebugEnabled() && $.log.debug('Optimal width measuring aborted for column ' + this.column.id); // If measurement is still in progress, abort it and start a new measurement\n\n        this._resolve(-1);\n      } // Prepare a temporary container that is not (yet) part of the DOM to prevent\n      // expensive \"forced reflow\" while adding the cell divs. Only after all cells\n      // are rendered, the container is added to the DOM.\n\n\n      this.$measurement = this.table.$data.makeDiv('hidden');\n      this.imageCount = 0;\n      this.completeImageCount = 0; // Create divs for all relevant cells of the column\n\n      this._appendElements(); // Add to DOM\n\n\n      this.table.$data.append(this.$measurement);\n\n      if (this.completeImageCount >= this.imageCount) {\n        // Measure now\n        var optimalWidth = this._measure();\n\n        $.log.isDebugEnabled() && $.log.debug('Optimal width measuring done (sync) for column ' + this.column.id + ': ' + optimalWidth);\n        this.remove();\n        return optimalWidth;\n      } // Measure later as soon as every image has been loaded\n\n\n      $.log.isDebugEnabled() && $.log.debug('Not all images loaded, deferring measurement for column ' + this.column.id + '. Images complete: ' + this.completeImageCount + '/' + this.imageCount);\n      this.$measurement[0].addEventListener('load', this._imageLoadOrErrorHandler, true);\n      this.$measurement[0].addEventListener('error', this._imageLoadOrErrorHandler, true);\n      this.deferred = $.Deferred();\n      return this.deferred.promise();\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (!this.$measurement) {\n        return;\n      }\n\n      this.$measurement[0].removeEventListener('load', this._imageLoadOrErrorHandler, true);\n      this.$measurement[0].removeEventListener('error', this._imageLoadOrErrorHandler, true);\n      this.$measurement.remove();\n      this.$measurement = null;\n    }\n  }, {\n    key: \"_measure\",\n    value: function _measure() {\n      var optimalWidth = this.column.minWidth; // Since the measurement may be async due to image loading, the $measurement is hidden (=display: none) until the real measurement starts.\n      // Otherwise it would influence the scroll width of the real table data\n\n      this.$measurement.addClass('invisible').removeClass('hidden').children().each(function () {\n        optimalWidth = Math.max(optimalWidth, graphics.size($(this)).width);\n      });\n      return optimalWidth;\n    }\n  }, {\n    key: \"_resolve\",\n    value: function _resolve(optimalWidth) {\n      this.remove();\n\n      if (this.deferred) {\n        this.deferred.resolve(optimalWidth);\n        this.deferred = null;\n      }\n    }\n  }, {\n    key: \"_appendElements\",\n    value: function _appendElements() {\n      this._appendHeader();\n\n      this._appendRows();\n\n      this._appendAggregateRows();\n    }\n  }, {\n    key: \"_appendHeader\",\n    value: function _appendHeader() {\n      if (this.column.$header) {\n        this._appendToMeasurement(this.column.$header.clone());\n      }\n    }\n  }, {\n    key: \"_appendRows\",\n    value: function _appendRows() {\n      this.table.rows.forEach(this._appendRow.bind(this));\n      this._columnCellContents = {};\n    }\n  }, {\n    key: \"_appendRow\",\n    value: function _appendRow(row) {\n      var columnContent = this.column.buildCellForRow(row);\n\n      if (this._columnCellContents[columnContent]) {\n        return;\n      }\n\n      this._columnCellContents[columnContent] = true;\n\n      this._appendToMeasurement($(columnContent));\n    }\n  }, {\n    key: \"_appendAggregateRows\",\n    value: function _appendAggregateRows() {\n      this.table._aggregateRows.forEach(this._appendAggregateRow.bind(this));\n    }\n  }, {\n    key: \"_appendAggregateRow\",\n    value: function _appendAggregateRow(row) {\n      this._appendToMeasurement($(this.column.buildCellForAggregateRow(row)));\n    }\n  }, {\n    key: \"_appendToMeasurement\",\n    value: function _appendToMeasurement($calc) {\n      // Count images\n      var $calcImgs = $calc.find('img');\n      $calcImgs.each(function (index, elem) {\n        var $img = $(elem);\n        $img.data('measure', 'in-progress');\n\n        if (elem.complete) {\n          $img.data('complete', elem.complete);\n          this.completeImageCount++;\n        }\n\n        this.imageCount++;\n      }.bind(this)); // Append to measurement element\n\n      $calc.css({\n        minWidth: '',\n        maxWidth: ''\n      }).appendTo(this.$measurement);\n    }\n  }, {\n    key: \"_onImageLoadOrError\",\n    value: function _onImageLoadOrError(event) {\n      var $img = $(event.target);\n\n      if ($img.data('complete')) {\n        // Ignore images which were already complete and therefore already incremented the _imageCompleteCount\n        return;\n      }\n\n      this.completeImageCount++;\n      $.log.isTraceEnabled() && $.log.trace('Images complete (async) ' + this.completeImageCount + '/' + this.imageCount, event.target.src);\n\n      if (this.completeImageCount >= this.imageCount) {\n        var optimalWidth = this._measure();\n\n        $.log.isDebugEnabled() && $.log.debug('Optimal width measuring done (async) for column ' + this.column.id + ': ' + optimalWidth);\n\n        this._resolve(optimalWidth);\n      }\n    }\n  }]);\n\n  return ColumnOptimalWidthMeasurer;\n}();\n\nexport { ColumnOptimalWidthMeasurer as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/table/columns/ColumnOptimalWidthMeasurer.js"],"names":["graphics","$","ColumnOptimalWidthMeasurer","column","table","$measurement","deferred","imageCount","completeImageCount","_imageLoadOrErrorHandler","_onImageLoadOrError","bind","_columnCellContents","promise","log","isDebugEnabled","debug","id","_resolve","$data","makeDiv","_appendElements","append","optimalWidth","_measure","remove","addEventListener","Deferred","removeEventListener","minWidth","addClass","removeClass","children","each","Math","max","size","width","resolve","_appendHeader","_appendRows","_appendAggregateRows","$header","_appendToMeasurement","clone","rows","forEach","_appendRow","row","columnContent","buildCellForRow","_aggregateRows","_appendAggregateRow","buildCellForAggregateRow","$calc","$calcImgs","find","index","elem","$img","data","complete","css","maxWidth","appendTo","event","target","isTraceEnabled","trace","src"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {graphics} from '../../index';\nimport $ from 'jquery';\n\nexport default class ColumnOptimalWidthMeasurer {\n\n  constructor(column) {\n    this.column = column;\n    this.table = null;\n    this.$measurement = null;\n    this.deferred = null;\n    this.imageCount = 0;\n    this.completeImageCount = 0;\n    this._imageLoadOrErrorHandler = this._onImageLoadOrError.bind(this);\n    this._columnCellContents = {};\n  }\n\n  measure(promise) {\n    $.log.isDebugEnabled() && $.log.debug('Optimal width measuring started for column ' + this.column.id);\n\n    // Table is not yet available on the column in the constructor -> set it here\n    this.table = this.column.table;\n\n    if (this.$measurement) {\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring aborted for column ' + this.column.id);\n\n      // If measurement is still in progress, abort it and start a new measurement\n      this._resolve(-1);\n    }\n\n    // Prepare a temporary container that is not (yet) part of the DOM to prevent\n    // expensive \"forced reflow\" while adding the cell divs. Only after all cells\n    // are rendered, the container is added to the DOM.\n    this.$measurement = this.table.$data.makeDiv('hidden');\n    this.imageCount = 0;\n    this.completeImageCount = 0;\n\n    // Create divs for all relevant cells of the column\n    this._appendElements();\n\n    // Add to DOM\n    this.table.$data.append(this.$measurement);\n\n    if (this.completeImageCount >= this.imageCount) {\n      // Measure now\n      var optimalWidth = this._measure();\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring done (sync) for column ' + this.column.id + ': ' + optimalWidth);\n      this.remove();\n      return optimalWidth;\n    }\n\n    // Measure later as soon as every image has been loaded\n    $.log.isDebugEnabled() && $.log.debug('Not all images loaded, deferring measurement for column ' + this.column.id + '. Images complete: ' + this.completeImageCount + '/' + this.imageCount);\n    this.$measurement[0].addEventListener('load', this._imageLoadOrErrorHandler, true);\n    this.$measurement[0].addEventListener('error', this._imageLoadOrErrorHandler, true);\n    this.deferred = $.Deferred();\n    return this.deferred.promise();\n  }\n\n  remove() {\n    if (!this.$measurement) {\n      return;\n    }\n    this.$measurement[0].removeEventListener('load', this._imageLoadOrErrorHandler, true);\n    this.$measurement[0].removeEventListener('error', this._imageLoadOrErrorHandler, true);\n    this.$measurement.remove();\n    this.$measurement = null;\n  }\n\n  _measure() {\n    var optimalWidth = this.column.minWidth;\n    // Since the measurement may be async due to image loading, the $measurement is hidden (=display: none) until the real measurement starts.\n    // Otherwise it would influence the scroll width of the real table data\n    this.$measurement\n      .addClass('invisible')\n      .removeClass('hidden')\n      .children()\n      .each(function() {\n        optimalWidth = Math.max(optimalWidth, graphics.size($(this)).width);\n      });\n    return optimalWidth;\n  }\n\n  _resolve(optimalWidth) {\n    this.remove();\n    if (this.deferred) {\n      this.deferred.resolve(optimalWidth);\n      this.deferred = null;\n    }\n  }\n\n  _appendElements() {\n    this._appendHeader();\n    this._appendRows();\n    this._appendAggregateRows();\n  }\n\n  _appendHeader() {\n    if (this.column.$header) {\n      this._appendToMeasurement(this.column.$header.clone());\n    }\n  }\n\n  _appendRows() {\n    this.table.rows.forEach(this._appendRow.bind(this));\n    this._columnCellContents = {};\n  }\n\n  _appendRow(row) {\n    var columnContent = this.column.buildCellForRow(row);\n    if (this._columnCellContents[columnContent]) {\n      return;\n    }\n    this._columnCellContents[columnContent] = true;\n\n    this._appendToMeasurement($(columnContent));\n  }\n\n  _appendAggregateRows() {\n    this.table._aggregateRows.forEach(this._appendAggregateRow.bind(this));\n  }\n\n  _appendAggregateRow(row) {\n    this._appendToMeasurement($(this.column.buildCellForAggregateRow(row)));\n  }\n\n  _appendToMeasurement($calc) {\n    // Count images\n    var $calcImgs = $calc.find('img');\n    $calcImgs.each(function(index, elem) {\n      var $img = $(elem);\n      $img.data('measure', 'in-progress');\n      if (elem.complete) {\n        $img.data('complete', elem.complete);\n        this.completeImageCount++;\n      }\n      this.imageCount++;\n    }.bind(this));\n\n    // Append to measurement element\n    $calc.css({\n      minWidth: '',\n      maxWidth: ''\n    }).appendTo(this.$measurement);\n  }\n\n  _onImageLoadOrError(event) {\n    var $img = $(event.target);\n    if ($img.data('complete')) {\n      // Ignore images which were already complete and therefore already incremented the _imageCompleteCount\n      return;\n    }\n\n    this.completeImageCount++;\n    $.log.isTraceEnabled() && $.log.trace('Images complete (async) ' + this.completeImageCount + '/' + this.imageCount, event.target.src);\n    if (this.completeImageCount >= this.imageCount) {\n      var optimalWidth = this._measure();\n      $.log.isDebugEnabled() && $.log.debug('Optimal width measuring done (async) for column ' + this.column.id + ': ' + optimalWidth);\n      this._resolve(optimalWidth);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}