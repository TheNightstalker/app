{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, Dimension, graphics, HtmlComponent, LogicalGridLayout, PlaceholderTile, Point, Rectangle, scrollbars, styles } from '../index';\nimport $ from 'jquery';\n\nvar TileGridLayout = /*#__PURE__*/function (_LogicalGridLayout) {\n  _inherits(TileGridLayout, _LogicalGridLayout);\n\n  var _super = _createSuper(TileGridLayout);\n\n  function TileGridLayout(widget, layoutConfig) {\n    var _this;\n\n    _classCallCheck(this, TileGridLayout);\n\n    _this = _super.call(this, widget, layoutConfig);\n    _this.containerPos = null;\n    _this.containerScrollTop = null;\n    _this.tiles = [];\n    _this._calculatingPrimitivePrefSize = false;\n    return _this;\n  }\n\n  _createClass(TileGridLayout, [{\n    key: \"_initDefaults\",\n    value: function _initDefaults() {\n      _get(_getPrototypeOf(TileGridLayout.prototype), \"_initDefaults\", this).call(this);\n\n      var dim = TileGridLayout.getTileDimensions();\n      this.hgap = dim.x;\n      this.vgap = dim.y;\n      this.columnWidth = dim.width;\n      this.rowHeight = dim.height;\n      this.maxWidth = -1;\n    }\n  }, {\n    key: \"layout\",\n    value: function layout($container) {\n      var htmlComp = this.widget.htmlComp;\n\n      if (this.widget.scrolling) {\n        // Try to layout only as much as needed while scrolling in virtual mode\n        // Scroll top may be dirty when layout is validated before scrolling to a specific tile (see tileGrid.scrollTo)\n        if (!this.widget.scrollTopDirty) {\n          this.widget._renderViewPort();\n        }\n\n        this._layout($container);\n\n        this.widget.trigger('layoutAnimationDone');\n        return;\n      } // Animate only once on startup (if enabled) but animate every time on resize\n\n\n      var animated = htmlComp.layouted || this.widget.startupAnimationEnabled && !this.widget.startupAnimationDone || this.widget.renderAnimationEnabled;\n      this.tiles = this.widget.renderedTiles(); // Make them invisible otherwise the influence scrollHeight (e.g. if grid is scrolled to the very bottom and tiles are filtered, scrollbar would still increase scroll height)\n\n      scrollbars.setVisible($container, false); // Store the current position of the tiles\n\n      if (animated) {\n        this._storeBounds(this.tiles);\n      }\n\n      this._updateMaxWidth();\n\n      this._resetGridColumnCount();\n\n      this.widget.invalidateLayout();\n      this.widget.invalidateLogicalGrid(false);\n      var contentFits = false;\n      var containerWidth = $container.outerWidth();\n      containerWidth = Math.max(containerWidth, this.minWidth);\n\n      if (htmlComp.prefSize().width <= containerWidth) {\n        this._layout($container);\n\n        contentFits = true;\n      } // If content does not fit, the columnCount will be reduced until it fits\n\n\n      while (!contentFits && this.widget.gridColumnCount > 1) {\n        this.widget.gridColumnCount--;\n        this.widget.invalidateLayout();\n        this.widget.invalidateLogicalGrid(false);\n\n        if (htmlComp.prefSize().width <= containerWidth) {\n          this._layout($container);\n\n          contentFits = true;\n        }\n      } // If it does not fit, layout anyway (happens on small sizes if even one column is not sufficient)\n\n\n      if (!contentFits) {\n        this._layout($container);\n      }\n\n      if (!htmlComp.layouted) {\n        this.widget._renderScrollTop();\n      }\n\n      if (this.widget.virtual && (!htmlComp.layouted || this._sizeChanged(htmlComp) || this.widget.withPlaceholders)) {\n        // When changing size of the container, more or less tiles might be shown and some tiles might even change rows due to a new gridColumnCount -> ensure correct tiles are rendered in the range\n        this.widget.setViewRangeSize(this.widget.calculateViewRangeSize(), false);\n\n        var newTiles = this.widget._renderTileDelta(); // Make sure newly rendered tiles are animated (if enabled) and layouted as well\n\n\n        this._storeBounds(newTiles);\n\n        arrays.pushAll(this.tiles, newTiles);\n\n        this._layout($container);\n      }\n\n      var promises = [];\n\n      if (animated) {\n        promises = this._animateTiles();\n      }\n\n      this.widget.startupAnimationDone = true; // When all animations have been finished, trigger event and update scrollbar\n\n      if (promises.length > 0) {\n        $.promiseAll(promises).done(this._onAnimationDone.bind(this));\n      } else {\n        this._onAnimationDone();\n      }\n    }\n  }, {\n    key: \"_sizeChanged\",\n    value: function _sizeChanged(htmlComp) {\n      return htmlComp.sizeCached && !htmlComp.sizeCached.equals(htmlComp.size());\n    }\n  }, {\n    key: \"_storeBounds\",\n    value: function _storeBounds(tiles) {\n      tiles.forEach(function (tile, i) {\n        var bounds = graphics.cssBounds(tile.$container);\n        tile.$container.data('oldBounds', bounds);\n        tile.$container.data('was-layouted', tile.htmlComp.layouted);\n      }, this);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_validateGridData\",\n    value: function _validateGridData(htmlComp) {\n      htmlComp.$comp.removeClass('newly-rendered');\n      return _get(_getPrototypeOf(TileGridLayout.prototype), \"_validateGridData\", this).call(this, htmlComp);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_layoutCellBounds\",\n    value: function _layoutCellBounds(containerSize, containerInsets) {\n      // Since the tiles are positioned absolutely it is necessary to add the height of the filler to the top insets\n      if (this.widget.virtual) {\n        containerInsets.top += this.widget.$fillBefore.outerHeight(true);\n      }\n\n      return _get(_getPrototypeOf(TileGridLayout.prototype), \"_layoutCellBounds\", this).call(this, containerSize, containerInsets);\n    }\n  }, {\n    key: \"_animateTiles\",\n    value: function _animateTiles() {\n      var htmlComp = this.widget.htmlComp;\n      var $container = htmlComp.$comp;\n      this.containerPos = htmlComp.offset();\n      this.containerScrollTop = $container.scrollTop(); // Hide scrollbar before the animation (does not look good if scrollbar is hidden after the animation)\n\n      scrollbars.setVisible($container, true);\n      scrollbars.opacity($container, 0); // Animate the position change of the tiles\n\n      var promises = [];\n      this.tiles.forEach(function (tile, i) {\n        if (!tile.rendered) {\n          // Only animate tiles which were there at the beginning of the layout\n          // RenderViewPort may remove or render some, the removed ones cannot be animated because $container is missing and don't need to anyway, the rendered ones cannot because fromBounds are missing\n          return;\n        }\n\n        var promise = this._animateTile(tile);\n\n        if (promise) {\n          promises.push(promise);\n        }\n\n        tile.$container.removeData('oldBounds');\n        tile.$container.removeData('was-layouted');\n      }, this);\n      return promises;\n    }\n  }, {\n    key: \"_animateTile\",\n    value: function _animateTile(tile) {\n      var htmlComp = this.widget.htmlComp; // Stop running animations before starting the new ones to make sure existing promises are not resolved too early\n      // It may also happen that while the animation of a tile is in progress, the layout is triggered again but the tile should not be animated anymore\n      // (e.g. if it is not in the viewport anymore). In that case the animation must be stopped otherwise it may be placed at a wrong position\n\n      tile.$container.stop();\n\n      if (tile.$container.hasClass('invisible') || tile.$container.hasClass('animate-visible')) {\n        // When tiles are inserted they are invisible because a dedicated insert animation will be started after the layouting,\n        // the animation here is to animate the position change -> don't animate inserted tiles here\n        // Also: don't animate tiles which are fading in (due to filtering), they should appear at the correct position.\n        // Already visible tiles which were in the view port before will be moved from the old position. Tiles which were not in the view port before will fly in from the top left corner (same happens when sorting).\n        // Reason: When sorting, if some tiles are in the viewport and some not, it is confusing if some tiles just appear and others are moved, even though all actually change position.\n        return;\n      }\n\n      var bounds = graphics.cssBounds(tile.$container);\n      var fromBounds = tile.$container.data('oldBounds');\n\n      if (tile instanceof PlaceholderTile && !tile.$container.data('was-layouted')) {\n        // Placeholders may not have fromBounds because they are added while layouting\n        // Just let them appear at the correct position\n        fromBounds = bounds.clone();\n      }\n\n      if (!htmlComp.layouted && this.widget.startupAnimationDone && this.widget.renderAnimationEnabled) {\n        // This is a small, discreet render animation, just move the tiles a little\n        // It will happen if the startup animation is disabled or done and every time the tiles are rendered anew\n        fromBounds = new Rectangle(bounds.x * 0.95, bounds.y * 0.95, bounds.width, bounds.height);\n      }\n\n      if (fromBounds.equals(bounds)) {\n        // Don't animate if bounds are equals (otherwise promises would always resolve after 300ms even though no animation was visible)\n        return;\n      }\n\n      if (!this._inViewport(bounds) && !this._inViewport(fromBounds)) {\n        // If neither the new nor the old position is in the viewport don't animate the tile. This will affect the animation performance in a positive way if there are many tiles\n        return;\n      }\n\n      if (!tile.$container.data('was-layouted') && !this._inViewport(bounds)) {\n        // If a newly inserted tile will be rendered outside the view port, don't animate it. If it is rendered inside the view port it is fine if it will be moved from the top left corner\n        return;\n      } // Start animation\n\n\n      return this._animateTileBounds(tile, fromBounds, bounds);\n    }\n  }, {\n    key: \"_inViewport\",\n    value: function _inViewport(bounds) {\n      bounds = bounds.translate(this.containerPos.x, this.containerPos.y).translate(0, -this.containerScrollTop);\n      var topLeftPos = new Point(bounds.x, bounds.y);\n      var bottomRightPos = new Point(bounds.x + bounds.width, bounds.y + bounds.height);\n      var $scrollable = this.widget.$container.scrollParent();\n      return scrollbars.isLocationInView(topLeftPos, $scrollable) || scrollbars.isLocationInView(bottomRightPos, $scrollable);\n    }\n  }, {\n    key: \"_onAnimationDone\",\n    value: function _onAnimationDone() {\n      this._updateScrollbar();\n\n      this.widget.trigger('layoutAnimationDone');\n    }\n  }, {\n    key: \"_animateTileBounds\",\n    value: function _animateTileBounds(tile, fromBounds, bounds) {\n      // jQuery's animate() function sets \"overflow: hidden\" during the animation. After the animation, the\n      // original value is restored. (Search for \"opts.overflow\" in the jQuery source code, and see\n      // https://stackoverflow.com/a/5696656/7188380 for details why this is required.)\n      // Unfortunately, because we are running multiple animations in parallel here, the second animation will\n      // remember the temporary value set by the first animation and will restore it at the end. This causes the\n      // tile to have the inline style \"overflow: hidden\" after all animations have been completed, even if the\n      // CSS rules say something different.\n      // As a workaround, we remember the correct original value ourselves and restore it manually after all\n      // individual animations have been completed. Only then will the resulting promise be resolved.\n      var elem = tile.$container[0];\n      var oldOverflowStyles = [elem.style.overflow, elem.style.overflowX, elem.style.overflowY];\n\n      var restoreOverflowStyle = function restoreOverflowStyle() {\n        elem.style.overflow = oldOverflowStyles[0];\n        elem.style.overflowX = oldOverflowStyles[1];\n        elem.style.overflowY = oldOverflowStyles[2];\n      };\n\n      var promises = [];\n      tile.$container.cssLeftAnimated(fromBounds.x, bounds.x, {\n        start: function start(promise) {\n          promises.push(promise);\n        },\n        queue: false\n      }).cssTopAnimated(fromBounds.y, bounds.y, {\n        start: function start(promise) {\n          promises.push(promise);\n        },\n        queue: false\n      }).cssWidthAnimated(fromBounds.width, bounds.width, {\n        start: function start(promise) {\n          promises.push(promise);\n        },\n        queue: false\n      }).cssHeightAnimated(fromBounds.height, bounds.height, {\n        start: function start(promise) {\n          promises.push(promise);\n        },\n        queue: false\n      });\n      return $.promiseAll(promises).then(restoreOverflowStyle);\n    }\n  }, {\n    key: \"_updateScrollbar\",\n    value: function _updateScrollbar() {\n      scrollbars.setVisible(this.widget.$container, true);\n      scrollbars.opacity(this.widget.$container, 1); // Update first scrollable parent (if widget itself is not scrollable, maybe a parent is)\n\n      var htmlComp = this.widget.htmlComp;\n\n      while (htmlComp) {\n        if (htmlComp.scrollable) {\n          // Update immediately to prevent flickering (scrollbar is made visible on the top of this function)\n          scrollbars.update(htmlComp.$comp, true);\n          break;\n        }\n\n        htmlComp = htmlComp.getParent();\n      }\n    }\n    /**\n     * When max. width should be enforced, add a padding to the container if necessary\n     * (to make sure, scrollbar position is not changed)\n     */\n\n  }, {\n    key: \"_updateMaxWidth\",\n    value: function _updateMaxWidth() {\n      // Reset padding-right set by layout\n      var htmlComp = this.widget.htmlComp;\n      htmlComp.$comp.cssPaddingRight(null);\n\n      if (this.maxWidth <= 0) {\n        return;\n      } // Measure current padding-right (by CSS)\n\n\n      var cssPaddingRight = htmlComp.$comp.cssPaddingRight(); // Calculate difference between current with and max. width\n\n      var containerSize = htmlComp.size();\n      var oldWidth = containerSize.width;\n      var newWidth = Math.min(containerSize.width, this.maxWidth);\n      var diff = oldWidth - newWidth - htmlComp.$comp.cssPaddingLeft() - htmlComp.$comp.cssBorderWidthX();\n\n      if (diff > cssPaddingRight) {\n        htmlComp.$comp.cssPaddingRight(diff);\n      }\n    }\n  }, {\n    key: \"_resetGridColumnCount\",\n    value: function _resetGridColumnCount() {\n      this.widget.gridColumnCount = this.widget.prefGridColumnCount;\n    }\n  }, {\n    key: \"preferredLayoutSize\",\n    value: function preferredLayoutSize($container, options) {\n      options = $.extend({}, options);\n\n      if (this.widget.virtual) {\n        return this.virtualPrefSize($container, options);\n      }\n\n      return this.primitivePrefSize($container, options);\n    }\n    /**\n     * Calculates the preferred size only based on the grid column count, row count and layout config. Does not use rendered elements.\n     * Therefore only works if all tiles are of the same size (which is a precondition for the virtual scrolling anyway).\n     */\n\n  }, {\n    key: \"virtualPrefSize\",\n    value: function virtualPrefSize($container, options) {\n      var rowCount, columnCount;\n      var insets = HtmlComponent.get($container).insets();\n      var prefSize = new Dimension();\n      var columnWidth = this.columnWidth;\n      var rowHeight = this.rowHeight;\n      var hgap = this.hgap;\n      var vgap = this.vgap;\n\n      if (options.widthHint) {\n        columnCount = Math.floor(options.widthHint / (columnWidth + hgap));\n        var width = columnCount * (columnWidth + hgap);\n\n        if (options.widthHint - width > columnWidth) {\n          // The last column does not have a hgap -> Correct the grid column count if another column would fit in\n          columnCount++;\n        }\n\n        columnCount = Math.max(Math.min(this.widget.prefGridColumnCount, columnCount), 1);\n        rowCount = this.widget.rowCount(columnCount);\n        prefSize.width = options.widthHint;\n        prefSize.height = Math.max(rowCount * rowHeight + (rowCount - 1) * vgap, 0);\n        prefSize.width += insets.horizontal();\n        prefSize.height += insets.vertical();\n        return prefSize;\n      }\n\n      columnCount = this.widget.gridColumnCount;\n      rowCount = this.widget.rowCount();\n      prefSize.width = Math.max(columnCount * columnWidth + (columnCount - 1) * hgap, 0);\n      prefSize.height = Math.max(rowCount * rowHeight + (rowCount - 1) * vgap, 0);\n      prefSize.width += insets.horizontal();\n      prefSize.height += insets.vertical();\n      return prefSize;\n    }\n  }, {\n    key: \"primitivePrefSize\",\n    value: function primitivePrefSize($container, options) {\n      if (!options.widthHint || this._calculatingPrimitivePrefSize) {\n        return _get(_getPrototypeOf(TileGridLayout.prototype), \"preferredLayoutSize\", this).call(this, $container, options);\n      }\n\n      this._calculatingPrimitivePrefSize = true;\n\n      var prefSize = this._primitivePrefSize(options);\n\n      this._calculatingPrimitivePrefSize = false;\n      return prefSize;\n    }\n  }, {\n    key: \"_primitivePrefSize\",\n    value: function _primitivePrefSize(options) {\n      var prefSize,\n          htmlComp = this.widget.htmlComp,\n          contentFits = false,\n          gridColumnCount = this.widget.gridColumnCount,\n          width = options.widthHint; // prefSize will be called for tileGrid itself, hints must not be adjusted\n\n      options.removeInsetsFromHints = false;\n      width += htmlComp.insets().horizontal();\n\n      this._resetGridColumnCount();\n\n      this.widget.invalidateLayout();\n      this.widget.invalidateLogicalGrid(false);\n      prefSize = htmlComp.prefSize(options);\n\n      if (prefSize.width <= width) {\n        contentFits = true;\n      }\n\n      while (!contentFits && this.widget.gridColumnCount > 1) {\n        this.widget.gridColumnCount--;\n        this.widget.invalidateLayout();\n        this.widget.invalidateLogicalGrid(false);\n        prefSize = htmlComp.prefSize(options);\n\n        if (prefSize.width <= width) {\n          contentFits = true;\n        }\n      } // Reset to previous gridColumnCount (prefSize should not modify properties)\n\n\n      this.widget.gridColumnCount = gridColumnCount;\n      return prefSize;\n    }\n  }], [{\n    key: \"getTileDimensions\",\n    value: function getTileDimensions() {\n      if (!(TileGridLayout._DEFAULTSIZE instanceof Rectangle)) {\n        var h = styles.getSize('tile-grid-layout-config', 'height', 'height', -1);\n        var w = styles.getSize('tile-grid-layout-config', 'width', 'width', -1);\n        var horizontalGap = styles.getSize('tile-grid-layout-config', 'margin-left', 'marginLeft', -1);\n        var verticalGap = styles.getSize('tile-grid-layout-config', 'margin-top', 'marginTop', -1);\n        TileGridLayout._DEFAULTSIZE = new Rectangle(horizontalGap, verticalGap, w, h);\n      }\n\n      return TileGridLayout._DEFAULTSIZE;\n    }\n  }]);\n\n  return TileGridLayout;\n}(LogicalGridLayout);\n\n_defineProperty(TileGridLayout, \"_DEFAULTSIZE\", undefined);\n\nexport { TileGridLayout as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/tile/TileGridLayout.js"],"names":["arrays","Dimension","graphics","HtmlComponent","LogicalGridLayout","PlaceholderTile","Point","Rectangle","scrollbars","styles","$","TileGridLayout","widget","layoutConfig","containerPos","containerScrollTop","tiles","_calculatingPrimitivePrefSize","dim","getTileDimensions","hgap","x","vgap","y","columnWidth","width","rowHeight","height","maxWidth","$container","htmlComp","scrolling","scrollTopDirty","_renderViewPort","_layout","trigger","animated","layouted","startupAnimationEnabled","startupAnimationDone","renderAnimationEnabled","renderedTiles","setVisible","_storeBounds","_updateMaxWidth","_resetGridColumnCount","invalidateLayout","invalidateLogicalGrid","contentFits","containerWidth","outerWidth","Math","max","minWidth","prefSize","gridColumnCount","_renderScrollTop","virtual","_sizeChanged","withPlaceholders","setViewRangeSize","calculateViewRangeSize","newTiles","_renderTileDelta","pushAll","promises","_animateTiles","length","promiseAll","done","_onAnimationDone","bind","sizeCached","equals","size","forEach","tile","i","bounds","cssBounds","data","$comp","removeClass","containerSize","containerInsets","top","$fillBefore","outerHeight","offset","scrollTop","opacity","rendered","promise","_animateTile","push","removeData","stop","hasClass","fromBounds","clone","_inViewport","_animateTileBounds","translate","topLeftPos","bottomRightPos","$scrollable","scrollParent","isLocationInView","_updateScrollbar","elem","oldOverflowStyles","style","overflow","overflowX","overflowY","restoreOverflowStyle","cssLeftAnimated","start","queue","cssTopAnimated","cssWidthAnimated","cssHeightAnimated","then","scrollable","update","getParent","cssPaddingRight","oldWidth","newWidth","min","diff","cssPaddingLeft","cssBorderWidthX","prefGridColumnCount","options","extend","virtualPrefSize","primitivePrefSize","rowCount","columnCount","insets","get","widthHint","floor","horizontal","vertical","_primitivePrefSize","removeInsetsFromHints","_DEFAULTSIZE","h","getSize","w","horizontalGap","verticalGap","undefined"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, Dimension, graphics, HtmlComponent, LogicalGridLayout, PlaceholderTile, Point, Rectangle, scrollbars, styles} from '../index';\nimport $ from 'jquery';\n\nexport default class TileGridLayout extends LogicalGridLayout {\n\n  constructor(widget, layoutConfig) {\n    super(widget, layoutConfig);\n    this.containerPos = null;\n    this.containerScrollTop = null;\n    this.tiles = [];\n    this._calculatingPrimitivePrefSize = false;\n  }\n\n  static _DEFAULTSIZE = undefined;\n\n  static getTileDimensions() {\n    if (!(TileGridLayout._DEFAULTSIZE instanceof Rectangle)) {\n      var h = styles.getSize('tile-grid-layout-config', 'height', 'height', -1);\n      var w = styles.getSize('tile-grid-layout-config', 'width', 'width', -1);\n      var horizontalGap = styles.getSize('tile-grid-layout-config', 'margin-left', 'marginLeft', -1);\n      var verticalGap = styles.getSize('tile-grid-layout-config', 'margin-top', 'marginTop', -1);\n      TileGridLayout._DEFAULTSIZE = new Rectangle(horizontalGap, verticalGap, w, h);\n    }\n    return TileGridLayout._DEFAULTSIZE;\n  }\n\n  _initDefaults() {\n    super._initDefaults();\n    var dim = TileGridLayout.getTileDimensions();\n    this.hgap = dim.x;\n    this.vgap = dim.y;\n    this.columnWidth = dim.width;\n    this.rowHeight = dim.height;\n    this.maxWidth = -1;\n  }\n\n  layout($container) {\n    var htmlComp = this.widget.htmlComp;\n    if (this.widget.scrolling) {\n      // Try to layout only as much as needed while scrolling in virtual mode\n      // Scroll top may be dirty when layout is validated before scrolling to a specific tile (see tileGrid.scrollTo)\n      if (!this.widget.scrollTopDirty) {\n        this.widget._renderViewPort();\n      }\n      this._layout($container);\n      this.widget.trigger('layoutAnimationDone');\n      return;\n    }\n\n    // Animate only once on startup (if enabled) but animate every time on resize\n    var animated = htmlComp.layouted || (this.widget.startupAnimationEnabled && !this.widget.startupAnimationDone) || this.widget.renderAnimationEnabled;\n    this.tiles = this.widget.renderedTiles();\n\n    // Make them invisible otherwise the influence scrollHeight (e.g. if grid is scrolled to the very bottom and tiles are filtered, scrollbar would still increase scroll height)\n    scrollbars.setVisible($container, false);\n\n    // Store the current position of the tiles\n    if (animated) {\n      this._storeBounds(this.tiles);\n    }\n\n    this._updateMaxWidth();\n    this._resetGridColumnCount();\n\n    this.widget.invalidateLayout();\n    this.widget.invalidateLogicalGrid(false);\n    var contentFits = false;\n    var containerWidth = $container.outerWidth();\n    containerWidth = Math.max(containerWidth, this.minWidth);\n    if (htmlComp.prefSize().width <= containerWidth) {\n      this._layout($container);\n      contentFits = true;\n    }\n\n    // If content does not fit, the columnCount will be reduced until it fits\n    while (!contentFits && this.widget.gridColumnCount > 1) {\n      this.widget.gridColumnCount--;\n      this.widget.invalidateLayout();\n      this.widget.invalidateLogicalGrid(false);\n      if (htmlComp.prefSize().width <= containerWidth) {\n        this._layout($container);\n        contentFits = true;\n      }\n    }\n\n    // If it does not fit, layout anyway (happens on small sizes if even one column is not sufficient)\n    if (!contentFits) {\n      this._layout($container);\n    }\n\n    if (!htmlComp.layouted) {\n      this.widget._renderScrollTop();\n    }\n    if (this.widget.virtual && (!htmlComp.layouted || this._sizeChanged(htmlComp) || this.widget.withPlaceholders)) {\n      // When changing size of the container, more or less tiles might be shown and some tiles might even change rows due to a new gridColumnCount -> ensure correct tiles are rendered in the range\n      this.widget.setViewRangeSize(this.widget.calculateViewRangeSize(), false);\n      var newTiles = this.widget._renderTileDelta();\n      // Make sure newly rendered tiles are animated (if enabled) and layouted as well\n      this._storeBounds(newTiles);\n      arrays.pushAll(this.tiles, newTiles);\n      this._layout($container);\n    }\n\n    var promises = [];\n    if (animated) {\n      promises = this._animateTiles();\n    }\n    this.widget.startupAnimationDone = true;\n\n    // When all animations have been finished, trigger event and update scrollbar\n    if (promises.length > 0) {\n      $.promiseAll(promises).done(this._onAnimationDone.bind(this));\n    } else {\n      this._onAnimationDone();\n    }\n  }\n\n  _sizeChanged(htmlComp) {\n    return htmlComp.sizeCached && !htmlComp.sizeCached.equals(htmlComp.size());\n  }\n\n  _storeBounds(tiles) {\n    tiles.forEach(function(tile, i) {\n      var bounds = graphics.cssBounds(tile.$container);\n      tile.$container.data('oldBounds', bounds);\n      tile.$container.data('was-layouted', tile.htmlComp.layouted);\n    }, this);\n  }\n\n  /**\n   * @override\n   */\n  _validateGridData(htmlComp) {\n    htmlComp.$comp.removeClass('newly-rendered');\n    return super._validateGridData(htmlComp);\n  }\n\n  /**\n   * @override\n   */\n  _layoutCellBounds(containerSize, containerInsets) {\n    // Since the tiles are positioned absolutely it is necessary to add the height of the filler to the top insets\n    if (this.widget.virtual) {\n      containerInsets.top += this.widget.$fillBefore.outerHeight(true);\n    }\n    return super._layoutCellBounds(containerSize, containerInsets);\n  }\n\n  _animateTiles() {\n    var htmlComp = this.widget.htmlComp;\n    var $container = htmlComp.$comp;\n\n    this.containerPos = htmlComp.offset();\n    this.containerScrollTop = $container.scrollTop();\n\n    // Hide scrollbar before the animation (does not look good if scrollbar is hidden after the animation)\n    scrollbars.setVisible($container, true);\n    scrollbars.opacity($container, 0);\n\n    // Animate the position change of the tiles\n    var promises = [];\n    this.tiles.forEach(function(tile, i) {\n      if (!tile.rendered) {\n        // Only animate tiles which were there at the beginning of the layout\n        // RenderViewPort may remove or render some, the removed ones cannot be animated because $container is missing and don't need to anyway, the rendered ones cannot because fromBounds are missing\n        return;\n      }\n\n      var promise = this._animateTile(tile);\n      if (promise) {\n        promises.push(promise);\n      }\n\n      tile.$container.removeData('oldBounds');\n      tile.$container.removeData('was-layouted');\n    }, this);\n\n    return promises;\n  }\n\n  _animateTile(tile) {\n    var htmlComp = this.widget.htmlComp;\n\n    // Stop running animations before starting the new ones to make sure existing promises are not resolved too early\n    // It may also happen that while the animation of a tile is in progress, the layout is triggered again but the tile should not be animated anymore\n    // (e.g. if it is not in the viewport anymore). In that case the animation must be stopped otherwise it may be placed at a wrong position\n    tile.$container.stop();\n\n    if (tile.$container.hasClass('invisible') || tile.$container.hasClass('animate-visible')) {\n      // When tiles are inserted they are invisible because a dedicated insert animation will be started after the layouting,\n      // the animation here is to animate the position change -> don't animate inserted tiles here\n\n      // Also: don't animate tiles which are fading in (due to filtering), they should appear at the correct position.\n      // Already visible tiles which were in the view port before will be moved from the old position. Tiles which were not in the view port before will fly in from the top left corner (same happens when sorting).\n      // Reason: When sorting, if some tiles are in the viewport and some not, it is confusing if some tiles just appear and others are moved, even though all actually change position.\n      return;\n    }\n\n    var bounds = graphics.cssBounds(tile.$container);\n    var fromBounds = tile.$container.data('oldBounds');\n    if (tile instanceof PlaceholderTile && !tile.$container.data('was-layouted')) {\n      // Placeholders may not have fromBounds because they are added while layouting\n      // Just let them appear at the correct position\n      fromBounds = bounds.clone();\n    }\n\n    if (!htmlComp.layouted && this.widget.startupAnimationDone && this.widget.renderAnimationEnabled) {\n      // This is a small, discreet render animation, just move the tiles a little\n      // It will happen if the startup animation is disabled or done and every time the tiles are rendered anew\n      fromBounds = new Rectangle(bounds.x * 0.95, bounds.y * 0.95, bounds.width, bounds.height);\n    }\n\n    if (fromBounds.equals(bounds)) {\n      // Don't animate if bounds are equals (otherwise promises would always resolve after 300ms even though no animation was visible)\n      return;\n    }\n\n    if (!this._inViewport(bounds) && !this._inViewport(fromBounds)) {\n      // If neither the new nor the old position is in the viewport don't animate the tile. This will affect the animation performance in a positive way if there are many tiles\n      return;\n    }\n\n    if (!tile.$container.data('was-layouted') && !this._inViewport(bounds)) {\n      // If a newly inserted tile will be rendered outside the view port, don't animate it. If it is rendered inside the view port it is fine if it will be moved from the top left corner\n      return;\n    }\n\n    // Start animation\n    return this._animateTileBounds(tile, fromBounds, bounds);\n  }\n\n  _inViewport(bounds) {\n    bounds = bounds.translate(this.containerPos.x, this.containerPos.y).translate(0, -this.containerScrollTop);\n    var topLeftPos = new Point(bounds.x, bounds.y);\n    var bottomRightPos = new Point(bounds.x + bounds.width, bounds.y + bounds.height);\n    var $scrollable = this.widget.$container.scrollParent();\n    return scrollbars.isLocationInView(topLeftPos, $scrollable) || scrollbars.isLocationInView(bottomRightPos, $scrollable);\n  }\n\n  _onAnimationDone() {\n    this._updateScrollbar();\n    this.widget.trigger('layoutAnimationDone');\n  }\n\n  _animateTileBounds(tile, fromBounds, bounds) {\n    // jQuery's animate() function sets \"overflow: hidden\" during the animation. After the animation, the\n    // original value is restored. (Search for \"opts.overflow\" in the jQuery source code, and see\n    // https://stackoverflow.com/a/5696656/7188380 for details why this is required.)\n    // Unfortunately, because we are running multiple animations in parallel here, the second animation will\n    // remember the temporary value set by the first animation and will restore it at the end. This causes the\n    // tile to have the inline style \"overflow: hidden\" after all animations have been completed, even if the\n    // CSS rules say something different.\n    // As a workaround, we remember the correct original value ourselves and restore it manually after all\n    // individual animations have been completed. Only then will the resulting promise be resolved.\n    var elem = tile.$container[0];\n    var oldOverflowStyles = [elem.style.overflow, elem.style.overflowX, elem.style.overflowY];\n    var restoreOverflowStyle = function() {\n      elem.style.overflow = oldOverflowStyles[0];\n      elem.style.overflowX = oldOverflowStyles[1];\n      elem.style.overflowY = oldOverflowStyles[2];\n    };\n\n    var promises = [];\n    tile.$container\n      .cssLeftAnimated(fromBounds.x, bounds.x, {\n        start: function(promise) {\n          promises.push(promise);\n        },\n        queue: false\n      })\n      .cssTopAnimated(fromBounds.y, bounds.y, {\n        start: function(promise) {\n          promises.push(promise);\n        },\n        queue: false\n      })\n      .cssWidthAnimated(fromBounds.width, bounds.width, {\n        start: function(promise) {\n          promises.push(promise);\n        },\n        queue: false\n      })\n      .cssHeightAnimated(fromBounds.height, bounds.height, {\n        start: function(promise) {\n          promises.push(promise);\n        },\n        queue: false\n      });\n\n    return $.promiseAll(promises).then(restoreOverflowStyle);\n  }\n\n  _updateScrollbar() {\n    scrollbars.setVisible(this.widget.$container, true);\n    scrollbars.opacity(this.widget.$container, 1);\n\n    // Update first scrollable parent (if widget itself is not scrollable, maybe a parent is)\n    var htmlComp = this.widget.htmlComp;\n    while (htmlComp) {\n      if (htmlComp.scrollable) {\n        // Update immediately to prevent flickering (scrollbar is made visible on the top of this function)\n        scrollbars.update(htmlComp.$comp, true);\n        break;\n      }\n      htmlComp = htmlComp.getParent();\n    }\n  }\n\n  /**\n   * When max. width should be enforced, add a padding to the container if necessary\n   * (to make sure, scrollbar position is not changed)\n   */\n  _updateMaxWidth() {\n    // Reset padding-right set by layout\n    var htmlComp = this.widget.htmlComp;\n    htmlComp.$comp.cssPaddingRight(null);\n\n    if (this.maxWidth <= 0) {\n      return;\n    }\n\n    // Measure current padding-right (by CSS)\n    var cssPaddingRight = htmlComp.$comp.cssPaddingRight();\n\n    // Calculate difference between current with and max. width\n    var containerSize = htmlComp.size();\n    var oldWidth = containerSize.width;\n    var newWidth = Math.min(containerSize.width, this.maxWidth);\n    var diff = oldWidth - newWidth - htmlComp.$comp.cssPaddingLeft() - htmlComp.$comp.cssBorderWidthX();\n    if (diff > cssPaddingRight) {\n      htmlComp.$comp.cssPaddingRight(diff);\n    }\n  }\n\n  _resetGridColumnCount() {\n    this.widget.gridColumnCount = this.widget.prefGridColumnCount;\n  }\n\n  preferredLayoutSize($container, options) {\n    options = $.extend({}, options);\n\n    if (this.widget.virtual) {\n      return this.virtualPrefSize($container, options);\n    }\n    return this.primitivePrefSize($container, options);\n  }\n\n  /**\n   * Calculates the preferred size only based on the grid column count, row count and layout config. Does not use rendered elements.\n   * Therefore only works if all tiles are of the same size (which is a precondition for the virtual scrolling anyway).\n   */\n  virtualPrefSize($container, options) {\n    var rowCount, columnCount;\n    var insets = HtmlComponent.get($container).insets();\n    var prefSize = new Dimension();\n    var columnWidth = this.columnWidth;\n    var rowHeight = this.rowHeight;\n    var hgap = this.hgap;\n    var vgap = this.vgap;\n\n    if (options.widthHint) {\n      columnCount = Math.floor(options.widthHint / (columnWidth + hgap));\n      var width = columnCount * (columnWidth + hgap);\n      if (options.widthHint - width > columnWidth) {\n        // The last column does not have a hgap -> Correct the grid column count if another column would fit in\n        columnCount++;\n      }\n      columnCount = Math.max(Math.min(this.widget.prefGridColumnCount, columnCount), 1);\n\n      rowCount = this.widget.rowCount(columnCount);\n      prefSize.width = options.widthHint;\n      prefSize.height = Math.max(rowCount * rowHeight + (rowCount - 1) * vgap, 0);\n      prefSize.width += insets.horizontal();\n      prefSize.height += insets.vertical();\n      return prefSize;\n    }\n\n    columnCount = this.widget.gridColumnCount;\n    rowCount = this.widget.rowCount();\n    prefSize.width = Math.max(columnCount * columnWidth + (columnCount - 1) * hgap, 0);\n    prefSize.height = Math.max(rowCount * rowHeight + (rowCount - 1) * vgap, 0);\n    prefSize.width += insets.horizontal();\n    prefSize.height += insets.vertical();\n    return prefSize;\n  }\n\n  primitivePrefSize($container, options) {\n    if (!options.widthHint || this._calculatingPrimitivePrefSize) {\n      return super.preferredLayoutSize($container, options);\n    }\n    this._calculatingPrimitivePrefSize = true;\n    var prefSize = this._primitivePrefSize(options);\n    this._calculatingPrimitivePrefSize = false;\n    return prefSize;\n  }\n\n  _primitivePrefSize(options) {\n    var prefSize,\n      htmlComp = this.widget.htmlComp,\n      contentFits = false,\n      gridColumnCount = this.widget.gridColumnCount,\n      width = options.widthHint;\n\n    // prefSize will be called for tileGrid itself, hints must not be adjusted\n    options.removeInsetsFromHints = false;\n\n    width += htmlComp.insets().horizontal();\n    this._resetGridColumnCount();\n\n    this.widget.invalidateLayout();\n    this.widget.invalidateLogicalGrid(false);\n    prefSize = htmlComp.prefSize(options);\n    if (prefSize.width <= width) {\n      contentFits = true;\n    }\n\n    while (!contentFits && this.widget.gridColumnCount > 1) {\n      this.widget.gridColumnCount--;\n      this.widget.invalidateLayout();\n      this.widget.invalidateLogicalGrid(false);\n      prefSize = htmlComp.prefSize(options);\n      if (prefSize.width <= width) {\n        contentFits = true;\n      }\n    }\n    // Reset to previous gridColumnCount (prefSize should not modify properties)\n    this.widget.gridColumnCount = gridColumnCount;\n    return prefSize;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}