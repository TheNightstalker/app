{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { events, graphics, Insets, scout, scrollbars, Widget } from '../index';\nimport $ from 'jquery';\n\nvar Scrollbar = /*#__PURE__*/function (_Widget) {\n  _inherits(Scrollbar, _Widget);\n\n  var _super = _createSuper(Scrollbar);\n\n  function Scrollbar() {\n    var _this;\n\n    _classCallCheck(this, Scrollbar);\n\n    _this = _super.call(this); // jQuery Elements\n\n    _this.$container = null; // Scrollbar <div>\n\n    _this.$thumb = null; // thumb body for layout purposes <div>\n\n    _this.$thumbHandle = null; // thumb handle <div>\n    // Defaults\n\n    _this.axis = 'y';\n    _this.borderless = false;\n    _this.mouseWheelNeedsShift = false; // Varaibles for calculation\n\n    _this._scrollSize = null;\n    _this._offsetSize = null; // Axis based helper variables (y)\n\n    _this._dim = 'Height'; // x: 'Width'\n\n    _this._dir = 'top'; // x: 'left'\n\n    _this._dirReverse = 'bottom'; // x: 'right'\n\n    _this._scrollDir = 'scrollTop'; // x: 'scrollLeft\n\n    _this._thumbClipping = new Insets(0, 0, 0, 0); // Event Handling\n\n    _this._onScrollHandler = _this._onScroll.bind(_assertThisInitialized(_this));\n    _this._onScrollWheelHandler = _this._onScrollWheel.bind(_assertThisInitialized(_this));\n    _this._onScrollbarMouseDownHandler = _this._onScrollbarMouseDown.bind(_assertThisInitialized(_this));\n    _this._onTouchStartHandler = _this._onTouchStart.bind(_assertThisInitialized(_this));\n    _this._onThumbMouseDownHandler = _this._onThumbMouseDown.bind(_assertThisInitialized(_this));\n    _this._onDocumentMousemoveHandler = _this._onDocumentMousemove.bind(_assertThisInitialized(_this));\n    _this._onDocumentMouseUpHandler = _this._onDocumentMouseUp.bind(_assertThisInitialized(_this));\n    _this._onAncestorScrollOrResizeHandler = _this.update.bind(_assertThisInitialized(_this)); // Fix Scrollbar\n\n    _this._fixScrollbarHandler = _this._fixScrollbar.bind(_assertThisInitialized(_this));\n    _this._unfixScrollbarHandler = _this._unfixScrollbar.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Scrollbar, [{\n    key: \"_render\",\n    value: function _render() {\n      this._ensureParentPosition(); // Create scrollbar and thumb\n\n\n      this.$container = this.$parent.appendDiv('scrollbar').addClass(this.axis + '-axis');\n      this._$thumb = this.$container.appendDiv('scrollbar-thumb').addClass(this.axis + '-axis');\n      this._$thumbHandle = this._$thumb.appendDiv('scrollbar-thumb-handle').addClass(this.axis + '-axis');\n\n      if (this.borderless) {\n        this.$container.addClass('borderless');\n      } // Init helper variables based on axis (x/y)\n\n\n      this._dim = this.axis === 'x' ? 'Width' : 'Height';\n      this._dir = this.axis === 'x' ? 'left' : 'top';\n      this._dirReverse = this.axis === 'x' ? 'right' : 'bottom';\n      this._scrollDir = this.axis === 'x' ? 'scrollLeft' : 'scrollTop'; // Install listeners\n\n      var scrollbars = this.$parent.data('scrollbars');\n\n      if (!scrollbars) {\n        throw new Error('Data \"scrollbars\" missing in ' + graphics.debugOutput(this.$parent) + '\\nAncestors: ' + this.ancestorsToString(1));\n      }\n\n      this.$parent.on('DOMMouseScroll mousewheel', this._onScrollWheelHandler).on('scroll', this._onScrollHandler).onPassive('touchstart', this._onTouchStartHandler);\n      scrollbars.forEach(function (scrollbar) {\n        scrollbar.on('scrollStart', this._fixScrollbarHandler);\n        scrollbar.on('scrollEnd', this._unfixScrollbarHandler);\n      }.bind(this));\n      this.$container.on('mousedown', this._onScrollbarMouseDownHandler);\n\n      this._$thumb.on('mousedown', this._onThumbMouseDownHandler); // Scrollbar might be clipped to prevent overlapping an ancestor. In order to reset this clipping the scrollbar needs\n      // an update whenever a parent div is scrolled ore resized.\n\n\n      this._$ancestors = this.$container.parents('div').on('scroll resize', this._onAncestorScrollOrResizeHandler);\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      // Uninstall listeners\n      var scrollbars = this.$parent.data('scrollbars');\n      this.$parent.off('DOMMouseScroll mousewheel', this._onScrollWheelHandler).off('scroll', this._onScrollHandler).offPassive('touchstart', this._onTouchStartHandler);\n      scrollbars.forEach(function (scrollbar) {\n        scrollbar.off('scrollStart', this._fixScrollbarHandler);\n        scrollbar.off('scrollEnd', this._unfixScrollbarHandler);\n      }.bind(this));\n      this.$container.off('mousedown', this._onScrollbarMouseDownHandler);\n\n      this._$thumb.off('mousedown', '', this._onThumbMouseDownHandler);\n\n      this._$ancestors.off('scroll resize', this._onAncestorScrollOrResizeHandler);\n\n      this._$ancestors = null;\n\n      _get(_getPrototypeOf(Scrollbar.prototype), \"_remove\", this).call(this);\n    }\n  }, {\n    key: \"_renderOnAttach\",\n    value: function _renderOnAttach() {\n      _get(_getPrototypeOf(Scrollbar.prototype), \"_renderOnAttach\", this).call(this);\n\n      this._ensureParentPosition();\n    }\n  }, {\n    key: \"_ensureParentPosition\",\n    value: function _ensureParentPosition() {\n      // Container with JS scrollbars must have either relative or absolute position\n      // otherwise we cannot determine the correct dimension of the scrollbars\n      if (this.$parent && this.$parent.isAttached()) {\n        var cssPosition = this.$parent.css('position');\n\n        if (!scout.isOneOf(cssPosition, 'relative', 'absolute')) {\n          this.$parent.css('position', 'relative');\n        }\n      }\n    }\n    /**\n     * scroll by \"diff\" in px (positive and negative)\n     */\n\n  }, {\n    key: \"scroll\",\n    value: function scroll(diff) {\n      var posOld = Math.max(0, this.$parent[this._scrollDir]());\n\n      this._scrollToAbsolutePoint(posOld + diff);\n    }\n    /**\n     * scroll to absolute point (expressed as absolute point in px)\n     */\n\n  }, {\n    key: \"_scrollToAbsolutePoint\",\n    value: function _scrollToAbsolutePoint(absolutePoint) {\n      var scrollPos = Math.min(this._scrollSize - this._offsetSize + 1, // scrollPos can't be larger than the start of last page. Add +1 because at least chrome has issues to scroll to the very bottom if scrollTop is fractional\n      Math.max(0, Math.round(absolutePoint))); // scrollPos can't be negative\n\n      this.$parent[this._scrollDir](scrollPos);\n    }\n    /**\n     * do not use this internal method (triggered by scroll event)\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (!this.rendered) {\n        return;\n      }\n\n      var margin = this.$container['cssMargin' + this.axis.toUpperCase()]();\n\n      var scrollPos = this.$parent[this._scrollDir]();\n\n      var scrollLeft = this.$parent.scrollLeft();\n      var scrollTop = this.$parent.scrollTop();\n      this.reset();\n      this._offsetSize = this.$parent[0]['offset' + this._dim];\n      this._scrollSize = this.$parent[0]['scroll' + this._dim]; // calc size and range of thumb\n\n      var thumbSize = Math.max(this._offsetSize * this._offsetSize / this._scrollSize - margin, 25);\n      var thumbRange = this._offsetSize - thumbSize - margin; // set size of thumb\n\n      this._$thumb.css(this._dim.toLowerCase(), thumbSize); // set location of thumb\n\n\n      var posNew = scrollPos / (this._scrollSize - this._offsetSize) * thumbRange;\n\n      this._$thumb.css(this._dir, posNew); // Add 1px to make sure scroll bar is not shown if width is a floating point value.\n      // Even if we were using getBoundingClientRect().width to get an exact width,\n      // it would not help because scroll size is always an integer\n\n\n      var offsetFix = 1; // show scrollbar\n\n      if (this._offsetSize + offsetFix >= this._scrollSize) {\n        this.$container.css('display', 'none');\n      } else {\n        this.$container.css('display', ''); // indicate that thumb movement is not possible\n\n        if (this._isContainerTooSmallForThumb()) {\n          this._$thumb.addClass('container-too-small-for-thumb');\n        } else {\n          this._$thumb.removeClass('container-too-small-for-thumb');\n        }\n      }\n\n      this._clipWhenOverlappingAncestor(); // Position the scrollbar(s)\n      // Always update both to make sure every scrollbar (x and y) is positioned correctly\n\n\n      this.$container.cssRight(-1 * scrollLeft);\n      this.$container.cssBottom(-1 * scrollTop);\n    }\n  }, {\n    key: \"_resetClipping\",\n    value: function _resetClipping() {\n      // Only reset dimension and position for the secondary axis,\n      // for the scroll-axis these properties are set during update()\n      if (this.axis === 'y') {\n        this._$thumb.css('width', '').css('left', '');\n      } else {\n        this._$thumb.css('height', '').css('top', '');\n      }\n\n      this._$thumb.removeClass('clipped-left clipped-right clipped-top clipped-bottom');\n\n      this._thumbClipping = new Insets(0, 0, 0, 0);\n    }\n    /**\n     * Make sure scrollbar does not appear outside an ancestor when fixed\n     */\n\n  }, {\n    key: \"_clipWhenOverlappingAncestor\",\n    value: function _clipWhenOverlappingAncestor() {\n      this._resetClipping(); // Clipping is only needed when scrollbar has a fixed position.\n      // Otherwise the over-size is handled by 'overflow: hidden;'.\n\n\n      if (this.$container.css('position') === 'fixed') {\n        var thumbBounds = graphics.offsetBounds(this._$thumb);\n        var thumbWidth = thumbBounds.width;\n        var thumbHeight = thumbBounds.height;\n        var thumbEndX = thumbBounds.x + thumbBounds.width;\n        var thumbEndY = thumbBounds.y + thumbBounds.height;\n        var biggestAncestorBeginX = 0;\n        var biggestAncestorBeginY = 0;\n        var smallestAncestorEndX = thumbEndX;\n        var smallestAncestorEndY = thumbEndY; // Find nearest clip boundaries: It is not necessarily the boundary of the closest ancestor-div in the DOM,\n        // because ancestor-divs themselves may be scrolled.\n\n        this.$container.parents('div').each(function () {\n          var $ancestor = $(this);\n          var ancestorBounds = graphics.offsetBounds($ancestor);\n\n          if ($ancestor.css('overflow-x') !== 'visible') {\n            if (ancestorBounds.x > biggestAncestorBeginX) {\n              biggestAncestorBeginX = ancestorBounds.x;\n            }\n\n            var ancestorEndX = ancestorBounds.x + ancestorBounds.width;\n\n            if (ancestorEndX < smallestAncestorEndX) {\n              smallestAncestorEndX = ancestorEndX;\n            }\n          }\n\n          if ($ancestor.css('overflow-y') !== 'visible') {\n            if (ancestorBounds.y > biggestAncestorBeginY) {\n              biggestAncestorBeginY = ancestorBounds.y;\n            }\n\n            var ancestorEndY = ancestorBounds.y + ancestorBounds.height;\n\n            if (ancestorEndY < smallestAncestorEndY) {\n              smallestAncestorEndY = ancestorEndY;\n            }\n          }\n        });\n        var clipLeft = 0;\n        var clipRight = 0;\n        var clipTop = 0;\n        var clipBottom = 0; // clip left\n\n        if (biggestAncestorBeginX > thumbBounds.x) {\n          clipLeft = biggestAncestorBeginX - thumbBounds.x;\n          thumbWidth -= clipLeft;\n\n          this._$thumb.css('width', thumbWidth).css('left', graphics.bounds(this._$thumb).x + clipLeft).addClass('clipped-left');\n        } // clip top\n\n\n        if (biggestAncestorBeginY > thumbBounds.y) {\n          clipTop = biggestAncestorBeginY - thumbBounds.y;\n          thumbHeight -= clipTop;\n\n          this._$thumb.css('height', thumbHeight).css('top', graphics.bounds(this._$thumb).y + clipTop).addClass('clipped-top');\n        } // clip right\n\n\n        if (thumbEndX > smallestAncestorEndX) {\n          clipRight = thumbEndX - smallestAncestorEndX;\n\n          this._$thumb.css('width', thumbWidth - clipRight).addClass('clipped-right');\n        } // clip bottom\n\n\n        if (thumbEndY > smallestAncestorEndY) {\n          clipBottom = thumbEndY - smallestAncestorEndY;\n\n          this._$thumb.css('height', thumbHeight - clipBottom).addClass('clipped-bottom');\n        }\n\n        this._thumbClipping = new Insets(clipTop, clipRight, clipBottom, clipLeft);\n      }\n    }\n    /**\n     * Resets thumb size and scrollbar position to make sure it does not extend the scrollSize\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._$thumb.css(this._dim.toLowerCase(), 0);\n\n      this.$container.cssRight(0);\n      this.$container.cssBottom(0);\n    }\n    /*\n     * EVENT HANDLING\n     */\n\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll(event) {\n      this.update();\n    }\n  }, {\n    key: \"_onTouchStart\",\n    value: function _onTouchStart(event) {\n      // In hybrid mode scroll bar is moved by the scroll event.\n      // On a mobile device scroll events are fired delayed so the update will be delayed as well.\n      // This will lead to flickering and could be prevented by calling fixScrollbar. But unfortunately calling fix will stop the scroll pane from scrolling immediately, at least in Edge.\n      // In order to reduce the flickering the current approach is to hide the scrollbars while scrolling (only in this specific hybrid touch scrolling)\n      events.onScrollStartEndDuringTouch(this.$parent, function () {\n        if (!this.rendered) {\n          return;\n        }\n\n        this.$container.css('opacity', 0);\n      }.bind(this), function () {\n        if (!this.rendered) {\n          return;\n        }\n\n        this.$container.css('opacity', '');\n      }.bind(this));\n    }\n  }, {\n    key: \"_onScrollWheel\",\n    value: function _onScrollWheel(event) {\n      if (!this.$container.isVisible()) {\n        return true; // ignore scroll wheel event if there is no scroll bar visible\n      }\n\n      if (event.ctrlKey) {\n        return true; // allow ctrl + mousewheel to zoom the page\n      }\n\n      if (this.mouseWheelNeedsShift !== event.shiftKey) {\n        return true; // only scroll if shift modifier matches\n      }\n\n      event = event.originalEvent || this.$container.window(true).event.originalEvent;\n      var w = event.wheelDelta ? -event.wheelDelta / 2 : event.detail * 20;\n      this.notifyBeforeScroll();\n      this.scroll(w);\n      this.notifyAfterScroll();\n      return false;\n    }\n  }, {\n    key: \"_onScrollbarMouseDown\",\n    value: function _onScrollbarMouseDown(event) {\n      this.notifyBeforeScroll();\n\n      var clickableAreaSize = this.$container[this._dim.toLowerCase()]();\n\n      var offset = this.$container.offset()[this._dir];\n\n      var clicked = (this.axis === 'x' ? event.pageX : event.pageY) - offset;\n      var percentage;\n\n      if (this._isContainerTooSmallForThumb()) {\n        percentage = Math.min(1, Math.max(0, clicked / clickableAreaSize)); // percentage can't be larger than 1, nor negative\n\n        this._scrollToAbsolutePoint(percentage * this._scrollSize - Math.round(this._offsetSize / 2));\n      } else {\n        // move the thumb center to clicked point\n        var thumbSize = this._$thumb['outer' + this._dim](true);\n\n        var minPossible = Math.round(thumbSize / 2);\n        var maxPossible = clickableAreaSize - Math.round(thumbSize / 2);\n        var rawPercentage = (clicked - minPossible) * (1 / (maxPossible - minPossible));\n        percentage = Math.min(1, Math.max(0, rawPercentage)); // percentage can't be larger than 1, nor negative\n\n        this._scrollToAbsolutePoint(percentage * (this._scrollSize - this._offsetSize));\n      }\n\n      this.notifyAfterScroll();\n    }\n  }, {\n    key: \"_onThumbMouseDown\",\n    value: function _onThumbMouseDown(event) {\n      // ignore event if container is too small for thumb movement\n      if (this._isContainerTooSmallForThumb()) {\n        return true; // let _onScrollbarMouseDown handle the click event\n      }\n\n      this.notifyBeforeScroll(); // calculate thumbCenterOffset in px (offset from clicked point to thumb center)\n\n      var clipped = this.axis === 'x' ? this._thumbClipping.horizontal() : this._thumbClipping.vertical();\n\n      var thumbSize = clipped + this._$thumb['outer' + this._dim](true); // including border, margin and padding\n\n\n      var thumbClippingOffset = this.axis === 'x' ? this._thumbClipping.left : this._thumbClipping.top;\n      var thumbCenter = this._$thumb.offset()[this._dir] + Math.floor(thumbSize / 2) - thumbClippingOffset;\n      var thumbCenterOffset = Math.round((this.axis === 'x' ? event.pageX : event.pageY) - thumbCenter);\n\n      this._$thumb.addClass('scrollbar-thumb-move');\n\n      this._$thumb.document().on('mousemove', {\n        'thumbCenterOffset': thumbCenterOffset\n      }, this._onDocumentMousemoveHandler).one('mouseup', this._onDocumentMouseUpHandler);\n\n      return false;\n    }\n  }, {\n    key: \"_onDocumentMousemove\",\n    value: function _onDocumentMousemove(event) {\n      // Scrollbar may be removed in the meantime\n      if (!this.rendered) {\n        return;\n      } // represents offset in px of clicked point in thumb to the center of the thumb (positive and negative)\n\n\n      var thumbCenterOffset = event.data.thumbCenterOffset;\n      var clipped = this.axis === 'x' ? this._thumbClipping.horizontal() : this._thumbClipping.vertical();\n\n      var thumbSize = clipped + this._$thumb['outer' + this._dim](true); // including border, margin and padding\n\n\n      var size = this.$container[this._dim.toLowerCase()]() - thumbSize; // size of div excluding margin/padding/border\n\n      var offset = this.$container.offset()[this._dir] + thumbSize / 2;\n      var movedTo = Math.min(size, Math.max(0, (this.axis === 'x' ? event.pageX : event.pageY) - offset - thumbCenterOffset));\n      var percentage = Math.min(1, // percentage can't be larger than 1\n      Math.max(0, movedTo / size)); // percentage can't be negative\n\n      var posNew = percentage * (this._scrollSize - this._offsetSize);\n\n      this._scrollToAbsolutePoint(posNew);\n    }\n  }, {\n    key: \"_onDocumentMouseUp\",\n    value: function _onDocumentMouseUp(event) {\n      var $document = $(event.currentTarget);\n      $document.off('mousemove', this._onDocumentMousemoveHandler);\n\n      if (this.rendered) {\n        this._$thumb.removeClass('scrollbar-thumb-move');\n      }\n\n      this.notifyAfterScroll();\n      return false;\n    }\n  }, {\n    key: \"notifyBeforeScroll\",\n    value: function notifyBeforeScroll() {\n      this.trigger('scrollStart');\n    }\n  }, {\n    key: \"notifyAfterScroll\",\n    value: function notifyAfterScroll() {\n      this.trigger('scrollEnd');\n    }\n    /*\n     * Fix Scrollbar\n     */\n\n    /**\n     * Sets the position to fixed and updates left and top position\n     * (This is necessary to prevent flickering in IE)\n     */\n\n  }, {\n    key: \"_fixScrollbar\",\n    value: function _fixScrollbar() {\n      scrollbars.fix(this.$container);\n      this.update();\n    }\n    /**\n     * Reverts the changes made by _fixScrollbar\n     */\n\n  }, {\n    key: \"_unfixScrollbar\",\n    value: function _unfixScrollbar() {\n      // true = do it immediately without a timeout.\n      // This is important because scrollTop may be set during layout but before the element is positioned correctly (e.g. popup)\n      // which could have the effect that the scroll bar is drown outside the widget\n      scrollbars.unfix(this.$container, null, true);\n      this.update();\n    }\n    /*\n     * INTERNAL METHODS\n     */\n\n    /**\n     * If the thumb gets bigger than its container this method will return true, otherwise false\n     */\n\n  }, {\n    key: \"_isContainerTooSmallForThumb\",\n    value: function _isContainerTooSmallForThumb() {\n      var thumbSize = this._$thumb['outer' + this._dim](true);\n\n      var thumbMovableAreaSize = this.$container[this._dim.toLowerCase()]();\n\n      return thumbSize >= thumbMovableAreaSize;\n    }\n  }]);\n\n  return Scrollbar;\n}(Widget);\n\nexport { Scrollbar as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/scrollbar/Scrollbar.js"],"names":["events","graphics","Insets","scout","scrollbars","Widget","$","Scrollbar","$container","$thumb","$thumbHandle","axis","borderless","mouseWheelNeedsShift","_scrollSize","_offsetSize","_dim","_dir","_dirReverse","_scrollDir","_thumbClipping","_onScrollHandler","_onScroll","bind","_onScrollWheelHandler","_onScrollWheel","_onScrollbarMouseDownHandler","_onScrollbarMouseDown","_onTouchStartHandler","_onTouchStart","_onThumbMouseDownHandler","_onThumbMouseDown","_onDocumentMousemoveHandler","_onDocumentMousemove","_onDocumentMouseUpHandler","_onDocumentMouseUp","_onAncestorScrollOrResizeHandler","update","_fixScrollbarHandler","_fixScrollbar","_unfixScrollbarHandler","_unfixScrollbar","_ensureParentPosition","$parent","appendDiv","addClass","_$thumb","_$thumbHandle","data","Error","debugOutput","ancestorsToString","on","onPassive","forEach","scrollbar","_$ancestors","parents","off","offPassive","isAttached","cssPosition","css","isOneOf","diff","posOld","Math","max","_scrollToAbsolutePoint","absolutePoint","scrollPos","min","round","rendered","margin","toUpperCase","scrollLeft","scrollTop","reset","thumbSize","thumbRange","toLowerCase","posNew","offsetFix","_isContainerTooSmallForThumb","removeClass","_clipWhenOverlappingAncestor","cssRight","cssBottom","_resetClipping","thumbBounds","offsetBounds","thumbWidth","width","thumbHeight","height","thumbEndX","x","thumbEndY","y","biggestAncestorBeginX","biggestAncestorBeginY","smallestAncestorEndX","smallestAncestorEndY","each","$ancestor","ancestorBounds","ancestorEndX","ancestorEndY","clipLeft","clipRight","clipTop","clipBottom","bounds","event","onScrollStartEndDuringTouch","isVisible","ctrlKey","shiftKey","originalEvent","window","w","wheelDelta","detail","notifyBeforeScroll","scroll","notifyAfterScroll","clickableAreaSize","offset","clicked","pageX","pageY","percentage","minPossible","maxPossible","rawPercentage","clipped","horizontal","vertical","thumbClippingOffset","left","top","thumbCenter","floor","thumbCenterOffset","document","one","size","movedTo","$document","currentTarget","trigger","fix","unfix","thumbMovableAreaSize"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {events, graphics, Insets, scout, scrollbars, Widget} from '../index';\nimport $ from 'jquery';\n\nexport default class Scrollbar extends Widget {\n\n  constructor() {\n    super();\n\n    // jQuery Elements\n    this.$container = null; // Scrollbar <div>\n    this.$thumb = null; // thumb body for layout purposes <div>\n    this.$thumbHandle = null; // thumb handle <div>\n\n    // Defaults\n    this.axis = 'y';\n    this.borderless = false;\n    this.mouseWheelNeedsShift = false;\n\n    // Varaibles for calculation\n    this._scrollSize = null;\n    this._offsetSize = null;\n\n    // Axis based helper variables (y)\n    this._dim = 'Height'; // x: 'Width'\n    this._dir = 'top'; // x: 'left'\n    this._dirReverse = 'bottom'; // x: 'right'\n    this._scrollDir = 'scrollTop'; // x: 'scrollLeft\n    this._thumbClipping = new Insets(0, 0, 0, 0);\n\n    // Event Handling\n    this._onScrollHandler = this._onScroll.bind(this);\n    this._onScrollWheelHandler = this._onScrollWheel.bind(this);\n    this._onScrollbarMouseDownHandler = this._onScrollbarMouseDown.bind(this);\n    this._onTouchStartHandler = this._onTouchStart.bind(this);\n    this._onThumbMouseDownHandler = this._onThumbMouseDown.bind(this);\n    this._onDocumentMousemoveHandler = this._onDocumentMousemove.bind(this);\n    this._onDocumentMouseUpHandler = this._onDocumentMouseUp.bind(this);\n    this._onAncestorScrollOrResizeHandler = this.update.bind(this);\n\n    // Fix Scrollbar\n    this._fixScrollbarHandler = this._fixScrollbar.bind(this);\n    this._unfixScrollbarHandler = this._unfixScrollbar.bind(this);\n  }\n\n  _render() {\n    this._ensureParentPosition();\n\n    // Create scrollbar and thumb\n    this.$container = this.$parent\n      .appendDiv('scrollbar')\n      .addClass(this.axis + '-axis');\n    this._$thumb = this.$container\n      .appendDiv('scrollbar-thumb')\n      .addClass(this.axis + '-axis');\n    this._$thumbHandle = this._$thumb\n      .appendDiv('scrollbar-thumb-handle')\n      .addClass(this.axis + '-axis');\n\n    if (this.borderless) {\n      this.$container.addClass('borderless');\n    }\n\n    // Init helper variables based on axis (x/y)\n    this._dim = this.axis === 'x' ? 'Width' : 'Height';\n    this._dir = this.axis === 'x' ? 'left' : 'top';\n    this._dirReverse = this.axis === 'x' ? 'right' : 'bottom';\n    this._scrollDir = this.axis === 'x' ? 'scrollLeft' : 'scrollTop';\n\n    // Install listeners\n    var scrollbars = this.$parent.data('scrollbars');\n    if (!scrollbars) {\n      throw new Error('Data \"scrollbars\" missing in ' + graphics.debugOutput(this.$parent) + '\\nAncestors: ' + this.ancestorsToString(1));\n    }\n    this.$parent\n      .on('DOMMouseScroll mousewheel', this._onScrollWheelHandler)\n      .on('scroll', this._onScrollHandler)\n      .onPassive('touchstart', this._onTouchStartHandler);\n    scrollbars.forEach(function(scrollbar) {\n      scrollbar.on('scrollStart', this._fixScrollbarHandler);\n      scrollbar.on('scrollEnd', this._unfixScrollbarHandler);\n    }.bind(this));\n    this.$container.on('mousedown', this._onScrollbarMouseDownHandler);\n    this._$thumb.on('mousedown', this._onThumbMouseDownHandler);\n    // Scrollbar might be clipped to prevent overlapping an ancestor. In order to reset this clipping the scrollbar needs\n    // an update whenever a parent div is scrolled ore resized.\n    this._$ancestors = this.$container.parents('div')\n      .on('scroll resize', this._onAncestorScrollOrResizeHandler);\n  }\n\n  _remove() {\n    // Uninstall listeners\n    var scrollbars = this.$parent.data('scrollbars');\n    this.$parent\n      .off('DOMMouseScroll mousewheel', this._onScrollWheelHandler)\n      .off('scroll', this._onScrollHandler)\n      .offPassive('touchstart', this._onTouchStartHandler);\n    scrollbars.forEach(function(scrollbar) {\n      scrollbar.off('scrollStart', this._fixScrollbarHandler);\n      scrollbar.off('scrollEnd', this._unfixScrollbarHandler);\n    }.bind(this));\n    this.$container.off('mousedown', this._onScrollbarMouseDownHandler);\n    this._$thumb.off('mousedown', '', this._onThumbMouseDownHandler);\n    this._$ancestors.off('scroll resize', this._onAncestorScrollOrResizeHandler);\n    this._$ancestors = null;\n\n    super._remove();\n  }\n\n  _renderOnAttach() {\n    super._renderOnAttach();\n    this._ensureParentPosition();\n  }\n\n  _ensureParentPosition() {\n    // Container with JS scrollbars must have either relative or absolute position\n    // otherwise we cannot determine the correct dimension of the scrollbars\n    if (this.$parent && this.$parent.isAttached()) {\n      var cssPosition = this.$parent.css('position');\n      if (!scout.isOneOf(cssPosition, 'relative', 'absolute')) {\n        this.$parent.css('position', 'relative');\n      }\n    }\n  }\n\n  /**\n   * scroll by \"diff\" in px (positive and negative)\n   */\n  scroll(diff) {\n    var posOld = Math.max(0, this.$parent[this._scrollDir]());\n    this._scrollToAbsolutePoint(posOld + diff);\n  }\n\n  /**\n   * scroll to absolute point (expressed as absolute point in px)\n   */\n  _scrollToAbsolutePoint(absolutePoint) {\n    var scrollPos = Math.min(\n      (this._scrollSize - this._offsetSize + 1), // scrollPos can't be larger than the start of last page. Add +1 because at least chrome has issues to scroll to the very bottom if scrollTop is fractional\n      Math.max(0, Math.round(absolutePoint))); // scrollPos can't be negative\n\n    this.$parent[this._scrollDir](scrollPos);\n  }\n\n  /**\n   * do not use this internal method (triggered by scroll event)\n   */\n  update() {\n    if (!this.rendered) {\n      return;\n    }\n    var margin = this.$container['cssMargin' + this.axis.toUpperCase()]();\n    var scrollPos = this.$parent[this._scrollDir]();\n    var scrollLeft = this.$parent.scrollLeft();\n    var scrollTop = this.$parent.scrollTop();\n\n    this.reset();\n\n    this._offsetSize = this.$parent[0]['offset' + this._dim];\n    this._scrollSize = this.$parent[0]['scroll' + this._dim];\n\n    // calc size and range of thumb\n    var thumbSize = Math.max(this._offsetSize * this._offsetSize / this._scrollSize - margin, 25);\n    var thumbRange = this._offsetSize - thumbSize - margin;\n\n    // set size of thumb\n    this._$thumb.css(this._dim.toLowerCase(), thumbSize);\n\n    // set location of thumb\n    var posNew = scrollPos / (this._scrollSize - this._offsetSize) * thumbRange;\n    this._$thumb.css(this._dir, posNew);\n\n    // Add 1px to make sure scroll bar is not shown if width is a floating point value.\n    // Even if we were using getBoundingClientRect().width to get an exact width,\n    // it would not help because scroll size is always an integer\n    var offsetFix = 1;\n\n    // show scrollbar\n    if (this._offsetSize + offsetFix >= this._scrollSize) {\n      this.$container.css('display', 'none');\n    } else {\n      this.$container.css('display', '');\n\n      // indicate that thumb movement is not possible\n      if (this._isContainerTooSmallForThumb()) {\n        this._$thumb.addClass('container-too-small-for-thumb');\n      } else {\n        this._$thumb.removeClass('container-too-small-for-thumb');\n      }\n    }\n\n    this._clipWhenOverlappingAncestor();\n\n    // Position the scrollbar(s)\n    // Always update both to make sure every scrollbar (x and y) is positioned correctly\n    this.$container.cssRight(-1 * scrollLeft);\n    this.$container.cssBottom(-1 * scrollTop);\n  }\n\n  _resetClipping() {\n    // Only reset dimension and position for the secondary axis,\n    // for the scroll-axis these properties are set during update()\n    if (this.axis === 'y') {\n      this._$thumb\n        .css('width', '')\n        .css('left', '');\n    } else {\n      this._$thumb\n        .css('height', '')\n        .css('top', '');\n    }\n    this._$thumb.removeClass('clipped-left clipped-right clipped-top clipped-bottom');\n    this._thumbClipping = new Insets(0, 0, 0, 0);\n  }\n\n  /**\n   * Make sure scrollbar does not appear outside an ancestor when fixed\n   */\n  _clipWhenOverlappingAncestor() {\n    this._resetClipping();\n\n    // Clipping is only needed when scrollbar has a fixed position.\n    // Otherwise the over-size is handled by 'overflow: hidden;'.\n    if (this.$container.css('position') === 'fixed') {\n      var thumbBounds = graphics.offsetBounds(this._$thumb);\n      var thumbWidth = thumbBounds.width;\n      var thumbHeight = thumbBounds.height;\n      var thumbEndX = thumbBounds.x + thumbBounds.width;\n      var thumbEndY = thumbBounds.y + thumbBounds.height;\n      var biggestAncestorBeginX = 0;\n      var biggestAncestorBeginY = 0;\n      var smallestAncestorEndX = thumbEndX;\n      var smallestAncestorEndY = thumbEndY;\n\n      // Find nearest clip boundaries: It is not necessarily the boundary of the closest ancestor-div in the DOM,\n      // because ancestor-divs themselves may be scrolled.\n      this.$container.parents('div').each(function() {\n        var $ancestor = $(this);\n        var ancestorBounds = graphics.offsetBounds($ancestor);\n        if ($ancestor.css('overflow-x') !== 'visible') {\n          if (ancestorBounds.x > biggestAncestorBeginX) {\n            biggestAncestorBeginX = ancestorBounds.x;\n          }\n          var ancestorEndX = ancestorBounds.x + ancestorBounds.width;\n          if (ancestorEndX < smallestAncestorEndX) {\n            smallestAncestorEndX = ancestorEndX;\n          }\n        }\n        if ($ancestor.css('overflow-y') !== 'visible') {\n          if (ancestorBounds.y > biggestAncestorBeginY) {\n            biggestAncestorBeginY = ancestorBounds.y;\n          }\n          var ancestorEndY = ancestorBounds.y + ancestorBounds.height;\n          if (ancestorEndY < smallestAncestorEndY) {\n            smallestAncestorEndY = ancestorEndY;\n          }\n        }\n      });\n\n      var clipLeft = 0;\n      var clipRight = 0;\n      var clipTop = 0;\n      var clipBottom = 0;\n\n      // clip left\n      if (biggestAncestorBeginX > thumbBounds.x) {\n        clipLeft = biggestAncestorBeginX - thumbBounds.x;\n        thumbWidth -= clipLeft;\n        this._$thumb\n          .css('width', thumbWidth)\n          .css('left', graphics.bounds(this._$thumb).x + clipLeft)\n          .addClass('clipped-left');\n      }\n\n      // clip top\n      if (biggestAncestorBeginY > thumbBounds.y) {\n        clipTop = biggestAncestorBeginY - thumbBounds.y;\n        thumbHeight -= clipTop;\n        this._$thumb\n          .css('height', thumbHeight)\n          .css('top', graphics.bounds(this._$thumb).y + clipTop)\n          .addClass('clipped-top');\n      }\n\n      // clip right\n      if (thumbEndX > smallestAncestorEndX) {\n        clipRight = thumbEndX - smallestAncestorEndX;\n        this._$thumb\n          .css('width', thumbWidth - clipRight)\n          .addClass('clipped-right');\n      }\n\n      // clip bottom\n      if (thumbEndY > smallestAncestorEndY) {\n        clipBottom = thumbEndY - smallestAncestorEndY;\n        this._$thumb\n          .css('height', thumbHeight - clipBottom)\n          .addClass('clipped-bottom');\n      }\n\n      this._thumbClipping = new Insets(clipTop, clipRight, clipBottom, clipLeft);\n    }\n  }\n\n  /**\n   * Resets thumb size and scrollbar position to make sure it does not extend the scrollSize\n   */\n  reset() {\n    this._$thumb.css(this._dim.toLowerCase(), 0);\n    this.$container.cssRight(0);\n    this.$container.cssBottom(0);\n  }\n\n  /*\n   * EVENT HANDLING\n   */\n\n  _onScroll(event) {\n    this.update();\n  }\n\n  _onTouchStart(event) {\n    // In hybrid mode scroll bar is moved by the scroll event.\n    // On a mobile device scroll events are fired delayed so the update will be delayed as well.\n    // This will lead to flickering and could be prevented by calling fixScrollbar. But unfortunately calling fix will stop the scroll pane from scrolling immediately, at least in Edge.\n    // In order to reduce the flickering the current approach is to hide the scrollbars while scrolling (only in this specific hybrid touch scrolling)\n    events.onScrollStartEndDuringTouch(this.$parent, function() {\n      if (!this.rendered) {\n        return;\n      }\n      this.$container.css('opacity', 0);\n    }.bind(this), function() {\n      if (!this.rendered) {\n        return;\n      }\n      this.$container.css('opacity', '');\n    }.bind(this));\n  }\n\n  _onScrollWheel(event) {\n    if (!this.$container.isVisible()) {\n      return true; // ignore scroll wheel event if there is no scroll bar visible\n    }\n    if (event.ctrlKey) {\n      return true; // allow ctrl + mousewheel to zoom the page\n    }\n    if (this.mouseWheelNeedsShift !== event.shiftKey) {\n      return true; // only scroll if shift modifier matches\n    }\n    event = event.originalEvent || this.$container.window(true).event.originalEvent;\n    var w = event.wheelDelta ? -event.wheelDelta / 2 : event.detail * 20;\n\n    this.notifyBeforeScroll();\n    this.scroll(w);\n    this.notifyAfterScroll();\n\n    return false;\n  }\n\n  _onScrollbarMouseDown(event) {\n    this.notifyBeforeScroll();\n\n    var clickableAreaSize = this.$container[this._dim.toLowerCase()]();\n\n    var offset = this.$container.offset()[this._dir];\n    var clicked = (this.axis === 'x' ? event.pageX : event.pageY) - offset;\n\n    var percentage;\n\n    if (this._isContainerTooSmallForThumb()) {\n      percentage = Math.min(1, Math.max(0, (clicked / clickableAreaSize))); // percentage can't be larger than 1, nor negative\n      this._scrollToAbsolutePoint((percentage * this._scrollSize) - Math.round(this._offsetSize / 2));\n    } else { // move the thumb center to clicked point\n      var thumbSize = this._$thumb['outer' + this._dim](true);\n      var minPossible = Math.round(thumbSize / 2);\n      var maxPossible = clickableAreaSize - Math.round(thumbSize / 2);\n\n      var rawPercentage = ((clicked - minPossible) * (1 / (maxPossible - minPossible)));\n      percentage = Math.min(1, Math.max(0, rawPercentage)); // percentage can't be larger than 1, nor negative\n\n      this._scrollToAbsolutePoint(percentage * (this._scrollSize - this._offsetSize));\n    }\n\n    this.notifyAfterScroll();\n  }\n\n  _onThumbMouseDown(event) {\n    // ignore event if container is too small for thumb movement\n    if (this._isContainerTooSmallForThumb()) {\n      return true; // let _onScrollbarMouseDown handle the click event\n    }\n    this.notifyBeforeScroll();\n    // calculate thumbCenterOffset in px (offset from clicked point to thumb center)\n    var clipped = (this.axis === 'x' ? this._thumbClipping.horizontal() : this._thumbClipping.vertical());\n    var thumbSize = clipped + this._$thumb['outer' + this._dim](true); // including border, margin and padding\n    var thumbClippingOffset = (this.axis === 'x' ? this._thumbClipping.left : this._thumbClipping.top);\n    var thumbCenter = this._$thumb.offset()[this._dir] + Math.floor(thumbSize / 2) - thumbClippingOffset;\n    var thumbCenterOffset = Math.round((this.axis === 'x' ? event.pageX : event.pageY) - thumbCenter);\n\n    this._$thumb.addClass('scrollbar-thumb-move');\n    this._$thumb\n      .document()\n      .on('mousemove', {\n        'thumbCenterOffset': thumbCenterOffset\n      }, this._onDocumentMousemoveHandler)\n      .one('mouseup', this._onDocumentMouseUpHandler);\n\n    return false;\n  }\n\n  _onDocumentMousemove(event) {\n    // Scrollbar may be removed in the meantime\n    if (!this.rendered) {\n      return;\n    }\n\n    // represents offset in px of clicked point in thumb to the center of the thumb (positive and negative)\n    var thumbCenterOffset = event.data.thumbCenterOffset;\n\n    var clipped = (this.axis === 'x' ? this._thumbClipping.horizontal() : this._thumbClipping.vertical());\n    var thumbSize = clipped + this._$thumb['outer' + this._dim](true); // including border, margin and padding\n    var size = this.$container[this._dim.toLowerCase()]() - thumbSize; // size of div excluding margin/padding/border\n    var offset = this.$container.offset()[this._dir] + (thumbSize / 2);\n\n    var movedTo = Math.min(\n      size,\n      Math.max(0, (this.axis === 'x' ? event.pageX : event.pageY) - offset - thumbCenterOffset));\n\n    var percentage = Math.min(\n      1, // percentage can't be larger than 1\n      Math.max(0, (movedTo / size))); // percentage can't be negative\n\n    var posNew = (percentage * (this._scrollSize - this._offsetSize));\n    this._scrollToAbsolutePoint(posNew);\n  }\n\n  _onDocumentMouseUp(event) {\n    var $document = $(event.currentTarget);\n    $document.off('mousemove', this._onDocumentMousemoveHandler);\n    if (this.rendered) {\n      this._$thumb.removeClass('scrollbar-thumb-move');\n    }\n    this.notifyAfterScroll();\n    return false;\n  }\n\n  notifyBeforeScroll() {\n    this.trigger('scrollStart');\n  }\n\n  notifyAfterScroll() {\n    this.trigger('scrollEnd');\n  }\n\n  /*\n   * Fix Scrollbar\n   */\n\n  /**\n   * Sets the position to fixed and updates left and top position\n   * (This is necessary to prevent flickering in IE)\n   */\n  _fixScrollbar() {\n    scrollbars.fix(this.$container);\n    this.update();\n  }\n\n  /**\n   * Reverts the changes made by _fixScrollbar\n   */\n  _unfixScrollbar() {\n    // true = do it immediately without a timeout.\n    // This is important because scrollTop may be set during layout but before the element is positioned correctly (e.g. popup)\n    // which could have the effect that the scroll bar is drown outside the widget\n    scrollbars.unfix(this.$container, null, true);\n    this.update();\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n\n  /**\n   * If the thumb gets bigger than its container this method will return true, otherwise false\n   */\n  _isContainerTooSmallForThumb() {\n    var thumbSize = this._$thumb['outer' + this._dim](true);\n    var thumbMovableAreaSize = this.$container[this._dim.toLowerCase()]();\n    return thumbSize >= thumbMovableAreaSize;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}