{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, graphics, KeyStroke } from '../../index';\n\nvar AbstractTableNavigationKeyStroke = /*#__PURE__*/function (_KeyStroke) {\n  _inherits(AbstractTableNavigationKeyStroke, _KeyStroke);\n\n  var _super = _createSuper(AbstractTableNavigationKeyStroke);\n\n  function AbstractTableNavigationKeyStroke(table) {\n    var _this;\n\n    _classCallCheck(this, AbstractTableNavigationKeyStroke);\n\n    _this = _super.call(this);\n    _this.repeatable = true;\n    _this.field = table;\n    _this.shift = !table.multiSelect ? false : undefined;\n    _this.stopPropagation = true;\n    _this.keyStrokeMode = KeyStroke.Mode.DOWN;\n    return _this;\n  }\n\n  _createClass(AbstractTableNavigationKeyStroke, [{\n    key: \"_accept\",\n    value: function _accept(event) {\n      var accepted = _get(_getPrototypeOf(AbstractTableNavigationKeyStroke.prototype), \"_accept\", this).call(this, event);\n\n      if (!accepted) {\n        return false;\n      }\n\n      if (!this.field.visibleRows.length) {\n        return false;\n      }\n\n      var activeElement = this.field.$container.activeElement(true),\n          elementType = activeElement.tagName.toLowerCase();\n\n      if (activeElement.className !== 'table-text-filter' && (elementType === 'textarea' || elementType === 'input') && (!event.originalEvent || event.originalEvent && !event.originalEvent.smartFieldEvent)) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Returns viewport sensitive information containing the first and last visible row in the viewport.\n     */\n\n  }, {\n    key: \"_viewportInfo\",\n    value: function _viewportInfo() {\n      var viewportBounds,\n          dataInsets,\n          dataMarginTop,\n          firstRow,\n          lastRow,\n          table = this.field,\n          viewport = {},\n          rows = table.visibleRows;\n\n      if (rows.length === 0) {\n        return viewport;\n      }\n\n      viewportBounds = graphics.offsetBounds(table.$data);\n      dataInsets = graphics.insets(table.$data);\n      dataMarginTop = table.$data.cssMarginTop();\n      viewportBounds = viewportBounds.subtract(dataInsets); // if data has a negative margin, adjust viewport otherwise a selected first row will never be in the viewport\n\n      if (dataMarginTop < 0) {\n        viewportBounds.y -= Math.abs(dataMarginTop);\n        viewportBounds.height += Math.abs(dataMarginTop);\n      }\n\n      firstRow = this._findFirstRowInViewport(table, viewportBounds);\n      lastRow = this._findLastRowInViewport(table, rows.indexOf(firstRow), viewportBounds);\n      viewport.firstRow = firstRow;\n      viewport.lastRow = lastRow;\n      return viewport;\n    }\n  }, {\n    key: \"firstRowAfterSelection\",\n    value: function firstRowAfterSelection() {\n      var $selectedRows = this.field.$selectedRows();\n\n      if (!$selectedRows.length) {\n        return;\n      }\n\n      var rows = this.field.visibleRows,\n          row = $selectedRows.last().data('row'),\n          rowIndex = this.field.filteredRows().indexOf(row);\n      return rows[rowIndex + 1];\n    }\n  }, {\n    key: \"firstRowBeforeSelection\",\n    value: function firstRowBeforeSelection() {\n      var $selectedRows = this.field.$selectedRows();\n\n      if (!$selectedRows.length) {\n        return;\n      }\n\n      var rows = this.field.visibleRows,\n          row = $selectedRows.first().data('row'),\n          rowIndex = this.field.visibleRows.indexOf(row);\n      return rows[rowIndex - 1];\n    }\n    /**\n     * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.\n     */\n\n  }, {\n    key: \"_findLastSelectedRowBefore\",\n    value: function _findLastSelectedRowBefore(table, rowIndex) {\n      var row,\n          rows = table.visibleRows;\n\n      if (rowIndex === 0) {\n        return rows[rowIndex];\n      }\n\n      row = arrays.findFromReverse(rows, rowIndex, function (row, i) {\n        var previousRow = rows[i - 1];\n\n        if (!previousRow) {\n          return false;\n        }\n\n        return !table.isRowSelected(previousRow);\n      }); // when no row has been found, use first row in table\n\n      if (!row) {\n        row = rows[0];\n      }\n\n      return row;\n    }\n    /**\n     * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.\n     */\n\n  }, {\n    key: \"_findLastSelectedRowAfter\",\n    value: function _findLastSelectedRowAfter(table, rowIndex) {\n      var row,\n          rows = table.visibleRows;\n\n      if (rowIndex === rows.length - 1) {\n        return rows[rowIndex];\n      }\n\n      row = arrays.findFrom(rows, rowIndex, function (row, i) {\n        var nextRow = rows[i + 1];\n\n        if (!nextRow) {\n          return false;\n        }\n\n        return !table.isRowSelected(nextRow);\n      }); // when no row has been found, use last row in table\n\n      if (!row) {\n        row = rows[rows.length - 1];\n      }\n\n      return row;\n    }\n  }, {\n    key: \"_findFirstRowInViewport\",\n    value: function _findFirstRowInViewport(table, viewportBounds) {\n      var rows = table.visibleRows;\n      return arrays.find(rows, function (row, i) {\n        var rowOffset,\n            rowMarginTop,\n            $row = row.$row;\n\n        if (!row.$row) {\n          // If row is not rendered, it cannot be part of the view port -> check next row\n          return false;\n        }\n\n        rowOffset = $row.offset();\n        rowMarginTop = row.$row.cssMarginTop(); // Selected row has a negative row margin\n        // -> add this margin to the offset to make sure this function does always return the same row independent of selection state\n\n        if (rowMarginTop < 0) {\n          rowOffset.top += Math.abs(rowMarginTop);\n        } // If the row is fully visible in the viewport -> break and return the row\n\n\n        return viewportBounds.contains(rowOffset.left, rowOffset.top);\n      });\n    }\n  }, {\n    key: \"_findLastRowInViewport\",\n    value: function _findLastRowInViewport(table, startRowIndex, viewportBounds) {\n      var rows = table.visibleRows;\n\n      if (startRowIndex === rows.length - 1) {\n        return rows[startRowIndex];\n      }\n\n      return arrays.findFromForward(rows, startRowIndex, function (row, i) {\n        var nextRowOffsetBounds,\n            $nextRow,\n            nextRow = rows[i + 1];\n\n        if (!nextRow) {\n          // If next row is not available (row is the last row) -> break and return current row\n          return true;\n        }\n\n        $nextRow = nextRow.$row;\n\n        if (!$nextRow) {\n          // If next row is not rendered anymore, current row has to be the last in the viewport\n          return true;\n        }\n\n        nextRowOffsetBounds = graphics.offsetBounds($nextRow); // If the next row is not fully visible in the viewport -> break and return current row\n\n        return !viewportBounds.contains(nextRowOffsetBounds.x, nextRowOffsetBounds.y + nextRowOffsetBounds.height - 1);\n      });\n    }\n  }, {\n    key: \"_isEnabled\",\n    value: function _isEnabled() {\n      return !this.field.tileMode;\n    }\n  }]);\n\n  return AbstractTableNavigationKeyStroke;\n}(KeyStroke);\n\nexport { AbstractTableNavigationKeyStroke as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/table/keystrokes/AbstractTableNavigationKeyStroke.js"],"names":["arrays","graphics","KeyStroke","AbstractTableNavigationKeyStroke","table","repeatable","field","shift","multiSelect","undefined","stopPropagation","keyStrokeMode","Mode","DOWN","event","accepted","visibleRows","length","activeElement","$container","elementType","tagName","toLowerCase","className","originalEvent","smartFieldEvent","viewportBounds","dataInsets","dataMarginTop","firstRow","lastRow","viewport","rows","offsetBounds","$data","insets","cssMarginTop","subtract","y","Math","abs","height","_findFirstRowInViewport","_findLastRowInViewport","indexOf","$selectedRows","row","last","data","rowIndex","filteredRows","first","findFromReverse","i","previousRow","isRowSelected","findFrom","nextRow","find","rowOffset","rowMarginTop","$row","offset","top","contains","left","startRowIndex","findFromForward","nextRowOffsetBounds","$nextRow","x","tileMode"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, graphics, KeyStroke} from '../../index';\n\nexport default class AbstractTableNavigationKeyStroke extends KeyStroke {\n\n  constructor(table) {\n    super();\n    this.repeatable = true;\n    this.field = table;\n    this.shift = !table.multiSelect ? false : undefined;\n    this.stopPropagation = true;\n    this.keyStrokeMode = KeyStroke.Mode.DOWN;\n  }\n\n  _accept(event) {\n    var accepted = super._accept(event);\n    if (!accepted) {\n      return false;\n    }\n\n    if (!this.field.visibleRows.length) {\n      return false;\n    }\n\n    var activeElement = this.field.$container.activeElement(true),\n      elementType = activeElement.tagName.toLowerCase();\n    if (activeElement.className !== 'table-text-filter' &&\n      (elementType === 'textarea' || elementType === 'input') &&\n      (!event.originalEvent || (event.originalEvent && !event.originalEvent.smartFieldEvent))) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns viewport sensitive information containing the first and last visible row in the viewport.\n   */\n  _viewportInfo() {\n    var viewportBounds, dataInsets, dataMarginTop, firstRow, lastRow,\n      table = this.field,\n      viewport = {},\n      rows = table.visibleRows;\n\n    if (rows.length === 0) {\n      return viewport;\n    }\n\n    viewportBounds = graphics.offsetBounds(table.$data);\n    dataInsets = graphics.insets(table.$data);\n    dataMarginTop = table.$data.cssMarginTop();\n    viewportBounds = viewportBounds.subtract(dataInsets);\n\n    // if data has a negative margin, adjust viewport otherwise a selected first row will never be in the viewport\n    if (dataMarginTop < 0) {\n      viewportBounds.y -= Math.abs(dataMarginTop);\n      viewportBounds.height += Math.abs(dataMarginTop);\n    }\n\n    firstRow = this._findFirstRowInViewport(table, viewportBounds);\n    lastRow = this._findLastRowInViewport(table, rows.indexOf(firstRow), viewportBounds);\n\n    viewport.firstRow = firstRow;\n    viewport.lastRow = lastRow;\n    return viewport;\n  }\n\n  firstRowAfterSelection() {\n    var $selectedRows = this.field.$selectedRows();\n    if (!$selectedRows.length) {\n      return;\n    }\n\n    var rows = this.field.visibleRows,\n      row = $selectedRows.last().data('row'),\n      rowIndex = this.field.filteredRows().indexOf(row);\n\n    return rows[rowIndex + 1];\n  }\n\n  firstRowBeforeSelection() {\n    var $selectedRows = this.field.$selectedRows();\n    if (!$selectedRows.length) {\n      return;\n    }\n    var rows = this.field.visibleRows,\n      row = $selectedRows.first().data('row'),\n      rowIndex = this.field.visibleRows.indexOf(row);\n\n    return rows[rowIndex - 1];\n  }\n\n  /**\n   * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.\n   */\n  _findLastSelectedRowBefore(table, rowIndex) {\n    var row, rows = table.visibleRows;\n    if (rowIndex === 0) {\n      return rows[rowIndex];\n    }\n    row = arrays.findFromReverse(rows, rowIndex, function(row, i) {\n      var previousRow = rows[i - 1];\n      if (!previousRow) {\n        return false;\n      }\n      return !table.isRowSelected(previousRow);\n    });\n    // when no row has been found, use first row in table\n    if (!row) {\n      row = rows[0];\n    }\n    return row;\n  }\n\n  /**\n   * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.\n   */\n  _findLastSelectedRowAfter(table, rowIndex) {\n    var row, rows = table.visibleRows;\n    if (rowIndex === rows.length - 1) {\n      return rows[rowIndex];\n    }\n    row = arrays.findFrom(rows, rowIndex, function(row, i) {\n      var nextRow = rows[i + 1];\n      if (!nextRow) {\n        return false;\n      }\n      return !table.isRowSelected(nextRow);\n    });\n    // when no row has been found, use last row in table\n    if (!row) {\n      row = rows[rows.length - 1];\n    }\n    return row;\n  }\n\n  _findFirstRowInViewport(table, viewportBounds) {\n    var rows = table.visibleRows;\n    return arrays.find(rows, function(row, i) {\n      var rowOffset, rowMarginTop,\n        $row = row.$row;\n\n      if (!row.$row) {\n        // If row is not rendered, it cannot be part of the view port -> check next row\n        return false;\n      }\n      rowOffset = $row.offset();\n      rowMarginTop = row.$row.cssMarginTop();\n      // Selected row has a negative row margin\n      // -> add this margin to the offset to make sure this function does always return the same row independent of selection state\n      if (rowMarginTop < 0) {\n        rowOffset.top += Math.abs(rowMarginTop);\n      }\n\n      // If the row is fully visible in the viewport -> break and return the row\n      return viewportBounds.contains(rowOffset.left, rowOffset.top);\n    });\n  }\n\n  _findLastRowInViewport(table, startRowIndex, viewportBounds) {\n    var rows = table.visibleRows;\n    if (startRowIndex === rows.length - 1) {\n      return rows[startRowIndex];\n    }\n    return arrays.findFromForward(rows, startRowIndex, function(row, i) {\n      var nextRowOffsetBounds, $nextRow,\n        nextRow = rows[i + 1];\n\n      if (!nextRow) {\n        // If next row is not available (row is the last row) -> break and return current row\n        return true;\n      }\n      $nextRow = nextRow.$row;\n      if (!$nextRow) {\n        // If next row is not rendered anymore, current row has to be the last in the viewport\n        return true;\n      }\n      nextRowOffsetBounds = graphics.offsetBounds($nextRow);\n      // If the next row is not fully visible in the viewport -> break and return current row\n      return !viewportBounds.contains(nextRowOffsetBounds.x, nextRowOffsetBounds.y + nextRowOffsetBounds.height - 1);\n    });\n  }\n\n  _isEnabled() {\n    return !this.field.tileMode;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}