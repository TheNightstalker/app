{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { arrays, objects, scout } from '../index';\nimport $ from 'jquery';\n\nvar EventSupport = /*#__PURE__*/function () {\n  function EventSupport() {\n    _classCallCheck(this, EventSupport);\n\n    this._eventListeners = [];\n    this._subTypePredicates = objects.createMap();\n  }\n\n  _createClass(EventSupport, [{\n    key: \"_assertFunc\",\n    value: function _assertFunc(func) {\n      if (!func) {\n        throw new Error('Missing callback function');\n      }\n    }\n    /**\n     * Registers the given func for the event specified by the type param.\n     *\n     * @param {string} type event-name\n     * @param {function} func callback function executed when event is triggered. An event object is passed to the func as first parameter\n     * @param {function} [origFunc] (optional) used internally when func is registered with one(). The property is set on the listener\n     *   object so the event-handler can be de-registered by using the original function.\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(type, func, origFunc) {\n      this._assertFunc(func);\n\n      var listener = {\n        type: type,\n        func: func,\n        origFunc: origFunc\n      };\n      this.addListener(listener);\n      return listener;\n    }\n    /**\n     * Registers the given func for the event specified by the type param.\n     * The event is only triggered one time, and after that it is automatically de-registered by calling the off() function.\n     *\n     * @param {string} type event-name\n     * @param {function} func callback function executed when event is triggered. An event object is passed to the func as first parameter\n     */\n\n  }, {\n    key: \"one\",\n    value: function one(type, func) {\n      this._assertFunc(func);\n\n      var that = this,\n          offFunc = function offFunc(event) {\n        that.off(type, offFunc);\n        func(event);\n      };\n\n      return this.on(type, offFunc, func);\n    }\n  }, {\n    key: \"off\",\n    value: function off(type, func) {\n      if (!type && !func) {\n        return;\n      }\n\n      for (var i = this._eventListeners.length - 1; i >= 0; i--) {\n        var listener = this._eventListeners[i];\n        var funcMatches = func === listener.func || func === listener.origFunc;\n        var typeMatches = type === listener.type;\n        var remove = false;\n\n        if (func && type) {\n          remove = funcMatches && typeMatches;\n        } else if (func) {\n          remove = funcMatches;\n        } else {\n          // always type. all other cases have been checked above\n          remove = typeMatches;\n        }\n\n        if (remove) {\n          this._eventListeners.splice(i, 1);\n        }\n      }\n    }\n    /**\n     * Adds an event handler using {@link #one()} and returns a promise.\n     * The promise is resolved as soon as the event is triggered.\n     */\n\n  }, {\n    key: \"when\",\n    value: function when(type) {\n      var deferred = $.Deferred();\n      this.one(type, deferred.resolve.bind(deferred));\n      return deferred.promise();\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener(listener) {\n      this._eventListeners.push(listener);\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(listener) {\n      arrays.remove(this._eventListeners, listener);\n    }\n  }, {\n    key: \"count\",\n    value: function count(type, func) {\n      var count = 0;\n\n      this._eventListeners.forEach(function (listener) {\n        if (type && type !== listener.type) {\n          return;\n        }\n\n        if (func && func !== listener.func) {\n          return;\n        }\n\n        count++;\n      });\n\n      return count;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(type, event) {\n      event = event || {};\n      event.type = type;\n\n      var i,\n          listener,\n          listeners = this._eventListeners.slice();\n\n      for (i = 0; i < listeners.length; i++) {\n        listener = listeners[i];\n\n        if (!listener.type || typeMatches.call(this, event, listener.type)) {\n          listener.func(event);\n        }\n      } // ---- Helper functions -----\n\n\n      function typeMatches(event, listenerType) {\n        var eventType = event.type;\n        var types = listenerType.split(' '); // support for multi type definition 'type1 type2 [...]'\n\n        for (var i = 0; i < types.length; i++) {\n          if (eventType === types[i]) {\n            return true;\n          }\n\n          if (this._subTypeMatches(event, types[i])) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    }\n  }, {\n    key: \"_subTypeMatches\",\n    value: function _subTypeMatches(event, listenerType) {\n      if (listenerType.indexOf(':') < 0) {\n        return false;\n      }\n\n      var parts = listenerType.split(':');\n      var type = parts[0];\n      var subType = parts[1];\n      var predicate = this._subTypePredicates[type];\n\n      if (!predicate) {\n        return;\n      }\n\n      return predicate(event, subType);\n    }\n    /**\n     *\n     * @param {string} type the type which could contain a sub type\n     * @param {function} predicate the predicate which will be tested when an event with the given type is triggered. The function has two parameters: event and subType\n     */\n\n  }, {\n    key: \"registerSubTypePredicate\",\n    value: function registerSubTypePredicate(type, predicate) {\n      scout.assertParameter('type', type);\n      scout.assertParameter('predicate', predicate);\n      this._subTypePredicates[type] = predicate;\n    }\n  }]);\n\n  return EventSupport;\n}();\n\nexport { EventSupport as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/util/EventSupport.js"],"names":["arrays","objects","scout","$","EventSupport","_eventListeners","_subTypePredicates","createMap","func","Error","type","origFunc","_assertFunc","listener","addListener","that","offFunc","event","off","on","i","length","funcMatches","typeMatches","remove","splice","deferred","Deferred","one","resolve","bind","promise","push","count","forEach","listeners","slice","call","listenerType","eventType","types","split","_subTypeMatches","indexOf","parts","subType","predicate","assertParameter"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {arrays, objects, scout} from '../index';\nimport $ from 'jquery';\n\nexport default class EventSupport {\n\n  constructor() {\n    this._eventListeners = [];\n    this._subTypePredicates = objects.createMap();\n  }\n\n  _assertFunc(func) {\n    if (!func) {\n      throw new Error('Missing callback function');\n    }\n  }\n\n  /**\n   * Registers the given func for the event specified by the type param.\n   *\n   * @param {string} type event-name\n   * @param {function} func callback function executed when event is triggered. An event object is passed to the func as first parameter\n   * @param {function} [origFunc] (optional) used internally when func is registered with one(). The property is set on the listener\n   *   object so the event-handler can be de-registered by using the original function.\n   */\n  on(type, func, origFunc) {\n    this._assertFunc(func);\n    var listener = {\n      type: type,\n      func: func,\n      origFunc: origFunc\n    };\n    this.addListener(listener);\n    return listener;\n  }\n\n  /**\n   * Registers the given func for the event specified by the type param.\n   * The event is only triggered one time, and after that it is automatically de-registered by calling the off() function.\n   *\n   * @param {string} type event-name\n   * @param {function} func callback function executed when event is triggered. An event object is passed to the func as first parameter\n   */\n  one(type, func) {\n    this._assertFunc(func);\n    var that = this,\n      offFunc = function(event) {\n        that.off(type, offFunc);\n        func(event);\n      };\n    return this.on(type, offFunc, func);\n  }\n\n  off(type, func) {\n    if (!type && !func) {\n      return;\n    }\n\n    for (var i = this._eventListeners.length - 1; i >= 0; i--) {\n      var listener = this._eventListeners[i];\n      var funcMatches = (func === listener.func || func === listener.origFunc);\n      var typeMatches = (type === listener.type);\n      var remove = false;\n      if (func && type) {\n        remove = (funcMatches && typeMatches);\n      } else if (func) {\n        remove = funcMatches;\n      } else { // always type. all other cases have been checked above\n        remove = typeMatches;\n      }\n\n      if (remove) {\n        this._eventListeners.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Adds an event handler using {@link #one()} and returns a promise.\n   * The promise is resolved as soon as the event is triggered.\n   */\n  when(type) {\n    var deferred = $.Deferred();\n    this.one(type, deferred.resolve.bind(deferred));\n    return deferred.promise();\n  }\n\n  addListener(listener) {\n    this._eventListeners.push(listener);\n  }\n\n  removeListener(listener) {\n    arrays.remove(this._eventListeners, listener);\n  }\n\n  count(type, func) {\n    var count = 0;\n    this._eventListeners.forEach(function(listener) {\n      if (type && type !== listener.type) {\n        return;\n      }\n      if (func && func !== listener.func) {\n        return;\n      }\n      count++;\n    });\n    return count;\n  }\n\n  trigger(type, event) {\n    event = event || {};\n    event.type = type;\n\n    var i, listener, listeners = this._eventListeners.slice();\n    for (i = 0; i < listeners.length; i++) {\n      listener = listeners[i];\n      if (!listener.type || typeMatches.call(this, event, listener.type)) {\n        listener.func(event);\n      }\n    }\n\n    // ---- Helper functions -----\n\n    function typeMatches(event, listenerType) {\n      var eventType = event.type;\n      var types = listenerType.split(' ');\n      // support for multi type definition 'type1 type2 [...]'\n      for (var i = 0; i < types.length; i++) {\n        if (eventType === types[i]) {\n          return true;\n        }\n        if (this._subTypeMatches(event, types[i])) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  _subTypeMatches(event, listenerType) {\n    if (listenerType.indexOf(':') < 0) {\n      return false;\n    }\n    var parts = listenerType.split(':');\n    var type = parts[0];\n    var subType = parts[1];\n    var predicate = this._subTypePredicates[type];\n    if (!predicate) {\n      return;\n    }\n    return predicate(event, subType);\n  }\n\n  /**\n   *\n   * @param {string} type the type which could contain a sub type\n   * @param {function} predicate the predicate which will be tested when an event with the given type is triggered. The function has two parameters: event and subType\n   */\n  registerSubTypePredicate(type, predicate) {\n    scout.assertParameter('type', type);\n    scout.assertParameter('predicate', predicate);\n    this._subTypePredicates[type] = predicate;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}