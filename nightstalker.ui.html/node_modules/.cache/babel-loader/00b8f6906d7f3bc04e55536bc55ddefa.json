{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { filters, focusUtils, graphics, keys, Point, scrollbars } from '../index';\nimport $ from 'jquery';\n/**\n * A focus context is associated with a $container, and controls how to focus elements within that $container.\n */\n\nvar FocusContext = /*#__PURE__*/function () {\n  function FocusContext($container, focusManager) {\n    _classCallCheck(this, FocusContext);\n\n    this.$container = $container;\n    this.focusManager = focusManager;\n    this.lastValidFocusedElement = null; // variable to store the last valid focus position; used to restore focus once being re-activated.\n\n    this.focusedElement = null;\n    this.prepared = false; // Notice: every listener is installed on $container and not on $field level, except 'remove' listener because it does not bubble.\n\n    this._keyDownListener = this._onKeyDown.bind(this);\n    this._focusInListener = this._onFocusIn.bind(this);\n    this._focusOutListener = this._onFocusOut.bind(this);\n    this._unfocusableListener = this._onUnfocusable.bind(this);\n    this._removeListener = this._onRemove.bind(this);\n  }\n\n  _createClass(FocusContext, [{\n    key: \"ready\",\n    value: function ready() {\n      if (this.prepared) {\n        return;\n      }\n\n      this.$container.on('keydown', this._keyDownListener).on('focusin', this._focusInListener).on('focusout', this._focusOutListener).on('hide disable', this._unfocusableListener);\n      this.prepared = true;\n\n      if (this.lastValidFocusedElement) {\n        // If a widget requested the focus while focus context was not ready, lastValidFocusedElement is set to that widget but the widget itself is not focused.\n        // -> Ensure that widget is focused\n        this.restoreFocus();\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (!this.prepared) {\n        return;\n      }\n\n      this.$container.off('keydown', this._keyDownListener).off('focusin', this._focusInListener).off('focusout', this._focusOutListener).off('hide disable', this._unfocusableListener);\n      $(this.focusedElement).off('remove', this._removeListener);\n    }\n    /**\n     * Method invoked once a 'keydown' event is fired to control proper tab cycle.\n     */\n\n  }, {\n    key: \"_onKeyDown\",\n    value: function _onKeyDown(event) {\n      if (event.which === keys.TAB) {\n        var activeElement = this.$container.activeElement(true),\n            $focusableElements = this.$container.find(':tabbable:visible'),\n            firstFocusableElement = $focusableElements.first()[0],\n            lastFocusableElement = $focusableElements.last()[0],\n            activeElementIndex = $focusableElements.index(activeElement),\n            focusedElement; // Forward Tab\n\n        if (!event.shiftKey) {\n          // If the last focusable element is focused, or the focus is on the container, set the focus to the first focusable element\n          if (firstFocusableElement && (activeElement === lastFocusableElement || activeElement === this.$container[0])) {\n            $.suppressEvent(event);\n            this.validateAndSetFocus(firstFocusableElement);\n            focusedElement = firstFocusableElement;\n          } else if (activeElementIndex < $focusableElements.length - 1) {\n            focusedElement = $focusableElements.get(activeElementIndex + 1); // Note: event is _not_ suppressed here --> will be handled by browser\n          }\n        } else {\n          // Backward Tab (Shift+TAB)\n          // If the first focusable element is focused, or the focus is on the container, set the focus to the last focusable element\n          if (lastFocusableElement && (activeElement === firstFocusableElement || activeElement === this.$container[0])) {\n            $.suppressEvent(event);\n            this.validateAndSetFocus(lastFocusableElement);\n            focusedElement = lastFocusableElement;\n          } else if (activeElementIndex > 0) {\n            focusedElement = $focusableElements.get(activeElementIndex - 1); // Note: event is _not_ suppressed here --> will be handled by browser\n          }\n        }\n\n        if (!focusedElement) {\n          return;\n        } // Check if new focused element is currently visible, otherwise scroll the container\n\n\n        var $focusableElement = $(focusedElement),\n            containerBounds = graphics.offsetBounds($focusableElement),\n            $scrollable = $focusableElement.scrollParent();\n\n        if (!scrollbars.isLocationInView(new Point(containerBounds.x, containerBounds.y), $scrollable)) {\n          scrollbars.scrollTo($scrollable, $focusableElement);\n        }\n      }\n    }\n    /**\n     * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.\n     */\n\n  }, {\n    key: \"_onFocusIn\",\n    value: function _onFocusIn(event) {\n      var $target = $(event.target);\n      $target.on('remove', this._removeListener);\n      this.focusedElement = event.target; // Do not update current focus context nor validate focus if target is $entryPoint.\n      // That is because focusing the $entryPoint is done whenever no control is currently focusable, e.g. due to glasspanes.\n\n      if (event.target === this.$container.entryPoint(true)) {\n        return;\n      } // Make this context the active context (nothing done if already active) and validate the focus event.\n\n\n      this.focusManager._pushIfAbsendElseMoveTop(this);\n\n      this.validateAndSetFocus(event.target);\n      event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.\n    }\n    /**\n     * Method invoked once a 'focusout' event is fired by this context's $container or one of its child controls.\n     */\n\n  }, {\n    key: \"_onFocusOut\",\n    value: function _onFocusOut(event) {\n      $(event.target).off('remove', this._removeListener);\n      this.focusedElement = null;\n      event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.\n    }\n    /**\n     * Method invoked once a child element of this context's $container is removed.\n     */\n\n  }, {\n    key: \"_onRemove\",\n    value: function _onRemove(event) {\n      // This listener is installed on the focused element only.\n      this.validateAndSetFocus(null, filters.notSameFilter(event.target));\n      event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.\n    }\n    /**\n     * Function invoked once a child element of this context's $container is hidden or disabled\n     * and it cannot have the focus anymore. In that case we need to look for a new focusable\n     * element.\n     */\n\n  }, {\n    key: \"_onUnfocusable\",\n    value: function _onUnfocusable(event) {\n      if ($(event.target).isOrHas(this.lastValidFocusedElement)) {\n        this.validateAndSetFocus(null, filters.notSameFilter(event.target));\n        event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.\n      }\n    }\n    /**\n     * Focuses the given element if being a child of this context's container and matches the given filter (if provided).\n     *\n     * @param element\n     *        the element to gain focus, or null to focus the context's first focusable element matching the given filter.\n     * @param filter\n     *        filter to control which element to gain focus, or null to accept all focusable candidates.\n     */\n\n  }, {\n    key: \"validateAndSetFocus\",\n    value: function validateAndSetFocus(element, filter) {\n      // Ensure the element to be a child element, or set it to null otherwise.\n      if (element && !$.contains(this.$container[0], element)) {\n        element = null;\n      }\n\n      var elementToFocus = null;\n\n      if (!element) {\n        elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);\n      } else if (!filter || filter.call(element)) {\n        elementToFocus = element;\n      } else {\n        elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);\n      } // Store the element to be focused, and regardless of whether currently covert by a glass pane or the focus manager is not active. That is for later focus restore.\n\n\n      this.lastValidFocusedElement = elementToFocus; // Focus the element.\n\n      this._focus(elementToFocus);\n    }\n    /**\n     * Calls {@link #validateAndSetFocus} with {@link #lastValidFocusedElement}.\n     */\n\n  }, {\n    key: \"validateFocus\",\n    value: function validateFocus(filter) {\n      this.validateAndSetFocus(this.lastValidFocusedElement, filter);\n    }\n    /**\n     * Restores the focus on the last valid focused element. Does nothing, if there is no last valid focused element.\n     */\n\n  }, {\n    key: \"restoreFocus\",\n    value: function restoreFocus() {\n      if (this.lastValidFocusedElement) {\n        this._focus(this.lastValidFocusedElement);\n      }\n    }\n    /**\n     * Focuses the requested element.\n     */\n\n  }, {\n    key: \"_focus\",\n    value: function _focus(elementToFocus) {\n      // Only focus element if focus manager is active\n      if (!this.focusManager.active) {\n        return;\n      }\n\n      if (!this.prepared) {\n        return;\n      } // Check whether the element is covert by a glasspane\n\n\n      if (this.focusManager.isElementCovertByGlassPane(elementToFocus)) {\n        var activeElement = this.$container.activeElement(true);\n\n        if (elementToFocus && (!activeElement || !this.focusManager.isElementCovertByGlassPane(activeElement))) {\n          // If focus should be removed (blur), don't break here and try to focus the root element\n          // Otherwise, if desired element cannot be focused then break and leave the focus where it is, unless the currently focused element is covered by a glass pane\n          return false;\n        }\n\n        elementToFocus = null;\n      } // Focus $entryPoint if current focus is to be blured.\n      // Otherwise, the HTML body would be focused which makes global keystrokes (like backspace) not to work anymore.\n\n\n      elementToFocus = elementToFocus || this.$container.entryPoint(true); // If element may not be focused (example SVG element in IE) -> use the entryPoint as fallback\n      // $elementToFocus.focus() would trigger a focus event even the element won't be focused -> loop\n      // In that case the focus function does not exist on the svg element\n\n      if (!elementToFocus.focus) {\n        elementToFocus = this.$container.entryPoint(true);\n      } // Only focus element if different to current focused element\n\n\n      if (focusUtils.isActiveElement(elementToFocus)) {\n        return;\n      } // Focus the requested element\n\n\n      elementToFocus.focus();\n      $.log.isDebugEnabled() && $.log.debug('Focus set to ' + graphics.debugOutput(elementToFocus));\n    }\n  }]);\n\n  return FocusContext;\n}();\n\nexport { FocusContext as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/focus/FocusContext.js"],"names":["filters","focusUtils","graphics","keys","Point","scrollbars","$","FocusContext","$container","focusManager","lastValidFocusedElement","focusedElement","prepared","_keyDownListener","_onKeyDown","bind","_focusInListener","_onFocusIn","_focusOutListener","_onFocusOut","_unfocusableListener","_onUnfocusable","_removeListener","_onRemove","on","restoreFocus","off","event","which","TAB","activeElement","$focusableElements","find","firstFocusableElement","first","lastFocusableElement","last","activeElementIndex","index","shiftKey","suppressEvent","validateAndSetFocus","length","get","$focusableElement","containerBounds","offsetBounds","$scrollable","scrollParent","isLocationInView","x","y","scrollTo","$target","target","entryPoint","_pushIfAbsendElseMoveTop","stopPropagation","notSameFilter","isOrHas","element","filter","contains","elementToFocus","findFirstFocusableElement","call","_focus","active","isElementCovertByGlassPane","focus","isActiveElement","log","isDebugEnabled","debug","debugOutput"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {filters, focusUtils, graphics, keys, Point, scrollbars} from '../index';\nimport $ from 'jquery';\n\n/**\n * A focus context is associated with a $container, and controls how to focus elements within that $container.\n */\nexport default class FocusContext {\n\n  constructor($container, focusManager) {\n    this.$container = $container;\n    this.focusManager = focusManager;\n\n    this.lastValidFocusedElement = null; // variable to store the last valid focus position; used to restore focus once being re-activated.\n    this.focusedElement = null;\n    this.prepared = false;\n\n    // Notice: every listener is installed on $container and not on $field level, except 'remove' listener because it does not bubble.\n    this._keyDownListener = this._onKeyDown.bind(this);\n    this._focusInListener = this._onFocusIn.bind(this);\n    this._focusOutListener = this._onFocusOut.bind(this);\n    this._unfocusableListener = this._onUnfocusable.bind(this);\n    this._removeListener = this._onRemove.bind(this);\n  }\n\n  ready() {\n    if (this.prepared) {\n      return;\n    }\n    this.$container\n      .on('keydown', this._keyDownListener)\n      .on('focusin', this._focusInListener)\n      .on('focusout', this._focusOutListener)\n      .on('hide disable', this._unfocusableListener);\n    this.prepared = true;\n\n    if (this.lastValidFocusedElement) {\n      // If a widget requested the focus while focus context was not ready, lastValidFocusedElement is set to that widget but the widget itself is not focused.\n      // -> Ensure that widget is focused\n      this.restoreFocus();\n    }\n  }\n\n  dispose() {\n    if (!this.prepared) {\n      return;\n    }\n    this.$container\n      .off('keydown', this._keyDownListener)\n      .off('focusin', this._focusInListener)\n      .off('focusout', this._focusOutListener)\n      .off('hide disable', this._unfocusableListener);\n    $(this.focusedElement).off('remove', this._removeListener);\n  }\n\n  /**\n   * Method invoked once a 'keydown' event is fired to control proper tab cycle.\n   */\n  _onKeyDown(event) {\n    if (event.which === keys.TAB) {\n      var activeElement = this.$container.activeElement(true),\n        $focusableElements = this.$container.find(':tabbable:visible'),\n        firstFocusableElement = $focusableElements.first()[0],\n        lastFocusableElement = $focusableElements.last()[0],\n        activeElementIndex = $focusableElements.index(activeElement),\n        focusedElement;\n\n      // Forward Tab\n      if (!event.shiftKey) {\n        // If the last focusable element is focused, or the focus is on the container, set the focus to the first focusable element\n        if (firstFocusableElement && (activeElement === lastFocusableElement || activeElement === this.$container[0])) {\n          $.suppressEvent(event);\n          this.validateAndSetFocus(firstFocusableElement);\n          focusedElement = firstFocusableElement;\n        } else if (activeElementIndex < $focusableElements.length - 1) {\n          focusedElement = $focusableElements.get(activeElementIndex + 1);\n          // Note: event is _not_ suppressed here --> will be handled by browser\n        }\n      } else { // Backward Tab (Shift+TAB)\n        // If the first focusable element is focused, or the focus is on the container, set the focus to the last focusable element\n        if (lastFocusableElement && (activeElement === firstFocusableElement || activeElement === this.$container[0])) {\n          $.suppressEvent(event);\n          this.validateAndSetFocus(lastFocusableElement);\n          focusedElement = lastFocusableElement;\n        } else if (activeElementIndex > 0) {\n          focusedElement = $focusableElements.get(activeElementIndex - 1);\n          // Note: event is _not_ suppressed here --> will be handled by browser\n        }\n      }\n      if (!focusedElement) {\n        return;\n      }\n\n      // Check if new focused element is currently visible, otherwise scroll the container\n      var $focusableElement = $(focusedElement),\n        containerBounds = graphics.offsetBounds($focusableElement),\n        $scrollable = $focusableElement.scrollParent();\n      if (!scrollbars.isLocationInView(new Point(containerBounds.x, containerBounds.y), $scrollable)) {\n        scrollbars.scrollTo($scrollable, $focusableElement);\n      }\n    }\n  }\n\n  /**\n   * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.\n   */\n  _onFocusIn(event) {\n    var $target = $(event.target);\n    $target.on('remove', this._removeListener);\n    this.focusedElement = event.target;\n\n    // Do not update current focus context nor validate focus if target is $entryPoint.\n    // That is because focusing the $entryPoint is done whenever no control is currently focusable, e.g. due to glasspanes.\n    if (event.target === this.$container.entryPoint(true)) {\n      return;\n    }\n\n    // Make this context the active context (nothing done if already active) and validate the focus event.\n    this.focusManager._pushIfAbsendElseMoveTop(this);\n    this.validateAndSetFocus(event.target);\n    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.\n  }\n\n  /**\n   * Method invoked once a 'focusout' event is fired by this context's $container or one of its child controls.\n   */\n  _onFocusOut(event) {\n    $(event.target).off('remove', this._removeListener);\n    this.focusedElement = null;\n    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.\n  }\n\n  /**\n   * Method invoked once a child element of this context's $container is removed.\n   */\n  _onRemove(event) {\n    // This listener is installed on the focused element only.\n    this.validateAndSetFocus(null, filters.notSameFilter(event.target));\n    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.\n  }\n\n  /**\n   * Function invoked once a child element of this context's $container is hidden or disabled\n   * and it cannot have the focus anymore. In that case we need to look for a new focusable\n   * element.\n   */\n  _onUnfocusable(event) {\n    if ($(event.target).isOrHas(this.lastValidFocusedElement)) {\n      this.validateAndSetFocus(null, filters.notSameFilter(event.target));\n      event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.\n    }\n  }\n\n  /**\n   * Focuses the given element if being a child of this context's container and matches the given filter (if provided).\n   *\n   * @param element\n   *        the element to gain focus, or null to focus the context's first focusable element matching the given filter.\n   * @param filter\n   *        filter to control which element to gain focus, or null to accept all focusable candidates.\n   */\n  validateAndSetFocus(element, filter) {\n    // Ensure the element to be a child element, or set it to null otherwise.\n    if (element && !$.contains(this.$container[0], element)) {\n      element = null;\n    }\n\n    var elementToFocus = null;\n    if (!element) {\n      elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);\n    } else if (!filter || filter.call(element)) {\n      elementToFocus = element;\n    } else {\n      elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);\n    }\n\n    // Store the element to be focused, and regardless of whether currently covert by a glass pane or the focus manager is not active. That is for later focus restore.\n    this.lastValidFocusedElement = elementToFocus;\n\n    // Focus the element.\n    this._focus(elementToFocus);\n  }\n\n  /**\n   * Calls {@link #validateAndSetFocus} with {@link #lastValidFocusedElement}.\n   */\n  validateFocus(filter) {\n    this.validateAndSetFocus(this.lastValidFocusedElement, filter);\n  }\n\n  /**\n   * Restores the focus on the last valid focused element. Does nothing, if there is no last valid focused element.\n   */\n  restoreFocus() {\n    if (this.lastValidFocusedElement) {\n      this._focus(this.lastValidFocusedElement);\n    }\n  }\n\n  /**\n   * Focuses the requested element.\n   */\n  _focus(elementToFocus) {\n    // Only focus element if focus manager is active\n    if (!this.focusManager.active) {\n      return;\n    }\n    if (!this.prepared) {\n      return;\n    }\n\n    // Check whether the element is covert by a glasspane\n    if (this.focusManager.isElementCovertByGlassPane(elementToFocus)) {\n      var activeElement = this.$container.activeElement(true);\n      if (elementToFocus && (!activeElement || !this.focusManager.isElementCovertByGlassPane(activeElement))) {\n        // If focus should be removed (blur), don't break here and try to focus the root element\n        // Otherwise, if desired element cannot be focused then break and leave the focus where it is, unless the currently focused element is covered by a glass pane\n        return false;\n      }\n      elementToFocus = null;\n    }\n\n    // Focus $entryPoint if current focus is to be blured.\n    // Otherwise, the HTML body would be focused which makes global keystrokes (like backspace) not to work anymore.\n    elementToFocus = elementToFocus || this.$container.entryPoint(true);\n\n    // If element may not be focused (example SVG element in IE) -> use the entryPoint as fallback\n    // $elementToFocus.focus() would trigger a focus event even the element won't be focused -> loop\n    // In that case the focus function does not exist on the svg element\n    if (!elementToFocus.focus) {\n      elementToFocus = this.$container.entryPoint(true);\n    }\n\n    // Only focus element if different to current focused element\n    if (focusUtils.isActiveElement(elementToFocus)) {\n      return;\n    }\n\n    // Focus the requested element\n    elementToFocus.focus();\n\n    $.log.isDebugEnabled() && $.log.debug('Focus set to ' + graphics.debugOutput(elementToFocus));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}