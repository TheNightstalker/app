{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { DateFormat, DatePickerPopup, dates, DateTimeCompositeLayout, Device, fields, focusUtils, FormField, HtmlComponent, InputFieldKeyStrokeContext, keys, objects, scout, Status, strings, styles, TimePickerPopup, ValueField } from '../../../index';\nimport $ from 'jquery';\n\nvar DateField = /*#__PURE__*/function (_ValueField) {\n  _inherits(DateField, _ValueField);\n\n  var _super = _createSuper(DateField);\n\n  function DateField() {\n    var _this;\n\n    _classCallCheck(this, DateField);\n\n    _this = _super.call(this);\n    _this.popup = null;\n    _this.autoDate = null;\n    _this.dateDisplayText = null;\n    _this.dateHasText = false;\n    _this.dateFocused = false;\n    _this.dateFormatPattern = null;\n    _this.disabledCopyOverlay = true;\n    _this.hasDate = true;\n    _this.oldDisplayText = null;\n    _this.touchMode = false;\n    _this.embedded = false;\n    _this.hasTime = false;\n    _this.hasTimePopup = true;\n    _this.timeDisplayText = null;\n    _this.timeHasText = false;\n    _this.timeDisplayText = null;\n    _this.timePickerResolution = 30;\n    _this.timeFormatPattern = null;\n    _this.timeFocused = false;\n    _this.$dateField = null;\n    _this.$timeField = null;\n    _this.$dateFieldIcon = null;\n    _this.$timeFieldIcon = null;\n    _this.$dateClearIcon = null;\n    _this.$timeClearIcon = null;\n    _this._$predictDateField = null;\n    _this._$predictTimeField = null; // This is the storage for the time (as date) while the focus in the field (e.g. when\n    // pressing up/down). In date fields, the date picker is used for that purposes.\n\n    _this._tempTimeDate = null;\n    _this.invalidValueMessageKey = 'ui.InvalidDate';\n\n    _this._addCloneProperties(['hasDate', 'hasTime', 'dateFormatPattern', 'timeFormatPattern', 'allowedDates', 'autoDate']);\n\n    return _this;\n  }\n\n  _createClass(DateField, [{\n    key: \"_createKeyStrokeContext\",\n\n    /**\n     * @override Widget.js\n     */\n    value: function _createKeyStrokeContext() {\n      return new InputFieldKeyStrokeContext();\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(model) {\n      _get(_getPrototypeOf(DateField.prototype), \"_init\", this).call(this, model);\n\n      fields.initTouch(this, model);\n      this.popup = model.popup;\n\n      this._setAutoDate(this.autoDate);\n\n      this._setDisplayText(this.displayText);\n\n      this._setAllowedDates(this.allowedDates);\n\n      this._setTimePickerResolution(this.timePickerResolution);\n    }\n    /**\n     * Initializes the date format before calling set value.\n     * This cannot be done in _init because the value field would call _setValue first\n     */\n\n  }, {\n    key: \"_initValue\",\n    value: function _initValue(value) {\n      this._setDateFormatPattern(this.dateFormatPattern);\n\n      this._setTimeFormatPattern(this.timeFormatPattern);\n\n      _get(_getPrototypeOf(DateField.prototype), \"_initValue\", this).call(this, value);\n    }\n  }, {\n    key: \"createDatePopup\",\n    value: function createDatePopup() {\n      var popupType = this.touchMode ? 'DatePickerTouchPopup' : 'DatePickerPopup';\n      return scout.create(popupType, {\n        parent: this,\n        $anchor: this.$field,\n        boundToAnchor: !this.touchMode,\n        cssClass: this._errorStatusClass(),\n        closeOnAnchorMouseDown: false,\n        field: this,\n        allowedDates: this.allowedDates,\n        dateFormat: this.isolatedDateFormat,\n        displayText: this.dateDisplayText\n      });\n    }\n  }, {\n    key: \"createTimePopup\",\n    value: function createTimePopup() {\n      var popupType = this.touchMode ? 'TimePickerTouchPopup' : 'TimePickerPopup';\n      return scout.create(popupType, {\n        parent: this,\n        $anchor: this.$timeField,\n        boundToAnchor: !this.touchMode,\n        cssClass: this._errorStatusClass(),\n        closeOnAnchorMouseDown: false,\n        field: this,\n        timeResolution: this.timePickerResolution\n      });\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      this.addContainer(this.$parent, 'date-field');\n      this.addLabel();\n      this.addField(this.$parent.makeDiv('date-time-composite'));\n      this.addStatus(this.$field);\n\n      if (!this.embedded) {\n        this.addMandatoryIndicator();\n      }\n\n      this.htmlDateTimeComposite = HtmlComponent.install(this.$field, this.session);\n      this.htmlDateTimeComposite.setLayout(new DateTimeCompositeLayout(this));\n    }\n  }, {\n    key: \"_renderProperties\",\n    value: function _renderProperties() {\n      this._renderHasDate();\n\n      this._renderHasTime(); // Has to be the last call, otherwise _renderErrorStatus() would operate on the wrong state.\n\n\n      _get(_getPrototypeOf(DateField.prototype), \"_renderProperties\", this).call(this);\n\n      this._renderDateHasText();\n\n      this._renderTimeHasText();\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      _get(_getPrototypeOf(DateField.prototype), \"_remove\", this).call(this);\n\n      this.$dateField = null;\n      this.$timeField = null;\n      this.$dateFieldIcon = null;\n      this.$timeFieldIcon = null;\n      this.$dateClearIcon = null;\n      this.$timeClearIcon = null;\n      this._$predictDateField = null;\n      this._$predictTimeField = null;\n      this.popup = null;\n    }\n  }, {\n    key: \"setHasDate\",\n    value: function setHasDate(hasDate) {\n      this.setProperty('hasDate', hasDate);\n    }\n  }, {\n    key: \"_setHasDate\",\n    value: function _setHasDate(hasDate) {\n      this._setProperty('hasDate', hasDate);\n\n      if (this.initialized) {\n        // if property changes on the fly, update the display text\n        this._updateDisplayTextProperty();\n      }\n    }\n  }, {\n    key: \"_renderHasDate\",\n    value: function _renderHasDate() {\n      if (this.hasDate && !this.$dateField) {\n        // Add $dateField\n        this.$dateField = fields.makeInputOrDiv(this, 'date').on('mousedown', this._onDateFieldMouseDown.bind(this)).appendTo(this.$field);\n\n        if (this.$timeField) {\n          // make sure date field comes before time field, otherwise tab won't work as expected\n          this.$dateField.insertBefore(this.$timeField);\n        }\n\n        if (!this.touchMode) {\n          this.$dateField.on('keydown', this._onDateFieldKeyDown.bind(this)).on('input', this._onDateFieldInput.bind(this)).on('blur', this._onDateFieldBlur.bind(this)).on('focus', this._onDateFieldFocus.bind(this));\n        }\n\n        this._linkWithLabel(this.$dateField);\n\n        HtmlComponent.install(this.$dateField, this.session);\n        this.$dateFieldIcon = fields.appendIcon(this.$field, 'date').on('mousedown', this._onDateIconMouseDown.bind(this)); // avoid fastclick on icon. Otherwise the blur event overtakes the mousedown event.\n\n        this.$dateFieldIcon.addClass('needsclick');\n      } else if (!this.hasDate && this.$dateField) {\n        // Remove $dateField\n        this.$dateField.remove();\n        this.$dateField = null;\n        this.$dateFieldIcon.remove();\n        this.$dateFieldIcon = null;\n      }\n\n      if (!this.rendering) {\n        this._renderDisplayText();\n\n        this._renderFieldStyle();\n\n        this._renderEnabled();\n\n        this.htmlDateTimeComposite.invalidateLayoutTree();\n      }\n\n      this._renderDateClearable();\n    }\n  }, {\n    key: \"setHasTime\",\n    value: function setHasTime(hasTime) {\n      this.setProperty('hasTime', hasTime);\n    }\n  }, {\n    key: \"_setHasTime\",\n    value: function _setHasTime(hasTime) {\n      this._setProperty('hasTime', hasTime);\n\n      if (this.initialized) {\n        // if property changes on the fly, update the display text\n        this._updateDisplayTextProperty();\n      }\n    }\n  }, {\n    key: \"_renderHasTime\",\n    value: function _renderHasTime() {\n      if (this.hasTime && !this.$timeField) {\n        // Add $timeField\n        this.$timeField = fields.makeInputOrDiv(this, 'time').on('mousedown', this._onTimeFieldMouseDown.bind(this)).appendTo(this.$field);\n\n        if (this.$dateField) {\n          // make sure time field comes after date field, otherwise tab won't work as expected\n          this.$timeField.insertAfter(this.$dateField);\n        }\n\n        if (!this.touchMode || !this.hasTimePopup) {\n          this.$timeField.on('keydown', this._onTimeFieldKeyDown.bind(this)).on('input', this._onTimeFieldInput.bind(this)).on('blur', this._onTimeFieldBlur.bind(this)).on('focus', this._onTimeFieldFocus.bind(this));\n        }\n\n        this._linkWithLabel(this.$timeField);\n\n        HtmlComponent.install(this.$timeField, this.session);\n        this.$timeFieldIcon = fields.appendIcon(this.$field, 'time').on('mousedown', this._onTimeIconMouseDown.bind(this)); // avoid fastclick on icon. Otherwise the blur event overtakes the mousedown event.\n\n        this.$timeFieldIcon.addClass('needsclick');\n      } else if (!this.hasTime && this.$timeField) {\n        // Remove $timeField\n        this.$timeField.remove();\n        this.$timeField = null;\n        this.$timeFieldIcon.remove();\n        this.$timeFieldIcon = null;\n      }\n\n      if (!this.rendering) {\n        this._renderDisplayText();\n\n        this._renderFieldStyle();\n\n        this._renderEnabled();\n\n        this.htmlDateTimeComposite.invalidateLayoutTree();\n      }\n\n      this._renderTimeClearable();\n    }\n  }, {\n    key: \"setTimePickerResolution\",\n    value: function setTimePickerResolution(timePickerResolution) {\n      this.setProperty('timePickerResolution', timePickerResolution);\n    }\n  }, {\n    key: \"_setTimePickerResolution\",\n    value: function _setTimePickerResolution(timePickerResolution) {\n      if (timePickerResolution < 1) {\n        // default\n        timePickerResolution = 10;\n        this.hasTimePopup = false;\n      } else {\n        this.hasTimePopup = true;\n      }\n\n      this._setProperty('timePickerResolution', timePickerResolution);\n    }\n    /**\n     * @override FormField.js\n     */\n\n  }, {\n    key: \"_renderPlaceholder\",\n    value: function _renderPlaceholder($field) {\n      _get(_getPrototypeOf(DateField.prototype), \"_renderPlaceholder\", this).call(this, this._fieldForPlaceholder());\n    }\n    /**\n     * @override FormField.js\n     */\n\n  }, {\n    key: \"_removePlaceholder\",\n    value: function _removePlaceholder($field) {\n      _get(_getPrototypeOf(DateField.prototype), \"_removePlaceholder\", this).call(this, this._fieldForPlaceholder());\n    }\n  }, {\n    key: \"_fieldForPlaceholder\",\n    value: function _fieldForPlaceholder() {\n      if (this.hasDate) {\n        return this.$dateField;\n      } else if (this.hasTime) {\n        return this.$timeField;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"setDateFormatPattern\",\n    value: function setDateFormatPattern(dateFormatPattern) {\n      this.setProperty('dateFormatPattern', dateFormatPattern);\n    }\n  }, {\n    key: \"_setDateFormatPattern\",\n    value: function _setDateFormatPattern(dateFormatPattern) {\n      if (!dateFormatPattern) {\n        dateFormatPattern = this.session.locale.dateFormatPatternDefault;\n      }\n\n      this._setProperty('dateFormatPattern', dateFormatPattern);\n\n      this.isolatedDateFormat = new DateFormat(this.session.locale, this.dateFormatPattern);\n\n      if (this.initialized) {\n        // if format changes on the fly, just update the display text\n        this._updateDisplayText();\n      }\n    }\n  }, {\n    key: \"setTimeFormatPattern\",\n    value: function setTimeFormatPattern(timeFormatPattern) {\n      this.setProperty('timeFormatPattern', timeFormatPattern);\n    }\n  }, {\n    key: \"_setTimeFormatPattern\",\n    value: function _setTimeFormatPattern(timeFormatPattern) {\n      if (!timeFormatPattern) {\n        timeFormatPattern = this.session.locale.timeFormatPatternDefault;\n      }\n\n      this._setProperty('timeFormatPattern', timeFormatPattern);\n\n      this.isolatedTimeFormat = new DateFormat(this.session.locale, this.timeFormatPattern);\n\n      if (this.initialized) {\n        // if format changes on the fly, just update the display text\n        this._updateDisplayText();\n      }\n    }\n    /**\n     * @override FormField.js\n     */\n\n  }, {\n    key: \"_renderEnabled\",\n    value: function _renderEnabled() {\n      _get(_getPrototypeOf(DateField.prototype), \"_renderEnabled\", this).call(this);\n\n      this.$container.setEnabled(this.enabledComputed);\n\n      if (this.$dateField) {\n        this.$dateField.setEnabled(this.enabledComputed);\n      }\n\n      if (this.$timeField) {\n        this.$timeField.setEnabled(this.enabledComputed);\n      } // Workaround for IE11 issue: other than all other browsers IE11 doesn't trigger a blur event when the field is disabled.\n      // In cases where the field is disabled asynchronously, the popup would stay opened by error #240929.\n\n\n      if (Device.get().isInternetExplorer() && !this.enabledComputed) {\n        this.closePopup();\n      }\n    }\n    /**\n     * @override ValueField.js\n     */\n\n  }, {\n    key: \"_renderDisplayText\",\n    value: function _renderDisplayText() {\n      if (this.hasDate) {\n        this._renderDateDisplayText();\n      }\n\n      if (this.hasTime) {\n        this._renderTimeDisplayText();\n      }\n\n      this._removePredictionFields();\n    }\n  }, {\n    key: \"_readDisplayText\",\n    value: function _readDisplayText() {\n      var dateDisplayText, timeDisplayText;\n\n      if (this.hasDate) {\n        dateDisplayText = this._readDateDisplayText();\n      }\n\n      if (this.hasTime) {\n        timeDisplayText = this._readTimeDisplayText();\n      }\n\n      return this._computeDisplayText(dateDisplayText, timeDisplayText);\n    }\n  }, {\n    key: \"_renderDateDisplayText\",\n    value: function _renderDateDisplayText() {\n      fields.valOrText(this.$dateField, this.dateDisplayText);\n\n      this._updateDateHasText();\n    }\n  }, {\n    key: \"_readDateDisplayText\",\n    value: function _readDateDisplayText() {\n      return this._$predictDateField ? fields.valOrText(this._$predictDateField) : fields.valOrText(this.$dateField);\n    }\n  }, {\n    key: \"_renderTimeDisplayText\",\n    value: function _renderTimeDisplayText() {\n      fields.valOrText(this.$timeField, this.timeDisplayText);\n\n      this._updateTimeHasText();\n    }\n  }, {\n    key: \"_readTimeDisplayText\",\n    value: function _readTimeDisplayText() {\n      return this._$predictTimeField ? fields.valOrText(this._$predictTimeField) : fields.valOrText(this.$timeField);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"setDisplayText\",\n    value: function setDisplayText(displayText) {\n      // Overridden to avoid the equals check -> make sure renderDisplayText is executed whenever setDisplayText is called\n      // Reason: key up/down and picker day click modify the display text, but input doesn't\n      // -> reverting to a date using day click or up down after the input changed would not work anymore\n      // changing 'onXyInput' to always update the display text would fix that, but would break acceptInput\n      this._setDisplayText(displayText);\n\n      if (this.rendered) {\n        this._renderDisplayText();\n      }\n    }\n  }, {\n    key: \"_setDisplayText\",\n    value: function _setDisplayText(displayText) {\n      this.oldDisplayText = this.displayText;\n\n      this._setProperty('displayText', displayText);\n\n      var parts = this._splitDisplayText(displayText);\n\n      if (this.hasDate) {\n        // preserve dateDisplayText if hasDate is set to false (only override if it is true)\n        this.dateDisplayText = parts.dateText;\n      }\n\n      if (this.hasTime) {\n        // preserve timeDisplayText if hasTime is set to false (only override if it is true)\n        this.timeDisplayText = parts.timeText;\n      }\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_ensureValue\",\n    value: function _ensureValue(value) {\n      return dates.ensure(value);\n    }\n    /**\n     * @param {Date} value the date to validate\n     * @return {Date} the validated date\n     * @override\n     */\n\n  }, {\n    key: \"_validateValue\",\n    value: function _validateValue(value) {\n      if (objects.isNullOrUndefined(value)) {\n        return value;\n      }\n\n      if (!(value instanceof Date)) {\n        throw this.session.text(this.invalidValueMessageKey);\n      }\n\n      if (!this.hasDate && !this.value) {\n        // truncate to 01.01.1970 if no date was entered before. Otherwise preserve date part (important for toggling hasDate on the fly)\n        value = dates.combineDateTime(null, value);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_valueEquals\",\n    value: function _valueEquals(valueA, valueB) {\n      return dates.equals(valueA, valueB);\n    }\n  }, {\n    key: \"setAutoDate\",\n    value: function setAutoDate(autoDate) {\n      this.setProperty('autoDate', autoDate);\n    }\n  }, {\n    key: \"_setAutoDate\",\n    value: function _setAutoDate(autoDate) {\n      autoDate = dates.ensure(autoDate);\n\n      this._setProperty('autoDate', autoDate);\n    }\n  }, {\n    key: \"_setAllowedDates\",\n    value: function _setAllowedDates(allowedDates) {\n      if (Array.isArray(allowedDates)) {\n        allowedDates = allowedDates.map(function (date) {\n          return dates.ensure(date);\n        });\n\n        this._setProperty('allowedDates', allowedDates);\n      } else {\n        this._setProperty('allowedDates', null);\n      }\n    }\n    /**\n     * @override FormField.js\n     */\n\n  }, {\n    key: \"_renderErrorStatus\",\n    value: function _renderErrorStatus() {\n      _get(_getPrototypeOf(DateField.prototype), \"_renderErrorStatus\", this).call(this);\n\n      var hasStatus = !!this.errorStatus,\n          statusClass = this._errorStatusClass();\n\n      if (this.$dateField) {\n        this.$dateField.removeClass(FormField.SEVERITY_CSS_CLASSES);\n        this.$dateField.toggleClass(statusClass, hasStatus); // Because the error color of field icons depends on the error status of sibling <input> elements.\n        // The prediction fields are clones of the input fields, so the 'has-error' class has to be\n        // removed from them as well to make the icon \"valid\".\n\n        if (this._$predictDateField) {\n          this._$predictDateField.removeClass(FormField.SEVERITY_CSS_CLASSES);\n\n          this._$predictDateField.toggleClass(statusClass, hasStatus);\n        }\n      } // Do the same for the time field\n\n\n      if (this.$timeField) {\n        this.$timeField.removeClass(FormField.SEVERITY_CSS_CLASSES);\n        this.$timeField.toggleClass(statusClass, hasStatus);\n\n        if (this._$predictTimeField) {\n          this._$predictTimeField.removeClass(FormField.SEVERITY_CSS_CLASSES);\n\n          this._$predictTimeField.toggleClass(statusClass, hasStatus);\n        }\n      }\n\n      if (this.popup) {\n        this.popup.$container.removeClass(FormField.SEVERITY_CSS_CLASSES);\n        this.popup.$container.toggleClass(statusClass, hasStatus);\n      }\n    }\n  }, {\n    key: \"_errorStatusClass\",\n    value: function _errorStatusClass() {\n      return this.errorStatus ? 'has-' + this.errorStatus.cssClass() : '';\n    }\n    /**\n     * @Override FormField.js\n     */\n\n  }, {\n    key: \"_renderFont\",\n    value: function _renderFont() {\n      this.$dateField && styles.legacyFont(this, this.$dateField);\n      this.$timeField && styles.legacyFont(this, this.$timeField);\n    }\n    /**\n     * @Override FormField.js\n     */\n\n  }, {\n    key: \"_renderForegroundColor\",\n    value: function _renderForegroundColor() {\n      this.$dateField && styles.legacyForegroundColor(this, this.$dateField);\n      this.$timeField && styles.legacyForegroundColor(this, this.$timeField);\n    }\n    /**\n     * @override FormField.js\n     */\n\n  }, {\n    key: \"_renderBackgroundColor\",\n    value: function _renderBackgroundColor() {\n      this.$dateField && styles.legacyBackgroundColor(this, this.$dateField);\n      this.$timeField && styles.legacyBackgroundColor(this, this.$timeField);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"activate\",\n    value: function activate() {\n      if (!this.enabledComputed || !this.rendered) {\n        return;\n      }\n\n      if (this.$dateField) {\n        this.$dateField.focus();\n\n        this._onDateFieldMouseDown();\n      } else if (this.$timeField) {\n        this.$timeField.focus();\n\n        this._onTimeFieldMouseDown();\n      }\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"getFocusableElement\",\n    value: function getFocusableElement() {\n      if (this.$dateField) {\n        return this.$dateField;\n      }\n\n      if (this.$timeField) {\n        return this.$timeField;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_onDateFieldMouseDown\",\n    value: function _onDateFieldMouseDown() {\n      if (fields.handleOnClick(this)) {\n        this.openDatePopupAndSelect(this.value);\n      }\n    }\n  }, {\n    key: \"_onTimeFieldMouseDown\",\n    value: function _onTimeFieldMouseDown() {\n      if (fields.handleOnClick(this)) {\n        this.openTimePopupAndSelect(this.value);\n      }\n    }\n  }, {\n    key: \"setDateFocused\",\n    value: function setDateFocused(dateFocused) {\n      this.setProperty('dateFocused', dateFocused);\n    }\n  }, {\n    key: \"_renderDateFocused\",\n    value: function _renderDateFocused() {\n      this.$container.toggleClass('date-focused', this.dateFocused);\n    }\n  }, {\n    key: \"_updateTimeHasText\",\n    value: function _updateTimeHasText() {\n      this.setTimeHasText(strings.hasText(this._readTimeDisplayText()));\n    }\n  }, {\n    key: \"setTimeHasText\",\n    value: function setTimeHasText(timeHasText) {\n      this.setProperty('timeHasText', timeHasText);\n    }\n  }, {\n    key: \"_renderTimeHasText\",\n    value: function _renderTimeHasText() {\n      if (this.$timeField) {\n        this.$timeField.toggleClass('has-text', this.timeHasText);\n      }\n\n      this.$container.toggleClass('time-has-text', this.timeHasText);\n    }\n  }, {\n    key: \"_updateDateHasText\",\n    value: function _updateDateHasText() {\n      this.setDateHasText(strings.hasText(this._readDateDisplayText()));\n    }\n  }, {\n    key: \"setDateHasText\",\n    value: function setDateHasText(dateHasText) {\n      this.setProperty('dateHasText', dateHasText);\n    }\n  }, {\n    key: \"_renderDateHasText\",\n    value: function _renderDateHasText() {\n      if (this.$dateField) {\n        this.$dateField.toggleClass('has-text', this.dateHasText);\n      }\n\n      this.$container.toggleClass('date-has-text', this.dateHasText);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (!(this.hasDate && this.hasTime)) {\n        _get(_getPrototypeOf(DateField.prototype), \"clear\", this).call(this);\n\n        return;\n      }\n\n      this._clear(); // If field shows date and time, don't accept input while one field has the focus\n      // Reason: x icon is shown in one field, pressing that icon should clear the content of that field.\n      // Accept input would set the value to '', thus clearing both fields which may be unexpected.\n\n\n      if (!this.dateFocused && !this.timeFocused) {\n        this.acceptInput();\n      }\n\n      this._triggerClear();\n    }\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      this._removePredictionFields();\n\n      if (this.hasDate && !this.timeFocused) {\n        fields.valOrText(this.$dateField, '');\n\n        this._setDateValid(true);\n\n        this._updateDateHasText();\n      }\n\n      if (this.hasTime && !this.dateFocused) {\n        fields.valOrText(this.$timeField, '');\n\n        this._setTimeValid(true);\n\n        this._updateTimeHasText();\n      }\n    }\n  }, {\n    key: \"_onDateClearIconMouseDown\",\n    value: function _onDateClearIconMouseDown(event) {\n      if (!this.enabledComputed) {\n        return;\n      }\n\n      this.$dateField.focus();\n      this.clear();\n\n      if (this.value) {\n        this.selectDate(this.value, false);\n      } else {\n        this.preselectDate(this._referenceDate(), false);\n      }\n\n      event.preventDefault();\n    }\n  }, {\n    key: \"_onDateIconMouseDown\",\n    value: function _onDateIconMouseDown(event) {\n      if (!this.enabledComputed) {\n        return;\n      }\n\n      this.$dateField.focus();\n\n      if (!this.embedded) {\n        this.openDatePopupAndSelect(this.value);\n      }\n    }\n  }, {\n    key: \"setTimeFocused\",\n    value: function setTimeFocused(timeFocused) {\n      this.setProperty('timeFocused', timeFocused);\n    }\n  }, {\n    key: \"_renderTimeFocused\",\n    value: function _renderTimeFocused() {\n      this.$container.toggleClass('time-focused', this.timeFocused);\n    }\n  }, {\n    key: \"_renderClearable\",\n    value: function _renderClearable() {\n      this._renderDateClearable();\n\n      this._renderTimeClearable();\n\n      this._updateClearableStyles();\n    }\n  }, {\n    key: \"_renderDateClearable\",\n    value: function _renderDateClearable() {\n      if (this.hasDate || this.isClearable()) {\n        if (!this.$dateClearIcon) {\n          // date clear icon\n          this.$dateClearIcon = this.$field.appendSpan('icon date-clear unfocusable').on('mousedown', this._onDateClearIconMouseDown.bind(this)); // avoid fastclick on icon. Otherwise the blur event overtakes the mousedown event.\n\n          this.$dateClearIcon.addClass('needsclick');\n        }\n      } else {\n        if (this.$dateClearIcon) {\n          // Remove clear icon\n          this.$dateClearIcon.remove();\n          this.$dateClearIcon = null;\n        }\n      }\n    }\n  }, {\n    key: \"_renderTimeClearable\",\n    value: function _renderTimeClearable() {\n      if (this.hasTime && this.isClearable() && !this.$timeClearIcon) {\n        // date clear icon\n        this.$timeClearIcon = this.$field.appendSpan('icon time-clear unfocusable').on('mousedown', this._onTimeClearIconMouseDown.bind(this)); // avoid fastclick on icon. Otherwise the blur event overtakes the mousedown event.\n\n        this.$timeClearIcon.addClass('needsclick');\n      } else if ((!this.hasTime || !this.isClearable()) && this.$timeClearIcon) {\n        // Remove $dateField\n        this.$timeClearIcon.remove();\n        this.$timeClearIcon = null;\n      }\n    }\n  }, {\n    key: \"_onTimeClearIconMouseDown\",\n    value: function _onTimeClearIconMouseDown(event) {\n      if (!this.enabledComputed) {\n        return;\n      }\n\n      this.$timeField.focus();\n      this.clear();\n\n      if (this.value) {\n        this.selectTime(this.value, false);\n      } else {\n        this.preselectTime(this._referenceDate(), false);\n      }\n\n      event.preventDefault();\n    }\n  }, {\n    key: \"_onTimeIconMouseDown\",\n    value: function _onTimeIconMouseDown(event) {\n      if (!this.enabledComputed) {\n        return;\n      }\n\n      this.$timeField.focus();\n\n      if (!this.embedded) {\n        this.openTimePopupAndSelect(this.value);\n      }\n    }\n  }, {\n    key: \"_onDateFieldBlur\",\n    value: function _onDateFieldBlur(event) {\n      this.setFocused(false);\n      this.setDateFocused(false);\n\n      if (this.embedded) {\n        // Don't execute, otherwise date would be accepted even though touch popup is still open.\n        // This prevents following behavior: user clears date by pressing x and then selects another date. Now a blur event is triggered which would call acceptDate and eventually remove the time\n        // -> Don't accept as long as touch dialog is open\n        return;\n      } // Close picker and update model\n\n\n      if (this.popup instanceof DatePickerPopup) {\n        // in embedded mode we must update the date prediction but not close the popup (don't accidentally close time picker popup)\n        this.closePopup();\n      }\n\n      this.setDateFocused(false);\n      this.acceptDate();\n\n      this._removePredictionFields();\n    }\n  }, {\n    key: \"_onDateFieldFocus\",\n    value: function _onDateFieldFocus(event) {\n      this.setFocused(true);\n      this.setDateFocused(true);\n    }\n  }, {\n    key: \"_onTimeFieldBlur\",\n    value: function _onTimeFieldBlur(event) {\n      this._tempTimeDate = null;\n      this.setFocused(false);\n      this.setTimeFocused(false);\n\n      if (this.embedded) {\n        // Don't execute, otherwise time would be accepted even though touch popup is still open.\n        // This prevents following behavior: user clears time by pressing x and then selects another time. Now a blur event is triggered which would call acceptTime and eventually remove the date\n        // -> Don't accept as long as touch dialog is open\n        return;\n      } // Close picker and update model\n\n\n      if (this.popup instanceof TimePickerPopup) {\n        // in embedded mode we must update the date prediction but not close the popup\n        this.closePopup();\n      }\n\n      this._tempTimeDate = null;\n      this.setTimeFocused(false);\n      this.acceptTime();\n\n      this._removePredictionFields();\n    }\n  }, {\n    key: \"_onTimeFieldFocus\",\n    value: function _onTimeFieldFocus() {\n      this.setFocused(true);\n      this.setTimeFocused(true);\n    }\n    /**\n     * Handle \"navigation\" keys, i.e. keys that don't emit visible characters. Character input is handled\n     * in _onDateFieldInput(), which is fired after 'keydown'.\n     */\n\n  }, {\n    key: \"_onDateFieldKeyDown\",\n    value: function _onDateFieldKeyDown(event) {\n      var delta = 0,\n          diffYears = 0,\n          diffMonths = 0,\n          diffDays = 0,\n          cursorPos = this.$dateField[0].selectionStart,\n          displayText = fields.valOrText(this.$dateField),\n          prediction = this._$predictDateField && fields.valOrText(this._$predictDateField),\n          modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),\n          pickerStartDate = this.value || this._referenceDate(),\n          shiftDate = true; // Don't propagate tab to cell editor -> tab should focus time field\n\n\n      if (this.hasTime && this.mode === FormField.Mode.CELLEDITOR && event.which === keys.TAB && modifierCount === 0) {\n        event.stopPropagation();\n        return;\n      }\n\n      if (event.which === keys.TAB || event.which === keys.SHIFT || event.which === keys.HOME || event.which === keys.END || event.which === keys.CTRL || event.which === keys.ALT) {\n        // Default handling\n        return;\n      }\n\n      if (event.which === keys.ENTER) {\n        if (this.popup || this._$predictDateField) {\n          // Close the picker and accept the current prediction (if available)\n          this.acceptDate();\n          this.closePopup();\n          $.suppressEvent(event);\n        }\n\n        return;\n      }\n\n      if (event.which === keys.ESC) {\n        if (this.popup) {\n          // Close the picker, but don't do anything else\n          this.closePopup();\n          $.suppressEvent(event);\n        }\n\n        return;\n      }\n\n      if (event.which === keys.RIGHT && cursorPos === displayText.length) {\n        // Move cursor one right and apply next char of the prediction\n        if (prediction) {\n          this._setDateDisplayText(prediction.substring(0, displayText.length + 1));\n        }\n\n        return;\n      }\n\n      if (event.which === keys.UP || event.which === keys.DOWN || event.which === keys.PAGE_UP || event.which === keys.PAGE_DOWN) {\n        if (displayText && !this._isDateValid()) {\n          // If there is an error, try to parse the date. If it may be parsed, the error was likely a validation error.\n          // In that case use the parsed date as starting point and not the for the user invisible value\n          var parsedValue = this.isolatedDateFormat.parse(displayText, pickerStartDate);\n\n          if (parsedValue) {\n            pickerStartDate = parsedValue;\n\n            this._setDateValid(true);\n          }\n        }\n      }\n\n      if (event.which === keys.PAGE_UP || event.which === keys.PAGE_DOWN) {\n        if (!displayText || !this._isDateValid()) {\n          // If input is empty or invalid, set picker to reference date\n          pickerStartDate = this._referenceDate();\n\n          if (this.hasTime) {\n            // keep time part\n            pickerStartDate = dates.combineDateTime(pickerStartDate, this.value || this._referenceDate());\n          }\n\n          this.openDatePopupAndSelect(pickerStartDate);\n\n          this._updateDisplayText(pickerStartDate);\n\n          this._setDateValid(true);\n\n          shiftDate = false; // don't shift if field has no value yet and popup was not open\n        } else if (!this.popup) {\n          // Otherwise, ensure picker is open\n          this.openDatePopupAndSelect(pickerStartDate);\n        }\n\n        if (shiftDate) {\n          diffMonths = event.which === keys.PAGE_UP ? -1 : 1;\n          this.shiftSelectedDate(0, diffMonths, 0);\n\n          this._updateDisplayText(this.getDatePicker().selectedDate);\n        }\n\n        $.suppressEvent(event);\n        return;\n      }\n\n      if (event.which === keys.UP || event.which === keys.DOWN) {\n        delta = event.which === keys.UP ? -1 : 1; // event.ctrlKey || event.metaKey  --> some keystrokes with ctrl modifier are captured and suppressed by osx, use command key instead\n\n        if ((event.ctrlKey || event.metaKey) && modifierCount === 1) {\n          // only ctrl\n          diffYears = delta;\n        } else if (event.shiftKey && modifierCount === 1) {\n          // only shift\n          diffMonths = delta;\n        } else if (modifierCount === 0) {\n          // no modifier\n          diffDays = delta;\n        } else {\n          // Unsupported modifier or too many modifiers\n          $.suppressEvent(event);\n          return;\n        }\n\n        if (!displayText || !this._isDateValid()) {\n          // If input is empty or invalid, set picker to reference date\n          pickerStartDate = this._referenceDate();\n\n          if (this.hasTime) {\n            // keep time part\n            pickerStartDate = dates.combineDateTime(pickerStartDate, this.value || this._referenceDate());\n          }\n\n          this.openDatePopupAndSelect(pickerStartDate);\n\n          this._updateDisplayText(pickerStartDate);\n\n          this._setDateValid(true);\n\n          shiftDate = false; // don't shift if field has no value yet and popup was not open\n        } else if (!this.popup) {\n          // Otherwise, ensure picker is open\n          this.openDatePopupAndSelect(pickerStartDate);\n        }\n\n        if (shiftDate) {\n          this.shiftSelectedDate(diffYears, diffMonths, diffDays);\n\n          this._updateDisplayText(this.getDatePicker().selectedDate);\n        }\n\n        $.suppressEvent(event);\n      }\n    }\n    /**\n     * Handle changed input. This method is fired when the field's content has been altered by a user\n     * action (not by JS) such as pressing a character key, deleting a character using DELETE or\n     * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.\n     * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled\n     * in _onDateFieldKeyDown().\n     */\n\n  }, {\n    key: \"_onDateFieldInput\",\n    value: function _onDateFieldInput(event) {\n      var displayText = fields.valOrText(this.$dateField); // If the focus has changed to another field in the meantime, don't predict anything and\n      // don't show the picker. Just validate the input.\n\n      if (this.$dateField[0] !== this.$dateField.activeElement(true)) {\n        return;\n      } // Create $predictDateField if necessary\n\n\n      if (!this._$predictDateField) {\n        this._$predictDateField = this._createPredictionField(this.$dateField);\n      } // Predict date\n\n\n      var datePrediction = this._predictDate(displayText); // this also updates the errorStatus\n\n\n      if (datePrediction) {\n        fields.valOrText(this._$predictDateField, datePrediction.text);\n        this.openDatePopupAndSelect(datePrediction.date);\n      } else {\n        // No valid prediction!\n        this._removePredictionFields();\n      }\n\n      this._updateDateHasText(); // Hide the prediction field if input field is scrolled to the left. Otherwise, the\n      // two fields would not be aligned correctly, which looks bad. This can only happen\n      // when the fields are rather small, so the prediction would be of limited use anyway.\n      // Unfortunately, most browsers don't fire 'scroll' events for input fields. Also,\n      // when the 'input' even is fired, the scrollLeft() position sometimes has not been\n      // updated yet, that's why we must use setTimeout() with a short delay.\n\n\n      setTimeout(function () {\n        if (this._$predictDateField) {\n          this._$predictDateField.setVisible(this.$dateField.scrollLeft() === 0);\n        }\n      }.bind(this), 50);\n    }\n  }, {\n    key: \"acceptInput\",\n    value: function acceptInput() {\n      var displayText = scout.nvl(this._readDisplayText(), '');\n\n      var inputChanged = this._checkDisplayTextChanged(displayText);\n\n      if (inputChanged) {\n        this.parseAndSetValue(displayText);\n      } else {\n        var oldValue = this.value;\n        this.parseAndSetValue(displayText);\n\n        if (!dates.equals(this.value, oldValue)) {\n          inputChanged = true;\n        }\n      }\n\n      if (inputChanged) {\n        this._triggerAcceptInput();\n      }\n    }\n    /**\n     * Clears the time field if date field is empty before accepting the input\n     */\n\n  }, {\n    key: \"acceptDate\",\n    value: function acceptDate() {\n      if (this.hasTime && !this.errorStatus && strings.empty(this.$dateField.val())) {\n        this.$timeField.val('');\n      }\n\n      this.acceptInput();\n    }\n    /**\n     * Clears the date field if time field is empty before accepting the input\n     */\n\n  }, {\n    key: \"acceptTime\",\n    value: function acceptTime() {\n      if (this.hasDate && !this.errorStatus && strings.empty(this.$timeField.val())) {\n        this.$dateField.val('');\n      }\n\n      this.acceptInput();\n    }\n  }, {\n    key: \"acceptDateTime\",\n    value: function acceptDateTime(acceptDate, acceptTime) {\n      if (acceptDate) {\n        this.acceptDate();\n      } else if (acceptTime) {\n        this.acceptTime();\n      }\n    }\n    /**\n     * Handle \"navigation\" keys, i.e. keys that don't emit visible characters. Character input is handled\n     * in _onTimeFieldInput(), which is fired after 'keydown'.\n     */\n\n  }, {\n    key: \"_onTimeFieldKeyDown\",\n    value: function _onTimeFieldKeyDown(event) {\n      var delta = 0,\n          diffHours = 0,\n          diffMinutes = 0,\n          diffSeconds = 0,\n          cursorPos = this.$timeField[0].selectionStart,\n          displayText = this.$timeField.val(),\n          prediction = this._$predictTimeField && this._$predictTimeField.val(),\n          modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),\n          pickerStartTime = this.value || this._referenceDate(),\n          shiftTime = true; // Don't propagate shift-tab to cell editor -> shift tab should focus date field\n\n\n      if (this.hasDate && this.mode === FormField.Mode.CELLEDITOR && event.which === keys.TAB && event.shiftKey && modifierCount === 1) {\n        event.stopPropagation();\n        return;\n      }\n\n      if (event.which === keys.TAB || event.which === keys.SHIFT || event.which === keys.HOME || event.which === keys.END || event.which === keys.CTRL || event.which === keys.ALT) {\n        // Default handling\n        return;\n      }\n\n      if (event.which === keys.ENTER) {\n        // Timefield is shown in touch popup, so we need to make sure time gets accepted and popup closed, even if the regular time field itself has no popup\n        if (this.popup || this._$predictDateField) {\n          // Accept the current prediction (if available)\n          this._tempTimeDate = null;\n          this.acceptTime();\n          this.closePopup();\n          $.suppressEvent(event);\n        }\n\n        return;\n      }\n\n      if (event.which === keys.ESC) {\n        if (this.popup) {\n          // Close the picker, but don't do anything else\n          this.closePopup();\n          $.suppressEvent(event);\n        }\n\n        return;\n      }\n\n      if (event.which === keys.RIGHT && cursorPos === displayText.length) {\n        // Move cursor one right and apply next char of the prediction\n        if (prediction) {\n          this._setTimeDisplayText(prediction.substring(0, displayText.length + 1));\n        }\n\n        return;\n      }\n\n      if (event.which === keys.UP || event.which === keys.DOWN) {\n        delta = event.which === keys.UP ? -1 : 1;\n\n        if (event.ctrlKey && modifierCount === 1) {\n          // only ctrl\n          diffSeconds = delta;\n        } else if (event.shiftKey && modifierCount === 1) {\n          // only shift\n          diffHours = delta;\n        } else if (modifierCount === 0) {\n          // no modifier\n          diffMinutes = delta;\n        } else {\n          // Unsupported modifier or too many modifiers\n          $.suppressEvent(event);\n          return;\n        }\n\n        if (this.hasTimePopup) {\n          if (!displayText || !this._isTimeValid()) {\n            // If input is empty or invalid, set picker to reference date\n            pickerStartTime = this._referenceDate();\n            this.openTimePopupAndSelect(pickerStartTime);\n\n            this._updateDisplayText(pickerStartTime);\n\n            this._setTimeValid(true);\n\n            shiftTime = false; // don't shift if field has no value yet and popup was not open\n          } else if (!this.popup) {\n            // Otherwise, ensure picker is open\n            this.openTimePopupAndSelect(pickerStartTime);\n          }\n\n          if (shiftTime) {\n            this.shiftSelectedTime(diffHours, diffMinutes, diffSeconds);\n\n            this._updateDisplayText(this.getTimePicker().selectedTime);\n          }\n\n          $.suppressEvent(event);\n        } else {\n          // without picker\n          if (!this._tempTimeDate) {\n            var timePrediction = this._predictTime(displayText); // this also updates the errorStatus\n\n\n            if (timePrediction && timePrediction.date) {\n              this._tempTimeDate = timePrediction.date;\n            } else {\n              this._tempTimeDate = this._referenceDate();\n              shiftTime = false;\n            }\n          }\n\n          if (shiftTime) {\n            this._tempTimeDate = dates.shiftTime(this._tempTimeDate, diffHours, diffMinutes, diffSeconds);\n          }\n\n          if (this.hasDate) {\n            // Combine _tempTimeDate with existing date part\n            this._tempTimeDate = dates.combineDateTime(this.value || this._referenceDate(), this._tempTimeDate);\n          }\n\n          this._updateDisplayText(this._tempTimeDate);\n\n          this._setTimeValid(true);\n\n          $.suppressEvent(event);\n        }\n      }\n    }\n    /**\n     * Handle changed input. This method is fired when the field's content has been altered by a user\n     * action (not by JS) such as pressing a character key, deleting a character using DELETE or\n     * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.\n     * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled\n     * in _onTimeFieldKeyDown().\n     */\n\n  }, {\n    key: \"_onTimeFieldInput\",\n    value: function _onTimeFieldInput(event) {\n      var displayText = this.$timeField.val(); // If the focus has changed to another field in the meantime, don't predict anything and\n      // don't show the picker. Just validate the input.\n\n      if (this.$timeField[0] !== this.$timeField.activeElement(true)) {\n        return;\n      } // Create $predictTimeField if necessary\n\n\n      if (!this._$predictTimeField) {\n        this._$predictTimeField = this._createPredictionField(this.$timeField);\n      } // Predict time\n\n\n      var timePrediction = this._predictTime(displayText); // this also updates the errorStatus\n\n\n      if (timePrediction) {\n        this._$predictTimeField.val(timePrediction.text);\n\n        this.openTimePopupAndSelect(timePrediction.date);\n      } else {\n        // No valid prediction!\n        this._tempTimeDate = null;\n\n        this._removePredictionFields();\n      }\n\n      this._updateTimeHasText(); // See comment for similar code in _onDateFieldInput()\n\n\n      setTimeout(function () {\n        if (this._$predictTimeField) {\n          this._$predictTimeField.setVisible(this.$timeField.scrollLeft() === 0);\n        }\n      }.bind(this), 50);\n    }\n  }, {\n    key: \"_onDatePickerDateSelect\",\n    value: function _onDatePickerDateSelect(event) {\n      this._setDateValid(true);\n\n      this._setTimeValid(true);\n\n      var newValue = this._newTimestampAsDate(event.date, this.value);\n\n      this.setValue(newValue);\n      this.closePopup();\n\n      this._triggerAcceptInput();\n    }\n  }, {\n    key: \"_onTimePickerTimeSelect\",\n    value: function _onTimePickerTimeSelect(event) {\n      this._setDateValid(true);\n\n      this._setTimeValid(true);\n\n      var newValue = this._newTimestampAsDate(this.value, event.time);\n\n      this.setValue(newValue);\n      this.closePopup();\n\n      this._triggerAcceptInput();\n    }\n  }, {\n    key: \"_createPredictionField\",\n    value: function _createPredictionField($inputField) {\n      var $predictionField = $inputField.clone().addClass('predict').attr('tabIndex', '-1').insertBefore($inputField);\n\n      if ($inputField.hasClass('has-error')) {\n        $predictionField.addClass('has-error');\n      }\n\n      return $predictionField;\n    }\n  }, {\n    key: \"_removePredictionFields\",\n    value: function _removePredictionFields() {\n      if (this._$predictDateField) {\n        this._$predictDateField.remove();\n\n        this._$predictDateField = null;\n      }\n\n      if (this._$predictTimeField) {\n        this._$predictTimeField.remove();\n\n        this._$predictTimeField = null;\n      }\n    }\n  }, {\n    key: \"_setDateDisplayText\",\n    value: function _setDateDisplayText(displayText) {\n      this.dateDisplayText = displayText;\n\n      this._updateDisplayTextProperty();\n\n      if (this.rendered) {\n        this._renderDateDisplayText();\n      }\n    }\n  }, {\n    key: \"_setTimeDisplayText\",\n    value: function _setTimeDisplayText(displayText) {\n      this.timeDisplayText = displayText;\n\n      this._updateDisplayTextProperty();\n\n      if (this.rendered) {\n        this._renderTimeDisplayText();\n      }\n    }\n  }, {\n    key: \"_computeDisplayText\",\n    value: function _computeDisplayText(dateDisplayText, timeDisplayText) {\n      var dateText = dateDisplayText || '',\n          timeText = timeDisplayText || ''; // do not use strings.join which ignores empty components\n\n      var displayText = (this.hasDate ? dateText : '') + (this.hasDate && this.hasTime ? '\\n' : '') + (this.hasTime ? timeText : ''); // empty display text should always be just an empty string\n\n      if (displayText === '\\n') {\n        displayText = '';\n      }\n\n      return displayText;\n    }\n  }, {\n    key: \"_splitDisplayText\",\n    value: function _splitDisplayText(displayText) {\n      var dateText = '',\n          timeText = '';\n\n      if (strings.hasText(displayText)) {\n        var parts = displayText.split('\\n');\n        dateText = this.hasDate ? parts[0] : '';\n        timeText = this.hasTime ? this.hasDate ? parts[1] : parts[0] : '';\n      }\n\n      return {\n        dateText: dateText,\n        timeText: timeText\n      };\n    }\n  }, {\n    key: \"_updateDisplayTextProperty\",\n    value: function _updateDisplayTextProperty() {\n      this._setProperty('displayText', this._computeDisplayText(this.dateDisplayText, this.timeDisplayText));\n    }\n    /**\n     * @override ValueField.js\n     */\n\n  }, {\n    key: \"aboutToBlurByMouseDown\",\n    value: function aboutToBlurByMouseDown(target) {\n      var dateFieldActive,\n          timeFieldActive,\n          eventOnDatePicker,\n          eventOnTimePicker,\n          eventOnDateField = this.$dateField ? this.$dateField.isOrHas(target) || this.$dateFieldIcon.isOrHas(target) || this.$dateClearIcon && this.$dateClearIcon.isOrHas(target) : false,\n          eventOnTimeField = this.$timeField ? this.$timeField.isOrHas(target) || this.$timeFieldIcon.isOrHas(target) || this.$timeClearIcon && this.$timeClearIcon.isOrHas(target) : false,\n          eventOnPopup = this.popup && this.popup.$container.isOrHas(target),\n          eventOnStatus = this.fieldStatus && this.fieldStatus.$container.isOrHas(target),\n          datePicker = this.getDatePicker(),\n          timePicker = this.getTimePicker();\n\n      if (!eventOnDateField && !eventOnTimeField && !eventOnPopup && !eventOnStatus) {\n        // event outside this field.\n        dateFieldActive = focusUtils.isActiveElement(this.$dateField);\n        timeFieldActive = focusUtils.isActiveElement(this.$timeField); // Accept only the currently focused part (the other one cannot have a pending change)\n\n        this.acceptDateTime(dateFieldActive, timeFieldActive);\n        return;\n      } // when date-field is embedded, time-prediction must be accepted before\n      // the date-picker triggers the 'dateSelect' event.\n\n\n      if (this.embedded) {\n        eventOnDatePicker = datePicker && datePicker.$container.isOrHas(target);\n        eventOnTimePicker = timePicker && timePicker.$container.isOrHas(target);\n\n        if (eventOnDatePicker && eventOnTimePicker) {\n          this.acceptTime();\n        }\n      }\n    }\n    /**\n     * Returns null if both arguments are not set. Otherwise, this.value or the current date\n     * is used as basis and the given arguments are applied to that date. The result is returned.\n     */\n\n  }, {\n    key: \"_newTimestampAsDate\",\n    value: function _newTimestampAsDate(date, time) {\n      var result = null;\n\n      if (date || time) {\n        result = this.value || this._referenceDate();\n\n        if (date) {\n          result = dates.combineDateTime(date, result);\n        }\n\n        if (time) {\n          result = dates.combineDateTime(result, time);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Returns the reference date for this date field, which is used in various places (i.e. opening the date picker, analyzing user inputs).\n     *\n     * The reference date is either (in that order):\n     * - the model's \"auto timestamp\" (as date), or\n     * - the current date/time\n     */\n\n  }, {\n    key: \"_referenceDate\",\n    value: function _referenceDate() {\n      var referenceDate = this.autoDate || dates.ceil(dates.newDate(), this.timePickerResolution);\n\n      if (this.autoDate) {\n        referenceDate = this.autoDate;\n      } else if (this.hasTime) {\n        referenceDate = dates.ceil(dates.newDate(), this.timePickerResolution);\n      } else {\n        referenceDate = dates.trunc(dates.newDate());\n      }\n\n      if (this.allowedDates) {\n        referenceDate = this._findAllowedReferenceDate(referenceDate);\n      }\n\n      return referenceDate;\n    }\n    /**\n     * Find nearest allowed date which is equals or greater than the current referenceDate.\n     */\n\n  }, {\n    key: \"_findAllowedReferenceDate\",\n    value: function _findAllowedReferenceDate(referenceDate) {\n      var i, allowedDate; // 1st: try to find a date which is equals or greater than the referenceDate (today)\n\n      for (i = 0; i < this.allowedDates.length; i++) {\n        allowedDate = this.allowedDates[i];\n\n        if (dates.compare(allowedDate, referenceDate) >= 0) {\n          return allowedDate;\n        }\n      } // 2nd: try to find an allowed date in the past\n\n\n      for (i = this.allowedDates.length - 1; i >= 0; i--) {\n        allowedDate = this.allowedDates[i];\n\n        if (dates.compare(allowedDate, referenceDate) <= 0) {\n          return allowedDate;\n        }\n      }\n\n      return referenceDate;\n    }\n  }, {\n    key: \"openDatePopup\",\n    value: function openDatePopup(date) {\n      if (this.popup) {\n        // already open\n        return;\n      }\n\n      this.popup = this.createDatePopup();\n      this.popup.open();\n      this.$dateField.addClass('focused');\n      this.popup.on('remove', function (event) {\n        this._onPopupRemove(event);\n\n        this.popup = null;\n        this.$dateField.removeClass('focused');\n      }.bind(this));\n      this.getDatePicker().on('dateSelect', this._onDatePickerDateSelect.bind(this));\n    }\n  }, {\n    key: \"closePopup\",\n    value: function closePopup() {\n      if (this.popup) {\n        this.popup.close();\n      }\n    }\n  }, {\n    key: \"toggleDatePopup\",\n    value: function toggleDatePopup() {\n      $.log.isInfoEnabled() && $.log.info('(DateField#toggleDatePopup) popupOpen=', !!this.popup);\n\n      if (this.popup) {\n        this.closePopup();\n      } else {\n        this.openDatePopupAndSelect(this.value);\n      }\n    }\n  }, {\n    key: \"openTimePopup\",\n    value: function openTimePopup(date) {\n      if (!this.hasTimePopup || this.popup) {\n        // already open\n        return;\n      }\n\n      this.popup = this.createTimePopup();\n      this.popup.open();\n      this.$timeField.addClass('focused');\n      this.popup.on('remove', function (event) {\n        this._onPopupRemove(event);\n\n        this.popup = null;\n        this.$timeField.removeClass('focused');\n      }.bind(this));\n      this.getTimePicker().on('timeSelect', this._onTimePickerTimeSelect.bind(this));\n    }\n  }, {\n    key: \"toggleTimePopup\",\n    value: function toggleTimePopup() {\n      $.log.isInfoEnabled() && $.log.info('(DateField#toggleTimePopup) popupOpen=', !!this.popup);\n\n      if (this.popup) {\n        this.closePopup();\n      } else {\n        this.openTimePopupAndSelect(this.value);\n      }\n    }\n  }, {\n    key: \"_parseValue\",\n    value: function _parseValue(displayText) {\n      var parts = this._splitDisplayText(displayText);\n\n      var dateText = parts.dateText;\n      var datePrediction = {};\n      var timeText = parts.timeText;\n      var timePrediction = {};\n      var success = true;\n\n      if (this.hasDate) {\n        datePrediction = this._predictDate(dateText); // this also updates the errorStatus\n\n        if (!datePrediction) {\n          success = false;\n        }\n\n        this._setDateDisplayText(dateText);\n      }\n\n      if (this.hasTime) {\n        timePrediction = this._predictTime(timeText); // this also updates the errorStatus\n\n        if (!timePrediction) {\n          success = false;\n        }\n\n        this._setTimeDisplayText(timeText);\n      } // Error status was already set by _predict functions, just throw it so that setValue is not called\n\n\n      if (!success) {\n        throw this.errorStatus;\n      } // parse success -> return new value\n\n\n      if (datePrediction.date || timePrediction.date) {\n        return this._newTimestampAsDate(datePrediction.date, timePrediction.date);\n      }\n\n      return null;\n    }\n    /**\n     * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'\n     */\n\n  }, {\n    key: \"_predictDate\",\n    value: function _predictDate(inputText) {\n      inputText = inputText || ''; // \"Date calculations\"\n\n      var m = inputText.match(/^([+-])(\\d*)$/);\n\n      if (m) {\n        var now = dates.newDate();\n        var daysToAdd = Number(m[1] + (m[2] || '0'));\n        now.setDate(now.getDate() + daysToAdd);\n\n        if (isNaN(now.valueOf()) || now.getDate() < 0) {\n          // Some older browsers don't set NaN but return invalid values\n          this._setDateValid(false);\n\n          return null;\n        }\n\n        this._setDateValid(true);\n\n        return {\n          date: now,\n          text: inputText\n        };\n      }\n\n      var analyzeInfo = this._analyzeInputAsDate(inputText, this.value || this._referenceDate());\n\n      if (analyzeInfo.error) {\n        this._setDateValid(false);\n\n        return null;\n      } // No predicted date? -> return empty string (may happen if inputText is empty)\n\n\n      if (!analyzeInfo.predictedDate) {\n        this._setDateValid(true);\n\n        return {\n          date: null,\n          text: ''\n        };\n      }\n\n      var predictedDate = analyzeInfo.predictedDate;\n      var predictionFormat = new DateFormat(this.isolatedDateFormat.locale, analyzeInfo.parsedPattern);\n      var predictedDateFormatted = predictionFormat.format(predictedDate, true); // If predicted date format starts with validatedText, ensure that the capitalization matches.\n      // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')\n\n      m = predictedDateFormatted.match(new RegExp('^' + strings.quote(inputText) + '(.*)$', 'i'));\n\n      if (m) {\n        predictedDateFormatted = inputText + m[1];\n      }\n\n      this._setDateValid(true);\n\n      return {\n        date: predictedDate,\n        text: predictedDateFormatted\n      };\n    }\n    /**\n     * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'\n     */\n\n  }, {\n    key: \"_predictTime\",\n    value: function _predictTime(inputText) {\n      inputText = inputText || '';\n\n      var analyzeInfo = this._analyzeInputAsTime(inputText, this.value || this._referenceDate());\n\n      if (analyzeInfo.error) {\n        this._setTimeValid(false);\n\n        return null;\n      } // No predicted date? -> return empty string (may happen if inputText is empty)\n\n\n      if (!analyzeInfo.predictedDate) {\n        this._setTimeValid(true);\n\n        return {\n          date: null,\n          text: ''\n        };\n      }\n\n      var predictedDate = analyzeInfo.predictedDate;\n      var predictionFormat = new DateFormat(this.isolatedTimeFormat.locale, analyzeInfo.parsedPattern);\n      var predictedTimeFormatted = predictionFormat.format(predictedDate, true); // If predicted date format starts with validatedText, ensure that the capitalization matches.\n      // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')\n\n      var m = predictedTimeFormatted.match(new RegExp('^' + strings.quote(inputText) + '(.*)$', 'i'));\n\n      if (m) {\n        predictedTimeFormatted = inputText + m[1];\n      }\n\n      this._setTimeValid(true);\n\n      return {\n        date: predictedDate,\n        text: predictedTimeFormatted\n      };\n    }\n  }, {\n    key: \"_analyzeInputAsDate\",\n    value: function _analyzeInputAsDate(inputText, startDate) {\n      return this.isolatedDateFormat.analyze(inputText, startDate);\n    }\n  }, {\n    key: \"_analyzeInputAsTime\",\n    value: function _analyzeInputAsTime(inputText, startDate) {\n      return this.isolatedTimeFormat.analyze(inputText, startDate);\n    }\n    /**\n     * This method updates the parts (date, time) of the error status.\n     */\n\n  }, {\n    key: \"_setErrorStatusPart\",\n    value: function _setErrorStatusPart(property, valid) {\n      if (valid) {\n        this.setErrorStatus(null);\n        return;\n      }\n\n      var errorStatus = this.errorStatus;\n\n      if (!errorStatus) {\n        errorStatus = this._createErrorStatus();\n      }\n\n      errorStatus[property] = true;\n      this.setErrorStatus(errorStatus);\n    }\n  }, {\n    key: \"_createErrorStatus\",\n    value: function _createErrorStatus() {\n      return new Status({\n        message: this.session.text('ui.InvalidDate'),\n        severity: Status.Severity.ERROR,\n        code: DateField.ErrorCode.PARSE_ERROR\n      });\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_createInvalidValueStatus\",\n    value: function _createInvalidValueStatus(value, error) {\n      var errorStatus = _get(_getPrototypeOf(DateField.prototype), \"_createInvalidValueStatus\", this).call(this, value, error); // Set date and time to invalid, otherwise isDateValid and isTimeValid return false even though there is a validation error\n\n\n      errorStatus.invalidDate = true;\n      errorStatus.invalidTime = true;\n      return errorStatus;\n    }\n  }, {\n    key: \"_setDateValid\",\n    value: function _setDateValid(valid) {\n      this._setErrorStatusPart('invalidDate', valid);\n    }\n  }, {\n    key: \"_setTimeValid\",\n    value: function _setTimeValid(valid) {\n      this._setErrorStatusPart('invalidTime', valid);\n    }\n  }, {\n    key: \"_isErrorStatusPartValid\",\n    value: function _isErrorStatusPartValid(property) {\n      if (this.errorStatus && this.errorStatus[property]) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_isDateValid\",\n    value: function _isDateValid() {\n      return this._isErrorStatusPartValid('invalidDate');\n    }\n  }, {\n    key: \"_isTimeValid\",\n    value: function _isTimeValid() {\n      return this._isErrorStatusPartValid('invalidTime');\n    }\n    /**\n     * Method invoked if being rendered within a cell-editor (mode='scout.FormField.Mode.CELLEDITOR'), and once the editor finished its rendering.\n     */\n\n  }, {\n    key: \"onCellEditorRendered\",\n    value: function onCellEditorRendered(options) {\n      if (options.openFieldPopup) {\n        if (this.hasDate && !this.hasTime) {\n          this.openDatePopupAndSelect(this.value);\n        } else if (!this.hasDate && this.hasTime) {\n          this.openTimePopupAndSelect(this.value);\n        } else if (!Device.get().supportsOnlyTouch()) {\n          // If date AND time are active, don't open popup on touch devices because the user has to choose first what he wants to edit\n          this.openDatePopupAndSelect(this.value);\n        }\n      }\n\n      if (this.touchMode) {\n        this._cellEditorPopup = options.cellEditorPopup;\n      }\n    }\n  }, {\n    key: \"_onPopupRemove\",\n    value: function _onPopupRemove(event) {\n      if (!this.touchMode || !this._cellEditorPopup) {\n        return;\n      }\n\n      if (this.hasDate && this.hasTime) {\n        // If date and time is shown, user might want to change both, let him close the cell editor when he is finished\n        return;\n      } // Close cell editor when touch popup closes\n\n\n      this._cellEditorPopup.completeEdit();\n\n      this._cellEditorPopup = null;\n    }\n    /**\n     * @override FormField.js\n     */\n\n  }, {\n    key: \"prepareForCellEdit\",\n    value: function prepareForCellEdit(opts) {\n      opts = opts || {};\n\n      _get(_getPrototypeOf(DateField.prototype), \"prepareForCellEdit\", this).call(this, opts);\n\n      this.$field.removeClass('cell-editor-field first last');\n\n      if (this.$dateField) {\n        this.addCellEditorFieldCssClasses(this.$dateField, opts);\n      }\n\n      if (this.$timeField) {\n        if (!this.$dateField) {\n          opts.cssClass = '';\n        }\n\n        this.addCellEditorFieldCssClasses(this.$timeField, opts);\n      }\n    }\n    /**\n     * @returns DatePicker instance from popup, because the property name is different\n     *    for DatePickerPopup and DatePickerTouchPopup.\n     */\n\n  }, {\n    key: \"getDatePicker\",\n    value: function getDatePicker() {\n      if (this.popup && this.popup.getDatePicker) {\n        return this.popup.getDatePicker();\n      }\n    }\n    /**\n     * Opens picker and selects date\n     *\n     * @param date\n     *          optional, Date to pass to the date picker. If no date is specified, the reference date\n     *          is preselected (not selected!).\n     */\n\n  }, {\n    key: \"openDatePopupAndSelect\",\n    value: function openDatePopupAndSelect(date) {\n      this.openDatePopup();\n\n      if (!date) {\n        this.preselectDate(this._referenceDate(), false);\n      } else {\n        this.selectDate(date, false);\n      }\n    }\n  }, {\n    key: \"preselectDate\",\n    value: function preselectDate(date, animated) {\n      var datePicker = this.getDatePicker();\n\n      if (datePicker) {\n        datePicker.preselectDate(date, animated);\n      }\n    }\n  }, {\n    key: \"selectDate\",\n    value: function selectDate(date, animated) {\n      var datePicker = this.getDatePicker();\n\n      if (datePicker) {\n        datePicker.selectDate(date, animated);\n      }\n    }\n    /**\n     * @returns DatePicker instance from popup, because the property name is different\n     *    for DatePickerPopup and DatePickerTouchPopup.\n     */\n\n  }, {\n    key: \"getTimePicker\",\n    value: function getTimePicker() {\n      if (this.popup && this.popup.getTimePicker) {\n        return this.popup.getTimePicker();\n      }\n    }\n    /**\n     * Opens picker and selects date\n     *\n     * @param date\n     *          optional, Date to pass to the date picker. If no date is specified, the reference date\n     *          is preselected (not selected!).\n     */\n\n  }, {\n    key: \"openTimePopupAndSelect\",\n    value: function openTimePopupAndSelect(time) {\n      // resolution < 1 means no picker required\n      if (!this.hasTimePopup) {\n        return;\n      }\n\n      this.openTimePopup();\n\n      if (!time) {\n        this.preselectTime(this._referenceDate());\n      } else {\n        this.selectTime(time);\n      }\n    }\n  }, {\n    key: \"preselectTime\",\n    value: function preselectTime(time) {\n      var timePicker = this.getTimePicker();\n\n      if (timePicker) {\n        timePicker.preselectTime(time);\n      }\n    }\n  }, {\n    key: \"selectTime\",\n    value: function selectTime(time) {\n      var timePicker = this.getTimePicker();\n\n      if (timePicker) {\n        timePicker.selectTime(time);\n      }\n    }\n  }, {\n    key: \"shiftSelectedDate\",\n    value: function shiftSelectedDate(years, months, days) {\n      this.openDatePopup();\n      this.getDatePicker().shiftSelectedDate(years, months, days);\n    }\n  }, {\n    key: \"shiftSelectedTime\",\n    value: function shiftSelectedTime(hourUnits, minuteUnits, secondUnits) {\n      this.openTimePopup();\n      this.getTimePicker().shiftSelectedTime(hourUnits, minuteUnits, secondUnits);\n    }\n  }, {\n    key: \"_formatValue\",\n    value: function _formatValue(value) {\n      var dateText = '',\n          timeText = '';\n\n      if (this.hasDate) {\n        if (value) {\n          dateText = this.isolatedDateFormat.format(value);\n        }\n\n        this.dateDisplayText = dateText;\n      }\n\n      if (this.hasTime) {\n        if (value) {\n          timeText = this.isolatedTimeFormat.format(value);\n        }\n\n        this.timeDisplayText = timeText;\n      }\n\n      return this._computeDisplayText(this.dateDisplayText, this.timeDisplayText);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_renderFieldStyle\",\n    value: function _renderFieldStyle() {\n      _get(_getPrototypeOf(DateField.prototype), \"_renderFieldStyle\", this).call(this);\n\n      this._renderFieldStyleInternal(this.$dateField);\n\n      this._renderFieldStyleInternal(this.$timeField);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_renderDisabledStyle\",\n    value: function _renderDisabledStyle() {\n      _get(_getPrototypeOf(DateField.prototype), \"_renderDisabledStyle\", this).call(this);\n\n      this._renderDisabledStyleInternal(this.$dateField);\n\n      this._renderDisabledStyleInternal(this.$timeField);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_triggerAcceptInput\",\n    value: function _triggerAcceptInput() {\n      var event = {\n        displayText: this.displayText,\n        errorStatus: this.errorStatus,\n        value: this.value\n      };\n      this.trigger('acceptInput', event);\n    }\n  }]);\n\n  return DateField;\n}(ValueField);\n\n_defineProperty(DateField, \"ErrorCode\", {\n  PARSE_ERROR: -1\n});\n\nexport { DateField as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/form/fields/datefield/DateField.js"],"names":["DateFormat","DatePickerPopup","dates","DateTimeCompositeLayout","Device","fields","focusUtils","FormField","HtmlComponent","InputFieldKeyStrokeContext","keys","objects","scout","Status","strings","styles","TimePickerPopup","ValueField","$","DateField","popup","autoDate","dateDisplayText","dateHasText","dateFocused","dateFormatPattern","disabledCopyOverlay","hasDate","oldDisplayText","touchMode","embedded","hasTime","hasTimePopup","timeDisplayText","timeHasText","timePickerResolution","timeFormatPattern","timeFocused","$dateField","$timeField","$dateFieldIcon","$timeFieldIcon","$dateClearIcon","$timeClearIcon","_$predictDateField","_$predictTimeField","_tempTimeDate","invalidValueMessageKey","_addCloneProperties","model","initTouch","_setAutoDate","_setDisplayText","displayText","_setAllowedDates","allowedDates","_setTimePickerResolution","value","_setDateFormatPattern","_setTimeFormatPattern","popupType","create","parent","$anchor","$field","boundToAnchor","cssClass","_errorStatusClass","closeOnAnchorMouseDown","field","dateFormat","isolatedDateFormat","timeResolution","addContainer","$parent","addLabel","addField","makeDiv","addStatus","addMandatoryIndicator","htmlDateTimeComposite","install","session","setLayout","_renderHasDate","_renderHasTime","_renderDateHasText","_renderTimeHasText","setProperty","_setProperty","initialized","_updateDisplayTextProperty","makeInputOrDiv","on","_onDateFieldMouseDown","bind","appendTo","insertBefore","_onDateFieldKeyDown","_onDateFieldInput","_onDateFieldBlur","_onDateFieldFocus","_linkWithLabel","appendIcon","_onDateIconMouseDown","addClass","remove","rendering","_renderDisplayText","_renderFieldStyle","_renderEnabled","invalidateLayoutTree","_renderDateClearable","_onTimeFieldMouseDown","insertAfter","_onTimeFieldKeyDown","_onTimeFieldInput","_onTimeFieldBlur","_onTimeFieldFocus","_onTimeIconMouseDown","_renderTimeClearable","_fieldForPlaceholder","locale","dateFormatPatternDefault","_updateDisplayText","timeFormatPatternDefault","isolatedTimeFormat","$container","setEnabled","enabledComputed","get","isInternetExplorer","closePopup","_renderDateDisplayText","_renderTimeDisplayText","_removePredictionFields","_readDateDisplayText","_readTimeDisplayText","_computeDisplayText","valOrText","_updateDateHasText","_updateTimeHasText","rendered","parts","_splitDisplayText","dateText","timeText","ensure","isNullOrUndefined","Date","text","combineDateTime","valueA","valueB","equals","Array","isArray","map","date","hasStatus","errorStatus","statusClass","removeClass","SEVERITY_CSS_CLASSES","toggleClass","legacyFont","legacyForegroundColor","legacyBackgroundColor","focus","handleOnClick","openDatePopupAndSelect","openTimePopupAndSelect","setTimeHasText","hasText","setDateHasText","_clear","acceptInput","_triggerClear","_setDateValid","_setTimeValid","event","clear","selectDate","preselectDate","_referenceDate","preventDefault","_updateClearableStyles","isClearable","appendSpan","_onDateClearIconMouseDown","_onTimeClearIconMouseDown","selectTime","preselectTime","setFocused","setDateFocused","acceptDate","setTimeFocused","acceptTime","delta","diffYears","diffMonths","diffDays","cursorPos","selectionStart","prediction","modifierCount","ctrlKey","shiftKey","altKey","metaKey","pickerStartDate","shiftDate","mode","Mode","CELLEDITOR","which","TAB","stopPropagation","SHIFT","HOME","END","CTRL","ALT","ENTER","suppressEvent","ESC","RIGHT","length","_setDateDisplayText","substring","UP","DOWN","PAGE_UP","PAGE_DOWN","_isDateValid","parsedValue","parse","shiftSelectedDate","getDatePicker","selectedDate","activeElement","_createPredictionField","datePrediction","_predictDate","setTimeout","setVisible","scrollLeft","nvl","_readDisplayText","inputChanged","_checkDisplayTextChanged","parseAndSetValue","oldValue","_triggerAcceptInput","empty","val","diffHours","diffMinutes","diffSeconds","pickerStartTime","shiftTime","_setTimeDisplayText","_isTimeValid","shiftSelectedTime","getTimePicker","selectedTime","timePrediction","_predictTime","newValue","_newTimestampAsDate","setValue","time","$inputField","$predictionField","clone","attr","hasClass","split","target","dateFieldActive","timeFieldActive","eventOnDatePicker","eventOnTimePicker","eventOnDateField","isOrHas","eventOnTimeField","eventOnPopup","eventOnStatus","fieldStatus","datePicker","timePicker","isActiveElement","acceptDateTime","result","referenceDate","ceil","newDate","trunc","_findAllowedReferenceDate","i","allowedDate","compare","createDatePopup","open","_onPopupRemove","_onDatePickerDateSelect","close","log","isInfoEnabled","info","createTimePopup","_onTimePickerTimeSelect","success","inputText","m","match","now","daysToAdd","Number","setDate","getDate","isNaN","valueOf","analyzeInfo","_analyzeInputAsDate","error","predictedDate","predictionFormat","parsedPattern","predictedDateFormatted","format","RegExp","quote","_analyzeInputAsTime","predictedTimeFormatted","startDate","analyze","property","valid","setErrorStatus","_createErrorStatus","message","severity","Severity","ERROR","code","ErrorCode","PARSE_ERROR","invalidDate","invalidTime","_setErrorStatusPart","_isErrorStatusPartValid","options","openFieldPopup","supportsOnlyTouch","_cellEditorPopup","cellEditorPopup","completeEdit","opts","addCellEditorFieldCssClasses","openDatePopup","animated","openTimePopup","years","months","days","hourUnits","minuteUnits","secondUnits","_renderFieldStyleInternal","_renderDisabledStyleInternal","trigger"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2018 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {\n  DateFormat,\n  DatePickerPopup,\n  dates,\n  DateTimeCompositeLayout,\n  Device,\n  fields,\n  focusUtils,\n  FormField,\n  HtmlComponent,\n  InputFieldKeyStrokeContext,\n  keys,\n  objects,\n  scout,\n  Status,\n  strings,\n  styles,\n  TimePickerPopup,\n  ValueField\n} from '../../../index';\nimport $ from 'jquery';\n\nexport default class DateField extends ValueField {\n\n  constructor() {\n    super();\n\n    this.popup = null;\n    this.autoDate = null;\n    this.dateDisplayText = null;\n    this.dateHasText = false;\n    this.dateFocused = false;\n    this.dateFormatPattern = null;\n    this.disabledCopyOverlay = true;\n    this.hasDate = true;\n    this.oldDisplayText = null;\n    this.touchMode = false;\n    this.embedded = false;\n\n    this.hasTime = false;\n    this.hasTimePopup = true;\n    this.timeDisplayText = null;\n    this.timeHasText = false;\n    this.timeDisplayText = null;\n    this.timePickerResolution = 30;\n    this.timeFormatPattern = null;\n    this.timeFocused = false;\n\n    this.$dateField = null;\n    this.$timeField = null;\n    this.$dateFieldIcon = null;\n    this.$timeFieldIcon = null;\n    this.$dateClearIcon = null;\n    this.$timeClearIcon = null;\n    this._$predictDateField = null;\n    this._$predictTimeField = null;\n\n    // This is the storage for the time (as date) while the focus in the field (e.g. when\n    // pressing up/down). In date fields, the date picker is used for that purposes.\n    this._tempTimeDate = null;\n    this.invalidValueMessageKey = 'ui.InvalidDate';\n    this._addCloneProperties(['hasDate', 'hasTime', 'dateFormatPattern', 'timeFormatPattern', 'allowedDates', 'autoDate']);\n  }\n\n  static ErrorCode = {\n    PARSE_ERROR: -1\n  };\n\n  /**\n   * @override Widget.js\n   */\n  _createKeyStrokeContext() {\n    return new InputFieldKeyStrokeContext();\n  }\n\n  _init(model) {\n    super._init(model);\n    fields.initTouch(this, model);\n    this.popup = model.popup;\n    this._setAutoDate(this.autoDate);\n    this._setDisplayText(this.displayText);\n    this._setAllowedDates(this.allowedDates);\n    this._setTimePickerResolution(this.timePickerResolution);\n  }\n\n  /**\n   * Initializes the date format before calling set value.\n   * This cannot be done in _init because the value field would call _setValue first\n   */\n  _initValue(value) {\n    this._setDateFormatPattern(this.dateFormatPattern);\n    this._setTimeFormatPattern(this.timeFormatPattern);\n    super._initValue(value);\n  }\n\n  createDatePopup() {\n    var popupType = this.touchMode ? 'DatePickerTouchPopup' : 'DatePickerPopup';\n    return scout.create(popupType, {\n      parent: this,\n      $anchor: this.$field,\n      boundToAnchor: !this.touchMode,\n      cssClass: this._errorStatusClass(),\n      closeOnAnchorMouseDown: false,\n      field: this,\n      allowedDates: this.allowedDates,\n      dateFormat: this.isolatedDateFormat,\n      displayText: this.dateDisplayText\n    });\n  }\n\n  createTimePopup() {\n    var popupType = this.touchMode ? 'TimePickerTouchPopup' : 'TimePickerPopup';\n    return scout.create(popupType, {\n      parent: this,\n      $anchor: this.$timeField,\n      boundToAnchor: !this.touchMode,\n      cssClass: this._errorStatusClass(),\n      closeOnAnchorMouseDown: false,\n      field: this,\n      timeResolution: this.timePickerResolution\n    });\n  }\n\n  _render() {\n    this.addContainer(this.$parent, 'date-field');\n    this.addLabel();\n    this.addField(this.$parent.makeDiv('date-time-composite'));\n    this.addStatus(this.$field);\n    if (!this.embedded) {\n      this.addMandatoryIndicator();\n    }\n\n    this.htmlDateTimeComposite = HtmlComponent.install(this.$field, this.session);\n    this.htmlDateTimeComposite.setLayout(new DateTimeCompositeLayout(this));\n  }\n\n  _renderProperties() {\n    this._renderHasDate();\n    this._renderHasTime();\n\n    // Has to be the last call, otherwise _renderErrorStatus() would operate on the wrong state.\n    super._renderProperties();\n\n    this._renderDateHasText();\n    this._renderTimeHasText();\n  }\n\n  _remove() {\n    super._remove();\n    this.$dateField = null;\n    this.$timeField = null;\n    this.$dateFieldIcon = null;\n    this.$timeFieldIcon = null;\n    this.$dateClearIcon = null;\n    this.$timeClearIcon = null;\n    this._$predictDateField = null;\n    this._$predictTimeField = null;\n    this.popup = null;\n  }\n\n  setHasDate(hasDate) {\n    this.setProperty('hasDate', hasDate);\n  }\n\n  _setHasDate(hasDate) {\n    this._setProperty('hasDate', hasDate);\n    if (this.initialized) {\n      // if property changes on the fly, update the display text\n      this._updateDisplayTextProperty();\n    }\n  }\n\n  _renderHasDate() {\n    if (this.hasDate && !this.$dateField) {\n      // Add $dateField\n      this.$dateField = fields.makeInputOrDiv(this, 'date')\n        .on('mousedown', this._onDateFieldMouseDown.bind(this))\n        .appendTo(this.$field);\n      if (this.$timeField) {\n        // make sure date field comes before time field, otherwise tab won't work as expected\n        this.$dateField.insertBefore(this.$timeField);\n      }\n      if (!this.touchMode) {\n        this.$dateField\n          .on('keydown', this._onDateFieldKeyDown.bind(this))\n          .on('input', this._onDateFieldInput.bind(this))\n          .on('blur', this._onDateFieldBlur.bind(this))\n          .on('focus', this._onDateFieldFocus.bind(this));\n      }\n      this._linkWithLabel(this.$dateField);\n      HtmlComponent.install(this.$dateField, this.session);\n\n      this.$dateFieldIcon = fields.appendIcon(this.$field, 'date')\n        .on('mousedown', this._onDateIconMouseDown.bind(this));\n      // avoid fastclick on icon. Otherwise the blur event overtakes the mousedown event.\n      this.$dateFieldIcon.addClass('needsclick');\n\n    } else if (!this.hasDate && this.$dateField) {\n      // Remove $dateField\n      this.$dateField.remove();\n      this.$dateField = null;\n      this.$dateFieldIcon.remove();\n      this.$dateFieldIcon = null;\n    }\n\n    if (!this.rendering) {\n      this._renderDisplayText();\n      this._renderFieldStyle();\n      this._renderEnabled();\n      this.htmlDateTimeComposite.invalidateLayoutTree();\n    }\n    this._renderDateClearable();\n  }\n\n  setHasTime(hasTime) {\n    this.setProperty('hasTime', hasTime);\n  }\n\n  _setHasTime(hasTime) {\n    this._setProperty('hasTime', hasTime);\n    if (this.initialized) {\n      // if property changes on the fly, update the display text\n      this._updateDisplayTextProperty();\n    }\n  }\n\n  _renderHasTime() {\n    if (this.hasTime && !this.$timeField) {\n      // Add $timeField\n      this.$timeField = fields.makeInputOrDiv(this, 'time')\n        .on('mousedown', this._onTimeFieldMouseDown.bind(this))\n        .appendTo(this.$field);\n      if (this.$dateField) {\n        // make sure time field comes after date field, otherwise tab won't work as expected\n        this.$timeField.insertAfter(this.$dateField);\n      }\n      if (!this.touchMode || !this.hasTimePopup) {\n        this.$timeField\n          .on('keydown', this._onTimeFieldKeyDown.bind(this))\n          .on('input', this._onTimeFieldInput.bind(this))\n          .on('blur', this._onTimeFieldBlur.bind(this))\n          .on('focus', this._onTimeFieldFocus.bind(this));\n      }\n      this._linkWithLabel(this.$timeField);\n      HtmlComponent.install(this.$timeField, this.session);\n\n      this.$timeFieldIcon = fields.appendIcon(this.$field, 'time')\n        .on('mousedown', this._onTimeIconMouseDown.bind(this));\n      // avoid fastclick on icon. Otherwise the blur event overtakes the mousedown event.\n      this.$timeFieldIcon.addClass('needsclick');\n\n    } else if (!this.hasTime && this.$timeField) {\n      // Remove $timeField\n      this.$timeField.remove();\n      this.$timeField = null;\n      this.$timeFieldIcon.remove();\n      this.$timeFieldIcon = null;\n    }\n\n    if (!this.rendering) {\n      this._renderDisplayText();\n      this._renderFieldStyle();\n      this._renderEnabled();\n      this.htmlDateTimeComposite.invalidateLayoutTree();\n    }\n    this._renderTimeClearable();\n  }\n\n  setTimePickerResolution(timePickerResolution) {\n    this.setProperty('timePickerResolution', timePickerResolution);\n  }\n\n  _setTimePickerResolution(timePickerResolution) {\n    if (timePickerResolution < 1) {\n      // default\n      timePickerResolution = 10;\n      this.hasTimePopup = false;\n    } else {\n      this.hasTimePopup = true;\n    }\n    this._setProperty('timePickerResolution', timePickerResolution);\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderPlaceholder($field) {\n    super._renderPlaceholder(\n      this._fieldForPlaceholder());\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _removePlaceholder($field) {\n    super._removePlaceholder(\n      this._fieldForPlaceholder());\n  }\n\n  _fieldForPlaceholder() {\n    if (this.hasDate) {\n      return this.$dateField;\n    } else if (this.hasTime) {\n      return this.$timeField;\n    }\n    return null;\n  }\n\n  setDateFormatPattern(dateFormatPattern) {\n    this.setProperty('dateFormatPattern', dateFormatPattern);\n  }\n\n  _setDateFormatPattern(dateFormatPattern) {\n    if (!dateFormatPattern) {\n      dateFormatPattern = this.session.locale.dateFormatPatternDefault;\n    }\n    this._setProperty('dateFormatPattern', dateFormatPattern);\n    this.isolatedDateFormat = new DateFormat(this.session.locale, this.dateFormatPattern);\n\n    if (this.initialized) {\n      // if format changes on the fly, just update the display text\n      this._updateDisplayText();\n    }\n  }\n\n  setTimeFormatPattern(timeFormatPattern) {\n    this.setProperty('timeFormatPattern', timeFormatPattern);\n  }\n\n  _setTimeFormatPattern(timeFormatPattern) {\n    if (!timeFormatPattern) {\n      timeFormatPattern = this.session.locale.timeFormatPatternDefault;\n    }\n    this._setProperty('timeFormatPattern', timeFormatPattern);\n    this.isolatedTimeFormat = new DateFormat(this.session.locale, this.timeFormatPattern);\n\n    if (this.initialized) {\n      // if format changes on the fly, just update the display text\n      this._updateDisplayText();\n    }\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderEnabled() {\n    super._renderEnabled();\n    this.$container.setEnabled(this.enabledComputed);\n    if (this.$dateField) {\n      this.$dateField.setEnabled(this.enabledComputed);\n    }\n    if (this.$timeField) {\n      this.$timeField.setEnabled(this.enabledComputed);\n    }\n    // Workaround for IE11 issue: other than all other browsers IE11 doesn't trigger a blur event when the field is disabled.\n    // In cases where the field is disabled asynchronously, the popup would stay opened by error #240929.\n    if (Device.get().isInternetExplorer() && !this.enabledComputed) {\n      this.closePopup();\n    }\n  }\n\n  /**\n   * @override ValueField.js\n   */\n  _renderDisplayText() {\n    if (this.hasDate) {\n      this._renderDateDisplayText();\n    }\n    if (this.hasTime) {\n      this._renderTimeDisplayText();\n    }\n    this._removePredictionFields();\n  }\n\n  _readDisplayText() {\n    var dateDisplayText, timeDisplayText;\n    if (this.hasDate) {\n      dateDisplayText = this._readDateDisplayText();\n    }\n    if (this.hasTime) {\n      timeDisplayText = this._readTimeDisplayText();\n    }\n    return this._computeDisplayText(dateDisplayText, timeDisplayText);\n  }\n\n  _renderDateDisplayText() {\n    fields.valOrText(this.$dateField, this.dateDisplayText);\n    this._updateDateHasText();\n  }\n\n  _readDateDisplayText() {\n    return (this._$predictDateField ? fields.valOrText(this._$predictDateField) : fields.valOrText(this.$dateField));\n  }\n\n  _renderTimeDisplayText() {\n    fields.valOrText(this.$timeField, this.timeDisplayText);\n    this._updateTimeHasText();\n  }\n\n  _readTimeDisplayText() {\n    return (this._$predictTimeField ? fields.valOrText(this._$predictTimeField) : fields.valOrText(this.$timeField));\n  }\n\n  /**\n   * @override\n   */\n  setDisplayText(displayText) {\n    // Overridden to avoid the equals check -> make sure renderDisplayText is executed whenever setDisplayText is called\n    // Reason: key up/down and picker day click modify the display text, but input doesn't\n    // -> reverting to a date using day click or up down after the input changed would not work anymore\n    // changing 'onXyInput' to always update the display text would fix that, but would break acceptInput\n    this._setDisplayText(displayText);\n    if (this.rendered) {\n      this._renderDisplayText();\n    }\n  }\n\n  _setDisplayText(displayText) {\n    this.oldDisplayText = this.displayText;\n    this._setProperty('displayText', displayText);\n\n    var parts = this._splitDisplayText(displayText);\n    if (this.hasDate) {\n      // preserve dateDisplayText if hasDate is set to false (only override if it is true)\n      this.dateDisplayText = parts.dateText;\n    }\n    if (this.hasTime) {\n      // preserve timeDisplayText if hasTime is set to false (only override if it is true)\n      this.timeDisplayText = parts.timeText;\n    }\n  }\n\n  /**\n   * @override\n   */\n  _ensureValue(value) {\n    return dates.ensure(value);\n  }\n\n  /**\n   * @param {Date} value the date to validate\n   * @return {Date} the validated date\n   * @override\n   */\n  _validateValue(value) {\n    if (objects.isNullOrUndefined(value)) {\n      return value;\n    }\n    if (!(value instanceof Date)) {\n      throw this.session.text(this.invalidValueMessageKey);\n    }\n    if (!this.hasDate && !this.value) {\n      // truncate to 01.01.1970 if no date was entered before. Otherwise preserve date part (important for toggling hasDate on the fly)\n      value = dates.combineDateTime(null, value);\n    }\n    return value;\n  }\n\n  _valueEquals(valueA, valueB) {\n    return dates.equals(valueA, valueB);\n  }\n\n  setAutoDate(autoDate) {\n    this.setProperty('autoDate', autoDate);\n  }\n\n  _setAutoDate(autoDate) {\n    autoDate = dates.ensure(autoDate);\n    this._setProperty('autoDate', autoDate);\n  }\n\n  _setAllowedDates(allowedDates) {\n    if (Array.isArray(allowedDates)) {\n      allowedDates = allowedDates.map(function(date) {\n        return dates.ensure(date);\n      });\n      this._setProperty('allowedDates', allowedDates);\n    } else {\n      this._setProperty('allowedDates', null);\n    }\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderErrorStatus() {\n    super._renderErrorStatus();\n    var hasStatus = !!this.errorStatus,\n      statusClass = this._errorStatusClass();\n\n    if (this.$dateField) {\n      this.$dateField.removeClass(FormField.SEVERITY_CSS_CLASSES);\n      this.$dateField.toggleClass(statusClass, hasStatus);\n\n      // Because the error color of field icons depends on the error status of sibling <input> elements.\n      // The prediction fields are clones of the input fields, so the 'has-error' class has to be\n      // removed from them as well to make the icon \"valid\".\n      if (this._$predictDateField) {\n        this._$predictDateField.removeClass(FormField.SEVERITY_CSS_CLASSES);\n        this._$predictDateField.toggleClass(statusClass, hasStatus);\n      }\n    }\n\n    // Do the same for the time field\n    if (this.$timeField) {\n      this.$timeField.removeClass(FormField.SEVERITY_CSS_CLASSES);\n      this.$timeField.toggleClass(statusClass, hasStatus);\n      if (this._$predictTimeField) {\n        this._$predictTimeField.removeClass(FormField.SEVERITY_CSS_CLASSES);\n        this._$predictTimeField.toggleClass(statusClass, hasStatus);\n      }\n    }\n\n    if (this.popup) {\n      this.popup.$container.removeClass(FormField.SEVERITY_CSS_CLASSES);\n      this.popup.$container.toggleClass(statusClass, hasStatus);\n    }\n  }\n\n  _errorStatusClass() {\n    return this.errorStatus ? 'has-' + this.errorStatus.cssClass() : '';\n  }\n\n  /**\n   * @Override FormField.js\n   */\n  _renderFont() {\n    this.$dateField && styles.legacyFont(this, this.$dateField);\n    this.$timeField && styles.legacyFont(this, this.$timeField);\n  }\n\n  /**\n   * @Override FormField.js\n   */\n  _renderForegroundColor() {\n    this.$dateField && styles.legacyForegroundColor(this, this.$dateField);\n    this.$timeField && styles.legacyForegroundColor(this, this.$timeField);\n  }\n\n  /**\n   * @override FormField.js\n   */\n  _renderBackgroundColor() {\n    this.$dateField && styles.legacyBackgroundColor(this, this.$dateField);\n    this.$timeField && styles.legacyBackgroundColor(this, this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  activate() {\n    if (!this.enabledComputed || !this.rendered) {\n      return;\n    }\n    if (this.$dateField) {\n      this.$dateField.focus();\n      this._onDateFieldMouseDown();\n    } else if (this.$timeField) {\n      this.$timeField.focus();\n      this._onTimeFieldMouseDown();\n    }\n  }\n\n  /**\n   * @override\n   */\n  getFocusableElement() {\n    if (this.$dateField) {\n      return this.$dateField;\n    }\n    if (this.$timeField) {\n      return this.$timeField;\n    }\n    return null;\n  }\n\n  _onDateFieldMouseDown() {\n    if (fields.handleOnClick(this)) {\n      this.openDatePopupAndSelect(this.value);\n    }\n  }\n\n  _onTimeFieldMouseDown() {\n    if (fields.handleOnClick(this)) {\n      this.openTimePopupAndSelect(this.value);\n    }\n  }\n\n  setDateFocused(dateFocused) {\n    this.setProperty('dateFocused', dateFocused);\n  }\n\n  _renderDateFocused() {\n    this.$container.toggleClass('date-focused', this.dateFocused);\n  }\n\n  _updateTimeHasText() {\n    this.setTimeHasText(strings.hasText(this._readTimeDisplayText()));\n  }\n\n  setTimeHasText(timeHasText) {\n    this.setProperty('timeHasText', timeHasText);\n  }\n\n  _renderTimeHasText() {\n    if (this.$timeField) {\n      this.$timeField.toggleClass('has-text', this.timeHasText);\n    }\n    this.$container.toggleClass('time-has-text', this.timeHasText);\n  }\n\n  _updateDateHasText() {\n    this.setDateHasText(strings.hasText(this._readDateDisplayText()));\n  }\n\n  setDateHasText(dateHasText) {\n    this.setProperty('dateHasText', dateHasText);\n  }\n\n  _renderDateHasText() {\n    if (this.$dateField) {\n      this.$dateField.toggleClass('has-text', this.dateHasText);\n    }\n    this.$container.toggleClass('date-has-text', this.dateHasText);\n  }\n\n  /**\n   * @override\n   */\n  clear() {\n    if (!(this.hasDate && this.hasTime)) {\n      super.clear();\n      return;\n    }\n    this._clear();\n    // If field shows date and time, don't accept input while one field has the focus\n    // Reason: x icon is shown in one field, pressing that icon should clear the content of that field.\n    // Accept input would set the value to '', thus clearing both fields which may be unexpected.\n    if (!this.dateFocused && !this.timeFocused) {\n      this.acceptInput();\n    }\n    this._triggerClear();\n  }\n\n  _clear() {\n    this._removePredictionFields();\n    if (this.hasDate && !this.timeFocused) {\n      fields.valOrText(this.$dateField, '');\n      this._setDateValid(true);\n      this._updateDateHasText();\n    }\n    if (this.hasTime && !this.dateFocused) {\n      fields.valOrText(this.$timeField, '');\n      this._setTimeValid(true);\n      this._updateTimeHasText();\n    }\n  }\n\n  _onDateClearIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$dateField.focus();\n    this.clear();\n    if (this.value) {\n      this.selectDate(this.value, false);\n    } else {\n      this.preselectDate(this._referenceDate(), false);\n    }\n    event.preventDefault();\n  }\n\n  _onDateIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$dateField.focus();\n    if (!this.embedded) {\n      this.openDatePopupAndSelect(this.value);\n    }\n  }\n\n  setTimeFocused(timeFocused) {\n    this.setProperty('timeFocused', timeFocused);\n  }\n\n  _renderTimeFocused() {\n    this.$container.toggleClass('time-focused', this.timeFocused);\n  }\n\n  _renderClearable() {\n    this._renderDateClearable();\n    this._renderTimeClearable();\n    this._updateClearableStyles();\n  }\n\n  _renderDateClearable() {\n    if (this.hasDate || this.isClearable()) {\n      if (!this.$dateClearIcon) {\n        // date clear icon\n        this.$dateClearIcon = this.$field.appendSpan('icon date-clear unfocusable')\n          .on('mousedown', this._onDateClearIconMouseDown.bind(this));\n        // avoid fastclick on icon. Otherwise the blur event overtakes the mousedown event.\n        this.$dateClearIcon.addClass('needsclick');\n      }\n    } else {\n      if (this.$dateClearIcon) {\n        // Remove clear icon\n        this.$dateClearIcon.remove();\n        this.$dateClearIcon = null;\n      }\n    }\n  }\n\n  _renderTimeClearable() {\n    if (this.hasTime && this.isClearable() && !this.$timeClearIcon) {\n      // date clear icon\n      this.$timeClearIcon = this.$field.appendSpan('icon time-clear unfocusable')\n        .on('mousedown', this._onTimeClearIconMouseDown.bind(this));\n      // avoid fastclick on icon. Otherwise the blur event overtakes the mousedown event.\n      this.$timeClearIcon.addClass('needsclick');\n    } else if ((!this.hasTime || !this.isClearable()) && this.$timeClearIcon) {\n      // Remove $dateField\n      this.$timeClearIcon.remove();\n      this.$timeClearIcon = null;\n    }\n  }\n\n  _onTimeClearIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$timeField.focus();\n    this.clear();\n    if (this.value) {\n      this.selectTime(this.value, false);\n    } else {\n      this.preselectTime(this._referenceDate(), false);\n    }\n    event.preventDefault();\n  }\n\n  _onTimeIconMouseDown(event) {\n    if (!this.enabledComputed) {\n      return;\n    }\n    this.$timeField.focus();\n    if (!this.embedded) {\n      this.openTimePopupAndSelect(this.value);\n    }\n  }\n\n  _onDateFieldBlur(event) {\n    this.setFocused(false);\n    this.setDateFocused(false);\n    if (this.embedded) {\n      // Don't execute, otherwise date would be accepted even though touch popup is still open.\n      // This prevents following behavior: user clears date by pressing x and then selects another date. Now a blur event is triggered which would call acceptDate and eventually remove the time\n      // -> Don't accept as long as touch dialog is open\n      return;\n    }\n\n    // Close picker and update model\n    if (this.popup instanceof DatePickerPopup) {\n      // in embedded mode we must update the date prediction but not close the popup (don't accidentally close time picker popup)\n      this.closePopup();\n    }\n    this.setDateFocused(false);\n    this.acceptDate();\n    this._removePredictionFields();\n  }\n\n  _onDateFieldFocus(event) {\n    this.setFocused(true);\n    this.setDateFocused(true);\n  }\n\n  _onTimeFieldBlur(event) {\n    this._tempTimeDate = null;\n    this.setFocused(false);\n    this.setTimeFocused(false);\n    if (this.embedded) {\n      // Don't execute, otherwise time would be accepted even though touch popup is still open.\n      // This prevents following behavior: user clears time by pressing x and then selects another time. Now a blur event is triggered which would call acceptTime and eventually remove the date\n      // -> Don't accept as long as touch dialog is open\n      return;\n    }\n\n    // Close picker and update model\n    if (this.popup instanceof TimePickerPopup) {\n      // in embedded mode we must update the date prediction but not close the popup\n      this.closePopup();\n    }\n    this._tempTimeDate = null;\n    this.setTimeFocused(false);\n    this.acceptTime();\n    this._removePredictionFields();\n  }\n\n  _onTimeFieldFocus() {\n    this.setFocused(true);\n    this.setTimeFocused(true);\n  }\n\n  /**\n   * Handle \"navigation\" keys, i.e. keys that don't emit visible characters. Character input is handled\n   * in _onDateFieldInput(), which is fired after 'keydown'.\n   */\n  _onDateFieldKeyDown(event) {\n    var delta = 0,\n      diffYears = 0,\n      diffMonths = 0,\n      diffDays = 0,\n      cursorPos = this.$dateField[0].selectionStart,\n      displayText = fields.valOrText(this.$dateField),\n      prediction = this._$predictDateField && fields.valOrText(this._$predictDateField),\n      modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),\n      pickerStartDate = this.value || this._referenceDate(),\n      shiftDate = true;\n\n    // Don't propagate tab to cell editor -> tab should focus time field\n    if (this.hasTime &&\n      this.mode === FormField.Mode.CELLEDITOR &&\n      event.which === keys.TAB &&\n      modifierCount === 0) {\n      event.stopPropagation();\n      return;\n    }\n\n    if (event.which === keys.TAB ||\n      event.which === keys.SHIFT ||\n      event.which === keys.HOME ||\n      event.which === keys.END ||\n      event.which === keys.CTRL ||\n      event.which === keys.ALT) {\n      // Default handling\n      return;\n    }\n\n    if (event.which === keys.ENTER) {\n      if (this.popup || this._$predictDateField) {\n        // Close the picker and accept the current prediction (if available)\n        this.acceptDate();\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n\n    if (event.which === keys.ESC) {\n      if (this.popup) {\n        // Close the picker, but don't do anything else\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n\n    if (event.which === keys.RIGHT && cursorPos === displayText.length) {\n      // Move cursor one right and apply next char of the prediction\n      if (prediction) {\n        this._setDateDisplayText(prediction.substring(0, displayText.length + 1));\n      }\n      return;\n    }\n\n    if (event.which === keys.UP || event.which === keys.DOWN ||\n      event.which === keys.PAGE_UP || event.which === keys.PAGE_DOWN) {\n      if (displayText && !this._isDateValid()) {\n        // If there is an error, try to parse the date. If it may be parsed, the error was likely a validation error.\n        // In that case use the parsed date as starting point and not the for the user invisible value\n        var parsedValue = this.isolatedDateFormat.parse(displayText, pickerStartDate);\n        if (parsedValue) {\n          pickerStartDate = parsedValue;\n          this._setDateValid(true);\n        }\n      }\n    }\n    if (event.which === keys.PAGE_UP || event.which === keys.PAGE_DOWN) {\n      if (!displayText || !this._isDateValid()) {\n        // If input is empty or invalid, set picker to reference date\n        pickerStartDate = this._referenceDate();\n        if (this.hasTime) { // keep time part\n          pickerStartDate = dates.combineDateTime(pickerStartDate, this.value || this._referenceDate());\n        }\n        this.openDatePopupAndSelect(pickerStartDate);\n        this._updateDisplayText(pickerStartDate);\n        this._setDateValid(true);\n        shiftDate = false; // don't shift if field has no value yet and popup was not open\n      } else if (!this.popup) {\n        // Otherwise, ensure picker is open\n        this.openDatePopupAndSelect(pickerStartDate);\n      }\n      if (shiftDate) {\n        diffMonths = (event.which === keys.PAGE_UP ? -1 : 1);\n        this.shiftSelectedDate(0, diffMonths, 0);\n        this._updateDisplayText(this.getDatePicker().selectedDate);\n      }\n      $.suppressEvent(event);\n      return;\n    }\n\n    if (event.which === keys.UP || event.which === keys.DOWN) {\n      delta = (event.which === keys.UP ? -1 : 1);\n      // event.ctrlKey || event.metaKey  --> some keystrokes with ctrl modifier are captured and suppressed by osx, use command key instead\n      if ((event.ctrlKey || event.metaKey) && modifierCount === 1) { // only ctrl\n        diffYears = delta;\n      } else if (event.shiftKey && modifierCount === 1) { // only shift\n        diffMonths = delta;\n      } else if (modifierCount === 0) { // no modifier\n        diffDays = delta;\n      } else {\n        // Unsupported modifier or too many modifiers\n        $.suppressEvent(event);\n        return;\n      }\n\n      if (!displayText || !this._isDateValid()) {\n        // If input is empty or invalid, set picker to reference date\n        pickerStartDate = this._referenceDate();\n        if (this.hasTime) { // keep time part\n          pickerStartDate = dates.combineDateTime(pickerStartDate, this.value || this._referenceDate());\n        }\n        this.openDatePopupAndSelect(pickerStartDate);\n        this._updateDisplayText(pickerStartDate);\n        this._setDateValid(true);\n        shiftDate = false; // don't shift if field has no value yet and popup was not open\n      } else if (!this.popup) {\n        // Otherwise, ensure picker is open\n        this.openDatePopupAndSelect(pickerStartDate);\n      }\n      if (shiftDate) {\n        this.shiftSelectedDate(diffYears, diffMonths, diffDays);\n        this._updateDisplayText(this.getDatePicker().selectedDate);\n      }\n      $.suppressEvent(event);\n    }\n  }\n\n  /**\n   * Handle changed input. This method is fired when the field's content has been altered by a user\n   * action (not by JS) such as pressing a character key, deleting a character using DELETE or\n   * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.\n   * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled\n   * in _onDateFieldKeyDown().\n   */\n  _onDateFieldInput(event) {\n    var displayText = fields.valOrText(this.$dateField);\n\n    // If the focus has changed to another field in the meantime, don't predict anything and\n    // don't show the picker. Just validate the input.\n    if (this.$dateField[0] !== this.$dateField.activeElement(true)) {\n      return;\n    }\n\n    // Create $predictDateField if necessary\n    if (!this._$predictDateField) {\n      this._$predictDateField = this._createPredictionField(this.$dateField);\n    }\n\n    // Predict date\n    var datePrediction = this._predictDate(displayText); // this also updates the errorStatus\n    if (datePrediction) {\n      fields.valOrText(this._$predictDateField, datePrediction.text);\n      this.openDatePopupAndSelect(datePrediction.date);\n    } else {\n      // No valid prediction!\n      this._removePredictionFields();\n    }\n    this._updateDateHasText();\n\n    // Hide the prediction field if input field is scrolled to the left. Otherwise, the\n    // two fields would not be aligned correctly, which looks bad. This can only happen\n    // when the fields are rather small, so the prediction would be of limited use anyway.\n    // Unfortunately, most browsers don't fire 'scroll' events for input fields. Also,\n    // when the 'input' even is fired, the scrollLeft() position sometimes has not been\n    // updated yet, that's why we must use setTimeout() with a short delay.\n    setTimeout(function() {\n      if (this._$predictDateField) {\n        this._$predictDateField.setVisible(this.$dateField.scrollLeft() === 0);\n      }\n    }.bind(this), 50);\n  }\n\n  acceptInput() {\n    var displayText = scout.nvl(this._readDisplayText(), '');\n\n    var inputChanged = this._checkDisplayTextChanged(displayText);\n    if (inputChanged) {\n      this.parseAndSetValue(displayText);\n    } else {\n      var oldValue = this.value;\n      this.parseAndSetValue(displayText);\n      if (!dates.equals(this.value, oldValue)) {\n        inputChanged = true;\n      }\n    }\n    if (inputChanged) {\n      this._triggerAcceptInput();\n    }\n  }\n\n  /**\n   * Clears the time field if date field is empty before accepting the input\n   */\n  acceptDate() {\n    if (this.hasTime && !this.errorStatus && strings.empty(this.$dateField.val())) {\n      this.$timeField.val('');\n    }\n    this.acceptInput();\n  }\n\n  /**\n   * Clears the date field if time field is empty before accepting the input\n   */\n  acceptTime() {\n    if (this.hasDate && !this.errorStatus && strings.empty(this.$timeField.val())) {\n      this.$dateField.val('');\n    }\n    this.acceptInput();\n  }\n\n  acceptDateTime(acceptDate, acceptTime) {\n    if (acceptDate) {\n      this.acceptDate();\n    } else if (acceptTime) {\n      this.acceptTime();\n    }\n  }\n\n  /**\n   * Handle \"navigation\" keys, i.e. keys that don't emit visible characters. Character input is handled\n   * in _onTimeFieldInput(), which is fired after 'keydown'.\n   */\n  _onTimeFieldKeyDown(event) {\n    var delta = 0,\n      diffHours = 0,\n      diffMinutes = 0,\n      diffSeconds = 0,\n      cursorPos = this.$timeField[0].selectionStart,\n      displayText = this.$timeField.val(),\n      prediction = this._$predictTimeField && this._$predictTimeField.val(),\n      modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),\n      pickerStartTime = this.value || this._referenceDate(),\n      shiftTime = true;\n\n    // Don't propagate shift-tab to cell editor -> shift tab should focus date field\n    if (this.hasDate &&\n      this.mode === FormField.Mode.CELLEDITOR &&\n      event.which === keys.TAB &&\n      event.shiftKey &&\n      modifierCount === 1) {\n      event.stopPropagation();\n      return;\n    }\n\n    if (event.which === keys.TAB ||\n      event.which === keys.SHIFT ||\n      event.which === keys.HOME ||\n      event.which === keys.END ||\n      event.which === keys.CTRL ||\n      event.which === keys.ALT) {\n      // Default handling\n      return;\n    }\n\n    if (event.which === keys.ENTER) {\n      // Timefield is shown in touch popup, so we need to make sure time gets accepted and popup closed, even if the regular time field itself has no popup\n      if (this.popup || this._$predictDateField) {\n        // Accept the current prediction (if available)\n        this._tempTimeDate = null;\n        this.acceptTime();\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n\n    if (event.which === keys.ESC) {\n      if (this.popup) {\n        // Close the picker, but don't do anything else\n        this.closePopup();\n        $.suppressEvent(event);\n      }\n      return;\n    }\n\n    if (event.which === keys.RIGHT && cursorPos === displayText.length) {\n      // Move cursor one right and apply next char of the prediction\n      if (prediction) {\n        this._setTimeDisplayText(prediction.substring(0, displayText.length + 1));\n      }\n      return;\n    }\n\n    if (event.which === keys.UP || event.which === keys.DOWN) {\n      delta = (event.which === keys.UP ? -1 : 1);\n      if (event.ctrlKey && modifierCount === 1) { // only ctrl\n        diffSeconds = delta;\n      } else if (event.shiftKey && modifierCount === 1) { // only shift\n        diffHours = delta;\n      } else if (modifierCount === 0) { // no modifier\n        diffMinutes = delta;\n      } else {\n        // Unsupported modifier or too many modifiers\n        $.suppressEvent(event);\n        return;\n      }\n\n      if (this.hasTimePopup) {\n        if (!displayText || !this._isTimeValid()) {\n          // If input is empty or invalid, set picker to reference date\n          pickerStartTime = this._referenceDate();\n          this.openTimePopupAndSelect(pickerStartTime);\n          this._updateDisplayText(pickerStartTime);\n          this._setTimeValid(true);\n          shiftTime = false; // don't shift if field has no value yet and popup was not open\n        } else if (!this.popup) {\n          // Otherwise, ensure picker is open\n          this.openTimePopupAndSelect(pickerStartTime);\n        }\n        if (shiftTime) {\n          this.shiftSelectedTime(diffHours, diffMinutes, diffSeconds);\n          this._updateDisplayText(this.getTimePicker().selectedTime);\n        }\n        $.suppressEvent(event);\n      } else {\n        // without picker\n        if (!this._tempTimeDate) {\n          var timePrediction = this._predictTime(displayText); // this also updates the errorStatus\n          if (timePrediction && timePrediction.date) {\n            this._tempTimeDate = timePrediction.date;\n          } else {\n            this._tempTimeDate = this._referenceDate();\n            shiftTime = false;\n          }\n        }\n        if (shiftTime) {\n          this._tempTimeDate = dates.shiftTime(this._tempTimeDate, diffHours, diffMinutes, diffSeconds);\n        }\n        if (this.hasDate) {\n          // Combine _tempTimeDate with existing date part\n          this._tempTimeDate = dates.combineDateTime(this.value || this._referenceDate(), this._tempTimeDate);\n        }\n        this._updateDisplayText(this._tempTimeDate);\n        this._setTimeValid(true);\n        $.suppressEvent(event);\n      }\n    }\n  }\n\n  /**\n   * Handle changed input. This method is fired when the field's content has been altered by a user\n   * action (not by JS) such as pressing a character key, deleting a character using DELETE or\n   * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.\n   * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled\n   * in _onTimeFieldKeyDown().\n   */\n  _onTimeFieldInput(event) {\n    var displayText = this.$timeField.val();\n\n    // If the focus has changed to another field in the meantime, don't predict anything and\n    // don't show the picker. Just validate the input.\n    if (this.$timeField[0] !== this.$timeField.activeElement(true)) {\n      return;\n    }\n\n    // Create $predictTimeField if necessary\n    if (!this._$predictTimeField) {\n      this._$predictTimeField = this._createPredictionField(this.$timeField);\n    }\n\n    // Predict time\n    var timePrediction = this._predictTime(displayText); // this also updates the errorStatus\n    if (timePrediction) {\n      this._$predictTimeField.val(timePrediction.text);\n      this.openTimePopupAndSelect(timePrediction.date);\n    } else {\n      // No valid prediction!\n      this._tempTimeDate = null;\n      this._removePredictionFields();\n    }\n    this._updateTimeHasText();\n\n    // See comment for similar code in _onDateFieldInput()\n    setTimeout(function() {\n      if (this._$predictTimeField) {\n        this._$predictTimeField.setVisible(this.$timeField.scrollLeft() === 0);\n      }\n    }.bind(this), 50);\n  }\n\n  _onDatePickerDateSelect(event) {\n    this._setDateValid(true);\n    this._setTimeValid(true);\n    var newValue = this._newTimestampAsDate(event.date, this.value);\n    this.setValue(newValue);\n    this.closePopup();\n    this._triggerAcceptInput();\n  }\n\n  _onTimePickerTimeSelect(event) {\n    this._setDateValid(true);\n    this._setTimeValid(true);\n    var newValue = this._newTimestampAsDate(this.value, event.time);\n    this.setValue(newValue);\n    this.closePopup();\n    this._triggerAcceptInput();\n  }\n\n  _createPredictionField($inputField) {\n    var $predictionField = $inputField.clone()\n      .addClass('predict')\n      .attr('tabIndex', '-1')\n      .insertBefore($inputField);\n    if ($inputField.hasClass('has-error')) {\n      $predictionField.addClass('has-error');\n    }\n    return $predictionField;\n  }\n\n  _removePredictionFields() {\n    if (this._$predictDateField) {\n      this._$predictDateField.remove();\n      this._$predictDateField = null;\n    }\n    if (this._$predictTimeField) {\n      this._$predictTimeField.remove();\n      this._$predictTimeField = null;\n    }\n  }\n\n  _setDateDisplayText(displayText) {\n    this.dateDisplayText = displayText;\n    this._updateDisplayTextProperty();\n    if (this.rendered) {\n      this._renderDateDisplayText();\n    }\n  }\n\n  _setTimeDisplayText(displayText) {\n    this.timeDisplayText = displayText;\n    this._updateDisplayTextProperty();\n    if (this.rendered) {\n      this._renderTimeDisplayText();\n    }\n  }\n\n  _computeDisplayText(dateDisplayText, timeDisplayText) {\n    var dateText = dateDisplayText || '',\n      timeText = timeDisplayText || '';\n\n    // do not use strings.join which ignores empty components\n    var displayText = (this.hasDate ? dateText : '') + (this.hasDate && this.hasTime ? '\\n' : '') + (this.hasTime ? timeText : '');\n\n    // empty display text should always be just an empty string\n    if (displayText === '\\n') {\n      displayText = '';\n    }\n    return displayText;\n  }\n\n  _splitDisplayText(displayText) {\n    var dateText = '',\n      timeText = '';\n\n    if (strings.hasText(displayText)) {\n      var parts = displayText.split('\\n');\n      dateText = this.hasDate ? parts[0] : '';\n      timeText = this.hasTime ? (this.hasDate ? parts[1] : parts[0]) : '';\n    }\n    return {\n      dateText: dateText,\n      timeText: timeText\n    };\n  }\n\n  _updateDisplayTextProperty() {\n    this._setProperty('displayText', this._computeDisplayText(this.dateDisplayText, this.timeDisplayText));\n  }\n\n  /**\n   * @override ValueField.js\n   */\n  aboutToBlurByMouseDown(target) {\n    var dateFieldActive, timeFieldActive, eventOnDatePicker, eventOnTimePicker,\n      eventOnDateField = this.$dateField ? (this.$dateField.isOrHas(target) || this.$dateFieldIcon.isOrHas(target) || (this.$dateClearIcon && this.$dateClearIcon.isOrHas(target))) : false,\n      eventOnTimeField = this.$timeField ? (this.$timeField.isOrHas(target) || this.$timeFieldIcon.isOrHas(target) || (this.$timeClearIcon && this.$timeClearIcon.isOrHas(target))) : false,\n      eventOnPopup = this.popup && this.popup.$container.isOrHas(target),\n      eventOnStatus = this.fieldStatus && this.fieldStatus.$container.isOrHas(target),\n      datePicker = this.getDatePicker(),\n      timePicker = this.getTimePicker();\n\n    if (!eventOnDateField && !eventOnTimeField && !eventOnPopup && !eventOnStatus) {\n      // event outside this field.\n      dateFieldActive = focusUtils.isActiveElement(this.$dateField);\n      timeFieldActive = focusUtils.isActiveElement(this.$timeField);\n      // Accept only the currently focused part (the other one cannot have a pending change)\n      this.acceptDateTime(dateFieldActive, timeFieldActive);\n      return;\n    }\n\n    // when date-field is embedded, time-prediction must be accepted before\n    // the date-picker triggers the 'dateSelect' event.\n    if (this.embedded) {\n      eventOnDatePicker = datePicker && datePicker.$container.isOrHas(target);\n      eventOnTimePicker = timePicker && timePicker.$container.isOrHas(target);\n      if (eventOnDatePicker && eventOnTimePicker) {\n        this.acceptTime();\n      }\n    }\n  }\n\n  /**\n   * Returns null if both arguments are not set. Otherwise, this.value or the current date\n   * is used as basis and the given arguments are applied to that date. The result is returned.\n   */\n  _newTimestampAsDate(date, time) {\n    var result = null;\n    if (date || time) {\n      result = this.value || this._referenceDate();\n      if (date) {\n        result = dates.combineDateTime(date, result);\n      }\n      if (time) {\n        result = dates.combineDateTime(result, time);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Returns the reference date for this date field, which is used in various places (i.e. opening the date picker, analyzing user inputs).\n   *\n   * The reference date is either (in that order):\n   * - the model's \"auto timestamp\" (as date), or\n   * - the current date/time\n   */\n  _referenceDate() {\n    var referenceDate = this.autoDate || dates.ceil(dates.newDate(), this.timePickerResolution);\n    if (this.autoDate) {\n      referenceDate = this.autoDate;\n    } else if (this.hasTime) {\n      referenceDate = dates.ceil(dates.newDate(), this.timePickerResolution);\n    } else {\n      referenceDate = dates.trunc(dates.newDate());\n    }\n    if (this.allowedDates) {\n      referenceDate = this._findAllowedReferenceDate(referenceDate);\n    }\n    return referenceDate;\n  }\n\n  /**\n   * Find nearest allowed date which is equals or greater than the current referenceDate.\n   */\n  _findAllowedReferenceDate(referenceDate) {\n    var i, allowedDate;\n    // 1st: try to find a date which is equals or greater than the referenceDate (today)\n    for (i = 0; i < this.allowedDates.length; i++) {\n      allowedDate = this.allowedDates[i];\n      if (dates.compare(allowedDate, referenceDate) >= 0) {\n        return allowedDate;\n      }\n    }\n    // 2nd: try to find an allowed date in the past\n    for (i = this.allowedDates.length - 1; i >= 0; i--) {\n      allowedDate = this.allowedDates[i];\n      if (dates.compare(allowedDate, referenceDate) <= 0) {\n        return allowedDate;\n      }\n    }\n    return referenceDate;\n  }\n\n  openDatePopup(date) {\n    if (this.popup) {\n      // already open\n      return;\n    }\n\n    this.popup = this.createDatePopup();\n    this.popup.open();\n    this.$dateField.addClass('focused');\n    this.popup.on('remove', function(event) {\n      this._onPopupRemove(event);\n      this.popup = null;\n      this.$dateField.removeClass('focused');\n    }.bind(this));\n    this.getDatePicker().on('dateSelect', this._onDatePickerDateSelect.bind(this));\n  }\n\n  closePopup() {\n    if (this.popup) {\n      this.popup.close();\n    }\n  }\n\n  toggleDatePopup() {\n    $.log.isInfoEnabled() && $.log.info('(DateField#toggleDatePopup) popupOpen=', !!this.popup);\n    if (this.popup) {\n      this.closePopup();\n    } else {\n      this.openDatePopupAndSelect(this.value);\n    }\n  }\n\n  openTimePopup(date) {\n    if (!this.hasTimePopup || this.popup) {\n      // already open\n      return;\n    }\n    this.popup = this.createTimePopup();\n    this.popup.open();\n    this.$timeField.addClass('focused');\n    this.popup.on('remove', function(event) {\n      this._onPopupRemove(event);\n      this.popup = null;\n      this.$timeField.removeClass('focused');\n    }.bind(this));\n    this.getTimePicker().on('timeSelect', this._onTimePickerTimeSelect.bind(this));\n  }\n\n  toggleTimePopup() {\n    $.log.isInfoEnabled() && $.log.info('(DateField#toggleTimePopup) popupOpen=', !!this.popup);\n    if (this.popup) {\n      this.closePopup();\n    } else {\n      this.openTimePopupAndSelect(this.value);\n    }\n  }\n\n  _parseValue(displayText) {\n    var parts = this._splitDisplayText(displayText);\n    var dateText = parts.dateText;\n    var datePrediction = {};\n    var timeText = parts.timeText;\n    var timePrediction = {};\n    var success = true;\n\n    if (this.hasDate) {\n      datePrediction = this._predictDate(dateText); // this also updates the errorStatus\n      if (!datePrediction) {\n        success = false;\n      }\n      this._setDateDisplayText(dateText);\n    }\n\n    if (this.hasTime) {\n      timePrediction = this._predictTime(timeText); // this also updates the errorStatus\n      if (!timePrediction) {\n        success = false;\n      }\n      this._setTimeDisplayText(timeText);\n    }\n\n    // Error status was already set by _predict functions, just throw it so that setValue is not called\n    if (!success) {\n      throw this.errorStatus;\n    }\n\n    // parse success -> return new value\n    if (datePrediction.date || timePrediction.date) {\n      return this._newTimestampAsDate(datePrediction.date, timePrediction.date);\n    }\n    return null;\n  }\n\n  /**\n   * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'\n   */\n  _predictDate(inputText) {\n    inputText = inputText || '';\n\n    // \"Date calculations\"\n    var m = inputText.match(/^([+-])(\\d*)$/);\n    if (m) {\n      var now = dates.newDate();\n      var daysToAdd = Number(m[1] + (m[2] || '0'));\n      now.setDate(now.getDate() + daysToAdd);\n      if (isNaN(now.valueOf()) || now.getDate() < 0) { // Some older browsers don't set NaN but return invalid values\n        this._setDateValid(false);\n        return null;\n      }\n      this._setDateValid(true);\n      return {\n        date: now,\n        text: inputText\n      };\n    }\n\n    var analyzeInfo = this._analyzeInputAsDate(inputText, this.value || this._referenceDate());\n    if (analyzeInfo.error) {\n      this._setDateValid(false);\n      return null;\n    }\n\n    // No predicted date? -> return empty string (may happen if inputText is empty)\n    if (!analyzeInfo.predictedDate) {\n      this._setDateValid(true);\n      return {\n        date: null,\n        text: ''\n      };\n    }\n\n    var predictedDate = analyzeInfo.predictedDate;\n    var predictionFormat = new DateFormat(this.isolatedDateFormat.locale, analyzeInfo.parsedPattern);\n    var predictedDateFormatted = predictionFormat.format(predictedDate, true);\n\n    // If predicted date format starts with validatedText, ensure that the capitalization matches.\n    // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')\n    m = predictedDateFormatted.match(new RegExp('^' + strings.quote(inputText) + '(.*)$', 'i'));\n    if (m) {\n      predictedDateFormatted = inputText + m[1];\n    }\n\n    this._setDateValid(true);\n    return {\n      date: predictedDate,\n      text: predictedDateFormatted\n    };\n  }\n\n  /**\n   * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'\n   */\n  _predictTime(inputText) {\n    inputText = inputText || '';\n\n    var analyzeInfo = this._analyzeInputAsTime(inputText, this.value || this._referenceDate());\n    if (analyzeInfo.error) {\n      this._setTimeValid(false);\n      return null;\n    }\n\n    // No predicted date? -> return empty string (may happen if inputText is empty)\n    if (!analyzeInfo.predictedDate) {\n      this._setTimeValid(true);\n      return {\n        date: null,\n        text: ''\n      };\n    }\n\n    var predictedDate = analyzeInfo.predictedDate;\n    var predictionFormat = new DateFormat(this.isolatedTimeFormat.locale, analyzeInfo.parsedPattern);\n    var predictedTimeFormatted = predictionFormat.format(predictedDate, true);\n\n    // If predicted date format starts with validatedText, ensure that the capitalization matches.\n    // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')\n    var m = predictedTimeFormatted.match(new RegExp('^' + strings.quote(inputText) + '(.*)$', 'i'));\n    if (m) {\n      predictedTimeFormatted = inputText + m[1];\n    }\n\n    this._setTimeValid(true);\n    return {\n      date: predictedDate,\n      text: predictedTimeFormatted\n    };\n  }\n\n  _analyzeInputAsDate(inputText, startDate) {\n    return this.isolatedDateFormat.analyze(inputText, startDate);\n  }\n\n  _analyzeInputAsTime(inputText, startDate) {\n    return this.isolatedTimeFormat.analyze(inputText, startDate);\n  }\n\n  /**\n   * This method updates the parts (date, time) of the error status.\n   */\n  _setErrorStatusPart(property, valid) {\n    if (valid) {\n      this.setErrorStatus(null);\n      return;\n    }\n    var errorStatus = this.errorStatus;\n    if (!errorStatus) {\n      errorStatus = this._createErrorStatus();\n    }\n    errorStatus[property] = true;\n    this.setErrorStatus(errorStatus);\n  }\n\n  _createErrorStatus() {\n    return new Status({\n      message: this.session.text('ui.InvalidDate'),\n      severity: Status.Severity.ERROR,\n      code: DateField.ErrorCode.PARSE_ERROR\n    });\n  }\n\n  /**\n   * @override\n   */\n  _createInvalidValueStatus(value, error) {\n    var errorStatus = super._createInvalidValueStatus(value, error);\n    // Set date and time to invalid, otherwise isDateValid and isTimeValid return false even though there is a validation error\n    errorStatus.invalidDate = true;\n    errorStatus.invalidTime = true;\n    return errorStatus;\n  }\n\n  _setDateValid(valid) {\n    this._setErrorStatusPart('invalidDate', valid);\n  }\n\n  _setTimeValid(valid) {\n    this._setErrorStatusPart('invalidTime', valid);\n  }\n\n  _isErrorStatusPartValid(property) {\n    if (this.errorStatus && this.errorStatus[property]) {\n      return false;\n    }\n    return true;\n  }\n\n  _isDateValid() {\n    return this._isErrorStatusPartValid('invalidDate');\n  }\n\n  _isTimeValid() {\n    return this._isErrorStatusPartValid('invalidTime');\n  }\n\n  /**\n   * Method invoked if being rendered within a cell-editor (mode='scout.FormField.Mode.CELLEDITOR'), and once the editor finished its rendering.\n   */\n  onCellEditorRendered(options) {\n    if (options.openFieldPopup) {\n      if (this.hasDate && !this.hasTime) {\n        this.openDatePopupAndSelect(this.value);\n      } else if (!this.hasDate && this.hasTime) {\n        this.openTimePopupAndSelect(this.value);\n      } else if (!Device.get().supportsOnlyTouch()) {\n        // If date AND time are active, don't open popup on touch devices because the user has to choose first what he wants to edit\n        this.openDatePopupAndSelect(this.value);\n      }\n    }\n    if (this.touchMode) {\n      this._cellEditorPopup = options.cellEditorPopup;\n    }\n  }\n\n  _onPopupRemove(event) {\n    if (!this.touchMode || !this._cellEditorPopup) {\n      return;\n    }\n    if (this.hasDate && this.hasTime) {\n      // If date and time is shown, user might want to change both, let him close the cell editor when he is finished\n      return;\n    }\n    // Close cell editor when touch popup closes\n    this._cellEditorPopup.completeEdit();\n    this._cellEditorPopup = null;\n  }\n\n  /**\n   * @override FormField.js\n   */\n  prepareForCellEdit(opts) {\n    opts = opts || {};\n    super.prepareForCellEdit(opts);\n\n    this.$field.removeClass('cell-editor-field first last');\n    if (this.$dateField) {\n      this.addCellEditorFieldCssClasses(this.$dateField, opts);\n    }\n    if (this.$timeField) {\n      if (!this.$dateField) {\n        opts.cssClass = '';\n      }\n      this.addCellEditorFieldCssClasses(this.$timeField, opts);\n    }\n  }\n\n  /**\n   * @returns DatePicker instance from popup, because the property name is different\n   *    for DatePickerPopup and DatePickerTouchPopup.\n   */\n  getDatePicker() {\n    if (this.popup && this.popup.getDatePicker) {\n      return this.popup.getDatePicker();\n    }\n  }\n\n  /**\n   * Opens picker and selects date\n   *\n   * @param date\n   *          optional, Date to pass to the date picker. If no date is specified, the reference date\n   *          is preselected (not selected!).\n   */\n  openDatePopupAndSelect(date) {\n    this.openDatePopup();\n    if (!date) {\n      this.preselectDate(this._referenceDate(), false);\n    } else {\n      this.selectDate(date, false);\n    }\n  }\n\n  preselectDate(date, animated) {\n    var datePicker = this.getDatePicker();\n    if (datePicker) {\n      datePicker.preselectDate(date, animated);\n    }\n  }\n\n  selectDate(date, animated) {\n    var datePicker = this.getDatePicker();\n    if (datePicker) {\n      datePicker.selectDate(date, animated);\n    }\n  }\n\n  /**\n   * @returns DatePicker instance from popup, because the property name is different\n   *    for DatePickerPopup and DatePickerTouchPopup.\n   */\n  getTimePicker() {\n    if (this.popup && this.popup.getTimePicker) {\n      return this.popup.getTimePicker();\n    }\n  }\n\n  /**\n   * Opens picker and selects date\n   *\n   * @param date\n   *          optional, Date to pass to the date picker. If no date is specified, the reference date\n   *          is preselected (not selected!).\n   */\n  openTimePopupAndSelect(time) {\n    // resolution < 1 means no picker required\n    if (!this.hasTimePopup) {\n      return;\n    }\n    this.openTimePopup();\n    if (!time) {\n      this.preselectTime(this._referenceDate());\n    } else {\n      this.selectTime(time);\n    }\n  }\n\n  preselectTime(time) {\n    var timePicker = this.getTimePicker();\n    if (timePicker) {\n      timePicker.preselectTime(time);\n    }\n  }\n\n  selectTime(time) {\n    var timePicker = this.getTimePicker();\n    if (timePicker) {\n      timePicker.selectTime(time);\n    }\n  }\n\n  shiftSelectedDate(years, months, days) {\n    this.openDatePopup();\n    this.getDatePicker().shiftSelectedDate(years, months, days);\n  }\n\n  shiftSelectedTime(hourUnits, minuteUnits, secondUnits) {\n    this.openTimePopup();\n    this.getTimePicker().shiftSelectedTime(hourUnits, minuteUnits, secondUnits);\n  }\n\n  _formatValue(value) {\n    var\n      dateText = '',\n      timeText = '';\n\n    if (this.hasDate) {\n      if (value) {\n        dateText = this.isolatedDateFormat.format(value);\n      }\n      this.dateDisplayText = dateText;\n    }\n    if (this.hasTime) {\n      if (value) {\n        timeText = this.isolatedTimeFormat.format(value);\n      }\n      this.timeDisplayText = timeText;\n    }\n\n    return this._computeDisplayText(this.dateDisplayText, this.timeDisplayText);\n  }\n\n  /**\n   * @override\n   */\n  _renderFieldStyle() {\n    super._renderFieldStyle();\n    this._renderFieldStyleInternal(this.$dateField);\n    this._renderFieldStyleInternal(this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  _renderDisabledStyle() {\n    super._renderDisabledStyle();\n    this._renderDisabledStyleInternal(this.$dateField);\n    this._renderDisabledStyleInternal(this.$timeField);\n  }\n\n  /**\n   * @override\n   */\n  _triggerAcceptInput() {\n    var event = {\n      displayText: this.displayText,\n      errorStatus: this.errorStatus,\n      value: this.value\n    };\n    this.trigger('acceptInput', event);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}