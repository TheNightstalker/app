{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport { strings } from '../index';\n\nvar ResponseQueue = /*#__PURE__*/function () {\n  function ResponseQueue(session) {\n    _classCallCheck(this, ResponseQueue);\n\n    this.session = session;\n    this.queue = [];\n    this.lastProcessedSequenceNo = 0;\n    this.nextExpectedSequenceNo = 1;\n    this.force = false;\n    this.forceTimeoutId = null;\n  }\n\n  _createClass(ResponseQueue, [{\n    key: \"add\",\n    // in ms\n    value: function add(response) {\n      var sequenceNo = response && response['#']; // Ignore responses that were already processed (duplicate detection)\n\n      if (sequenceNo && sequenceNo <= this.lastProcessedSequenceNo) {\n        return;\n      } // \"Fast-forward\" the expected sequence no. when a combined response is received\n\n\n      if (sequenceNo && response.combined) {\n        this.lastProcessedSequenceNo = Math.max(sequenceNo - 1, this.lastProcessedSequenceNo);\n        this.nextExpectedSequenceNo = Math.max(sequenceNo, this.nextExpectedSequenceNo);\n      }\n\n      if (!sequenceNo || this.queue.length === 0) {\n        // Handle messages without sequenceNo in the order they were received\n        this.queue.push(response);\n      } else {\n        // Insert at correct position (ascending order)\n        var newQueue = [];\n        var responseToInsert = response;\n\n        for (var i = 0; i < this.queue.length; i++) {\n          var el = this.queue[i];\n\n          if (el['#']) {\n            if (responseToInsert && el['#'] > sequenceNo) {\n              // insert at position\n              newQueue.push(response);\n              responseToInsert = null;\n            }\n\n            if (el['#'] <= this.lastProcessedSequenceNo) {\n              // skip obsolete elements (may happen when a combined response is added to the queue)\n              continue;\n            }\n          }\n\n          newQueue.push(el);\n        }\n\n        if (responseToInsert) {\n          // no element with bigger seqNo found -> insert as last element\n          newQueue.push(responseToInsert);\n        }\n\n        this.queue = newQueue;\n      }\n    }\n  }, {\n    key: \"process\",\n    value: function process(response) {\n      if (response) {\n        this.add(response);\n      } // Process the queue in ascending order\n\n\n      var responseSuccess = true;\n      var missingResponse = false;\n      var nonProcessedResponses = [];\n\n      for (var i = 0; i < this.queue.length; i++) {\n        var el = this.queue[i];\n        var sequenceNo = el['#']; // For elements with a sequence number, check if they are in the expected order\n\n        if (sequenceNo) {\n          if (this.nextExpectedSequenceNo && !this.force && !missingResponse) {\n            missingResponse = this.nextExpectedSequenceNo !== sequenceNo;\n          }\n\n          if (missingResponse) {\n            // Sequence is not complete, process those messages later\n            nonProcessedResponses.push(el);\n            continue;\n          }\n        } // Handle the element\n\n\n        var success = this.session.processJsonResponseInternal(el); // Only return success value of the response that was passed to the process() call\n\n        if (response && el === response) {\n          responseSuccess = success;\n        } // Update the expected next sequenceNo\n\n\n        if (sequenceNo) {\n          this.lastProcessedSequenceNo = sequenceNo;\n          this.nextExpectedSequenceNo = sequenceNo + 1;\n        }\n      } // Keep non-processed events (because they are not in sequence) in the queue\n\n\n      this.queue = nonProcessedResponses;\n\n      this._checkTimeout();\n\n      return responseSuccess;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.queue.length;\n    }\n  }, {\n    key: \"_checkTimeout\",\n    value: function _checkTimeout() {\n      // If there are non-processed elements, schedule a job that forces the processing of those\n      // elements after a certain timeout to prevent the \"blocked forever syndrome\" if a response\n      // was lost on the network.\n      if (this.queue.length === 0) {\n        clearTimeout(this.forceTimeoutId);\n        this.forceTimeoutId = null;\n      } else if (!this.forceTimeoutId) {\n        this.forceTimeoutId = setTimeout(function () {\n          try {\n            var s = '[';\n\n            for (var i = 0; i < this.queue.length; i++) {\n              if (i > 0) {\n                s += ', ';\n              }\n\n              s += strings.box('#', this.queue[i]['#']) || '<none>';\n            }\n\n            s += ']';\n            this.session.sendLogRequest('Expected response #' + this.nextExpectedSequenceNo + ' still missing after ' + ResponseQueue.FORCE_TIMEOUT + ' ms. Forcing response queue to process ' + this.size() + ' elements: ' + s);\n          } catch (error) {// nop\n          }\n\n          this.force = true;\n\n          try {\n            this.process();\n          } finally {\n            this.force = false;\n            this.forceTimeoutId = null;\n          }\n        }.bind(this), ResponseQueue.FORCE_TIMEOUT);\n      }\n    }\n  }, {\n    key: \"prepareRequest\",\n    value: function prepareRequest(request) {\n      request['#ACK'] = this.lastProcessedSequenceNo;\n    }\n  }, {\n    key: \"prepareHttpRequest\",\n    value: function prepareHttpRequest(ajaxOptions) {\n      ajaxOptions.headers = ajaxOptions.headers || {};\n      ajaxOptions.headers['X-Scout-#ACK'] = this.lastProcessedSequenceNo;\n    }\n  }]);\n\n  return ResponseQueue;\n}();\n\n_defineProperty(ResponseQueue, \"FORCE_TIMEOUT\", 10 * 1000);\n\nexport { ResponseQueue as default };","map":{"version":3,"sources":["C:/Tools/workspace/nightstalker/nightstalker.ui.html/node_modules/@eclipse-scout/core/src/session/ResponseQueue.js"],"names":["strings","ResponseQueue","session","queue","lastProcessedSequenceNo","nextExpectedSequenceNo","force","forceTimeoutId","response","sequenceNo","combined","Math","max","length","push","newQueue","responseToInsert","i","el","add","responseSuccess","missingResponse","nonProcessedResponses","success","processJsonResponseInternal","_checkTimeout","clearTimeout","setTimeout","s","box","sendLogRequest","FORCE_TIMEOUT","size","error","process","bind","request","ajaxOptions","headers"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2014-2017 BSI Business Systems Integration AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     BSI Business Systems Integration AG - initial API and implementation\n */\nimport {strings} from '../index';\n\nexport default class ResponseQueue {\n\n  constructor(session) {\n    this.session = session;\n    this.queue = [];\n    this.lastProcessedSequenceNo = 0;\n    this.nextExpectedSequenceNo = 1;\n\n    this.force = false;\n    this.forceTimeoutId = null;\n  }\n\n  static FORCE_TIMEOUT = 10 * 1000; // in ms\n\n  add(response) {\n    var sequenceNo = response && response['#'];\n\n    // Ignore responses that were already processed (duplicate detection)\n    if (sequenceNo && sequenceNo <= this.lastProcessedSequenceNo) {\n      return;\n    }\n\n    // \"Fast-forward\" the expected sequence no. when a combined response is received\n    if (sequenceNo && response.combined) {\n      this.lastProcessedSequenceNo = Math.max(sequenceNo - 1, this.lastProcessedSequenceNo);\n      this.nextExpectedSequenceNo = Math.max(sequenceNo, this.nextExpectedSequenceNo);\n    }\n\n    if (!sequenceNo || this.queue.length === 0) { // Handle messages without sequenceNo in the order they were received\n      this.queue.push(response);\n    } else {\n      // Insert at correct position (ascending order)\n      var newQueue = [];\n      var responseToInsert = response;\n      for (var i = 0; i < this.queue.length; i++) {\n        var el = this.queue[i];\n        if (el['#']) {\n          if (responseToInsert && el['#'] > sequenceNo) {\n            // insert at position\n            newQueue.push(response);\n            responseToInsert = null;\n          }\n          if (el['#'] <= this.lastProcessedSequenceNo) {\n            // skip obsolete elements (may happen when a combined response is added to the queue)\n            continue;\n          }\n        }\n        newQueue.push(el);\n      }\n      if (responseToInsert) {\n        // no element with bigger seqNo found -> insert as last element\n        newQueue.push(responseToInsert);\n      }\n      this.queue = newQueue;\n    }\n  }\n\n  process(response) {\n    if (response) {\n      this.add(response);\n    }\n\n    // Process the queue in ascending order\n    var responseSuccess = true;\n    var missingResponse = false;\n    var nonProcessedResponses = [];\n    for (var i = 0; i < this.queue.length; i++) {\n      var el = this.queue[i];\n      var sequenceNo = el['#'];\n\n      // For elements with a sequence number, check if they are in the expected order\n      if (sequenceNo) {\n        if (this.nextExpectedSequenceNo && !this.force && !missingResponse) {\n          missingResponse = (this.nextExpectedSequenceNo !== sequenceNo);\n        }\n        if (missingResponse) {\n          // Sequence is not complete, process those messages later\n          nonProcessedResponses.push(el);\n          continue;\n        }\n      }\n\n      // Handle the element\n      var success = this.session.processJsonResponseInternal(el);\n      // Only return success value of the response that was passed to the process() call\n      if (response && el === response) {\n        responseSuccess = success;\n      }\n\n      // Update the expected next sequenceNo\n      if (sequenceNo) {\n        this.lastProcessedSequenceNo = sequenceNo;\n        this.nextExpectedSequenceNo = sequenceNo + 1;\n      }\n    }\n    // Keep non-processed events (because they are not in sequence) in the queue\n    this.queue = nonProcessedResponses;\n\n    this._checkTimeout();\n\n    return responseSuccess;\n  }\n\n  size() {\n    return this.queue.length;\n  }\n\n  _checkTimeout() {\n    // If there are non-processed elements, schedule a job that forces the processing of those\n    // elements after a certain timeout to prevent the \"blocked forever syndrome\" if a response\n    // was lost on the network.\n    if (this.queue.length === 0) {\n      clearTimeout(this.forceTimeoutId);\n      this.forceTimeoutId = null;\n    } else if (!this.forceTimeoutId) {\n      this.forceTimeoutId = setTimeout(function() {\n        try {\n          var s = '[';\n          for (var i = 0; i < this.queue.length; i++) {\n            if (i > 0) {\n              s += ', ';\n            }\n            s += (strings.box('#', this.queue[i]['#']) || '<none>');\n          }\n          s += ']';\n          this.session.sendLogRequest('Expected response #' + this.nextExpectedSequenceNo + ' still missing after ' +\n            ResponseQueue.FORCE_TIMEOUT + ' ms. Forcing response queue to process ' + this.size() + ' elements: ' + s);\n        } catch (error) {\n          // nop\n        }\n        this.force = true;\n        try {\n          this.process();\n        } finally {\n          this.force = false;\n          this.forceTimeoutId = null;\n        }\n      }.bind(this), ResponseQueue.FORCE_TIMEOUT);\n    }\n  }\n\n  prepareRequest(request) {\n    request['#ACK'] = this.lastProcessedSequenceNo;\n  }\n\n  prepareHttpRequest(ajaxOptions) {\n    ajaxOptions.headers = ajaxOptions.headers || {};\n    ajaxOptions.headers['X-Scout-#ACK'] = this.lastProcessedSequenceNo;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}